/*
				*** DESCRIPTION ***
Autorem skryptu jest Mario. Wszelkie prawa zastrzeżone.
Głównym pomysłodawcą rozwiązań jest autor we własnej osobie.

*/

// Includes
#include <a_samp>

#include <YSI\y_va>
#include <YSI\y_timers>
#include <YSI\y_iterate>

#include <a_mysql>
#include <Pawn.CMD>
#include <sscanf2>
#include <streamer>
#include <dynamicgui>
#include <bcrypt>
#include <timestamptodate>
//#include <Pawn.RakNet>

// Main config
#define GAMEMODE		"MRP ©"
#define VERSION			"0.3"
#define SERVER_NAME 	"Mighty RolePlay"
#define WEB_URL         "www.m-rp.net"

// Database config
#define SQL_HOST        "127.0.0.1"
#define SQL_USER        "root"
#define SQL_PASS        ""
#define SQL_DTBS        "rp"
#define SQL_PREF     	"ipb_"

//#pragma tabsize 0
//#pragma dynamic 8196

#define INVALID_GROUP_ID    (-1)
#define INVALID_SLOT_ID 	(-1)
#define INVALID_DOOR_ID     (-1)
#define INVALID_ITEM_ID     (-1)
#define INVALID_AREA_ID     (-1)
#define INVALID_SKIN_ID     (-1)
#define INVALID_ANIM_ID     (-1)
#define INVALID_ACCESS_ID   (-1)
#define INVALID_PRODUCT_ID  (-1)
#define INVALID_PACKAGE_ID  (-1)
#define INVALID_ITEM_TYPE  	(-1)
#define INVALID_GROUP_TYPE  (-1)

#undef MAX_PLAYERS
#undef MAX_VEHICLES

// Limitations
#define MAX_PLAYERS         10
#define MAX_VEHICLES        10
#define MAX_ITEM_CACHE      10
#define MAX_PRODUCTS        10
#define MAX_ACCESS          200
#define MAX_SKINS           400
#define MAX_ANIMS           400
#define MAX_RACE_CP         200
#define	MAX_DRAW_DISTANCE   250.0

#define MAX_GROUPS          10
#define MAX_GROUP_SLOTS     4

#define MAX_VIS_OBJECTS 	500
#define MAX_VIS_LABELS      500
#define MAX_VIS_DOORS       100
#define MAX_VIS_ACTORS      50

#define ACTIVITY_LIMIT      1000

#define PACC_VEHICLES    	5
#define FACC_VEHICLES   	1

#define PACC_POINTS         15
#define FACC_POINTS         10

// Colors
#define COLOR_WHITE			0xFFFFFFFF
#define COLOR_BLACK         0x000000FF
#define COLOR_BROWN 		0x8F4747FF
#define COLOR_KREM 			0xFF8080FF
#define COLOR_SAY 			0x2986CEFF
#define COLOR_GREY 			0xAFAFAFFF
#define COLOR_SYSGREY 		0xC6BEBDFF
#define COLOR_GREEN 		0x33AA33AA
#define COLOR_RED 			0xAA3333AA
#define COLOR_LIGHTRED      0xFF6347AA
#define COLOR_YELLOW 		0xFFFF00AA
#define COLOR_BLUE 			0x0000BBAA
#define COLOR_LIGHTBLUE 	0x33CCFFFF
#define COLOR_ORANGE 		0xFF9900AA
#define COLOR_DARKRED 		0xAA993333
#define COLOR_GREEN 		0x33AA33AA
#define COLOR_RED 			0xAA3333AA
#define COLOR_YELLOW 		0xFFFF00AA
#define COLOR_PINK 			0xFF66FFAA
#define COLOR_BLUE 			0x0000BBAA
#define COLOR_ORANGE 		0xFF9900AA
#define COLOR_GOLD			0xBD9A28FF
#define COLOR_VIOLET 		0x8000FFFF
#define COLOR_BROWN 		0x8F4747FF
#define COLOR_DARKGREY 		0x808080FF
#define COLOR_BLACK 		0x000000FF
#define COLOR_DARKGREEN 	0x0D731FFF
#define COLOR_DARKBLUE 		0x2010E0FF
#define COLOR_DARKBROWN 	0x530000FF
#define COLOR_DARKVIOLET 	0x400040FF
#define COLOR_DARKYELLOW 	0x808000FF
#define COLOR_DARKPINK 		0x400040FF
#define COLOR_LIGHTGREEN 	0x00FF00FF
#define COLOR_LIGHTPINK 	0xFF80FFFF
#define COLOR_PURPLE     	0xC2A2DAFF
#define COLOR_PURPLE2	    0xE0EA64FF
#define COLOR_AREA          0x0000BBAA

#define COLOR_DO       		0x9A9CCDFF
#define COLOR_INFO			0xD7A064FF

#define COLOR_FADE1   		0xE6E6E6E6
#define COLOR_FADE2   		0xC8C8C8C8
#define COLOR_FADE3   		0xAAAAAAAA
#define COLOR_FADE4   		0x8C8C8C8C
#define COLOR_FADE5   		0x6E6E6E6E

#define COLOR_GRAD1   		0xB4B5B7FF
#define COLOR_GRAD2   		0xBFC0C2FF
#define COLOR_GRAD3   		0xCBCCCEFF
#define COLOR_GRAD4   		0xD8D8D8FF
#define COLOR_GRAD5   		0xE3E3E3FF
#define COLOR_GRAD6	  		0xF0F0F0FF

#define COLOR_BUSINESS      0x8A614DFF
#define COLOR_ORG  			0x70B8B8FF
#define COLOR_FACTION       0x8A8AFFFF
#define COLOR_DEPARTMENT    0x3DFF9EFF

#define COLOR_RADIO         0x0077FFFF

#define COLOR_ADMIN         0xEEE8AAFF
#define COLOR_SUPPORT       0x44D6FFFF

#define COLOR_SEND_PW   	0xFFC973FF
#define COLOR_GOT_PW  		0xFDAE33FF

#define COLOR_DESC          0xC2A2DAFF
#define COLOR_CB_RADIO      0xEFF291FF

#define COLOR_NICK          0xC7C7C700
#define COLOR_NICK_PACC     0xFFFFFF00

#define COLOR_PUNISH        0x9C9C9CFF

#define MAKE_COLOUR(%0,%1,%2) \
		((((%0) & 0xFF) << 16) | (((%1) & 0xFF) << 8) | (((%2) & 0xFF) << 0))
		
#define MAKE_COLOUR_AA(%0,%1,%2) \
		((((%0) & 0xFF) << 24) | (((%1) & 0xFF) << 16) | (((%2) & 0xFF) << 8) | 0xAA)
		
#define MAKE_COLOUR_ALPHA(%0,%1,%2,%3) \
 		((((%0) & 0xFF) << 24) | (((%1) & 0xFF) << 16) | (((%2) & 0xFF) << 8) | (((%3) & 0xFF) << 0))

#define chrtoupper(%1) \
        (((%1) > 0x60 && (%1) <= 0x7A) ?((%1) ^ 0x20) : (%1))

#define chrtolower(%1) \
        (((%1) > 0x40 && (%1) <= 0x5A) ? ((%1) | 0x20) : (%1))

#define is_null(%1) \
		((!(%1[0])) || (((%1[0]) == '\1') && (!(%1[1]))))

#define PRESSED(%0) \
		(((newkeys & (%0)) == (%0)) && ((oldkeys & (%0)) != (%0)))

#define HOLDING(%0) \
		((newkeys & (%0)) == (%0))
		
#define RELEASED(%0) \
		(((newkeys & (%0)) != (%0)) && ((oldkeys & (%0)) == (%0)))

#define GetObjectModel(%0) \
		Streamer_GetIntData(STREAMER_TYPE_OBJECT, %0, E_STREAMER_MODEL_ID)

#define GetLabelUID(%0) \
		Streamer_GetIntData(STREAMER_TYPE_3D_TEXT_LABEL, %0, E_STREAMER_EXTRA_ID)

#define GetVehicleName(%0) \
		VehicleModelData[%0 - 400][vName]
		
#define GetVehicleMaxFuel(%0) \
		VehicleModelData[%0 - 400][vMaxFuel]
		
#define GetVehicleMaxSpeed(%0) \
		VehicleModelData[%0 - 400][vMaxSpeed]
		
#define IsPlayerPremium(%0) \
		((PlayerCache[%0][pPremium] > gettime()) ? true : false)

// Typy InfoDialogs
#define D_TYPE_INFO     		0
#define D_TYPE_ERROR    		1
#define D_TYPE_SUCCESS  		2
#define D_TYPE_HELP     		3
#define D_TYPE_NO_PERM  		4

// Typy sesji
#define SESSION_NONE    		0
#define SESSION_GAME            1
#define SESSION_GROUP           2
#define SESSION_ADMIN           3
#define SESSION_LOGIN           4
#define SESSION_AFK             5
#define SESSION_COUNT           6

// Zapis gracza
#define SAVE_PLAYER_BASIC   	1
#define SAVE_PLAYER_POS     	2
#define SAVE_PLAYER_SETTING     4

// Zapis pojazdu
#define SAVE_VEH_POS        	1
#define SAVE_VEH_ACCESS     	2
#define SAVE_VEH_COUNT      	4
#define SAVE_VEH_THINGS     	8
#define SAVE_VEH_LOCK       	16

// Rodzaje paliw
#define FUEL_TYPE_BENS      	0
#define FUEL_TYPE_GAS       	1
#define FUEL_TYPE_DIESEL    	2

// Zapis drzwi
#define SAVE_DOOR_ENTER     	1
#define SAVE_DOOR_EXIT      	2
#define SAVE_DOOR_THINGS    	4
#define SAVE_DOOR_AUDIO     	8
#define SAVE_DOOR_LOCK      	16

// Typ opcji (groups)
#define GROUP_OPTION_INFO       0
#define GROUP_OPTION_CARS       1
#define GROUP_OPTION_DUTY       2
#define GROUP_OPTION_MAGAZINE   3
#define GROUP_OPTION_ONLINE     4

// Typ opcji (items)
#define ITEM_OPTION_USE         0
#define ITEM_OPTION_DROP        1

// Typy grup
#define G_TYPE_NONE     		0
#define G_TYPE_POLICE     		1
#define G_TYPE_MEDICAL		   	2
#define G_TYPE_NEWS   			3
#define G_TYPE_SECURITY         4
#define G_TYPE_GANG    			5
#define G_TYPE_GASSTATION       6
#define G_TYPE_BAR		      	7
#define G_TYPE_TAXI     		8
#define G_TYPE_WORKSHOP			9
#define G_TYPE_GYM         		10
#define G_TYPE_GOV     			11

#define G_TYPE_ARMY         	12
#define G_TYPE_FIREDEPT     	13
#define G_TYPE_FBI          	14

#define G_TYPE_MAFIA        	15

#define G_TYPE_FAMILY           16
#define G_TYPE_MOTORS      		17

#define G_TYPE_DRIVING          18
#define G_TYPE_RENTAL           19

#define G_TYPE_24/7             20

#define G_TYPE_CARDEALER        21
#define G_TYPE_CLOTHES          22

#define G_TYPE_HOTEL            23
#define G_TYPE_BANK             24

#define G_TYPE_COUNT            25

// Typy właścicieli
#define OWNER_NONE      		0
#define OWNER_PLAYER    		1
#define OWNER_GROUP     		2
#define OWNER_WORK              3

// Uprawnienia (groups)
#define G_PERM_CHAT       		1
#define G_PERM_DOORS      		2
#define G_PERM_CARS      		4
#define G_PERM_OFFER      		8
#define G_PERM_ORDER       		16
#define G_PERM_GATE       		32
#define G_PERM_LEADER     		64
#define G_PERM_CAPITAL          128
#define G_PERM_MAX          	255

// Uprawnienia (admins)
#define A_PERM_BASIC        	1
#define A_PERM_PUNISH       	2
#define A_PERM_3DTEXTS         	4
#define A_PERM_DOORS        	8
#define A_PERM_CARS        		16
#define A_PERM_GROUPS       	32
#define A_PERM_AREAS        	64
#define A_PERM_OBJECTS      	128
#define A_PERM_ITEMS          	256
#define A_PERM_ACTORS           512
#define A_PERM_MAX              1023

// Duty
#define DUTY_NONE       0
#define DUTY_ADMIN      1
#define DUTY_GROUP      2
#define DUTY_COUNT      3

// Miejsce przedmiotów
#define PLACE_NONE          	1
#define PLACE_PLAYER        	2
#define PLACE_CLOSET       		3
#define PLACE_VEHICLE           4
#define PLACE_BAG              	5
#define PLACE_CRAFT            	6
#define PLACE_ACTOR             7

// Typy przedmiotów
#define ITEM_NONE           	0   // Brak
#define ITEM_WATCH          	1   // Zegarek
#define ITEM_FOOD           	2   // Jedzenie (value1 = ilość hp)
#define ITEM_CIGGY          	3   // Papierosy (value2 = ilość sztuk)
#define ITEM_CUBE           	4   // Kostka do gry
#define ITEM_CLOTH          	5   // Ubranie (value1 = id skinu)
#define ITEM_WEAPON         	6   // Broń (value1 = model broni, value2 = amunicja)
#define ITEM_AMMO           	7   // Amunicja (value1 = model broni, value2 = ilość amunicji)
#define ITEM_PHONE          	8   // Telefon (value1 = numer telefonu)
#define ITEM_CANISTER       	9   // Karnister (value1 = ilość paliwa, value2 = typ paliwa)
#define ITEM_MASK           	10  // Maska
#define ITEM_INHIBITOR      	11  // Paralizator (value2 = ilość naboi)
#define ITEM_PAINT          	12  // Lakier (value2 = ilość naboi)
#define ITEM_HANDCUFFS      	13  // Kajdanki
#define ITEM_MEGAPHONE      	14  // Megafon
#define ITEM_LINE           	15  // Lina holownicza
#define ITEM_NOTEBOOK       	16  // Notes (value1 = ilość karteczek)
#define ITEM_CHIT           	17  // Karteczka (value1 = uid wpisu w bazie)
#define ITEM_TUNING         	18  // Część tuningu (value1 = id komponentu)
#define ITEM_CHECKBOOK      	19  // Ksiażeczka czekowa (value1 = ilość czeków)
#define ITEM_CHECK          	20  // Czek (value1 = ilość pieniędzy)
#define ITEM_BAG            	21  // Torba
#define ITEM_DRINK          	22  // Napój (value1 = special_action (20 - piwo, 22 - wino, 23 - sprunk))
#define ITEM_VEH_ACCESS         23  // Akcesoria do pojazdu
#define ITEM_DISC               24  // Płyta (value1 = uid wpisu w bazie)
#define ITEM_PLAYER             25  // Odtwarzacz (value1 = uid wpisu w bazie)
#define ITEM_CLOTH_ACCESS       26  // Akcesoria postaci (value1 = uid wpisu w bazie)
#define ITEM_PASS               27  // Karnet (value1 = czas, value2 = uid biznesu)
#define ITEM_CAR_CARD           28  // Karta pojazdu (value1 = model, value2 = właściciel)
#define ITEM_ROLL               29  // Rolki
#define ITEM_MEDICINE           30  // Medykament (value1 = hp)
#define ITEM_DRUG               31  // Narkotyk (value1 = typ narkotyku, value2 = waga (g))
#define ITEM_JOINT              32  // Joint (value1 = waga, value2 = jakość [0-3])
#define ITEM_KEYS               33  // Kluczyki (value1 = uid pojazdu)
#define ITEM_GLOVES             34  // Rękawiczki
#define ITEM_CORPSE             35  // Zwłoki (value1 = uid wpisu w bazie)
#define ITEM_MOLOTOV            36  // Koktajl molotova
#define ITEM_BOOMBOX            37  // Boombox (value1 = uid wpisu w bazie)
#define ITEM_CRAFT              38  // Crafting (value1 = binarka, value2 = typ przedmiotu)
#define ITEM_FLASHLIGHT         39  // Latarka
#define ITEM_NEWSPAPER          40  // Gazeta (value1 = uid z bazy)
#define ITEM_WOOD               41

#define ITEM_COUNT              41

// Typy list produktów
#define PRODUCT_LIST_NONE       1
#define PRODUCT_LIST_OFFER   	2
#define PRODUCT_LIST_BUY     	3
#define PRODUCT_LIST_OPTIONS    4
#define PRODUCT_LIST_PRICE      5

// Właściciel produktów
#define PRODUCT_OWNER_NONE      0
#define PRODUCT_OWNER_DOOR      1
#define PRODUCT_OWNER_AREA      2

// Logi transakcji
#define TRANSACTION_NONE 		0
#define TRANSACTION_ORDER 		1
#define TRANSACTION_OFFER 		2
#define TRANSACTION_SERVICE 	3
#define TRANSACTION_WITHDRAW 	4
#define TRANSACTION_DEPOSIT 	5
#define TRANSACTION_REMOVE      6
#define TRANSACTION_DOTATION    7

// Typy ofert
#define OFFER_NONE              0
#define OFFER_ITEM              1
#define OFFER_VEHICLE           2
#define OFFER_PRODUCT           3
#define OFFER_VCARD             4
#define OFFER_DOOR              5
#define OFFER_TOWING            6
#define OFFER_PASSAGE           7
#define OFFER_REFUEL            8
#define OFFER_REPAIR            9
#define OFFER_PAINT             10
#define OFFER_PAINTJOB          11
#define OFFER_MONTAGE           12
#define OFFER_MANDATE           13
#define OFFER_UNBLOCK           14
#define OFFER_DOCUMENT          15
#define OFFER_BUSINESS          16
#define OFFER_REGISTER          17
#define OFFER_HEAL              18
#define OFFER_PASS              19
#define OFFER_WELCOME           20
#define OFFER_ADVERTISE         21
#define OFFER_SALON             22
#define OFFER_TAX               23
#define OFFER_KEYS              24
#define OFFER_STYLE             25
#define OFFER_LESSON           	26

// Rodzaje płatności
#define PAY_TYPE_NONE           0
#define PAY_TYPE_CASH           1
#define PAY_TYPE_CARD           2
#define PAY_TYPE_CAPITAL        3

// Specjalne numery
#define NUMBER_NONE             000
#define NUMBER_WHOLESALE        333
#define NUMBER_TAXI             777
#define NUMBER_ALARM            911
#define NUMBER_NEWS             444
#define NUMBER_GASTRONOMY       888

// Rodzaje audio
#define AUDIO_NONE              0
#define AUDIO_CALLING_TO        1
#define AUDIO_CALLING           2
#define AUDIO_SMS               3
#define AUDIO_ALARM             4
#define AUDIO_LSPD              5
#define AUDIO_MESSAGE           6
#define AUDIO_ACHIEVE           7

// Sloty obiektów
#define SLOT_PHONE              0
#define SLOT_WEAPON             1
#define SLOT_HANDCUFFS          2
#define SLOT_ACCESS_1      		3
#define SLOT_ACCESS_2           4
#define SLOT_ACCESS_3           5
#define SLOT_TRYING             6
#define SLOT_TRAIN              7
#define SLOT_BOOMBOX            8
#define SLOT_EXTRA	         	9

// Typy broni
#define WEAPON_TYPE_NONE    	0
#define WEAPON_TYPE_HEAVY   	1
#define WEAPON_TYPE_LIGHT   	2
#define WEAPON_TYPE_MELEE   	3

// Prace dorywcze
#define JOB_NONE        		0
#define JOB_MECHANIC   			1
#define JOB_COURIER             2
#define JOB_SELLER              3
#define JOB_NEWSPAPER           4
#define JOB_LUMBERJACK          5
#define JOB_STOREKEEPR         	6
#define JOB_FISHERMAN           7

// Akcesoria w pojeździe
#define VEH_ACCESS_NONE         0
#define VEH_ACCESS_ALARM        1
#define VEH_ACCESS_IMMO         2
#define VEH_ACCESS_AUDIO        4
#define VEH_ACCESS_RADIO        8
#define VEH_ACCESS_DIM          16
#define VEH_ACCESS_GAS          32
#define VEH_ACCESS_TURBO        64
#define VEH_ACCESS_COMPRESSOR   128
#define VEH_ACCESS_ECU          256

// Używalne obiekty
#define OBJECT_ATM         	 	2942
#define OBJECT_BENCH        	2629
#define OBJECT_BARBELL      	2915
#define OBJECT_PUNCH_BAG   	 	1985
#define OBJECT_FUELING      	3465
#define OBJECT_BUSSTOP      	1257
#define OBJECT_POOL_TABLE   	2964
#define OBJECT_STOVE            0000
#define OBJECT_BASKET           947
#define OBJECT_CRAFT            14869
#define OBJECT_TAG              18663
#define OBJECT_ECHIDNA          2892
#define OBJECT_FOOD_BOX         1342
#define OBJECT_CORNER_GREEN     19606
#define OBJECT_CORNER_BLUE      19607
#define OBJECT_CORNER_RED       19605
#define OBJECT_TREE             657
#define OBJECT_SMUGGLE_CRATE    2969

// Typy lakierowania
#define SPRAY_TYPE_NONE     	0
#define SPRAY_TYPE_COLORS   	1
#define SPRAY_TYPE_PAINTJOB 	2

// Typy blokad
#define BLOCK_NONE          0
#define BLOCK_CHAR          1
#define BLOCK_VEH           2
#define BLOCK_RUN           4
#define BLOCK_OOC           8

// Typy kar
#define PUNISH_NONE         0
#define PUNISH_WARN         1
#define PUNISH_KICK         2
#define PUNISH_BAN          3
#define PUNISH_BLOCK        4
#define PUNISH_AJ           5

// Dokumenty
#define DOC_NONE            0
#define DOC_PROOF           1
#define DOC_DRIVER          2
#define DOC_SEND            4
#define DOC_SANITY          8

// Typy paczek
#define PACKAGE_NONE   		0
#define PACKAGE_PRODUCT   	1
#define PACKAGE_DRUGS       2
#define PACKAGE_WEAPON      3

// Pozycje
#define MAIN_SPAWN_POS      0
#define ADMIN_JAIL_POS      1
#define HOTEL_SPAWN_POS     2

// Typy checkpointów
#define CHECKPOINT_NONE     	0
#define CHECKPOINT_VEHICLE  	1
#define CHECKPOINT_PACKAGE  	2
#define CHECKPOINT_DOOR     	3
#define CHECKPOINT_ACTOR    	4
#define CHECKPOINT_BUSSTOP  	5
#define CHECKPOINT_NEWSPAPER    6
#define CHECKPOINT_MISSION      7

// Typy narkotyków
#define DRUG_NONE           0
#define DRUG_MARIHUANA      1
#define DRUG_COCAINE        2
#define DRUG_HEROIN         3
#define DRUG_AMPHETAMINE    4
#define DRUG_CRACK          5
#define DRUG_CONDITIONER    6

// Rodzaje statusów
#define STATUS_TYPE_NONE    	0
#define STATUS_TYPE_DAZED   	1
#define STATUS_TYPE_DRUNK       2
#define STATUS_TYPE_MUSCLE      4
#define STATUS_TYPE_ROLL        8
#define STATUS_TYPE_MASKED      16
#define STATUS_TYPE_EARPIECE    32
#define STATUS_TYPE_AFK         64
#define STATUS_TYPE_BELTS       128
#define STATUS_TYPE_STONED      256
#define STATUS_TYPE_GLOVES      512
#define STATUS_TYPE_DEFEATED    1024
#define STATUS_TYPE_SHOT        2048
#define STATUS_TYPE_INJURED     4096

// Rodzaje zgonu
#define DEATH_NONE              0
#define DEATH_OVERDOSAGE        1
#define DEATH_BEATING           2
#define DEATH_SHOOTING          3
#define DEATH_SUICIDE           4

// Części ciała
#define BODY_PART_TORSO         1
#define BODY_PART_GROIN         2
#define BODY_PART_LARM      	4
#define BODY_PART_RARM          8
#define BODY_PART_LLEG          16
#define BODY_PART_RLEG          32
#define BODY_PART_HEAD          64

// Pożar budynku
#define FIRE_TIME               0
#define FIRE_OBJECT             1
#define FIRE_LABEL              2

// Rodzaj craftingu
#define CRAFT_TYPE_NONE			0
#define CRAFT_TYPE_WEAPON		1
#define CRAFT_TYPE_FOOD			2
#define CRAFT_TYPE_DRUGS		3

// Osiągnięcia
#define ACHIEVE_PLAYER   		1
#define ACHIEVE_MASTER     		2
#define ACHIEVE_LEGEND	      	4
#define ACHIEVE_FIRST_VEH       8
#define ACHIEVE_INTEREST    	16
#define ACHIEVE_AJ              32
#define ACHIEVE_COLLECTOR       64
#define ACHIEVE_MYOMA           128
#define ACHIEVE_HOUSE           256
#define ACHIEVE_DRUGGIE         512
#define ACHIEVE_SAVINGS         1024
#define ACHIEVE_VCARDS          2048
#define ACHIEVE_STYLE           4096
#define ACHIEVE_RICH            8192
#define ACHIEVE_GROUP           16384
#define ACHIEVE_LEADER          32768
#define ACHIEVE_DRIVER          65536
#define ACHIEVE_FAST            131072

// Flagi grup
#define G_FLAG_IC               1
#define G_FLAG_OOC              2
#define G_FLAG_COLOR            4
#define G_FLAG_DEPARTMENT       8
#define G_FLAG_SPAWN            16
#define G_FLAG_ARREST           32
#define G_FLAG_BLOCADE          64
#define G_FLAG_WEAPONS          128
#define G_FLAG_911              256
#define G_FLAG_RACE             512
#define G_FLAG_LEAVE            1024
#define G_FLAG_TAX              2048
#define G_FLAG_MASK        		4096
#define G_FLAG_TAG              8192
#define G_FLAG_SEARCHING        16384
#define G_FLAG_HANDCUFFS        32768
#define G_FLAG_DUTY             65536

// Typy logów grup
#define LOG_TYPE_NONE           0
#define LOG_TYPE_OFFER          1
#define LOG_TYPE_DEPOSIT        2
#define LOG_TYPE_WITHDRAW       3
#define LOG_TYPE_ORDER          4

// Typy zawijania
#define WRAP_NONE               0
#define WRAP_AUTO               1
#define WRAP_MANUAL             2
#define WRAP_LONG               3

// Typy pickups
#define PICKUP_WORK             1
#define PICKUP_DOOR             2

// Typy actors
#define ACTOR_NONE              0
#define ACTOR_WORKER            1
#define ACTOR_PROSTITUTE        2
#define ACTOR_VICTIM            3
#define ACTOR_SPECIAL           4
#define ACTOR_CORPSE            5
#define ACTOR_TRADER            6

// Samouczek
#define HINT_NONE       		0
#define HINT_INTRO      		1
#define HINT_KEY_NO     		2
#define HINT_AUDIO      		4
#define HINT_BUSSTOP    		8
#define HINT_GOV        		16
#define HINT_DOCUMENT   		32
#define HINT_ATM       			64
#define HINT_BANK       		128
#define HINT_WORK       		256
#define HINT_24/7               512
#define HINT_CARDEALER          1024
#define HINT_HOTEL              2048
#define HINT_ITEMS              4096
#define HINT_ITEMS_NEAR         8192

// Flagi stref
#define A_FLAG_BMX              1
#define A_FLAG_BOOMBOX          2
#define A_FLAG_OFFER            4
#define A_FLAG_PARKING          8
#define A_FLAG_MONITORING       16
#define A_FLAG_CORNER           32
#define A_FLAG_SERVICE          64
#define A_FLAG_LUMBERJACK       128
#define A_FLAG_MISSION          256

// Typy misji
#define MISSION_NOTIFICATION    1
#define MISSION_FIRE_BUILD      2
#define MISSION_FIRE_VEHICLE    3
#define MISSION_ROBBERY         4
#define MISSION_GRAB            5
#define MISSION_KILLING         6
#define MISSION_THEFT			7
#define MISSION_SMUGGLE         8
#define MISSION_CHASE           9

// Interakcje (GII)
#define GII_OPTION_INFO     	0
#define GII_OPTION_CARP     	1
#define GII_OPTION_CART         2
#define GII_OPTION_KEYS     	3
#define GII_OPTION_HANDCUFF 	4
#define GII_OPTION_WELCOME  	5
#define GII_OPTION_GIVE         6
#define GII_OPTION_GET          7

// Dialogs
#define D_NONE      			0
#define D_REGISTER              120
#define D_LOGIN     			1

#define D_CHAR_SELECT           121

#define D_STATS                 2
#define D_PERMS                 3
#define D_INTRO                 4

#define D_SEND_PW               5
#define D_PLAYER_LIST           6

#define D_GROUP_TYPE            7

#define D_SPAWN_VEH             8
#define D_TARGET_VEH            9
#define D_ASSIGN_VEH            10
#define D_ASSIGN_VEH_ACCEPT     11
#define D_MANAGE_VEH            12

#define D_DOOR_PICKUP           13
#define D_DOOR_INTERIOR         14
#define D_DOOR_OPTIONS         	15
#define D_DOOR_NAME             16
#define D_DOOR_ENTER_PAY        17
#define D_DOOR_ASSIGN           18
#define D_DOOR_ASSIGN_ACCEPT    19
#define D_DOOR_AUDIO            20
#define D_DOOR_HOUR             21

#define D_ITEM_PLAYER_LIST      22
#define D_ITEM_OPTIONS          23
#define D_ITEM_SEPARATE         24
#define D_ITEM_CHECK            25
#define D_ITEM_FAVORITE         26
#define D_ITEM_OFFER            27
#define D_ITEM_OFFER_PRICE      28
#define D_ITEM_OFFER_FREE       220
#define D_ITEM_RAISE            29
#define D_ITEM_PUT_BAG          30
#define D_ITEM_REMOVE_BAG       31
#define D_ITEM_REMOVE_CLOSET    32
#define D_ITEM_RELOAD_WEAPON    33
#define D_ITEM_ADD_CHIT         34
#define D_ITEM_WRITE_A_CHECK    35

#define D_PRODUCT_OFFER         36
#define D_PRODUCT_BUY           37
#define D_PRODUCT_SELECT        38
#define D_PRODUCT_OPTIONS       39
#define D_PRODUCT_PRICE         40
#define D_PRODUCT_DELETE        41

#define D_OFFER_SEND            42
#define D_OFFER_PAY_TYPE        43
#define D_OFFER_LIST            44

#define D_PHONE_OPTIONS         45
#define D_PHONE_CALL_NUMBER     46
#define D_PHONE_SMS_NUMBER      47
#define D_PHONE_SEND_SMS        48
#define D_PHONE_SEND_VCARD      49

#define D_CONTACT_LIST          50
#define D_CONTACT_OPTIONS       51
#define D_CONTACT_DELETE        52

#define D_BANK_CREATE_ACCOUNT   53
#define D_BANK_SELECT_OPTIONS   54
#define D_BANK_DEPOSIT          55
#define D_BANK_WITHDRAW         56
#define D_BANK_TRANSFER_NUMBER  57
#define D_BANK_TRANSFER_CASH    58

#define D_DISC_INSERT           59
#define D_DISC_RECORD           60
#define D_DISC_NAME             61

#define D_RADIO_OPTIONS         62
#define D_RADIO_SET_CANAL       63
#define D_RADIO_PASSWORD        64
#define D_RADIO_BUY_CANAL       65
#define D_RADIO_ACCEPT_CANAL    66
#define D_RADIO_CANAL_PASSWORD  67
#define D_RADIO_SET_PASSWORD    68
#define D_RADIO_DELETE_CANAL    69
#define D_RADIO_DELETE_ACCEPT   70
#define D_RADIO_ASSIGN_CANAL    71
#define D_RADIO_ASSIGN_ACCEPT   72

#define D_ROOM_PRICE            73

#define D_TUNING_UNMOUNT        74

#define D_ACCESS_APPLY          75

#define D_CLOTH_TYPE_SELECT     76

#define D_DIRECTORY_LIST        77
#define D_DIRECTORY_ADD         78

#define D_BLOCK_WHEEL           79
#define D_REGISTER_EDIT         80

#define D_PLAY_ANIM             81
#define D_WALK_ANIM             82

#define D_ORDER_CATEGORY        83
#define D_ORDER_PRODUCT         84
#define D_ORDER_COUNT           85
#define D_ORDER_PRICE           86

#define D_BUS_ACCEPT            87

#define D_PACKAGE_GET           88

#define D_WORK_SELECT           89
#define D_WORK_ACCEPT           90

#define D_HELP_MAIN             91

#define D_GROUP_SELECT          93

#define D_CALL_TAXI             94
#define D_CALL_GROUP            95
#define D_CALL_NEWS             96

#define D_SALON_CATEGORY        97

#define D_ITEM_CRAFT            98

#define D_RACE_SAVE             99
#define D_RACE_SELECT           100
#define D_RACE_OPTIONS          101
#define D_RACE_DELETE           102
#define D_RACE_RENAME           103

#define D_ACTOR_ANIM            104
#define D_ACTOR_TYPE            105
#define D_ACTOR_WORKSHOP        106
#define D_ACTOR_GOV             107
#define D_ACTOR_CORPSE          108
#define D_ACTOR_CARDEALER       109
#define D_ACTOR_TRADER          110
#define D_ACTOR_TRADER_SELL     111

#define D_OBJECT_PRIORITY       112

#define D_CORNER_OFFER          113

#define D_AREA_FLAGS            114

#define D_TAG_TEXT              115

#define D_MISSION_DESC          116
#define D_MISSION_START         117

// Forward's
forward OnPlayerLogin(playerid);
forward SetPlayerSpawn(playerid);

forward OnPlayerPasswordHashed(playerid);
forward OnPlayerPasswordChecked(playerid);

forward UpdatePlayerSession(playerid, session_type, session_extraid);

forward ShowPlayerStatsForPlayer(playerid, giveplayer_id);

forward CreateGroup(GroupName[], group_type);
forward DeleteGroup(group_id);
forward query_OnLoadGroups();
forward ShowPlayerGroupInfo(playerid, group_id);
forward ShowPlayerGroupOptions(playerid);
forward HidePlayerGroupOptions(playerid);

forward CreateStaticVehicle(modelid, Float:PosX, Float:PosY, Float:PosZ, Float:PosA, color1, color2, respawn_delay);
forward DeleteVehicle(vehid);
forward LoadVehicle(veh_uid);
forward query_OnLoadVehicles();
forward query_OnLoadVehicleComponents();
forward ShowPlayerVehicleInfo(playerid, vehid);
forward OnVehicleEngineStarted(vehicleid);

forward CreateDoor(Float:DoorEnterX, Float:DoorEnterY, Float:DoorEnterZ, Float:DoorEnterA, DoorEnterInt, DoorEnterVW, DoorName[]);
forward SaveDoor(doorid);
forward DeleteDoor(doorid);
forward query_OnLoadDoors();
forward ShowPlayerDoorInfo(playerid, doorid);

forward CreatePlayerItem(playerid, item_name[], item_type, item_value1, item_value2);
forward DeletePlayerItem(playerid, itemid);
forward ShowPlayerItemInfo(playerid, item_uid);
forward ListPlayerItems(playerid);
forward ListPlayerFavoriteItems(playerid);
forward ListPlayerCheckedItems(playerid);

forward ListPlayerNearItems(playerid);
forward ListPlayerItemsForPlayer(playerid, giveplayer_id);
forward ListVehicleItemsForPlayer(vehicleid, playerid);
forward OnPlayerUseItem(playerid, itemid);
forward OnPlayerDropItem(playerid, itemid);
forward OnPlayerRaiseItems(playerid);
forward LoadPlayerItems(playerid);
forward LoadPlayerItem(playerid, item_uid);
forward UnloadPlayerItems(playerid);
forward UnloadPlayerItem(playerid, itemid);
forward query_OnListPlayerNearItems(playerid, item_place);

forward CreateArea(Float:AreaMinX, Float:AreaMinY, Float:AreaMaxX, Float:AreaMaxY, area_world, Float:AreaMinZ, Float:AreaMaxZ);
forward LoadArea(area_uid);
forward SaveArea(areaid);
forward DeleteArea(areaid);
forward query_OnLoadAreas();

forward CreateDoorProduct(doorid, ProductName[], ProductType, ProductValue1, ProductValue2, ProductPrice, ProductCount);
forward query_OnLoadProducts();
forward DeleteProduct(product_id);
forward ListGroupProductsForPlayer(group_id, playerid, list_type);
forward AddGroupTransactionLog(transaction_owner, group_id, transaction_type, price, transaction_value, transaction_extraid);

forward crp_AddObject(ModelID, Float:PosX, Float:PosY, Float:PosZ, Float:RotX, Float:RotY, Float:RotZ, InteriorID, VirtualWorld);
forward SaveObjectPos(object_id);
forward DeleteObject(object_id);
forward query_OnLoadObjects();

forward Add3DTextLabel(LabelDesc[256], LabelColor, Float:LabelPosX, Float:LabelPosY, Float:LabelPosZ, Float:LabelDrawDistance, LabelWorld, LabelInteriorID);
forward query_OnLoad3DTextLabels();
forward crp_Delete3DTextLabel(label_id);
forward Save3DTextLabel(label_id);

forward OnPlayerSendOffer(playerid, customerid, OfferName[], OfferType, OfferValue1, OfferValue2, OfferPrice);

forward OnPlayerAcceptOffer(playerid, offererid);
forward OnPlayerRejectOffer(playerid, offererid);

forward OnPlayerEnterDoor(playerid, doorid);
forward OnPlayerExitDoor(playerid, doorid);

forward LoadAllAccess();
forward LoadAllSkins();
forward LoadAllAnims();

forward LoadPlayerAccess(playerid);
forward LoadPlayerGroups(playerid);

forward ShowPlayerDirectoryForPlayer(playerid, giveplayer_id);
forward GivePlayerPunish(playerid, giverid, punish_type, punish_reason[], punish_time, punish_extraid);

forward LoadPlayerBans(playerid);

forward AddPlayerPunishLog(playerid, punish_giver, punish_type, punish_extraid, punish_reason[], punish_date, punish_end);
forward ProxDetector(Float:radi, playerid, string[], col1, col2, col3, col4, col5);

forward UpdatePlayerStatus(playerid);
forward CreatePlayerCorpse(playerid, killer_uid, weapon_uid);

forward GivePlayerAchievement(playerid, achieve_type);

forward crp_CreateActor(actor_name[32], modelid, Float:aX, Float:aY, Float:aZ, Float:aR, aVW, aInterior);
forward query_OnLoadActors();
forward DeleteActor(actorid);
forward SaveActor(actorid);
forward OnPlayerInteractActor(playerid, actorid);

forward CheckPlayerPayday(playerid);

forward OnPlayerStartMission(playerid, mission_uid);
forward OnPlayerStopMission(playerid);

forward CreateGroupMission(group_id, group_type, mission_type, mission_desc[], mission_victim, mission_members, mission_award, mission_time);
forward DeleteMission(mission_uid);

// New's

new models_url[] = "https://m-rp.net/models";
new audio_url[] = "https://m-rp.net/audio";

new MySQL:connHandle;

new Text:TextDrawServerLogo;
new Text:TextDrawMainLogo;
new Text:TextDrawNews;
new Text:TD_GroupOption[6][MAX_GROUP_SLOTS];

new Text:TextDrawPremium;

new PlayerText:TD_SmallInfo[MAX_PLAYERS];
new PlayerText:TextDrawLargeInfo[MAX_PLAYERS][2];

new PlayerText:TD_Hint[MAX_PLAYERS];

new PlayerText:TD_MainGroupTag[MAX_PLAYERS][MAX_GROUP_SLOTS];
new PlayerText:TD_MainGroupName[MAX_PLAYERS][MAX_GROUP_SLOTS];

new Text:TextDrawOfferAccept;
new Text:TextDrawOfferReject;

new Text:TextDrawOfferBack;
new PlayerText:TextDrawOfferDesc[MAX_PLAYERS];

new Text:TextDrawPunishTitle;
new Text:TextDrawPunishDesc;

new PlayerText:TextDrawAchieve[MAX_PLAYERS];
new PlayerText:TextDrawRadioCB[MAX_PLAYERS];

new PlayerText:TextDrawDuty[MAX_PLAYERS];

new PunishTime;
new AdminColor[20][12];

new WorldTime;
new Cache:external_items_cache[MAX_PLAYERS][10];

new PlayerText:GII_VisualItem[MAX_PLAYERS];
new Text:GII_Option[10];

new PlayerText:TextDrawScreenShot[MAX_PLAYERS];


// On top of script:
new Text:Textdraw0;
new Text:Textdraw2;
new Text:Textdraw3;
new Text:Textdraw4;
new Text:Textdraw5;
new Text:Textdraw6;
new Text:Textdraw7;
new Text:Textdraw8;
new Text:Textdraw9;

// Iterators
new Iterator:Groups<MAX_GROUPS>;
new Iterator:Vehicles<MAX_VEHICLES>;

new Iterator:PlayerItem[MAX_PLAYERS]<MAX_ITEM_CACHE>;
new Iterator:CheckedPlayerItem[MAX_PLAYERS]<MAX_ITEM_CACHE>;

new Iterator:MissionPlayer[MAX_PLAYERS]<20>;

new Iterator:Product<MAX_PRODUCTS>;
new Iterator:Access<MAX_ACCESS>;

new Iterator:Skin<MAX_SKINS>;
new Iterator:Anim<MAX_ANIMS>;

// tymczasowy enum na zapis
enum sAttachEdit
{
	aUID,
	aName[32]
}
new AttachEdit[MAX_PLAYERS][sAttachEdit];

// Enums
enum sPlayer
{
	pLastKey,

	pUID,
	pGID,
	
	pCharName[32],
	pGlobName[256],
	
	pPassword[256],
	
	pHours,
	pMinutes,
	
	pAdmin,
	pAdminType,
	
	pPoints,
	
	pCash,
	pBankCash,
	
	pPhoneNumber,
	pBankNumber,
	
	pNickColor,
	pPremium,
	
	pSkin,
	Float:pHealth,
	
	pSex,
	pBirth,
	
	Float:pPosX,
	Float:pPosY,
	Float:pPosZ,
	Float:pPosA,
	
	pVirtualWorld,
	pInteriorID,
	
	pBlock,
	pCrash,
	
	pArrest,
	
	pBW,
	pAJ,
	
	pHouse,
	
	pDocuments,
	pAchievements,
	
	pPDP,
	
	pHint,
	pLastPayday,
	
	pLogTries,
	
	pLastVeh,
	pLastW,
	pLastReport,
	pLastSkin,
	pLastMileage,
	pLastObject,
	pLastActor,
	pLastKeyUse,
	
	pAFK,
	bool: pOOC,
	
	pDuty[DUTY_COUNT],
	
	bool: pListPlayerGroups,
	
	pMainTable,
	pManageItem,
	
	pSmallTextTime,
	pLargeTextTime,
	pHintTextTime,
	pAchieveTextTime,
	
	pFreeze,
	
	pMainGroupSlot,
	
	pStrength,
	Float:pDepend,
	
	Float:pMileage,
	
	bool:pEpisode,
	
	pAudioHandle,
	pStatus,
	
	pTaxiVeh,
	pTaxiPay,
	pTaxiPrice,
	pTaxiPassenger,
	
	pRepairVeh,
	pRepairTime,
	Text3D:pRepairTag,
	
	pSprayVeh,
	pSprayTime,
	pSprayColor[2],
	pSprayType,
	Text3D:pSprayTag,
	
	pMontageVeh,
	pMontageItem,
	pMontageTime,
	
	pCuffedTo,
	pCallingTo,
	
	bool: pCreatingArea,
	Float:pCreatingAreaPos[6],
	
	bool: pCreatingChar,
	
	pCurrentArea,
	
	pEditObject,
	pEdit3DText,
	pEditActor,
	
	bool: pRadioLive,
	pRadioInterview,
	
	pSelectAccess,
	pSelectSkin,
	bool: pSelectTalkStyle,

	pItemArray[ITEM_COUNT],
	pItemWeapon,
	pItemPlayer,
	pItemPass,
	pItemMask,
	pItemBoombox,
	pItemGloves,
	
	bool: pPuttingBag,
	
	pCheckWeapon,
	bool: pCheckPos,
	
	pSearches,
	pSearchTime,
	
	pLesson,
	pLessonTime,
	
	pHealing,
	
 	pSpectate,
	
	pPackage,
	Float:pPackageDistance,
	
	pTalkStyle,
	pWalkStyle,
	pFightStyle,
	
	pGymObject,
	pGymRepeat,
	pGymTime,
	
	pBusStart,
	pBusTravel,
	pBusTime,
	pBusPrice,
	bool: pBusRide,
	Float:pBusPosition[3],
	
	pDrugType,
	pDrugLevel,
	pDrugValue1,
	pDrugValue2,
	
	pDeathKiller,
	pDeathWeapon,
	pDeathType,
	pDeathBody,
	
	pBasketObject,
	pBasketBall,
	
	pTaggingObject,
	pTaggingTime,
	
	pCornerObject,
	pCornerPrice,
	
	bool: pRaceCreating,
	pRaceCheckpoints,
	
	bool: pRoll,
	bool: pBelts,
	bool: pFlashLight,
	
	bool: pLogged,
	bool: pSpawned,
	bool: pBanned,

	pCheckpoint,
	pSession[6],
	
	bool: pTogW,
	bool: pTogDesc,
	bool: pTogNick,
	
	bool: pPlayAnim,
	
	Text3D:pNameTag,
	Text3D:pDescTag,
	Text3D:vDescTag,
	
	pFirstPersonObject,
	pIgnored[MAX_PLAYERS],
	
	Float:pPRVelocity[3],
	bool: pScreenShot,
	
	pGII_Type,
	pGII_Option,
	
	ORM: pOrm
}
new PlayerCache[MAX_PLAYERS][sPlayer];

enum sGroupInfo
{
	gUID,
	gName[32],
	
	gCash,
	gMaxPay,
	
	gCapital,

	gType,
	gOwner,

	gValue1,
	gValue2,
	
	gColor,
	gAdvertise[128],
	
	gTag[5],
	gLastTax,
	
	gFlags,
	gExtraArray[20],
	
	bool: gToggleChat,
	ORM:gOrm
}
new GroupData[MAX_GROUPS][sGroupInfo];

enum sPlayerGroup
{
	gpUID,
	gpID,
	
	gpPerm,
	gpTitle[32],
	
	gpPayment,
	gpSkin,
	
	gpDutyMinute,
	gpPay,
	
	bool: gpTogG
}
new PlayerGroup[MAX_PLAYERS][MAX_GROUP_SLOTS][sPlayerGroup];

enum sGroupTypeInfo
{
	gTypeName[24],
	gTypeMaxDotation,
	
	gTypeMapIcon,
	bool:gIconStatic,
	
	gTypePrice,
	gTypeFlags
}
new GroupTypeInfo[][sGroupTypeInfo] =
{
	{"Nieokreślony",			0,		0,		false,		2000,		G_FLAG_OOC | G_FLAG_TAX},
	{"Police",					900,	30,		true,		0,			G_FLAG_IC | G_FLAG_OOC | G_FLAG_COLOR | G_FLAG_DEPARTMENT | G_FLAG_ARREST | G_FLAG_BLOCADE | G_FLAG_WEAPONS | G_FLAG_911 | G_FLAG_MASK | G_FLAG_SEARCHING | G_FLAG_HANDCUFFS},
	{"Medical",					1100,	22,		true,		0,			G_FLAG_IC | G_FLAG_OOC | G_FLAG_COLOR | G_FLAG_DEPARTMENT},
	{"San News",				700,	48,		true,		0,			G_FLAG_IC | G_FLAG_OOC | G_FLAG_COLOR},
	{"Ochrona",					700,	0,		false,		11000,		G_FLAG_IC | G_FLAG_OOC | G_FLAG_TAX},
	{"Gang",					100,	0,		false,		0,			G_FLAG_OOC | G_FLAG_SPAWN | G_FLAG_MASK | G_FLAG_TAG | G_FLAG_SEARCHING},
	{"Stacja benzynowa",		700,	0,		true,		12000,		G_FLAG_IC | G_FLAG_OOC | G_FLAG_TAX},
	{"Gastronomia",				700,	50,		false,		9000,		G_FLAG_IC | G_FLAG_OOC | G_FLAG_TAX},
	{"Firma taksówkarska",		700,	0,		false,		12500,		G_FLAG_IC | G_FLAG_OOC | G_FLAG_TAX},
	{"Warsztat",				700,	27,		false,		10000,		G_FLAG_IC | G_FLAG_OOC | G_FLAG_TAX},
	{"Siłownia",				700,	54,		false,		7000,		G_FLAG_IC | G_FLAG_OOC | G_FLAG_TAX},
	{"Government",				900,	34,		true,		0,			G_FLAG_IC | G_FLAG_OOC | G_FLAG_COLOR | G_FLAG_DEPARTMENT},
	
	{"Armia",					900,	0,		false,		0,			G_FLAG_IC | G_FLAG_OOC | G_FLAG_COLOR | G_FLAG_DEPARTMENT | G_FLAG_ARREST | G_FLAG_BLOCADE | G_FLAG_WEAPONS | G_FLAG_MASK | G_FLAG_SEARCHING | G_FLAG_HANDCUFFS},
	{"Fire Department",			1100,	20,		true,		0,			G_FLAG_IC | G_FLAG_OOC | G_FLAG_COLOR | G_FLAG_DEPARTMENT | G_FLAG_BLOCADE},
	{"FBI",						900,	0,		false,		0,			G_FLAG_IC | G_FLAG_OOC | G_FLAG_COLOR | G_FLAG_DEPARTMENT | G_FLAG_ARREST | G_FLAG_BLOCADE | G_FLAG_WEAPONS | G_FLAG_MASK | G_FLAG_SEARCHING | G_FLAG_HANDCUFFS},

	{"Mafia",					0,		0,		false,		0,			G_FLAG_OOC | G_FLAG_SPAWN | G_FLAG_MASK | G_FLAG_SEARCHING},

	{"Rodzina",                 0,      0,		false,		0,          G_FLAG_OOC | G_FLAG_SPAWN},
	{"Zmotoryzowana",           0,      0,		false,		0,          G_FLAG_OOC | G_FLAG_SPAWN | G_FLAG_RACE},
	
	{"Szkoła jazdy",            700,    38,		false,		9000,       G_FLAG_OOC | G_FLAG_TAX},
	
	{"Wypożyczalnia",           700,    0,		false,		9800,      	G_FLAG_OOC | G_FLAG_TAX},
	{"24/7",					700,	25,		true,		5000,		G_FLAG_OOC | G_FLAG_TAX},

	{"Salon samochodowy",		700,	55,		true,		12500,		G_FLAG_IC | G_FLAG_OOC | G_FLAG_TAX},
	{"Ciucholand",				0,		45,		true,		8000,		G_FLAG_OOC | G_FLAG_TAX},

	{"Hotel",					150,	32,		true,		5500,		G_FLAG_OOC | G_FLAG_TAX},
	{"Bank",					0,		52,		true,		6000,		G_FLAG_OOC | G_FLAG_TAX}

};

enum sActorTypeInfo
{
	aTypeName[24]
}
new ActorTypeInfo[][sActorTypeInfo] =
{
	{"Nieokreślony"},
	{"Pracownik"},
	{"Prostytutka"},
	{"Ofiara"},
	{"Specjalny"},
	{"Zwłoki"},
	{"Kupiec"}
};

enum sCarInfo
{
	cUID,
	cModel,

	Float:cPosX,
	Float:cPosY,
	Float:cPosZ,
	Float:cPosA,
	
	cWorldID,
	cInteriorID,

	cColor1,
	cColor2,
	
	Float:cFuel,
	cFuelType,
	
	Float:cHealth,
	Float:cMileage,
	
	bool: cLocked,
	cVisual[32],
	
	cPaintJob,
	cAccess,

	cBlockWheel,
	cRegister[12],
	
	cOwner,
	cOwnerType,
	
	Float:cHandling,
	
	cDistTicker,
	cSavePoint,
	
	cComponent[14],
	cAudioURL[128],
	
	cRadioCanal,
	bool: cGPS,
	
	cLastUsing,
	bool: cGlass,
	
	ORM:cOrm
}
new CarInfo[MAX_VEHICLES][sCarInfo];

enum sVehicleModelData
{
	vName[32],
	vMaxSpeed,
	
	vMaxFuel,
	vMaxPrice
}
new VehicleModelData[212][sVehicleModelData] =
{
	{"Landstalker", 		140, 		70,			0},
	{"Bravura", 			131,		52,			6100},
	{"Buffalo", 			166, 		60,			0},
	{"Linerunner", 			98,  		400,		0},
	{"Pereniel", 			118, 		50,			3300},
	{"Sentinel", 			146, 		52,			12000},
	{"Dumper", 				98,			150,		0},
	{"Firetruck", 			132,		250,		0},
	{"Trashmaster", 		89,			150,		0},
	{"Stretch", 			140,		110,		0},
	{"Manana", 				115,		66,			4000},
	{"Infernus", 			197,		66,			0},
	{"Voodoo", 				150,		52,			0},
	{"Pony", 				98,			80,			0},
	{"Mule", 				94,			120,		0},
	{"Cheetah", 			171,		76,			0},
	{"Ambulance", 			137,		120,		0},
	{"Leviathan", 			399,		408,		0},
	{"Moonbeam", 			103,		80,			0},
	{"Esperanto", 			133,		72,			0},
	{"Taxi", 				129,		80,			0},
	{"Washington", 			137,		82,			0},
	{"Bobcat", 				124,		80,			0},
	{"Mr Whoopee", 			88,			90,			0},
	{"BF Injection", 		120,		30,			0},
	{"Hunter", 				399,		500,		0},
	{"Premier", 			154,		70,			0},
	{"Enforcer", 			147,		120,		0},
	{"Securicar", 			139,		120,		0},
	{"Banshee", 			179,		68,			0},
	{"Predator", 			399,		220,		0},
	{"Bus", 				116,		315,		0},
	{"Rhino", 				84,			1020,		0},
	{"Barracks", 			98,			430,		0},
	{"Hotknife", 			148,		30,			0},
	{"Trailer", 			0,			0,			0},
	{"Previon", 			133,		60,			0},
	{"Coach", 				140,		310,		0},
	{"Cabbie", 				127,		80,			0},
	{"Stallion", 			150,		72,			7900},
	{"Rumpo", 				121,		80,			0},
	{"RC Bandit", 			67,			0,			0},
	{"Romero", 				124,		61,			0},
	{"Packer", 				112,		180,		0},
	{"Monster Truck A", 	98,			162,		0},
	{"Admiral", 			146,		56,			4600},
	{"Squalo", 				399,		101,		0},
	{"Seasparrow", 			399,		140,		0},
	{"Pizzaboy",			162,		7,			0},
	{"Tram", 				399,		0,			0},
	{"Trailer", 			399,		0,			0},
	{"Turismo", 			172,		78,			0},
	{"Speeder", 			399,		111,		0},
	{"Reefer", 				399,		201,		0},
	{"Tropic", 				399,		221,		0},
	{"Flatbed", 			140,		198,		0},
	{"Yankee", 				94,			101,		0},
	{"Caddy", 				84,			15,			0},
	{"Solair", 				140,		70,			0},
	{"Berkleys RC Van",		121,		84,			0},
	{"Skimmer", 			399,		30,			0},
	{"PCJ-600", 			180,		25,			0},
	{"Faggio", 				155,		7,			1800},
	{"Freeway", 			180,		25,			0},
	{"RC Baron", 			399,		0,			0},
	{"RC Raider", 			399,		0,			0},
	{"Glendale", 			131,		71,			0},
	{"Oceanic", 			125,		61,			0},
	{"Sanchez", 			164,		27,			0},
	{"Sparrow", 			399,		50,			0},
	{"Patriot", 			139,		110,		0},
	{"Quad", 				98,			35,			0},
	{"Coastguard", 			399,		110,		0},
	{"Dinghy", 				399,		69,			0},
	{"Hermes", 				133,		70,			0},
	{"Sabre", 				154,		71,			0},
	{"Rustler", 			399,		68,			0},
	{"ZR-350", 				166,		69,			0},
	{"Walton", 				105,		45,			0},
	{"Regina", 				124,		61,			5200},
	{"Comet", 				164,		67,			0},
	{"BMX", 				86,			0,			0},
	{"Burrito", 			139,		96,			0},
	{"Camper", 				109,		75,			0},
	{"Marquis", 			399,		87,			0},
	{"Baggage", 			88,			40,			0},
	{"Dozer", 				56,			141,		0},
	{"Maverick", 			399,		123,		0},
	{"News Chopper", 		399,		121,		0},
	{"Rancher", 			124,		91,			0},
	{"FBI Rancher", 		139,		101,		0},
	{"Virgo", 				132,		81,			0},
	{"Greenwood", 			125,		62,			7100},
	{"Jetmax", 				399,		130,		0},
	{"Hotring", 			191,		99,			0},
	{"Sandking", 			157,		81,			0},
	{"Blista Compact", 		145,		61,			0},
	{"Police Maverick", 	399,		140,		0},
	{"Boxville", 			96,			121,		0},
	{"Benson", 				109,		104,		0},
	{"Mesa", 				125,		71,			0},
	{"RC Goblin", 			399,		0,			0},
	{"Hotring Racer", 		191,		96,			0},
	{"Hotring Racer", 		191,		97,			0},
	{"Bloodring Banger",	154,		91,			0},
	{"Rancher", 			124,		84,			0},
	{"Super GT", 			159,		67,			0},
	{"Elegant", 			148,		81,			0},
	{"Journey", 			96,			133,		0},
	{"Bike", 				93,			0,			650},
	{"Mountain Bike", 		117,		0,			0},
	{"Beagle", 				399,		210,		0},
	{"Cropdust", 			399,		130,		0},
	{"Stunt", 				399,		54,			0},
	{"Tanker", 				107,		300,		0},
	{"RoadTrain", 			126,		300,		0},
	{"Nebula", 				140,		63,			7400},
	{"Majestic", 			140,		64,			0},
	{"Buccaneer", 			146,		67,			0},
	{"Shamal", 				399,		300,		0},
	{"Hydra", 				399,		290,		0},
	{"FCR-900", 			190,		35,			0},
	{"NRG-500", 			200,		35,			0},
	{"HPV1000", 			172,		40,			0},
	{"Cement Truck", 		116,		91,			0},
	{"Tow Truck", 			143,		65,			0},
	{"Fortune", 			140,		63,			0},
	{"Cadrona", 			133,		71,			0},
	{"FBI Truck", 			157,		71,			0},
	{"Willard", 			133,		67,			8000},
	{"Forklift", 			54,			12,			0},
	{"Tractor", 			62,			21,			0},
	{"Combine", 			98,			36,			0},
	{"Feltzer", 			148,		61,			0},
	{"Remington", 			150,		71,			0},
	{"Slamvan", 			140,		85,			0},
	{"Blade", 				154,		69,			0},
	{"Freight", 			399,		0,			0},
	{"Streak", 				399,		0,			0},
	{"Vortex", 				89,			33,			0},
	{"Vincent", 			136,		60,			9600},
	{"Bullet", 				180,		71,			0},
	{"Clover", 				146,		69,			0},
	{"Sadler", 				134,		60,			0},
	{"Firetruck", 			132,		120,		0},
	{"Hustler", 			131,		74,			5500},
	{"Intruder", 			133,		64,			6100},
	{"Primo", 				127,		67,			8600},
	{"Cargobob", 			399,		210,		0},
	{"Tampa", 				136,		71,			0},
	{"Sunrise", 			128,		64,			0},
	{"Merit", 				140,		64,			0},
	{"Utility", 			108,		68,			0},
	{"Nevada", 				399,		330,		0},
	{"Yosemite", 			128,		81,			0},
	{"Windsor", 			141,		61,			0},
	{"Monster Truck B", 	98,			123,		0},
	{"Monster Truck C", 	98,			124,		0},
	{"Uranus", 				139,		61,			0},
	{"Jester", 				158,		63,			0},
	{"Sultan", 				150,		71,			0},
	{"Stratum", 			137,		74,			0},
	{"Elegy", 				158,		66,			0},
	{"Raindance", 			399,		210,		0},
	{"RC Tiger", 			79,			0,			0},
	{"Flash", 				146,		57,			0},
	{"Tahoma",				142,		65,			7800},
	{"Savanna", 			154,		66,			0},
	{"Bandito", 			130,		45,			0},
	{"Freight", 			399,		0,			0},
	{"Trailer", 			399,		0,			0},
	{"Kart", 				83,			10,			0},
	{"Mower", 				54,			10,			0},
	{"Duneride", 			98,			121,		0},
	{"Sweeper", 			53,			21,			0},
	{"Broadway", 			140,		71,			0},
	{"Tornado", 			140,		75,			0},
	{"AT-400", 				399,		900,		0},
	{"DFT-30", 				116,		210,		0},
	{"Huntley", 			140,		85,			0},
	{"Stafford", 			136,		80,			0},
	{"BF-400", 				170,		31,			0},
	{"Newsvan", 			121,		81,			0},
	{"Tug", 				76,			20,			0},
	{"Trailer", 			399,		0,			0},
	{"Emperor", 			136,		64,			0},
	{"Wayfarer", 			175,		30,			0},
	{"Euros", 				147,		66,			0},
	{"Hotdog",				96,			79,			0},
	{"Club", 				145,		59,			0},
	{"Trailer", 			399,		0,			0},
	{"Trailer", 			399,		0,			0},
	{"Andromada", 			399,		0,			0},
	{"Dodo", 				399,		110,		0},
	{"RC Cam", 				54,			0,			0},
	{"Launch",				399,		151,		0},
	{"Police Car",			156,		89,			0},
	{"Police Car", 			156,		89,			0},
	{"Police Car", 			156,		89,			0},
	{"Police Ranger", 		140,		94,			0},
	{"Picador", 			134,		61,			0},
	{"S.W.A.T. Van", 		98,			120,		0},
	{"Alpha", 				150,		61,			0},
	{"Phoenix", 			152,		59,			0},
	{"Glendale Shit", 		131,		91,			0},
	{"Sadler Shit", 		134,		64,			0},
	{"Luggage Trailer", 	399,		0,			0},
	{"Luggage Trailer", 	399,		0,			0},
	{"Stair Trailer", 		399,		0,			0},
	{"Boxville", 			96,			99,			0},
	{"Farm Plow", 			399,		0,			0},
	{"Utility Trailer", 	399,		0,			0}
};

new FuelTypeName[3][12] = {"Benzyna", "Gaz", "Ropa"};

enum sInteriorData
{
	INTERIOR_ID,
	Float:INTERIOR_X,
	Float:INTERIOR_Y,
	Float:INTERIOR_Z,
	Float:INTERIOR_A,
	
	INTERIOR_NAME[32],
	INTERIOR_PRICE
}
new InteriorInfo[][sInteriorData] = {
 	{5, 772.3852,-5.0267,1000.7289,0.6510,			"Ganton Gym", 						8000},
  	{3, 975.1497,-8.8785,1001.1484,92.6761, 		"Brothel", 							9500},
   	{3, 966.9457,-53.1448,1001.1246,91.2287,		"Brothel2", 						12500},
    {3, 834.2611,7.3429,1004.1870,88.4086, 			"Inside Track Betting", 			8000},
    {3, 1038.1899,-3.8097,1001.2845,359.7343, 		"Blastin' Fools Records", 			7500},
    {3, 1212.2024,-26.0924,1000.9531,181.7593,		"The Big Spread Ranch", 			11000},
    {18, 1291.9290,3.7353,1001.0112,180.8917, 		"Warehouse 1", 						35000},
    {1, 1403.9896,4.1124,1000.9089,180.0966, 		"Warehouse 2", 						40000},
    {3, 1525.9994,-10.8667,1002.0971,275.7367, 		"B Dup's Apartment", 				3000},
    {2, 1521.0021,-48.0825,1002.1310,269.8558, 		"B Dup's Crack Palace", 			3000},
    {3, 612.2191,-123.9028,997.9922,266.5704, 		"Wheel Arch Angels", 				8000},
    {3, 520.3263,-9.0747,1001.5653,90.2650, 		"OG Loc's House",					6000},
    {3, 418.7094,-84.0039,1001.8047,0.9642, 		"Barber Shop", 						7500},
    {3, 390.1465,173.8574,1008.3828,87.4451, 		"Planning Department", 				35000},
    {3, 288.7931,167.4812,1007.1719,357.5410, 		"Las Venturas Police Department", 	30000},
    {3, 207.1015,-140.0236,1003.5078,356.9143, 		"Pro-Laps", 						14500},
    {3, -100.4219,-24.6163,1000.7188,356.9143, 		"Sex Shop", 						19000},
    {3, -204.5397,-43.9880,1002.2734,356.9143, 		"Las Venturas Tattoo parlor", 		6500},
    {17, -204.2623,-8.3931,1002.2734,0.0477, 		"Lost San Fierro Tattoo parlor", 	22000},
    {17, -25.7220,-187.8216,1003.5469,5.0760, 		"24/7 (version 1)", 				13000},
    {5, 372.4557,-133.3936,1001.4922,1.6144, 		"Pizza Stack", 						25500},
    {17, 377.2173,-193.1430,1000.6401,0.0477, 		"Rusty Brown's Donuts", 			15000},
    {7, 315.9149,-143.4442,999.6016,1.6144, 		"Ammu-nation", 						19500},
    {5, 227.0982,-8.0044,1002.2109,90.9151, 		"Victim", 							7000},
    {2, 612.6995,-75.5179,997.9922,273.3493, 		"Loco Low Co", 						16000},
    {10, 246.3100,107.7927,1003.2188,2.7954, 		"San Fierro Police Department", 	90000},
    {10, 6.2462,-31.1101,1003.5494,0.0478, 			"24/7 (version 2 - large)", 		25000},
    {7, 773.8416,-78.5067,1000.6623,0.0478, 		"Below The Belt Gymr", 				15000},
    {1, 608.0074,-10.7054,1000.9174,272.1453, 		"Transfenders", 					26000},
    {1, 285.4489,-41.1734,1001.5156,355.6142, 		"Ammu-nation (version 2)", 			21000},
    {1, 203.9385,-50.1884,1001.8047,355.6142,		"SubUrban", 						18500},
    {1, 244.1629,304.8900,999.1484,268.8201, 		"Denise's Bedroom", 				5000},
    {3, 293.0890,309.9762,999.1484,86.1683, 		"Helena's Barn", 					7500},
    {5, 322.1865,302.7020,999.1484,358.1208, 		"Barbara's Love nest", 				40000},
    {2, 1204.9052,-13.4438,1000.9219,2.5557, 		"The Pig Pen (strip club 2)", 		29000},
    {10, 2018.6531,1017.8937,996.8750,87.1330, 		"Four Dragons", 					45000},
    {2, 2455.7131,-1706.5864,1013.5078,357.7831,	"Ryder's house",					14000},
    {1, 2524.6389,-1679.3669,1015.4986,270.1214, 	"Sweet's House", 					13000},
    {3, 2496.0498,-1692.4344,1014.7422,181.4706, 	"The Johnson House", 				32000},
    {10, 362.9743,-74.9267,1001.5078,317.1219, 		"Burger shot", 						15000},
    {1, 2234.0559,1714.0764,1012.3347,180.8439, 	"Caligula's Casino", 				60000},
    {2, 266.8239,304.9771,999.1484,272.9415, 		"Katie's Lovenest",		 			6000},
    {2, 411.5980,-22.9821,1001.8047,358.7722, 		"Barber Shop 2 (Reece's)", 			6500},
    {2, 1.1853,-3.2387,999.4284,87.5718, 			"Angel \"Pine Trailer\"", 			8000},
    {18, -31.1142,-91.6357,1003.5469,356.8922, 		"24/7 (version 3)", 				20000},
    {18, 161.3073,-96.5507,1001.8047,356.8922, 		"Zip", 								6500},
    {3, -2636.7996,1402.7880,906.4609,356.8922, 	"The Pleasure Domes", 				59000},
    {5, 1261.0970,-785.3736,1091.9063,269.3989, 	"Madd Dogg's Mansion", 				220000},
    {2, 2570.7341,-1301.9620,1044.1250,84.9398, 	"Big Smoke's Crack Palace", 		140000},
    {5, 2352.3013,-1180.8904,1027.9766,89.6399, 	"Burning Desire Building", 			2500},
    {1, -2158.6418,642.7681,1052.3750,186.1475, 	"Wu-Zi Mu's", 						28000},
    {10, 422.2926,2536.6521,10.0000,91.8332, 		"Abandoned AC tower", 				7000},
    {14, 254.3687,-41.7188,1002.0308,269.8082, 		"Wardrobe/Changing room", 			1500},
    {14, 204.3125,-168.7386,1000.5234,358.7724, 	"Didier Sachs", 					12000},
    {12, 1133.0537,-15.3457,1000.6797,357.5191, 	"Casino (Redsands West)", 			27000},
    {17, 493.5156,-24.7910,1000.6797,357.5191, 		"Club", 							34500},
    {18, 1726.9481,-1638.5168,20.2233,176.4107, 	"Atrium", 							36000},
    {16, -204.2385,-27.0951,1002.2734,359.6890, 	"Los Santos Tattoo Parlor", 		6500},
    {5, 2233.6138,-1115.0178,1050.8828,359.6890,	"Safe House group 1", 				6500},
    {9, 2317.9077,-1026.6240,1050.2178,3.1357, 		"Safe House group 3", 				43000},
    {10, 2259.6904,-1135.9205,1050.6328,266.9415, 	"Safe House group 4", 				9000},
    {15, 2214.9121,-1150.3807,1025.7969,268.5082, 	"Jefferson Motel", 					39500},
	{1, 2.1403,23.2410,1199.5938,93.0399, 			"Jet Interior", 					20000},
 	{1, 681.6216,-451.8933,-25.6172,166.1660, 		"The Welcome Pump", 				29000},
 	{3, 235.2854,1186.7764,1080.2578,359.9790, 		"Burglary House X1",				0},
  	{2, 225.5707,1240.0643,1082.1406,96.2852, 		"Burglary House X2", 				15000},
   	{1, 223.0885,1287.1864,1082.1406,356.2190, 		"Burglary House X3", 				50000},
	{5, 226.9825,1114.3130,1080.9965,270.0515, 		"Burglary House X4", 				0},
 	{15, 207.5804,-110.9442,1005.1328,358.4124, 	"Binco", 							27500},
  	{15, 295.1391,1473.3719,1080.2578,352.9526, 	"4 Burglary houses", 				6000},
    {12, 446.7587,506.6798,1001.4195,357.4724, 		"Budget Inn Motel Room", 			4500},
    {0, 2305.1001,-16.2089,26.7422,269.7382, 		"Palamino Bank", 					5500},
    {0, 663.0487,-573.6597,16.3359,266.0015, 		"Dillimore Gas Station", 			6800},
    {18, -228.8965,1401.3147,27.7656,266.0015, 		"Lil' Probe Inn", 					13000},
    {2, 446.9469,1397.5585,1084.3047,359.3991, 		"Pair of Burglary Houses", 			25000},
    {5, 226.6049,1114.2588,1080.9945,266.3383, 		"Burglary House X11", 				26000},
    {4, 260.8826,1284.4226,1080.2578,356.8690, 		"Burglary House X12", 				28000},
    {4, 285.7398,-86.2111,1001.5229,0.9424, 		"Ammu-nation (version 3)", 			23000},
    {4, 460.0900,-88.7736,999.5547,88.6766, 		"Jay's Diner", 						13000},
    {4, 300.2214,308.9092,1003.3047,267.5913, 		"Michelle's Love Nest*", 			6000},
    {10, 24.0752,1340.4037,1084.3750,357.5913,	 	"Burglary House X14", 				47500},
    {1, 964.8690,2160.1362,1011.0303,87.4463, 		"Sindacco Abatoir", 				15000},
    {4, 221.7042,1140.5739,1082.6094,355.0121, 		"Burglary House X13", 				12000},
    {12, 2324.4485,-1149.3555,1050.7101,355.0121, 	"Unused Safe House", 				115000},
    {6, 344.0542,305.0782,999.1484,270.3390, 		"Millie's Bedroom", 				4500},
    {12, 412.0997,-54.1158,1001.8984,357.5189, 		"Barber Shop", 						6500},
    {6, 774.1306,-50.3132,1000.5859,356.5555, 		"Cobra Gym", 						29000},
    {6, 246.7376,62.6765,1003.6406,359.6888, 		"Los Santos Police Department", 	80000},
    {4, -260.6812,1456.6299,1084.3672,84.9163, 		"Burglary House X15", 				31000},
    {5, 22.7006,1403.4539,1084.4370,0.0022, 		"Burglary House X16", 				34000},
    {5, 140.4259,1366.3585,1083.8594,354.6754, 		"Burglary House X17", 				105000},
    {3, 1494.4634,1303.9586,1093.2891,358.1221, 	"Bike School", 						15000},
    {6, 234.1510,1064.0935,1084.2117,358.1221, 		"Burglary House X18", 				55000},
    {6, -68.7717,1351.2863,1080.2109,358.1221, 		"Burglary House X19", 				0},
    {6, -2240.6143,137.1421,1035.4141,268.8213, 	"Zero's RC Shop", 					16000},
    {6, 296.8614,-111.8426,1001.5156,355.3021, 		"Ammu-nation (version 4)", 			18500},
    {6, 316.2793,-169.7145,999.6010,355.3021, 		"Ammu-nation (version 5)", 			22000},
    {15, -283.5468,1471.0049,1084.3750,89.3029, 	"Burglary House X20", 				28000},
    {6, 744.3742,1436.4757,1102.7031,356.9153, 		"Fanny Batter's Whore House", 		0},
    {8, 2807.4829,-1174.5416,1025.5703,356.9153, 	"Colonel Furhberger's", 			37000},
    {9, 364.8955,-11.1229,1001.8516,356.9153, 		"Cluckin' Bell", 					5500},
    {1, 2218.2136,-1076.3907,1050.4844,89.0129, 	"The Camel's Toe Safehouse", 		6500},
    {1, 2266.2695,1647.5325,1084.2344,265.7112, 	"Caligula's Roof", 					20000},
    {2, 2237.5891,-1081.4121,1049.0234,357.1820, 	"Old Venturas Strip Casino",		40000},
    {3, -2029.7666,-119.0861,1035.1719,357.1820, 	"Driving School", 					8000},
    {8, 2365.3745,-1135.1105,1050.8750,357.8087, 	"Verdant Bluffs Safehouse", 		25000},
    {10, 1893.7197,1018.2451,31.8828,96.3156, 		"Four Dragons' Janitor's Office", 	40000},
    {11, 502.0814,-68.0179,998.7578,179.9763, 		"Bar", 								30000},
    {8, -42.5038,1405.9224,1084.4297,356.6021, 		"Burglary House X21", 				27500},
    {9, 83.0910,1322.5833,1083.8662,1.6155, 		"Burglary House X22", 				36000},
    {9, 260.7572,1237.4823,1084.2578,1.6155, 		"Burglary House X23", 				30000}
};


new PickupID[9] = {1239, 1274, 1273, 1272, 1240, 1247, 1277, 1275, 1318};

enum sPlayerItem
{
	iUID,
	iName[32],

	iValue[2],

	iType,

	iPlace,
	iOwner,
	
	bool: iUsed,
	bool: iChecked,
	bool: iFavorite,

	iGroup,

	ORM:iOrm
}
new PlayerItemCache[MAX_PLAYERS][MAX_ITEM_CACHE][sPlayerItem];

enum sItemTypeInfo
{
	iTypeName[32],
	iTypeWeight,

	iTypeObjModel,

	Float:iTypeObjRotX,
	Float:iTypeObjRotY
}
new ItemTypeInfo[][sItemTypeInfo] =
{
	/* nazwa | 	waga | model | rotx | roty   */
	{"Nieokreślony",	50, 	328,   	90.0,   95.0},
	{"Zegarek",			80, 	2710, 	0.0,  	0.0},
	{"Jedzenie",        160,    2769,   0.0,    0.0},
	{"Papierosy",       30,    	1485,   0.0,    0.0},
	{"Kostka do gry",   10,    	328,   	90.0,   95.0},
	{"Ubranie",         380,    2843,   0.0,    0.0},
	{"Broń",            0,      0,      0.0,    0.0},
	{"Amunicja",        230,    328,    90.0,   95.0},
	{"Telefon",         120,    330, 	90.0,  	0.0},
	{"Kanister",        240,   	1650,   90.0,   0.0},
	{"Maska",           210,    328, 	90.0,	95.0},
	{"Paralizator",     0,    	0,      0.0,    0.0},
	{"Lakier",          0,    	0,      0.0,    0.0},
	{"Kajdanki",        330,    19418, 	90.0, 	0.0},
	{"Megafon",         260,    328, 	90.0, 	95.0},
	{"Lina",            180,	328, 	90.0, 	95.0},
	{"Notatnik",        40,     2894, 	0.0,  	0.0},
	{"Karteczka",       1,     	328, 	90.0, 	95.0},
	{"Tuning",          6800,   328, 	90.0, 	95.0},
	{"Ks. czekowa",     40,     2894, 	0.0,  	0.0},
	{"Czek",            1,     	328, 	90.0, 	95.0},
	{"Torba",           90,     2663, 	90.0,  	0.0},
	{"Napój",           520,    328, 	90.0, 	95.0},
	{"Akcesorie", 		1040,   328,    90.0,   95.0},
	{"Płyta",           140,    1961,   90.0,   180.0},
	{"Odtwarzacz",      240,    328,    90.0,   95.0},
	{"Przyczepialny",   210,    328,    90.0,   95.0},
	{"Karnet",          10,     328,    90.0,   95.0},
	{"Karta pojazdu",   10,     328,    90.0,   95.0},
	{"Rolki",           230,    328,    90.0,   95.0},
	{"Medykament",      30,     328,    90.0,   95.0},
	{"Używka",          1,      328,    90.0,   95.0},
	{"Joint",           1,      328,    90.0,   95.0},
	{"Kluczyki",        60,     328,    90.0,   95.0},
	{"Rękawiczki",      180,    328,    90.0,   95.0},
	{"Zwłoki",          7500,   2060,   0.0,    0.0},
	{"Molotova",        520,    344,    80.0,   0.0},
	{"Boombox",         1350,   2226,   0.0,    0.0},
	{"Craft",           320,    328,    90.0,   0.0},
	{"Latarka",         150,    18641,  90.0,   0.0},
	{"Gazeta",          20,     328,    90.0,   0.0},
	{"Drewno",          400,    19793,  0.0,    0.0}
};


enum sWeaponInfoData
{
	wModel,
	wWeight
}
new WeaponInfoData[][sWeaponInfoData] =
{
	{0,		0},
	{331,	70},
	{333,	230},
	{334,	190},
	{335,	60},
	{336,	250},
	{337,	290},
	{338,	140},
	{339,	270},
	{341,	3600},
	{321,	140},
	{322,	50},
	{323,	60},
	{324,	90},
	{325,	40},
	{326,	110},
	{342,	80},
	{343,	90},
	{344,	120},
	{0,		0},
	{0,		0},
	{0,		0},
	{346,	460},
	{347,	490},
	{348,	540},
	{349,	2400},
	{350,	2100},
	{351,	2600},
	{352,	890},
	{353,	1900},
	{355,	3200},
	{356,	3600},
	{372,	1100},
	{357,	2500},
	{358,	2900},
	{359,	8600},
	{360,	8300},
	{361,	4900},
	{362,	9400},
	{363,	450},
	{364,	90},
	{365,	480},
	{366,	2600},
	{367,	80},
	{368,	200},
	{369,	200},
	{371,	360}
};

enum sProductData
{
	pUID,

	pName[32],
	pType,

	pValue1,
	pValue2,

	pPrice,
	pCount,
	
	pOwner,
	pMaxPrice,
	
	ORM:pOrm
}
new ProductData[MAX_PRODUCTS][sProductData];

enum sOfferData
{
	oOffererID,
	oType,
	
	oName[32],
	
	oValue1,
	oValue2,
	
	oPrice,
	oPayType
}
new OfferData[MAX_PLAYERS][sOfferData];

enum sOfferTypeInfo
{
	oTypeName[32]
}
new OfferTypeInfo[][sOfferTypeInfo] =
{
	{"Nieokreslona"},
	{"Przedmiot"},
	{"Pojazd"},
	{"Produkt"},
	{"vCard"},
	{"Drzwi"},
	{"Holowanie"},
	{"Przejazd"},
	{"Tankowanie"},
	{"Naprawa"},
	{"Lakierowanie"},
	{"PaintJob"},
	{"Montaz"},
	{"Mandat"},
	{"Zdjecie blokady"},
	{"Dokument"},
	{"Biznes"},
	{"Rejestracja"},
	{"Leczenie"},
	{"Karnet"},
	{"Powitanie"},
	{"Reklama"},
	{"Nowy pojazd"},
	{"Podatek"},
	{"Kluczyki"},
	{"Styl walki"},
	{"Lekcja jazdy"}
};

enum sAttachAccess
{
	aUID,
	aModel,
	
	aName[32],
	aBone,
	
	Float:aPosX,
	Float:aPosY,
	Float:aPosZ,
	
	Float:aRotX,
	Float:aRotY,
	Float:aRotZ,
	
	Float:aScaleX,
	Float:aScaleY,
	Float:aScaleZ,
	
	aPrice
}
new AccessData[MAX_ACCESS][sAttachAccess];

enum sSkinInfo
{
	sModel,
	
	sName[32],
	sPrice
}
new SkinData[MAX_SKINS][sSkinInfo];

new TalkStyleData[9][3][24] =
{
	{"PED", 	"IDLE_CHAT", 		"Podstawowy"},
	{"GANGS", 	"prtial_gngtlkA",	"Gangster 1"},
	{"GANGS",   "prtial_gngtlkB",	"Gangster 2"},
	{"GANGS",   "prtial_gngtlkC",	"Gangster 3"},
	{"GANGS",   "prtial_gngtlkD",	"Gangster 4"},
	{"GANGS",   "prtial_gngtlkE",	"Gangster 5"},
	{"GANGS",   "prtial_gngtlkF",	"Gangster 6"},
	{"GANGS",   "prtial_gngtlkG",	"Gangster 7"},
	{"GANGS",   "prtial_gngtlkH",	"Gangster 8"}
};

new FightStyleData[4][1][24] =
{
	{"Normalny"},
	{"Box"},
	{"Karate"},
	{"Kick Boxing"}
};

enum sAnimData
{
	aUID,

	aCommand[12],
	aLib[16],
	aName[24],

	Float:aSpeed,

	aOpt1,
	aOpt2,
	aOpt3,
	aOpt4,
	aOpt5,

	aAction
}
new AnimCache[MAX_ANIMS][sAnimData];

enum sOrderData
{
	oUID,
	oName[32],
	
	oCount,
	oPrice
}
new OrderCache[MAX_PLAYERS][sOrderData];

enum sPosData
{
	Float:sPosX,
	Float:sPosY,
	Float:sPosZ,
	Float:sPosA,
	
	sPosInterior,
	sPosVirtualWorld,
}
new PosInfo[][sPosData] =
{
	{2601.3408,	47.9605,	26.3509,	89.2542, 	0, 0},
	{154.1221, 	-1951.9156, 47.8750,	  	0.0, 	0, 0},
	{2233.6584,	-1113.2397,	1050.8828,	 2.7833,  	5, 0}
};

new Float:SalonSpawnPos[3][4] =
{
	{2408.2136, 89.0735, 26.4746, 89.7015},
	{2408.1182, 96.5752, 26.4723, 89.0024},
	{2409.4045, 84.2846, 26.4730, 84.5432}
};

enum sDrugTypeInfo
{
	dName[32],
	dCornerPrice,
	
	dAmount
}
new DrugTypeInfo[][sDrugTypeInfo] =
{
	{"Nieokreślony",    0,		0},
	{"Marihuana",   	20,		0},
	{"Kokaina",         200,	30},
	{"Heroina",         80,		25},
	{"Amfetamina",      50,		20},
	{"Crack",           35,		35},
	{"Odżywka",         0,		10}
};

enum sStatusData
{
	sName[32],
	sType
}
new StatusInfo[][sStatusData] =
{
	{"nieprzytomny",    STATUS_TYPE_DAZED},
	{"pijany",          STATUS_TYPE_DRUNK},
	{"muskularny",      STATUS_TYPE_MUSCLE},
	{"rolki",           STATUS_TYPE_ROLL},
	{"zakryta twarz",   STATUS_TYPE_MASKED},
	{"słucha muzyki",   STATUS_TYPE_EARPIECE},
	{"AFK od:",         STATUS_TYPE_AFK},
	{"zapięte pasy",    STATUS_TYPE_BELTS},
	{"naćpany",         STATUS_TYPE_STONED},
	{"rękawice",        STATUS_TYPE_GLOVES},
	{"pobity",          STATUS_TYPE_DEFEATED},
	{"postrzelony",     STATUS_TYPE_SHOT},
	{"ranny",           STATUS_TYPE_INJURED}
};

new DeathTypeData[5][32] =
{
	{"Nieokreślone"},
	{"Przedawkowanie"},
	{"Pobicie"},
	{"Postrzelenie"},
	{"Samobójstwo"}
};

enum sBodyPartInfo
{
	bpName[64],
	bpIndex,

	bpType
}
new BodyPartInfo[][sBodyPartInfo] =
{
	{"klatka piersiowa",	3,	BODY_PART_TORSO},
	{"okolice pachwiny",	4,	BODY_PART_GROIN},
	{"lewa ręka",           5,  BODY_PART_LARM},
	{"prawa ręka",          6,  BODY_PART_RARM},
	{"lewa noga",           7,  BODY_PART_LLEG},
	{"prawa noga",          8,  BODY_PART_RLEG},
	{"głowa",               9,  BODY_PART_HEAD}
};

enum sAchieveData
{
	aName[32],
	aType,
	
	aPoints
}
new AchieveInfo[18][sAchieveData] =
{
	{"Staly gracz",     		ACHIEVE_PLAYER,     25},
	{"Mistrz gry",      		ACHIEVE_MASTER,     100},
	{"Legenda",         		ACHIEVE_LEGEND,     800},
	{"Pierwszy pojazd", 		ACHIEVE_FIRST_VEH,  50},
	{"Dobry interes",   		ACHIEVE_INTEREST,   220},
	{"Widoki z latarni",    	ACHIEVE_AJ,         -50},
	{"Kolekcjoner",         	ACHIEVE_COLLECTOR,  500},
	{"Miesniak",            	ACHIEVE_MYOMA,      300},
	{"Wlasne cztery katy",  	ACHIEVE_HOUSE,      200},
	{"Narkoman",            	ACHIEVE_DRUGGIE,    150},
	{"Pierwsze oszczednosci",   ACHIEVE_SAVINGS,    80},
	{"Znana twarz",             ACHIEVE_VCARDS,     50},
	{"Nowy styl",               ACHIEVE_STYLE,      1000},
	{"Bogacz",                  ACHIEVE_RICH,       2500},
	{"Nowy czlonek",            ACHIEVE_GROUP,      35},
	{"Przywodca",               ACHIEVE_LEADER,     150},
	{"Kierowca",                ACHIEVE_DRIVER,     450},
	{"Szybka jazda",            ACHIEVE_FAST,       200}
};

new AudioData[][32] =
{
	{"-"},
	{"calling_to.mp3"},
	{"calling.mp3"},
	{"sms.mp3"},
	{"alarm.mp3"},
	{"lspd.mp3"},
	{"message.mp3"},
	{"achieve.mp3"}
};

enum sRaceData
{
	rOwner,
	rStart,
	
	Float:rCPX[MAX_RACE_CP],
	Float:rCPY[MAX_RACE_CP],
	Float:rCPZ[MAX_RACE_CP],
	
	rPoint,
	rTime,
	
 	rPosition
}
new RaceInfo[MAX_PLAYERS][sRaceData];

enum sObjectData
{
	objUID,
	Float:objGateX,
	Float:objGateY,
	Float:objGateZ,
	
	Float:objGateRX,
	Float:objGateRY,
	Float:objGateRZ,
	
	bool:objGateStatus,
	bool:objGate,
	
	objExtraID
};

enum sAreaData
{
	aUID,
	
	aOwnerType,
	aOwner,
	
	aFlags,
	aAudioURL[128],

 	aExtraID
};

enum sActorData
{
	aUID,
	aName[32],
	
	aType,
	aAnim,
	
	aText[128],
	aExtraID,
	
	Text3D:aLabel
};

enum sDoorInfo
{
	dUID,
	dName[64],
	
	Float:dEnterA,

	Float:dExitX,
	Float:dExitY,
	Float:dExitZ,
	Float:dExitA,

	dExitInt,
	dExitVW,

	bool: dLocked,
	bool: dGarage,

	dOwner,
	dOwnerType,

	dAudioURL[128],
	dEnterPay,

	dAccess,
	dHour,
	
	dFireData[3],
	bool:dObjectsLoaded,
	
	dMapIcon,
	Text3D:d3DLabel,
	
	dExtraID
};

enum sWorkData
{
	wID,
	wValue[2],
	
	wExtraID
}
new WorkInfo[MAX_PLAYERS][sWorkData];

new WorkTypeName[][32] =
{
	{"Brak"},
	{"Mechanik"},
	{"Kurier"},
	{"Sprzedawca"},
	{"Rozwoziciel gazet"},
	{"Drwal"},
	{"Magazynier"},
	{"Rybak"}
};

enum sAreaFlag
{
	fName[32],
	fType
}
new AreaFlag[9][sAreaFlag] =
{
	{"Skakanie na BMX",			A_FLAG_BMX},
	{"Używanie boomboxa",		A_FLAG_BOOMBOX},
	{"Składanie ofert",			A_FLAG_OFFER},
	{"Ograniczone parkowanie",	A_FLAG_PARKING},
	{"Monitoring",				A_FLAG_MONITORING},
	{"Zbyt narkotyków",			A_FLAG_CORNER},
	{"Serwis pojazdów",         A_FLAG_SERVICE},
	{"Wycinka drzew",           A_FLAG_LUMBERJACK},
	{"Aktywne zadanie",         A_FLAG_MISSION}
};

enum sAdminPerm
{
	aName[24],
	aType
}
new AdminPerm[10][sAdminPerm] =
{
	{"Podstawowe",		A_PERM_BASIC},
	{"Nadawanie kar",   A_PERM_PUNISH},
	{"3D teksty", 		A_PERM_3DTEXTS},
	{"Drzwi",           A_PERM_DOORS},
	{"Pojazdy",         A_PERM_CARS},
	{"Grupy",           A_PERM_GROUPS},
	{"Strefy",          A_PERM_AREAS},
	{"Obiekty",         A_PERM_OBJECTS},
	{"Przedmioty",      A_PERM_ITEMS},
	{"Aktorzy",         A_PERM_ACTORS}
};

enum sMissionTypeInfo
{
	mName[32],
	
	mMinHour,
	mMaxHour
}
new MissionTypeInfo[9][sMissionTypeInfo] =
{
	{"Zgłoszenie",			0,	0},
	{"Pożar budynku", 		18,	22},
	{"Pożar pojazdu",		18,	22},
	{"Rabunek",				18,	22},
	{"Porwanie",			18,	22},
	{"Zabójstwo",			18,	22},
	{"Kradzież",			18,	22},
	{"Przemyt",         	18, 22},
	{"Pościg", 				0,  0}
};

enum sMissionData
{
	mUID,
	mType,
	
	mVictim,
	mMembers,
	
	mAward,
	
	mDate,
	mTime,
	
	mPoints,
	mNeedPoints,
	
	mGroup,
	mLevel,
	
	mValue[2],
	bool: mLeader
}
new MissionData[MAX_PLAYERS][sMissionData];


new BlockadeType[8] = {3578, 1228, 1238, 1425, -2060, -2061, 2892, 1437};

main()
{
	print("\n--------------------------------------------");
	print(" "GAMEMODE" v"VERSION" --> started");
	print("--------------------------------------------\n");
}


public OnGameModeInit()
{
	new hour, minute, second,
		year, month, day;

	gettime(hour, minute, second);
	getdate(year, month, day);
	
	SetWeather(13);
	WorldTime = hour + 1;
	
	Iter_Init(PlayerItem);
	Iter_Init(CheckedPlayerItem);
	Iter_Init(MissionPlayer);
	
	Iter_Add(Vehicles, 0);
	
	/*
	new pickup_id = CreateDynamicPickup(1210, 2, 1464.1624, -1749.0228, 15.4453);
	Streamer_SetIntData(STREAMER_TYPE_PICKUP, pickup_id, E_STREAMER_EXTRA_ID, PICKUP_WORK);
	*/
	
	Streamer_SetVisibleItems(STREAMER_TYPE_OBJECT, 			MAX_VIS_OBJECTS);
	Streamer_SetVisibleItems(STREAMER_TYPE_3D_TEXT_LABEL, 	MAX_VIS_LABELS);
	
	// Connect to database
	mysql_log(ALL);
	
 	connHandle = mysql_connect(SQL_HOST, SQL_USER, SQL_PASS, SQL_DTBS);
	if(connHandle)
	{
	    print("Pomyślnie połączono z bazą danych.\n\n----------\nHost: "SQL_HOST"\nUser: "SQL_USER"\nDatabase: "SQL_DTBS"\n----------\n\nRozpoczynam wczytywanie danych...");

		mysql_tquery(connHandle, "SELECT * FROM `"SQL_PREF"game_groups`", "query_OnLoadGroups", "");
		mysql_tquery(connHandle, "SELECT * FROM `"SQL_PREF"doors`", "query_OnLoadDoors", "");
		mysql_tquery(connHandle, "SELECT "SQL_PREF"objects.*, "SQL_PREF"materials.material_texture FROM "SQL_PREF"objects LEFT JOIN "SQL_PREF"materials on "SQL_PREF"objects.object_uid = "SQL_PREF"materials.material_owner WHERE "SQL_PREF"objects.object_world = 0 ORDER BY "SQL_PREF"objects.object_uid ASC", "query_OnLoadObjects", "");
		mysql_tquery(connHandle, "SELECT * FROM `"SQL_PREF"vehicles` WHERE vehicle_ownertype <> 1", "query_OnLoadVehicles", "");
		mysql_tquery(connHandle, "SELECT `item_vehuid`, `item_value1` FROM `"SQL_PREF"items` WHERE item_vehuid != '0'", "query_OnLoadVehicleComponents", "");
		mysql_tquery(connHandle, "SELECT * FROM `"SQL_PREF"areas`", "query_OnLoadAreas", "");
		mysql_tquery(connHandle, "SELECT * FROM `"SQL_PREF"3dlabels`", "query_OnLoad3DTextLabels", "");
		mysql_tquery(connHandle, "SELECT * FROM `"SQL_PREF"actors`", "query_OnLoadActors", "");
		mysql_tquery(connHandle, "SELECT * FROM `"SQL_PREF"products` WHERE product_count > 0", "query_OnLoadProducts", "");
		
		LoadAllAnims();
		LoadAllAccess();
		LoadAllSkins();
		
		print("Wczytywanie danych zostało zakończone pomyślnie.");
		
		if(GetConsoleVarAsInt("port") == 7777)
		{
	    	SetGameModeText(""GAMEMODE" v"VERSION"");
			mysql_query(connHandle, "DELETE FROM `"SQL_PREF"logged_players`");
		}
		else
		{
		    SetGameModeText(""GAMEMODE" v"VERSION" [test_svr]");
		}
	}
	else
	{
	    SetGameModeText(""GAMEMODE" -SQL_ERROR-");
	}

	// Settings
	AllowInteriorWeapons(false);
	ShowNameTags(false);

    ShowPlayerMarkers(PLAYER_MARKERS_MODE_STREAMED);
	EnableStuntBonusForAll(false);
	
	DisableInteriorEnterExits();
	ManualVehicleEngineAndLights();

	new logo_string[128];
	format(logo_string, sizeof(logo_string), "%02d.%02d.%d", day, month, year);

    TextDrawServerLogo = TextDrawCreate(550.000000, 22.000000, logo_string);
	TextDrawBackgroundColor(TextDrawServerLogo, 255);
	TextDrawFont(TextDrawServerLogo, 3);
	TextDrawLetterSize(TextDrawServerLogo, 0.320000, 1.000000);
	TextDrawColor(TextDrawServerLogo, COLOR_WHITE);
	TextDrawSetOutline(TextDrawServerLogo, 0);
	TextDrawSetProportional(TextDrawServerLogo, 1);
	TextDrawSetShadow(TextDrawServerLogo, 1);
	
	TextDrawMainLogo = TextDrawCreate(495.000000, -45.000000, "logomajty:logomajty");
	TextDrawBackgroundColor(TextDrawMainLogo, 0xFFFFFF00);
	TextDrawFont(TextDrawMainLogo, 5);
	TextDrawLetterSize(TextDrawMainLogo, 3.699998, 19.899999);
	TextDrawColor(TextDrawMainLogo, -1);
	TextDrawSetProportional(TextDrawMainLogo, 1);
	TextDrawSetShadow(TextDrawMainLogo, 1);
	TextDrawUseBox(TextDrawMainLogo, 1);
	TextDrawBoxColor(TextDrawMainLogo, 0xFFFFFF00);
	TextDrawTextSize(TextDrawMainLogo, 115.000000, 115.000000);
	TextDrawSetPreviewModel(TextDrawMainLogo, -2018);
	TextDrawSetPreviewRot(TextDrawMainLogo, 90.000000, 180.000000, 0.000000, 1.000000);

	/*
	TextDrawMainLogo = TextDrawCreate(270.000000, 70.000000, "logomajty:logomajty");
	TextDrawFont(TextDrawMainLogo, TEXT_DRAW_FONT_MODEL_PREVIEW);
    TextDrawSetPreviewModel(TextDrawMainLogo, -2018);
    TextDrawSetPreviewRot(TextDrawMainLogo, 90.000000, 180.000000, 0.000000, 2.000000);
	TextDrawLetterSize(TextDrawMainLogo, 0.500000, 0.500000);
	
	TextDrawMainLogo = TextDrawCreate(-10.000000, -10.000000, "logomajty:logomajty");
	TextDrawLetterSize(TextDrawMainLogo, -0.231199, 0.60479);
	TextDrawTextSize(TextDrawMainLogo, 650.000000, 180.000000);
	TextDrawAlignment(TextDrawMainLogo, 1);
	TextDrawColor(TextDrawMainLogo, -1);
	TextDrawUseBox(TextDrawMainLogo, true);
	TextDrawBoxColor(TextDrawMainLogo, 102);
	TextDrawSetShadow(TextDrawMainLogo, 0);
	TextDrawSetOutline(TextDrawMainLogo, 0);
	TextDrawFont(TextDrawMainLogo, 5);
	
	TextDrawSetPreviewRot(TextDrawMainLogo, 90.000000, 180.000000, 0.000000, 2.000000);
 */

    TextDrawNews = TextDrawCreate(1.000000, 437.000000, "~y~~h~LSN ~w~~>~ Brak sygnalu nadawania.");
	TextDrawBackgroundColor(TextDrawNews, 255);
	TextDrawFont(TextDrawNews, 1);
	TextDrawLetterSize(TextDrawNews, 0.219999, 1.000000);
	TextDrawColor(TextDrawNews, -1);
	TextDrawSetOutline(TextDrawNews, 1);
	TextDrawSetProportional(TextDrawNews, 1);
	TextDrawUseBox(TextDrawNews, 1);
	TextDrawBoxColor(TextDrawNews, 68);
	TextDrawTextSize(TextDrawNews, 640.000000, 0.000000);
	
	TextDrawPremium = TextDrawCreate(510.000000, 424.800000, "Gracz Premium");
	TextDrawBackgroundColor(TextDrawPremium, COLOR_GOLD);
	TextDrawFont(TextDrawPremium, 2);
	TextDrawLetterSize(TextDrawPremium, 0.300000, 1.000000);
	TextDrawColor(TextDrawPremium, -1);
	TextDrawSetOutline(TextDrawPremium, 1);
	TextDrawSetProportional(TextDrawPremium, 1);

	TextDrawOfferBack = TextDrawCreate(205.000000, 287.000000, "_");
	TextDrawLetterSize(TextDrawOfferBack, 0.500000, 6.299985);
	TextDrawUseBox(TextDrawOfferBack, 1);
	TextDrawBoxColor(TextDrawOfferBack, 68);
	TextDrawTextSize(TextDrawOfferBack, 430.000000, 30.000000);

	TextDrawOfferAccept = TextDrawCreate(353.000000, 328.000000, "Akceptuj");
	TextDrawSetSelectable(TextDrawOfferAccept, true);
	TextDrawAlignment(TextDrawOfferAccept, 2);
	TextDrawLetterSize(TextDrawOfferAccept, 0.200000, 1.000000);
	TextDrawSetOutline(TextDrawOfferAccept, 1);
	TextDrawUseBox(TextDrawOfferAccept, 1);
	TextDrawBoxColor(TextDrawOfferAccept, 102);
	TextDrawTextSize(TextDrawOfferAccept, 10.000000, 37.000000);

	TextDrawOfferReject = TextDrawCreate(396.000000, 328.000000, "Odrzuc");
	TextDrawSetSelectable(TextDrawOfferReject, true);
	TextDrawAlignment(TextDrawOfferReject, 2);
	TextDrawLetterSize(TextDrawOfferReject, 0.200000, 1.000000);
	TextDrawSetOutline(TextDrawOfferReject, 1);
	TextDrawUseBox(TextDrawOfferReject, 1);
	TextDrawBoxColor(TextDrawOfferReject, 102);
	TextDrawTextSize(TextDrawOfferReject, 10.000000, 37.000000);

	TextDrawPunishTitle = TextDrawCreate(100.000000, 250.000000, "_");
	TextDrawAlignment(TextDrawPunishTitle, 2);
	TextDrawBackgroundColor(TextDrawPunishTitle, 255);
	TextDrawFont(TextDrawPunishTitle, 1);
	TextDrawLetterSize(TextDrawPunishTitle, 0.179998, 0.899999);
	TextDrawColor(TextDrawPunishTitle, COLOR_PUNISH);
	TextDrawSetOutline(TextDrawPunishTitle, 1);
	TextDrawSetProportional(TextDrawPunishTitle, 1);
	TextDrawUseBox(TextDrawPunishTitle, 1);
	TextDrawBoxColor(TextDrawPunishTitle, 119);
	TextDrawTextSize(TextDrawPunishTitle, 0.000000, 162.000000);

	TextDrawPunishDesc = TextDrawCreate(19.000000, 261.000000, "_");
	TextDrawBackgroundColor(TextDrawPunishDesc, 255);
	TextDrawFont(TextDrawPunishDesc, 1);
	TextDrawLetterSize(TextDrawPunishDesc, 0.189998, 0.899999);
	TextDrawColor(TextDrawPunishDesc, COLOR_WHITE);
	TextDrawSetProportional(TextDrawPunishDesc, 1);
	TextDrawSetShadow(TextDrawPunishDesc, 1);
	TextDrawUseBox(TextDrawPunishDesc, 1);
	TextDrawBoxColor(TextDrawPunishDesc, 68);
	TextDrawTextSize(TextDrawPunishDesc, 181.000000, 20.000000);
	

	// GII
	GII_Option[0] = TextDrawCreate(210.000000, 160.000000, "lupa:szary");
	TextDrawBackgroundColor(GII_Option[0], 0xFFFFFF00);
	TextDrawFont(GII_Option[0], 5);
	TextDrawLetterSize(GII_Option[0], 0.500000, 23.000000);
	TextDrawColor(GII_Option[0], -1);
	TextDrawSetOutline(GII_Option[0], 0);
	TextDrawSetProportional(GII_Option[0], 1);
	TextDrawSetShadow(GII_Option[0], 1);
	TextDrawUseBox(GII_Option[0], 1);
	TextDrawBoxColor(GII_Option[0], 0xFFFFFF00);
	TextDrawTextSize(GII_Option[0], 50.000000, 52.000000);
	TextDrawSetPreviewModel(GII_Option[0], -2079);
	TextDrawSetPreviewRot(GII_Option[0], 90.000000, 360.000000, 0.000000, 0.10000);
	TextDrawSetSelectable(GII_Option[0], 1);

	GII_Option[1] = TextDrawCreate(260.000000, 110.000000, "carp:szary");
	TextDrawBackgroundColor(GII_Option[1], 0xFFFFFF00);
	TextDrawFont(GII_Option[1], 5);
	TextDrawLetterSize(GII_Option[1], 0.500000, 23.000000);
	TextDrawColor(GII_Option[1], -1);
	TextDrawSetOutline(GII_Option[1], 0);
	TextDrawSetProportional(GII_Option[1], 1);
	TextDrawSetShadow(GII_Option[1], 1);
	TextDrawUseBox(GII_Option[1], 1);
	TextDrawBoxColor(GII_Option[1], 0xFFFFFF00);
	TextDrawTextSize(GII_Option[1], 50.000000, 52.000000);
	TextDrawSetPreviewModel(GII_Option[1], -2076);
	TextDrawSetPreviewRot(GII_Option[1], 90.000000, 0.000000, 0.000000, 0.10000);
	TextDrawSetSelectable(GII_Option[1], 1);

	GII_Option[2] = TextDrawCreate(320.000000, 110.000000, "cart:szary");
	TextDrawBackgroundColor(GII_Option[2], 0xFFFFFF00);
	TextDrawFont(GII_Option[2], 5);
	TextDrawLetterSize(GII_Option[2], 0.500000, 23.000000);
	TextDrawColor(GII_Option[2], -1);
	TextDrawSetOutline(GII_Option[2], 0);
	TextDrawSetProportional(GII_Option[2], 1);
	TextDrawSetShadow(GII_Option[2], 1);
	TextDrawUseBox(GII_Option[2], 1);
	TextDrawBoxColor(GII_Option[2], 0xFFFFFF00);
	TextDrawTextSize(GII_Option[2], 50.000000, 52.000000);
	TextDrawSetPreviewModel(GII_Option[2], -2077);
	TextDrawSetPreviewRot(GII_Option[2], 90.000000, 0.000000, 0.000000, 0.10000);
	TextDrawSetSelectable(GII_Option[2], 1);
	

	GII_Option[3] = TextDrawCreate(370.000000, 160.000000, "klucz:szary");
	TextDrawBackgroundColor(GII_Option[3], 0xFFFFFF00);
	TextDrawFont(GII_Option[3], 5);
	TextDrawLetterSize(GII_Option[3], 0.500000, 23.000000);
	TextDrawColor(GII_Option[3], -1);
	TextDrawSetOutline(GII_Option[3], 0);
	TextDrawSetProportional(GII_Option[3], 1);
	TextDrawSetShadow(GII_Option[3], 1);
	TextDrawUseBox(GII_Option[3], 1);
	TextDrawBoxColor(GII_Option[3], 0xFFFFFF00);
	TextDrawTextSize(GII_Option[3], 50.000000, 52.000000);
	TextDrawSetPreviewModel(GII_Option[3], -2081);
	TextDrawSetPreviewRot(GII_Option[3], 90.000000, 180.000000, 180.000000, 0.05000);
	TextDrawSetSelectable(GII_Option[3], 1);

	GII_Option[4] = TextDrawCreate(370.000000, 240.000000, "kajdanki:szary");
	TextDrawBackgroundColor(GII_Option[4], 0xFFFFFF00);
	TextDrawFont(GII_Option[4], 5);
	TextDrawLetterSize(GII_Option[4], 0.500000, 23.000000);
	TextDrawColor(GII_Option[4], COLOR_GREY);
	TextDrawSetOutline(GII_Option[4], 0);
	TextDrawSetProportional(GII_Option[4], 1);
	TextDrawSetShadow(GII_Option[4], 1);
	TextDrawUseBox(GII_Option[4], 1);
	TextDrawBoxColor(GII_Option[4], 0xFFFFFF00);
	TextDrawTextSize(GII_Option[4], 50.000000, 52.000000);
	TextDrawSetPreviewModel(GII_Option[4], -2084);
	TextDrawSetPreviewRot(GII_Option[4], 90.000000, 360.000000, 90.000000, 0.05000);
	TextDrawSetSelectable(GII_Option[4], 1);

	GII_Option[5] = TextDrawCreate(320.000000, 290.000000, "hands:szary");
	TextDrawBackgroundColor(GII_Option[5], 0xFFFFFF00);
	TextDrawFont(GII_Option[5], 5);
	TextDrawLetterSize(GII_Option[5], 0.500000, 23.000000);
	TextDrawColor(GII_Option[5], -1);
	TextDrawSetOutline(GII_Option[5], 0);
	TextDrawSetProportional(GII_Option[5], 1);
	TextDrawSetShadow(GII_Option[5], 1);
	TextDrawUseBox(GII_Option[5], 1);
	TextDrawBoxColor(GII_Option[5], 0xFFFFFF00);
	TextDrawTextSize(GII_Option[5], 50.000000, 52.000000);
	TextDrawSetPreviewModel(GII_Option[5], -2078);
	TextDrawSetPreviewRot(GII_Option[5], 90.000000, 180.000000, 0.000000, 0.10000);
	TextDrawSetSelectable(GII_Option[5], 1);

	GII_Option[6] = TextDrawCreate(260.000000, 290.000000, "rekado:szary");
	TextDrawBackgroundColor(GII_Option[6], 0xFFFFFF00);
	TextDrawFont(GII_Option[6], 5);
	TextDrawLetterSize(GII_Option[6], 0.200000, 1.000000);
	TextDrawColor(GII_Option[6], -1);
	TextDrawSetOutline(GII_Option[6], 0);
	TextDrawSetProportional(GII_Option[6], 1);
	TextDrawSetShadow(GII_Option[6], 1);
	TextDrawUseBox(GII_Option[6], 1);
	TextDrawBoxColor(GII_Option[6], 0xFFFFFF00);
	TextDrawTextSize(GII_Option[6], 50.000000, 52.000000);
	TextDrawSetPreviewModel(GII_Option[6], -2082);
	TextDrawSetPreviewRot(GII_Option[6], 90.000000, 180.000000, 180.000000, 0.10000);
	TextDrawSetSelectable(GII_Option[6], 1);

	GII_Option[7] = TextDrawCreate(210.000000, 250.000000, "rekaz:szary");
	TextDrawBackgroundColor(GII_Option[7], 0xFFFFFF00);
	TextDrawFont(GII_Option[7], 5);
	TextDrawLetterSize(GII_Option[7], 0.200000, 1.000000);
	TextDrawColor(GII_Option[7], -1);
	TextDrawSetOutline(GII_Option[7], 0);
	TextDrawSetProportional(GII_Option[7], 1);
	TextDrawSetShadow(GII_Option[7], 1);
	TextDrawUseBox(GII_Option[7], 1);
	TextDrawBoxColor(GII_Option[7], 0xFFFFFF00);
	TextDrawTextSize(GII_Option[7], 50.000000, 52.000000);
	TextDrawSetPreviewModel(GII_Option[7], -2083);
	TextDrawSetPreviewRot(GII_Option[7], 90.000000, 180.000000, 180.000000, 0.10000);
	TextDrawSetSelectable(GII_Option[7], 1);
	
	
	// In OnGameModeInit prefferably, we procced to create our textdraws:
	Textdraw0 = TextDrawCreate(290.000000, 120.000000, "_");
	TextDrawBackgroundColor(Textdraw0, 255);
	TextDrawFont(Textdraw0, 1);
	TextDrawLetterSize(Textdraw0, 0.000000, 32.000000);
	TextDrawColor(Textdraw0, -1);
	TextDrawSetOutline(Textdraw0, 0);
	TextDrawSetProportional(Textdraw0, 1);
	TextDrawSetShadow(Textdraw0, 1);
	TextDrawUseBox(Textdraw0, 1);
	TextDrawBoxColor(Textdraw0, 102);
	TextDrawTextSize(Textdraw0, 10.000000, 0.000000);

	Textdraw2 = TextDrawCreate(140.000000, 190.000000, "NAZWISKO");
	TextDrawAlignment(Textdraw2, 2);
	TextDrawBackgroundColor(Textdraw2, 255);
	TextDrawFont(Textdraw2, 1);
	TextDrawLetterSize(Textdraw2, 0.400000, 2.000000);
	TextDrawColor(Textdraw2, -1);
	TextDrawSetOutline(Textdraw2, 0);
	TextDrawSetProportional(Textdraw2, 1);
	TextDrawSetShadow(Textdraw2, 1);
	TextDrawUseBox(Textdraw2, 1);
	TextDrawBoxColor(Textdraw2, 136);
	TextDrawTextSize(Textdraw2, 240.000000, 200.000000);

	Textdraw3 = TextDrawCreate(140.000000, 220.000000, "ROK URODZENIA");
	TextDrawAlignment(Textdraw3, 2);
	TextDrawBackgroundColor(Textdraw3, 255);
	TextDrawFont(Textdraw3, 1);
	TextDrawLetterSize(Textdraw3, 0.400000, 2.000000);
	TextDrawColor(Textdraw3, -1);
	TextDrawSetOutline(Textdraw3, 0);
	TextDrawSetProportional(Textdraw3, 1);
	TextDrawSetShadow(Textdraw3, 1);
	TextDrawUseBox(Textdraw3, 1);
	TextDrawBoxColor(Textdraw3, 136);
	TextDrawTextSize(Textdraw3, 240.000000, 200.000000);

	Textdraw4 = TextDrawCreate(140.000000, 160.000000, "IMIE");
	TextDrawAlignment(Textdraw4, 2);
	TextDrawBackgroundColor(Textdraw4, 255);
	TextDrawFont(Textdraw4, 1);
	TextDrawLetterSize(Textdraw4, 0.400000, 2.000000);
	TextDrawColor(Textdraw4, -1);
	TextDrawSetOutline(Textdraw4, 0);
	TextDrawSetProportional(Textdraw4, 1);
	TextDrawSetShadow(Textdraw4, 1);
	TextDrawUseBox(Textdraw4, 1);
	TextDrawBoxColor(Textdraw4, 136);
	TextDrawTextSize(Textdraw4, 240.000000, 200.000000);

	Textdraw5 = TextDrawCreate(40.000000, 130.000000, "Tworzenie postaci                 Wybierz ubranie");
	TextDrawBackgroundColor(Textdraw5, 255);
	TextDrawFont(Textdraw5, 2);
	TextDrawLetterSize(Textdraw5, 0.500000, 2.000000);
	TextDrawColor(Textdraw5, -1);
	TextDrawSetOutline(Textdraw5, 0);
	TextDrawSetProportional(Textdraw5, 1);
	TextDrawSetShadow(Textdraw5, 1);

	Textdraw6 = TextDrawCreate(310.000000, 251.000000, "~<~~<~");
	TextDrawBackgroundColor(Textdraw6, 255);
	TextDrawFont(Textdraw6, 1);
	TextDrawLetterSize(Textdraw6, 0.900000, 2.000000);
	TextDrawColor(Textdraw6, -1);
	TextDrawSetOutline(Textdraw6, 0);
	TextDrawSetProportional(Textdraw6, 1);
	TextDrawSetShadow(Textdraw6, 1);

	Textdraw7 = TextDrawCreate(540.000000, 251.000000, "~>~~>~");
	TextDrawBackgroundColor(Textdraw7, 255);
	TextDrawFont(Textdraw7, 1);
	TextDrawLetterSize(Textdraw7, 0.900000, 2.000000);
	TextDrawColor(Textdraw7, -1);
	TextDrawSetOutline(Textdraw7, 0);
	TextDrawSetProportional(Textdraw7, 1);
	TextDrawSetShadow(Textdraw7, 1);

	Textdraw8 = TextDrawCreate(140.000000, 250.000000, "PLEC");
	TextDrawAlignment(Textdraw8, 2);
	TextDrawBackgroundColor(Textdraw8, 255);
	TextDrawFont(Textdraw8, 1);
	TextDrawLetterSize(Textdraw8, 0.400000, 2.000000);
	TextDrawColor(Textdraw8, -1);
	TextDrawSetOutline(Textdraw8, 0);
	TextDrawSetProportional(Textdraw8, 1);
	TextDrawSetShadow(Textdraw8, 1);
	TextDrawUseBox(Textdraw8, 1);
	TextDrawBoxColor(Textdraw8, 136);
	TextDrawTextSize(Textdraw8, 240.000000, 200.000000);

	Textdraw9 = TextDrawCreate(20.000000, 310.000000, "Kliknij w wybrane miejsce, by wprowadzic dane postaci. Po prawej stronie wybierz wyglad Twojej postaci (klikajac na strzalki).");
	TextDrawBackgroundColor(Textdraw9, 255);
	TextDrawFont(Textdraw9, 1);
	TextDrawLetterSize(Textdraw9, 0.400000, 2.000000);
	TextDrawColor(Textdraw9, -1);
	TextDrawSetOutline(Textdraw9, 0);
	TextDrawSetProportional(Textdraw9, 1);
	TextDrawSetShadow(Textdraw9, 1);
	TextDrawUseBox(Textdraw9, 1);
	TextDrawBoxColor(Textdraw9, 0);
	TextDrawTextSize(Textdraw9, 279.000000, 0.000000);

	// Pętla na sloty grup
	new Float:posX, Float:posY;
	for(new group_slot = 0; group_slot < MAX_GROUP_SLOTS; group_slot++)
	{
	    posX = 225.0;
	    posY = 167.0;

	    if(group_slot == 2 || group_slot == 3)	posY += 120.0;
	    if(group_slot == 1 || group_slot == 3)	posX = 355.0;

		TD_GroupOption[0][group_slot] = TextDrawCreate(posX, posY, "INFO");
		TD_GroupOption[1][group_slot] = TextDrawCreate(posX, posY + 20.0, "Magazyn");
		TD_GroupOption[2][group_slot] = TextDrawCreate(posX, posY + 40.0, "Sluzba");

		TD_GroupOption[3][group_slot] = TextDrawCreate(posX + 50.0, posY, "Pojazdy");
		TD_GroupOption[4][group_slot] = TextDrawCreate(posX + 50.0, posY + 20.0, "Online");
		TD_GroupOption[5][group_slot] = TextDrawCreate(posX + 50.0, posY + 40.0, "Zadania");

		for(new group_option = 0; group_option < 6; group_option++)
		{
			TextDrawAlignment(TD_GroupOption[group_option][group_slot], 2);
			TextDrawBackgroundColor(TD_GroupOption[group_option][group_slot], 255);
			TextDrawFont(TD_GroupOption[group_option][group_slot], 1);
			TextDrawLetterSize(TD_GroupOption[group_option][group_slot], 0.250000, 1.199999);
			TextDrawColor(TD_GroupOption[group_option][group_slot], -1);
			TextDrawSetOutline(TD_GroupOption[group_option][group_slot], 1);
			TextDrawSetProportional(TD_GroupOption[group_option][group_slot], 1);
			TextDrawUseBox(TD_GroupOption[group_option][group_slot], 1);
			TextDrawBoxColor(TD_GroupOption[group_option][group_slot], 136);
			TextDrawTextSize(TD_GroupOption[group_option][group_slot], 10.000000, 40.000000);
			TextDrawSetSelectable(TD_GroupOption[group_option][group_slot], true);
		}
	}

	// Pętla na graczy
	for (new i = 0; i < MAX_PLAYERS; i++)
	{
  		PlayerCache[i][pNameTag] = CreateDynamic3DTextLabel(" ", COLOR_NICK, 0.0, 0.0, 0.0, 15.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 1, -1, -1, -1, 50.0);
		PlayerCache[i][pDescTag] = CreateDynamic3DTextLabel(" ", COLOR_DESC, 0.0, 0.0, 0.0, 10.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 1, -1, -1, -1, 50.0);
		PlayerCache[i][vDescTag] = CreateDynamic3DTextLabel(" ", COLOR_DESC, 0.0, 0.0, 0.0, 10.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 1, -1, -1, -1, 50.0);
	}
	
	// Pela na grupy
    for (new group_id = 0; group_id < MAX_GROUPS; group_id++)
	{
	    // Usuń za podatki
	    if(GroupData[group_id][gFlags] & G_FLAG_TAX)
	    {
	        if(GroupData[group_id][gLastTax] + (15 * 86000) <= gettime())
	        {
	            // DeleteGroup(group_id);
	        }
	    }
	}
	
	AddPlayerClass(0, 1958.3783, 1343.1572, 15.3746, 269.1425, 0, 0, 0, 0, 0, 0);
	return 1;
}

public OnGameModeExit()
{
	//Audio_DestroyTCPServer();
	mysql_close();
	return 1;
}

task OnMinuteTask[60000]()
{
	new hour, minute, second;
	gettime(hour, minute, second);
	
	WorldTime = hour + 1;

	// Godzina
	static LastHour = 25;
	if(hour > LastHour)
	{
	
		if(hour == 24)
		{
			new year, month, day, logo_string[128];
			getdate(year, month, day);
			
			format(logo_string, sizeof(logo_string), "%02d.%02d.%d", day, month, year);
			TextDrawSetString(Text:TextDrawServerLogo, logo_string);
		}
		
		if(hour == 4)
		{
			SendRconCommand("exit");
		}
	}
	LastHour = hour;
	
	new player_hour, player_minute;
	foreach(new i : Player)
	{
	    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	    {
			GetPlayerTime(i, player_hour, player_minute);
			if(LastHour > player_hour)
			{
   				if(GetPlayerVirtualWorld(i) == 0)
   				{
			   		SetPlayerTime(i, LastHour, 0);
				}
			}

	        // Czas gry
	        if(PlayerCache[i][pAFK] < 0)
	        {
		        PlayerCache[i][pMinutes] ++;
		        if(PlayerCache[i][pMinutes] > 59)
		        {
		            new query[128];
		        
		            PlayerCache[i][pMinutes] = 0;
		            PlayerCache[i][pHours] ++;
		            
		            PlayerCache[i][pPoints] += (IsPlayerPremium(i) ? PACC_POINTS : FACC_POINTS);

					mysql_format(connHandle, query, sizeof(query), "UPDATE `core_members` SET member_game_points = '%d' WHERE member_id = '%d' LIMIT 1", PlayerCache[i][pPoints], PlayerCache[i][pGID]);
					mysql_query(connHandle, query);

					SetPlayerScore(i, PlayerCache[i][pPoints]);
					
					if(PlayerCache[i][pHours] >= 10)    GivePlayerAchievement(i, ACHIEVE_PLAYER);
					if(PlayerCache[i][pHours] >= 50)    GivePlayerAchievement(i, ACHIEVE_MASTER);
					if(PlayerCache[i][pHours] >= 100)   GivePlayerAchievement(i, ACHIEVE_LEGEND);
				}
			}
	        
    	    // Animacja BW
		    if(PlayerCache[i][pBW])
		    {
	         	ApplyAnimation(i, "PED", "FLOOR_hit", 4.1, 0, 1, 1, 1, 1, true);
		    }

			// Pod wpływem używki
			if(PlayerCache[i][pDrugType] != DRUG_NONE)
			{
				switch(PlayerCache[i][pDrugType])
				{
				    // Marihuana
				    case DRUG_MARIHUANA:
				    {
				        PlayerCache[i][pDrugLevel] --;
				        switch(PlayerCache[i][pDrugLevel])
				        {
				            case 20:    SetPlayerWeather(i, 170);
				            case 15:    SetPlayerWeather(i, -2);
				            case 5:     SetPlayerWeather(i, 10);
				        }

				        if(PlayerCache[i][pDrugLevel] <= 0)
				        {
				            if(GetPlayerSpecialAction(i) != SPECIAL_ACTION_SMOKE_CIGGY)
				            {
					            PlayerCache[i][pDrugType] 	= DRUG_NONE;
					            PlayerCache[i][pDrugLevel] 	= 0;

					            PlayerCache[i][pDrugValue1] = 0;
					            PlayerCache[i][pDrugValue2] = 0;

					            SendClientMessage(i, COLOR_DO, "** Powróciłeś do stanu trzeźwości, odczuwasz duże pragnienie i głód. **");
							}
				        }
				    }

				    // Kokaina, Heroina
				    case DRUG_COCAINE, DRUG_HEROIN:
				    {
				        PlayerCache[i][pDrugLevel] --;
				        if(minute & 2 == 0)	ResetPlayerCamera(i);
				        
				        if(PlayerCache[i][pDrugLevel] <= 0)
				        {
		          			PlayerCache[i][pDrugType] 	= DRUG_NONE;
			            	PlayerCache[i][pDrugLevel] 	= 0;

							PlayerCache[i][pDrugValue1] = 0;
		     				PlayerCache[i][pDrugValue2] = 0;
				        }
				    }
				    
				    // Odżywka
				    case DRUG_CONDITIONER:
				    {
				        PlayerCache[i][pDrugValue1] --;
				        if(PlayerCache[i][pDrugValue1] <= 0)
				        {
		          			PlayerCache[i][pDrugType] 	= DRUG_NONE;
			            	PlayerCache[i][pDrugLevel] 	= 0;

							PlayerCache[i][pDrugValue1] = 0;
		     				PlayerCache[i][pDrugValue2] = 0;
				        }
				    }
				}
			}
			
			// Uzależnienie
			if(PlayerCache[i][pDepend] > 25.0)
			{
			    new Float:depend = PlayerCache[i][pDepend],
					drug_level = PlayerCache[i][pDrugLevel];
					
				if(drug_level < depend)
				{
				    if((depend > 25 && depend <= 35 && minute % 55 == 0) || (depend > 35 && depend <= 55 && minute & 45 == 0) || (depend > 55 && depend <= 70 && minute & 35 == 0))
				    {
						if(PlayerCache[i][pHealth] > 10)
						{
						    new Float:get_health = (depend - drug_level) / 10;
  							if(PlayerCache[i][pHealth] - get_health > 10)
         					{
								crp_SetPlayerHealth(i, PlayerCache[i][pHealth] - get_health);
         					}
              				else
				            {
                				crp_SetPlayerHealth(i, 10);
                			}
                			TD_ShowHint(i, HINT_NONE, 5, "Twoja postac odczuwa chec zazycia ~b~narkotyku~w~. Pasek ~r~stanu zdrowia ~w~ulegl zmianie z tego powodu.");

							if(depend >= 35)
							{
								new random_number = random(5),
									random_string[128];
									
								switch(random_number)
								{
									case 1: random_string = "** Odczuwasz lekkie duszności. **";
									case 2: random_string = "** Od kilku minut odnosisz wrażenie, że ktoś Cię śledzi. **";
									case 3: random_string = "** Słyszysz dziwne odgłosy, zdające się mówić do Ciebie. **";
									case 4: random_string = "** Masz wrażenie, jakby ktoś trzymał Cię za rękę. **";
								}
								SendClientMessage(i, COLOR_DO, random_string);
							}
						}
				    }
				}
			}
			
			CheckPlayerPayday(i);
	    }
	}
	
	new count_doors = Streamer_GetUpperBound(STREAMER_TYPE_PICKUP);
	for(new doorid = 0; doorid < count_doors; doorid++)
	{
	    new DoorData[sDoorInfo];
  		Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
  		
  		if(DoorData[dMapIcon] != 0)
  		{
  		    new count_players[2] = {0, 0};
			foreach(new i : Player)
			{
				if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
				{
				    if(GetPlayerDoorID(i) == doorid)
				    {
						// Pracownik
						if(PlayerCache[i][pDuty][DUTY_GROUP] != INVALID_GROUP_ID)
						{
	    					new group_id = PlayerCache[i][pDuty][DUTY_GROUP];
	    					if(DoorData[dOwner] == GroupData[group_id][gUID])
							{
							    count_players[0] ++;
				    		}
					    }
					    count_players[1] ++;
					}
				}
			}
			
			// Ikona
			new map_icon = DoorData[dMapIcon];
			if(count_players[0] > 0)
			{
   				Streamer_SetIntData(STREAMER_TYPE_MAP_ICON, map_icon, E_STREAMER_WORLD_ID, 0);
			}
			else
			{
			    if(!Streamer_GetIntData(STREAMER_TYPE_MAP_ICON, map_icon, E_STREAMER_EXTRA_ID))	Streamer_SetIntData(STREAMER_TYPE_MAP_ICON, map_icon, E_STREAMER_WORLD_ID, 9999);
			}
			
			// Ile osób w środku
			if(IsValidDynamic3DTextLabel(DoorData[d3DLabel]))
			{
			    new Text3D:label_id = DoorData[d3DLabel];
				if(count_players[1] > 0)
				{
				    new string[128];
				    format(string, sizeof(string), "** %d osób w środku (w tym %d pracowników) **", count_players[1], count_players[0]);
					UpdateDynamic3DTextLabelText(label_id, COLOR_DO, string);
				}
				else
				{
                    UpdateDynamic3DTextLabelText(label_id, COLOR_DO, " ");
				}
			}
  		}
  		
		if(DoorData[dFireData][FIRE_TIME] > 0)
	 	{
			new string[128], group_id,
			    Float:PosX, Float:PosY, Float:PosZ;

			DoorData[dFireData][FIRE_TIME] ++;
			Streamer_SetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);

			foreach(new i : Player)
			{
 				if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	   			{
					if(GetPlayerDoorID(i) == doorid)
					{
		     			if(PlayerCache[i][pDuty][DUTY_GROUP] != INVALID_GROUP_ID)
			       	 	{
							group_id = PlayerCache[i][pDuty][DUTY_GROUP];
							if(GroupData[group_id][gType] == G_TYPE_FIREDEPT)
							{
								if(PlayerCache[i][pItemWeapon] != INVALID_ITEM_ID)
								{
									if(GetPlayerWeapon(i) == 42)
									{
		    							DoorData[dFireData][FIRE_TIME] --;
			   							Streamer_SetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);

										GetPlayerPos(i, PosX, PosY, PosZ);
										GetXYInFrontOfPlayer(i, PosX, PosY, 8.0);
										
										CreateExplosion(PosX, PosY, PosZ, 9, 5.0);
										CreateExplosion(PosX, PosY, PosZ, 13, 10.0);
									}
								}
							}
	    				}
					}
		    	}
			}
			
 			new color, Float:percent = (float(DoorData[dFireData][FIRE_TIME]) / 15.0) * 100, fire_label = DoorData[dFireData][FIRE_LABEL],
				Float:door_enter[3];

			Streamer_GetItemPos(STREAMER_TYPE_PICKUP, doorid, door_enter[0], door_enter[1], door_enter[2]);
   			format(string, sizeof(string), "Ten budynek stanął w płomieniach!\nSzacowane zniszczenia: %d%", floatround(percent));

			if(DoorData[dFireData][FIRE_TIME] < 4)			color = 0x33AA33FF;
	      	else if(DoorData[dFireData][FIRE_TIME] >= 5 && DoorData[dFireData][FIRE_TIME] < 10)
			{
				color = 0xFF9900FF;
       			CreateExplosion(door_enter[0], door_enter[1], door_enter[2], 2, 5.0);
			}
  			else
  			{
			  	color = 0xAA3333FF;
			  	CreateExplosion(door_enter[0], door_enter[1], door_enter[2], 2, 10.0);
			}

			UpdateDynamic3DTextLabelText(Text3D:fire_label, color, string);

			// Pożar dobiegł końca
			if(percent >= 100)
			{
	   		    DoorData[dExitX]   = 0.0;
	   		    DoorData[dExitY]   = 0.0;
	   		    DoorData[dExitZ]   = 0.0;

				DoorData[dExitInt] = 0;
				DoorData[dExitVW]  = 0;

				DestroyDynamicObject(DoorData[dFireData][FIRE_OBJECT]);
				DestroyDynamic3DTextLabel(Text3D:DoorData[dFireData][FIRE_LABEL]);

				DoorData[dFireData][FIRE_TIME] = 0;
				CreateExplosion(door_enter[0], door_enter[1], door_enter[2], 2, 10.0);

				Streamer_SetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
				SaveDoor(doorid);
			}
			else if(percent <= 0)
			{
  		    	DestroyDynamicObject(DoorData[dFireData][FIRE_OBJECT]);
    		    DestroyDynamic3DTextLabel(Text3D:DoorData[dFireData][FIRE_LABEL]);

				DoorData[dFireData][FIRE_TIME] = 0;
            	Streamer_SetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
			}
		}
	}
	return 1;
}

task OnSecondTask[1000]()
{
	new hour, minute, second, time, string[256];
	time = gettime(hour, minute, second);

/*
	if(hour == 20 && minute == 0 && second == 0)
	{
		SendRconCommand("password  ");
	}
	else
	{
		format(string, sizeof(string), "hostname [m-rp.net] - START za %dh %dm %ds (20:00)", 19 - hour, 59 - minute, 59 - second);
		SendRconCommand(string);
	}
	
*/
	if(PunishTime > 0)
	{
	    PunishTime --;
		if(PunishTime <= 0)
		{
		    PunishTime = 0;
		
		    TextDrawHideForAll(Text:TextDrawPunishTitle);
			TextDrawHideForAll(Text:TextDrawPunishDesc);
		}
	}
	
	foreach(new i : Player)
	{
	    if(GetPlayerState(i) == PLAYER_STATE_ONFOOT && !PlayerCache[i][pSpawned])
	    {
            GivePlayerPunish(INVALID_PLAYER_ID, INVALID_PLAYER_ID, PUNISH_KICK, "Spawn bez zalogowania.", 0, 0);
		 	continue;
	    }
	    
     	// TextDraw informacyjny (mały)
   		if(PlayerCache[i][pSmallTextTime] && time > PlayerCache[i][pSmallTextTime])
	    {
     		TD_HideSmallInfo(i);
	    }
	    
	    // TextDraw informacyjny (duży)
	    if(PlayerCache[i][pLargeTextTime] && time > PlayerCache[i][pLargeTextTime])
	    {
	        TD_HideLargeInfo(i);
	    }
	    
	    // TextDraw samouczka
	    if(PlayerCache[i][pHintTextTime] && time > PlayerCache[i][pHintTextTime])
	    {
	        TD_HideHint(i);
	    }
	    
	    // Osiągnięcia
	    if(PlayerCache[i][pAchieveTextTime] && time > PlayerCache[i][pAchieveTextTime])
	    {
	        PlayerTextDrawHide(i, PlayerText:TextDrawAchieve[i]);
	    }
	    
	    if(PlayerCache[i][pSession][SESSION_LOGIN] && PlayerCache[i][pSession][SESSION_LOGIN] + 30 < time)
	    {
	        SendClientFormatMessage(i, COLOR_RED, "Przekroczony czas logowania: 30 sekund. Zostajesz wyrzucony z serwera.");
			defer OnKickPlayer(i);
			continue;
	    }
	    
	
	    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	    {
	        new //anim_id = GetPlayerAnimationIndex(i),
				Float:PosX, Float:PosY, Float:PosZ,
	            Float:Health, status = PlayerCache[i][pStatus];
	            
	        GetPlayerPos(i, PosX, PosY, PosZ);
	        GetPlayerHealth(i, Health);
	        
	        new keysa, uda, lra;
	        GetPlayerKeys(i, keysa, uda, lra);
	        
        	if((((keysa & (KEY_YES)) == (KEY_YES)) && ((PlayerCache[i][pLastKey] & (KEY_YES)) != (KEY_YES))))
			{
				OnPlayerInteractActor(i, GetPlayerCameraTargetDynActor(i));
			}
			if((((keysa & (KEY_YES)) != (KEY_YES)) && ((PlayerCache[i][pLastKey] & (KEY_YES)) == (KEY_YES))))
			{
			
			}
			
			PlayerCache[i][pLastKey] = keysa;
			
			// Timer misji
			if(MissionData[i][mUID] != 0)
			{
			    if(MissionData[i][mLeader])
			    {
					foreach(new member : MissionPlayer[i])
					{

					}
			    }
			}
			
			// Czas freeze
			if(PlayerCache[i][pFreeze] > 0)
			{
			    PlayerCache[i][pFreeze] --;
			    if(PlayerCache[i][pFreeze] <= 0)
			    {
					OnPlayerFreeze(i, false, 0);
			    }
			}
			PlayerCache[i][pAFK] ++;
			
			if(Health > PlayerCache[i][pHealth])
			{
		 		SetPlayerHealth(i, PlayerCache[i][pHealth]);
			}

			if(GetPlayerMoney(i) > PlayerCache[i][pCash])
			{
				ResetPlayerMoney(i);
				GivePlayerMoney(i, PlayerCache[i][pCash]);
			}

			if(IsPlayerInAnyVehicle(i))
			{
   				new vehid = GetPlayerVehicleID(i),
					speed = GetPlayerSpeed(i, true), componentid;

				if(speed >= VehicleModelData[CarInfo[vehid][cModel] - 400][vMaxSpeed] + 40)
				{
					GivePlayerPunish(i, INVALID_PLAYER_ID, PUNISH_KICK, "SpeedHack.", 0, 0);
					continue;
				}

				// Kierowca
	   			if(GetPlayerState(i) == PLAYER_STATE_DRIVER || GetPlayerVehicleSeat(i) == 0)
		        {
      				// UnAuthorised
					if(PlayerCache[i][pLastVeh] != vehid)
					{
	 					GivePlayerPunish(i, INVALID_PLAYER_ID, PUNISH_KICK, "Nieautoryzowane wejscie do pojazdu.", 0, 0);
	   					continue;
					}
					
					// Ograniczona prędkość
     				if(IsVehicleBike(vehid))
		            {
		                if(speed >= 55)
						{
                      		SetPlayerSpeed(i, 45.0);
		                }
		            }
		        
		            /*
		            // GPS
		            if(CarInfo[vehid][cGPS])
		            {
	                    for(new icon_id = 0; icon_id < 100; icon_id++) RemovePlayerMapIcon(i, icon_id);

						new icon_id, carid, group_id,
				   		    Float:VehPosX, Float:VehPosY, Float:VehPosZ;

				   		foreach(new playerid : Player)
				   		{
				   		    if(i != playerid)
				   		    {
					   		    if(PlayerCache[playerid][pLogged] && PlayerCache[playerid][pSpawned])
					   		    {
									if(PlayerCache[playerid][pDuty][DUTY_GROUP] != INVALID_GROUP_ID)
									{
									    group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
									    if(GroupData[group_id][gType] == G_TYPE_POLICE)
									    {
						   		            carid = GetPlayerVehicleID(playerid);
						   		            if(CarInfo[carid][cOwnerType] == OWNER_GROUP && CarInfo[carid][cOwner] == GroupData[group_id][gUID])
						   		            {
						   		                GetVehiclePos(carid, VehPosX, VehPosY, VehPosZ);
						   						SetPlayerMapIcon(i, icon_id, VehPosX, VehPosY, VehPosZ, 30, 0, MAPICON_GLOBAL);

						   						icon_id ++;
											}
										}
									}
								}
							}
						}
		            }
		            */

					if(GetVehicleEngineStatus(vehid) == 1 && !IsVehicleBike(vehid))
					{
						new Float:last_fuel = CarInfo[vehid][cFuel];

						if(speed < 1)
				    	{
		   					CarInfo[vehid][cFuel] -= 0.005;
				    	}
				    	else if(speed >= 1 && speed <= 40)
				    	{
		    				CarInfo[vehid][cFuel] -= 0.008;
				    	}
				    	else if(speed >= 41 && speed <= 80)
				    	{
		    				CarInfo[vehid][cFuel] -= 0.01;
				    	}
				    	else if(speed >= 81 && speed <= 120)
					   	{
		    				CarInfo[vehid][cFuel] -= 0.015;
				    	}
				    	else if(speed >= 121 && speed <= 150)
				    	{
		    				CarInfo[vehid][cFuel] -= 0.02;
				    	}
				    	else
				    	{
		    				CarInfo[vehid][cFuel] -= 0.03;
				    	}

				    	// Jeśli paliwo spadnie o 1 litr, pokaż info
	     				if(floatround(CarInfo[vehid][cFuel], floatround_floor) < floatround(last_fuel, floatround_floor))
		        		{
		    				format(string, sizeof(string), "~n~~n~~n~~n~~n~~n~~n~~y~Paliwo: ~g~~h~%.0f/%d L", CarInfo[vehid][cFuel], VehicleModelData[CarInfo[vehid][cModel] - 400][vMaxFuel]);
		    				GameTextForPlayer(i, string, 10000, 3);

		    				CarInfo[vehid][cSavePoint] += 5;
						}

						CarInfo[vehid][cDistTicker] += floatround(floatsqroot(floatpower(floatabs(floatsub(PosX, PlayerCache[i][pPosX])), 2)+ floatpower(floatabs(floatsub(PosY, PlayerCache[i][pPosY])), 2)+floatpower(floatabs(floatsub(PosZ, PlayerCache[i][pPosZ])), 2)));
						
						// Przejechał 100 metrów
						if(CarInfo[vehid][cDistTicker] >= 100)
	     				{
	     				    // Taxi
							if(PlayerCache[i][pTaxiPassenger] != INVALID_PLAYER_ID)
							{
								new passenger_id = PlayerCache[i][pTaxiPassenger];
								if(PlayerCache[passenger_id][pCash] > (PlayerCache[passenger_id][pTaxiPay] + PlayerCache[passenger_id][pTaxiPrice]))
								{
								    PlayerCache[passenger_id][pTaxiPay] += PlayerCache[passenger_id][pTaxiPrice];
	   								format(string, sizeof(string), "~w~Koszt: ~g~$%d", PlayerCache[passenger_id][pTaxiPay]);

									GameTextForPlayer(i, string, 5000, 6);
					    			GameTextForPlayer(passenger_id, string, 5000, 6);
								}
								else
								{
				    				GameTextForPlayer(i, "~r~Pasazer nie posiada tyle gotowki", 5000, 6);
								    GameTextForPlayer(passenger_id, "~r~Nie posiadasz tyle gotowki", 5000, 6);
								}
							}

						    // Nalicz przebieg
						    CarInfo[vehid][cMileage] += 0.1;
						    CarInfo[vehid][cDistTicker] = 0;

						    CarInfo[vehid][cSavePoint] += 5;
						    PlayerCache[i][pMileage] += 0.1;
						}

						// Stan techniczny
						GetVehicleHealth(vehid, Health);
						if(Health > CarInfo[vehid][cHealth])
						{
		 					SetVehicleHealth(vehid, CarInfo[vehid][cHealth]);
						}
						if(Health < CarInfo[vehid][cHealth])
						{
						    OnPlayerTakeDamage(i, INVALID_PLAYER_ID, ((CarInfo[vehid][cHealth] - Health) / ((PlayerCache[i][pBelts]) ? 10 : 5)), 0, 0);
		 					GetVehicleHealth(vehid, CarInfo[vehid][cHealth]);
		 					
		 					CarInfo[vehid][cSavePoint] ++;
		 					printf("[cars] Stan pojazdu %s (UID: %d) uległ zmianie. Kierowca: %s (UID: %d, GID: %d), HP: %.0f/%.0f", GetVehicleName(CarInfo[vehid][cModel]), CarInfo[vehid][cUID], PlayerRealName(i), PlayerCache[i][pUID], PlayerCache[i][pGID], Health, CarInfo[vehid][cHealth]);
						}

						// Stan wizualny
						new panels, doors, lights, tires, veh_visual[4];
						GetVehicleDamageStatus(vehid, panels, doors, lights, tires);
						
						sscanf(CarInfo[vehid][cVisual], "a<d>[4]", veh_visual);
						if(panels < veh_visual[0] || lights < veh_visual[2] || tires < veh_visual[3])	UpdateVehicleDamageStatus(vehid, veh_visual[0], veh_visual[1], veh_visual[2], veh_visual[3]);
						
						
						if(CarInfo[vehid][cHealth] <= 360 || CarInfo[vehid][cHealth] < 700 && random(150) == 25)
						{
							ChangeVehicleEngineStatus(vehid, false);
							TD_ShowSmallInfo(i, 5, "Silnik w pojezdzie zgasl ze wzgledu na liczne ~r~uszkodzenia ~w~techniczne.");

							CarInfo[vehid][cSavePoint] += 30;
						}

	    				if(CarInfo[vehid][cFuel] <= 0)
				    	{
	                        ChangeVehicleEngineStatus(vehid, false);
							TD_ShowSmallInfo(i, 5, "Silnik w pojezdzie zgasl ze wzgledu na ~r~brak ~w~paliwa.", 5000, 3);

							CarInfo[vehid][cSavePoint] += 30;
				    	}
				    	
				    	// Kolczatki
				    	if(GetPlayerInterior(i) == 0 && GetPlayerVirtualWorld(i) == 0)
				    	{
							new object_id = GetClosestObjectType(i, OBJECT_ECHIDNA);
							if(object_id != INVALID_OBJECT_ID)
							{
			   					sscanf(CarInfo[vehid][cVisual], "a<d>[4]", veh_visual);

								veh_visual[3] = 15;
			    				crp_UpdateVehicleDamageStatus(vehid, veh_visual[0], veh_visual[1], veh_visual[2], veh_visual[3]);

								DestroyDynamicObject(object_id);
								TD_ShowSmallInfo(i, 5, "Najechales na ~y~kolczatke~w~!~n~Opony zostaly ~r~przebite~w~.");
							}
						}

	 					// Zapisz statsy
						if(CarInfo[vehid][cSavePoint] >= 70)	orm_update(CarInfo[vehid][cOrm]);

						// Tuning mechaniczny
						//if(!IsPlayerUsingCHandling(i))
						//{
						if(second % 2 == 0)
						{
						    speed = speed + (speed * CarInfo[vehid][cHandling]);
							if(speed < GetVehicleMaxSpeed(CarInfo[vehid][cModel]) + (CarInfo[vehid][cHandling] * 100))
							{
								SetPlayerSpeed(i, speed);
							}
      					}
						//}
					}

					// Anty tuning
	  				for (new j = 0; j < 14; ++j)
		   			{
	   					componentid = GetVehicleComponentInSlot(vehid, j);
	     				if (componentid != 0 && componentid != (CarInfo[vehid][cComponent][j] + 999))
	        			{
	      	    			GivePlayerPunish(i, INVALID_PLAYER_ID, PUNISH_BAN, "Proba stuningowania pojazdu.", 365, 0);
							SetVehicleToRespawn(vehid);
	      					continue;
	      				}
			    	}
		        }
			}
	        
 			// Brutally Wounded (bw)
			if(PlayerCache[i][pBW])
			{
			    PlayerCache[i][pBW] --;
				if(PlayerCache[i][pBW] > 1 * 60)
				{
					format(string, sizeof(string), "~w~Koniec ~r~BW~w~: ~y~%d ~w~min.", PlayerCache[i][pBW] / 60);
					GameTextForPlayer(i, string, 1000, 1);
				}
				else
				{
					format(string, sizeof(string), "~w~Koniec ~r~BW~w~: ~y~%d ~w~sek.", PlayerCache[i][pBW]);
					GameTextForPlayer(i, string, 1000, 1);
				}
				
				// Koniec
				if(PlayerCache[i][pBW] <= 0)
				{
					PlayerCache[i][pBW] = 0;
					
					ApplyAnimation(i, "Attractors", "Stepsit_out", 4.0, 0, 1, 1, 0, 1, true);
					OnPlayerFreeze(i, false, 0);

					ResetPlayerCamera(i);
					crp_SetPlayerHealth(i, 20);

					TD_ShowSmallInfo(i, 5, "Ocknales sie, jednak nie jestes ~y~calkiem ~w~na silach.~n~Twoj stan zdrowia ~r~nie jest ~w~idealny, lepiej udaj sie do szpitala.");
					SetPlayerDrunkLevel(i, 5000);
					
					PlayerCache[i][pDeathBody] = 0;
				}
			}
			
			// AdminJail (aj)
			if(PlayerCache[i][pAJ])
			{
			    if(!IsPlayerInRangeOfPoint(i, 5.0, PosInfo[ADMIN_JAIL_POS][sPosX], PosInfo[ADMIN_JAIL_POS][sPosY], PosInfo[ADMIN_JAIL_POS][sPosZ]))
			    {
			        crp_SetPlayerPos(i,  PosInfo[ADMIN_JAIL_POS][sPosX], PosInfo[ADMIN_JAIL_POS][sPosY], PosInfo[ADMIN_JAIL_POS][sPosZ]);
			        
			       	SetPlayerInterior(i, PosInfo[ADMIN_JAIL_POS][sPosInterior]);
					SetPlayerVirtualWorld(i, i + 1000);
			    }

			    PlayerCache[i][pAJ] --;
				if(PlayerCache[i][pAJ] > 1*60)
				{
					format(string, sizeof(string), "~w~Koniec ~r~AJ~w~: ~g~%d ~w~min.", PlayerCache[i][pAJ] / 60);
					GameTextForPlayer(i, string, 1000, 1);
				}
				else
				{
					format(string, sizeof(string), "~w~Koniec ~r~AJ~w~: ~g~%d ~w~sek.", PlayerCache[i][pAJ]);
					GameTextForPlayer(i, string, 1000, 1);
				}
				if(PlayerCache[i][pAJ] <= 0)
				{
					PlayerCache[i][pAJ] = 0;
					SetPlayerSpawn(i);
				}
			}
			
			// Skuty gracz
			if(PlayerCache[i][pCuffedTo] != INVALID_PLAYER_ID)
			{
			    new cuffed_to = PlayerCache[i][pCuffedTo],
			        Float:cuffed_x, Float:cuffed_y, Float:cuffed_z,
			        cuffed_interior, cuffed_world;
			        
				GetPlayerPos(cuffed_to, cuffed_x, cuffed_y, cuffed_z);
				
				cuffed_interior = GetPlayerInterior(cuffed_to);
				cuffed_world = GetPlayerVirtualWorld(cuffed_to);
				
				if(!IsPlayerInAnyVehicle(cuffed_to))
				{
					if(!IsPlayerInRangeOfPoint(i, 5.0, cuffed_x, cuffed_y, cuffed_z))
					{
					    if(IsPlayerInAnyVehicle(i))
					    {
					        RemovePlayerFromVehicle(i);
							OnPlayerFreeze(i, false, 0);
					    }

					    crp_SetPlayerPos(i, cuffed_x + 1, cuffed_y, cuffed_z);

					    SetPlayerInterior(i, cuffed_interior);
					    SetPlayerVirtualWorld(i, cuffed_world);
					}
				}
				else
				{
				    new vehid = GetPlayerVehicleID(cuffed_to),
						seatid = GetFreeVehicleSeat(vehid);
				    
				    if(seatid != INVALID_VEHICLE_ID)
				    {
				        PlayerCache[i][pLastVeh] = vehid;
				        
				        PutPlayerInVehicle(i, vehid, seatid);
						OnPlayerFreeze(i, true, 0);
				    }
				    else
				    {
				        TD_ShowSmallInfo(cuffed_to, 3, "Brak ~r~wolnego miejsca ~w~w pojezdzie.");
				    }
				}
			}
			
			// Przeszukiwanie gracza
			if(PlayerCache[i][pSearches] != INVALID_PLAYER_ID)
			{
			    new searched_player = PlayerCache[i][pSearches];
			    if(PlayerToPlayer(5.0, i, searched_player))
			    {
					PlayerCache[i][pSearchTime] --;

					GameTextForPlayer(i, "~n~~n~~n~~n~~n~~n~~n~~g~Trwa przeszukiwanie...", 1000, 3);
					if(PlayerCache[i][pSearchTime] <= 0)
					{
					    ListPlayerItemsForPlayer(searched_player, i);

                    	format(string, sizeof(string), "~n~~n~~n~~n~~n~~n~~n~~n~~n~~y~Gotowka gracza ~r~%s~y~: ~g~$%d~y~.", PlayerName(searched_player), PlayerCache[searched_player][pCash]);
						GameTextForPlayer(i, string, 6000, 3);

					    PlayerCache[i][pSearches] = INVALID_PLAYER_ID;
					    PlayerCache[i][pSearchTime] = 0;
					}
				}
				else
				{
				    PlayerCache[i][pSearches] = INVALID_PLAYER_ID;
				    PlayerCache[i][pSearchTime] = 0;

				    ShowPlayerInfoDialog(i, D_TYPE_ERROR, "Przeszukiwanie gracza zostało anulowane.\nPowód: Gracz znajduje się zbyt daleko od Ciebie.");
                    GameTextForPlayer(searched_player, "~r~~h~Przeszukiwanie zostalo przerwane.", 4500, 3);
				}
			}
			
			// Leczenie gracza przez medyka
			if(PlayerCache[i][pHealing] != INVALID_PLAYER_ID)
			{
			    new patient_id = PlayerCache[i][pHealing];
			    if(PlayerToPlayer(5.0, i, patient_id))
			    {
			        if(PlayerCache[patient_id][pHealth] + 5.0 < 100.0)
			        {
						crp_SetPlayerHealth(patient_id, PlayerCache[patient_id][pHealth] + 5.0);

						GameTextForPlayer(i, "~n~~n~~n~~n~~n~~g~~h~Proces leczenia trwa...", 3000, 3);
                        GameTextForPlayer(patient_id, "~n~~n~~n~~n~~n~~g~~h~Proces leczenia trwa...", 3000, 3);
					}
			        else
			        {
			            PlayerCache[i][pHealing] = INVALID_PLAYER_ID;
			            crp_SetPlayerHealth(patient_id, 100.0);

			            ShowPlayerInfoDialog(i, D_TYPE_INFO, "Proces leczenia został zakończony pomyślnie.");
                        ShowPlayerInfoDialog(patient_id, D_TYPE_INFO, "Proces leczenia został zakończony pomyślnie.");
					}
			    }
			    else
			    {
			        PlayerCache[i][pHealing] = INVALID_PLAYER_ID;

					ShowPlayerInfoDialog(i, D_TYPE_ERROR, "Proces leczenia gracza został anulowany.\nPowód: Gracz znajduje się zbyt daleko od Ciebie.");
                    GameTextForPlayer(patient_id, "~r~~h~Leczenie zostalo przerwane.", 4500, 3);
				}
			}
			
			// Trening w siłowni
			if(PlayerCache[i][pItemPass] != INVALID_ITEM_ID)
			{
				PlayerCache[i][pGymTime] --;

				if(PlayerCache[i][pGymTime] > 60)
				{
					format(string, sizeof(string), "~w~Trening: ~y~%d ~w~min", PlayerCache[i][pGymTime] / 60);
					GameTextForPlayer(i, string, 1000, 6);
  				}
				else
				{
					format(string, sizeof(string), "~w~Trening: ~y~%d ~w~sec", PlayerCache[i][pGymTime]);
   					GameTextForPlayer(i, string, 1000, 6);
				}
				
				if(PlayerCache[i][pGymTime] <= 0)
				{
					new object_id = PlayerCache[i][pGymObject],
					    itemid = PlayerCache[i][pItemPass];

					if(object_id != INVALID_OBJECT_ID)
					{
						ClearAnimations(i, true);
		    			PlayerCache[i][pStrength] = PlayerCache[i][pStrength] + (PlayerCache[i][pGymRepeat] / 4);

						PlayerCache[i][pGymObject] 	= INVALID_OBJECT_ID;
		    			PlayerCache[i][pGymRepeat] 	= 0;

						RemovePlayerAttachedObject(i, SLOT_TRAIN);
		    			TD_ShowSmallInfo(i, 3, "Trening zostal ~g~pomyslnie ~w~zakonczony.");
		    			TD_HideHint(i);
					}
					DeletePlayerItem(i,  itemid);

					PlayerCache[i][pItemPass]    = INVALID_ITEM_ID;
			  		PlayerCache[i][pGymTime]     = 0;
				}
			}
			
			// Naprawa pojazdu
			if(PlayerCache[i][pRepairVeh] != INVALID_VEHICLE_ID)
			{
   				new vehid = PlayerCache[i][pRepairVeh], Float:VehX, Float:VehY, Float:VehZ;
			    GetVehiclePos(vehid, VehX, VehY, VehZ);
			    
			    if(IsPlayerInRangeOfPoint(i, 4.0, VehX, VehY, VehZ))
			    {
					if(GetVehicleEngineStatus(vehid) != 1)
					{
				        PlayerCache[i][pRepairTime] --;
						TD_ShowSmallInfo(i, 0, "Odgrywaj stosowna akcje ~r~RolePlay~w~.~n~Pozostalo do konca: ~y~%d ~w~sekund.", PlayerCache[i][pRepairTime]);
	  					
  						new Text3D:label_id = PlayerCache[i][pRepairTag],
				   			Float:percent = (floatabs((float(PlayerCache[i][pRepairTime]) / 180.0) * 100 - 100));

						format(string, sizeof(string), "Naprawianie w toku...\n -- (%d%%) --", floatround(percent));
						UpdateDynamic3DTextLabelText(Text3D:label_id, COLOR_LIGHTBLUE, string);

	  					if(PlayerCache[i][pRepairTime] <= 0)
	  					{
							strmid(CarInfo[vehid][cVisual], "0 0 0 0", 0, 32);
	  					    CarInfo[vehid][cHealth] = 1000;

	  					    RepairVehicle(vehid);
	  					    SetVehicleHealth(vehid, 1000);

                            DestroyDynamic3DTextLabel(Text3D:label_id);

                            printf("[cars] Pojazd %s (UID: %d) został naprawiony. HP: %.0f", GetVehicleName(CarInfo[vehid][cModel]), CarInfo[vehid][cUID], CarInfo[vehid][cHealth]);

							PlayerCache[i][pRepairVeh] 	= INVALID_VEHICLE_ID;
							PlayerCache[i][pRepairTime] = 0;

	  					    orm_update(CarInfo[vehid][cOrm]);
	  					    TD_ShowSmallInfo(i, 5, "Pojazd zostal ~g~pomyslnie ~w~naprawiony.");
						}
					}
					else
					{
					    GameTextForPlayer(i, "~r~Silnik pojazdu musi byc zgaszony!", 1000, 3);
					}
			    }
			}
			
			// Lakierowanie pojazdu
			if(PlayerCache[i][pSprayVeh] != INVALID_VEHICLE_ID)
			{
			    new vehid = PlayerCache[i][pSprayVeh];
				if(GetDistanceToVehicle(i, vehid) <= 4.0)
				{
					new itemid = PlayerCache[i][pItemWeapon];
					if(itemid != INVALID_ITEM_ID && (keysa & KEY_FIRE) && PlayerItemCache[i][itemid][iType] == ITEM_PAINT && GetPlayerState(i) == PLAYER_STATE_ONFOOT)
					{
				        if(IsPlayerFacingVehicle(i, vehid))
				        {
				            new weapon_ammo = GetPlayerWeaponAmmo(i, PlayerItemCache[i][itemid][iValue][0]);
				            if(weapon_ammo < PlayerItemCache[i][itemid][iValue][1])
				            {
		  						PlayerCache[i][pSprayTime] -= (PlayerItemCache[i][itemid][iValue][1] - weapon_ammo);
								TD_ShowSmallInfo(i, 0, "Psikaj ~g~lakierem ~w~w strone pojazdu.~n~Pozostala wymagana ilosc: ~y~%d", PlayerCache[i][pSprayTime]);

		  						new Text3D:label_id = PlayerCache[i][pSprayTag],
						   			Float:percent = (floatabs((float(PlayerCache[i][pSprayTime]) / 1800.0) * 100 - 100));

		   						format(string, sizeof(string), "Lakierowanie w toku...\n -- (%d%%) --", floatround(percent));
		   						UpdateDynamic3DTextLabelText(Text3D:label_id, COLOR_LIGHTBLUE, string);

								if(PlayerCache[i][pSprayTime] <= 0)
				 				{
					    			if(PlayerCache[i][pSprayType] == SPRAY_TYPE_COLORS)
				 			    	{
		      							new color1 = PlayerCache[i][pSprayColor][0],
										  	color2 = PlayerCache[i][pSprayColor][1];

										ChangeVehicleColor(vehid, color1, color2);

										CarInfo[vehid][cColor1] = color1;
			  							CarInfo[vehid][cColor2] = color2;

			  							printf("[cars] Kolory pojazdu %s (UID: %d) uległy zmianie. Nowe kolory: %d/%d.", GetVehicleName(CarInfo[vehid][cModel]), CarInfo[vehid][cUID], CarInfo[vehid][cColor1], CarInfo[vehid][cColor2]);
									}
									else if(PlayerCache[i][pSprayType] == SPRAY_TYPE_PAINTJOB)
									{
					    				new paintjob_id = PlayerCache[i][pSprayColor][0];
									    ChangeVehiclePaintjob(vehid, paintjob_id);

									    CarInfo[vehid][cPaintJob] = paintjob_id;
									    printf("[cars] Paintjob pojazdu %s (UID: %d) uległ zmianie. Nowy paintjob: %d.", GetVehicleName(CarInfo[vehid][cModel]), CarInfo[vehid][cUID], CarInfo[vehid][cPaintJob]);
									}

   									PlayerCache[i][pSprayVeh] 			= INVALID_VEHICLE_ID;

									PlayerCache[i][pSprayColor][0] 		= 0;
		    						PlayerCache[i][pSprayColor][1] 		= 0;

									PlayerCache[i][pSprayTime] 			= 0;
									PlayerCache[i][pSprayType] 			= SPRAY_TYPE_NONE;

									DestroyDynamic3DTextLabel(Text3D:label_id);

									orm_update(CarInfo[vehid][cOrm]);
									TD_ShowSmallInfo(i, 5, "Pojazd zostal ~g~pomyslnie ~w~przemalowany.");
								}
							}
						}
						else
						{
			    			GameTextForPlayer(i, "~r~Psikaj w strone pojazdu.", 1000, 3);
						}
					}
				}
				else
				{
				    GameTextForPlayer(i, "~r~Jestes zbyt daleko od pojazdu.", 1000, 3);
				}
			}
			
			// Montowanie części
			if(PlayerCache[i][pMontageVeh] != INVALID_VEHICLE_ID)
			{
			    new vehid = PlayerCache[i][pMontageVeh];
			    
				if(GetDistanceToVehicle(i, vehid) <= 4.0)
				{
				    PlayerCache[i][pMontageTime] --;

   					format(string, sizeof(string), "~n~~n~~n~~n~~n~~n~~n~~g~Pozostalo: ~w~%d sekund.", PlayerCache[i][pMontageTime]);
  					GameTextForPlayer(i, string, 1000, 3);

  					if(PlayerCache[i][pMontageTime] <= 0)
  					{
  					    new itemid = PlayerCache[i][pMontageItem];

  					    // Komponent tuningu
  					    if(PlayerItemCache[i][itemid][iType] == ITEM_TUNING)
  					    {
  					        new query[256];
  					        
							mysql_format(connHandle, query, sizeof(query), "UPDATE `"SQL_PREF"items` SET item_ownertype = '-1', item_owner = '0', item_vehuid = '%d' WHERE item_uid = '%d' LIMIT 1", CarInfo[vehid][cUID], PlayerItemCache[i][itemid][iUID]);
							mysql_query(connHandle, query);
							
							crp_AddVehicleComponent(vehid, PlayerItemCache[i][itemid][iValue][0]);
	  					    
	  					    printf("[cars] W pojeździe %s (UID: %d) został zamontowany komponent %s (UID: %d).", GetVehicleName(CarInfo[vehid][cModel]), CarInfo[vehid][cUID], PlayerItemCache[i][itemid][iName], PlayerItemCache[i][itemid][iUID]);
	  					    UnloadPlayerItem(i, itemid);
						}

						// Akcesoria (alarm, immobiliser, sprzęt audio [...])
						if(PlayerItemCache[i][itemid][iType] == ITEM_VEH_ACCESS)
						{
						    CarInfo[vehid][cAccess] += PlayerItemCache[i][itemid][iValue][0];
						    if(PlayerItemCache[i][itemid][iValue][0] & VEH_ACCESS_GAS)	CarInfo[vehid][cFuelType] = FUEL_TYPE_GAS;
						    
						    orm_update(CarInfo[vehid][cOrm]);

							printf("[cars] W pojeździe %s (UID: %d) zostało zamontowane akcesorie %s (UID: %d).", GetVehicleName(CarInfo[vehid][cModel]), CarInfo[vehid][cUID], PlayerItemCache[i][itemid][iName], PlayerItemCache[i][itemid][iUID]);
						    DeletePlayerItem(i, itemid);
						}
						
						PlayerCache[i][pMontageVeh] 	= INVALID_VEHICLE_ID;
		    			PlayerCache[i][pMontageTime] 	= 0;

						PlayerCache[i][pMontageItem] 	= 0;
   						ShowPlayerInfoDialog(i, D_TYPE_SUCCESS, "Część została pomyślnie zamontowana.");
  					}
				}
			}
			
			// Przejazd busem
			if(PlayerCache[i][pBusRide])
			{
   				PlayerCache[i][pBusTime] --;
			    if(PlayerCache[i][pBusTime] <= 0)
			    {
			        new object_id = PlayerCache[i][pBusTravel],
			            Float:oPosX, Float:oPosY, Float:oPosZ;
			            
					GetDynamicObjectPos(object_id, oPosX, oPosY, oPosZ);
					Streamer_UpdateEx(i, oPosX, oPosY, oPosZ, 0, 0, -1);
					
					crp_SetPlayerPos(i, oPosX, oPosY, oPosZ);

					SetPlayerInterior(i, 0);
					SetPlayerVirtualWorld(i, 0);

					ResetPlayerCamera(i);
					OnPlayerFreeze(i, false, 0);
					
					PlayerPlaySound(i, 1098, 0.0, 0.0, 0.0);
					PlayerPlaySound(i, 1147, 0.0, 0.0, 0.0);

					PlayerCache[i][pBusStart] 	= INVALID_OBJECT_ID;
					PlayerCache[i][pBusTravel] 	= INVALID_OBJECT_ID;
					
					PlayerCache[i][pBusRide]    = false;
					Streamer_ToggleCameraUpdate(i, false);
				}
			}
			
			// Tagowanie
			if(PlayerCache[i][pTaggingObject] != INVALID_OBJECT_ID)
			{
			    new object_id = PlayerCache[i][pTaggingObject], Float:distance;
			    Streamer_GetDistanceToItem(PosX, PosY, PosZ, STREAMER_TYPE_OBJECT, object_id, distance);

			    if(distance <= 3.0)
				{
        			new itemid = PlayerCache[i][pItemWeapon];
					if(itemid != INVALID_ITEM_ID && (keysa & KEY_FIRE) && PlayerItemCache[i][itemid][iType] == ITEM_WEAPON && PlayerItemCache[i][itemid][iValue][0] == 41 && GetPlayerState(i) == PLAYER_STATE_ONFOOT)
					{
     					if(IsPlayerFacingObject(i, object_id))
		        		{
				            new weapon_ammo = GetPlayerWeaponAmmo(i, PlayerItemCache[i][itemid][iValue][0]);
				            if(weapon_ammo < PlayerItemCache[i][itemid][iValue][1])
				            {
              					PlayerCache[i][pTaggingTime] -= (PlayerItemCache[i][itemid][iValue][1] - weapon_ammo);
              					TD_ShowSmallInfo(i, 0, "Psikaj w strone ~g~znacznika~w~, zeby malowac.~n~Pozostala wymagana ilosc: ~y~%d", PlayerCache[i][pTaggingTime]);

								if(PlayerCache[i][pTaggingTime] <= 0)
        						{
									ShowPlayerDialog(i, D_TAG_TEXT, DIALOG_STYLE_INPUT, "Stwórz TAG", "Dokończyłeś zamalowywanie TAGU. Możesz poniżej wprowadzić swój\nwłasny tekst, który zobaczą wszyscy inni będący w jego pobliżu.\nNie wprowadzaj zbyt dużej ilości znaków, by tekst był widoczny.\n\nFormatowanie tekstu:\n\n| - nowy wiersz\n(RRGGBB) - kolorowanie\n\nWprowadź nazwę czcionki i oddziel go dwukropkiem od treści, np:\nTahoma:Grove Street|HOME!", "Dalej", "Anuluj");
								}
					        }
						}
					}
				}
				else
				{
					PlayerCache[i][pTaggingObject] 	= INVALID_OBJECT_ID;
					PlayerCache[i][pTaggingTime]    = 0;

					TD_ShowSmallInfo(i, 3, "Tagowanie zostalo ~r~anulowane~w~.");
					CancelEdit(i);
				}
			}
			
			// Cornery
			if(PlayerCache[i][pCornerObject] != INVALID_OBJECT_ID)
			{
			    new object_id = PlayerCache[i][pCornerObject], object_type = GetObjectModel(object_id), Float:distance;
				Streamer_GetDistanceToItem(PosX, PosY, PosZ, STREAMER_TYPE_OBJECT, object_id, distance);
				
				if(distance <= 3.0)
				{
				    if(second % 20 == 0 && PlayerCache[i][pCornerPrice] == 0)
				    {
					    new time_multiplier, Float:price_multiplier;
						if(object_type == OBJECT_CORNER_RED)
						{
						    time_multiplier = 1;
						    price_multiplier = 0.9;
						}

						if(object_type == OBJECT_CORNER_BLUE)
						{
						    time_multiplier = 2;
							price_multiplier = 0.5;
						}

						if(object_type == OBJECT_CORNER_GREEN)
						{
						    time_multiplier = 3;
						    price_multiplier = 0.3;
						}

						// Przychodzi klient (time + random_time)
						if(minute % (time_multiplier + random(time_multiplier)) == 0)
						{
						    new drug_type = random(6), drug_value = random(10);
						    foreach(new itemid : PlayerItem[i])
						    {
						        if(PlayerItemCache[i][itemid][iUID])
						        {
						            if(PlayerItemCache[i][itemid][iType] == ITEM_DRUG && PlayerItemCache[i][itemid][iValue][0] == drug_type && PlayerItemCache[i][itemid][iValue][1] >= drug_value)
						            {
						                new drug_string[512],
											price = (DrugTypeInfo[drug_type][dCornerPrice] + random(floatround(DrugTypeInfo[drug_type][dCornerPrice] * price_multiplier))) * drug_value;

										format(drug_string, sizeof(drug_string), "Pojawił się nowy klient chętny na zakup %s (%dg). Jego oferta: $%d ($%d za gram).", PlayerItemCache[i][itemid][iName], drug_value, price, price / drug_value);
						                format(drug_string, sizeof(drug_string), "%s\n\nMożesz zaakceptować tę ofertę, lub podać swoją cenę (co niekoniecznie\nmoże się udać), bądź odrzucić tę ofertę i poczekać na korzystniejszą.\n\nWprowadź poniżej ile oczekujesz za gram tego produktu\njeśli natomiast akceptujesz złożoną ofertę przez klienta - zostaw okno puste.", drug_string);

						                ShowPlayerDialog(i, D_CORNER_OFFER, DIALOG_STYLE_INPUT, "Handel » Nowy klient", drug_string, "Negocjuj", "Odrzuć");
						                
										PlayerCache[i][pItemArray][ITEM_DRUG] = itemid;
										PlayerCache[i][pCornerPrice] = price;
										
										PlayerCache[i][pMainTable] = drug_value;
						                break;
						            }
						        }
						    }
						}
					}
				}
				else
				{
				    PlayerCache[i][pCornerObject]   = INVALID_OBJECT_ID;
				    PlayerCache[i][pCornerPrice] = 0;
				    
				    TD_ShowSmallInfo(i, 3, "Handel zostal ~r~zakonczony~w~.");
				}
			}
			
			// Drwal
			if(WorkInfo[i][wID] == JOB_LUMBERJACK && WorkInfo[i][wValue][0] != 0)
			{
			    if(WorkInfo[i][wExtraID] != 0)
			    {
			        if(time - WorkInfo[i][wValue][1] > 15)
			        {
 						new object_id = WorkInfo[i][wExtraID], objData[sObjectData],
    						Float:x, Float:y, Float:z, Float:rx, Float:ry, Float:rz;

						Streamer_GetArrayData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_EXTRA_ID, objData);

						GetDynamicObjectPos(object_id, x, y, z);
						GetDynamicObjectRot(object_id, rx, ry, rz);

						MoveDynamicObject(object_id, x, y, z + 0.03, 0.025, rx, ry -80.0, rz);
						objData[objExtraID] = gettime();

						Streamer_SetArrayData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_EXTRA_ID, objData);
						WorkInfo[i][wExtraID] = 0;

	                    TD_ShowSmallInfo(i, 5, "Drzewo zostalo ~g~pomyslnie ~w~sciete. Uzyj komendy ~p~/p podnies~w~, by podniesc drewno.");
                        ApplyAnimation(i, "CARRY", "crry_prtial", 4.0, 0, 0, 0, 0, 0, 1);
					}
				}
			}
			
			// Nauka jazdy
			if(PlayerCache[i][pLesson] != INVALID_GROUP_ID)
			{
				PlayerCache[i][pLessonTime] --;
				if(PlayerCache[i][pLessonTime] > 60)
				{
					format(string, sizeof(string), "~w~Nauka jazdy: ~y~%d ~w~min", PlayerCache[i][pLessonTime] / 60);
					GameTextForPlayer(i, string, 1000, 6);
  				}
				else
				{
					format(string, sizeof(string), "~w~Nauka jazdy: ~y~%d ~w~sec", PlayerCache[i][pLessonTime]);
   					GameTextForPlayer(i, string, 1000, 6);
				}
				
				if(PlayerCache[i][pLessonTime] <= 0)
				{
				    new group_id = PlayerCache[i][pLesson], vehid = GetPlayerVehicleID(i);
				    if(vehid != INVALID_VEHICLE_ID)
				    {
				        if(CarInfo[vehid][cOwnerType] == OWNER_GROUP && CarInfo[vehid][cOwner] == GroupData[group_id][gUID])
				        {
				            PlayerCache[i][pLesson] = INVALID_GROUP_ID;
				            PlayerCache[i][pLessonTime] = 0;
				        
				            RemovePlayerFromVehicle(i);
				            TD_ShowSmallInfo(i, 3, "Kurs nauki jazdy dobiegl ~r~konca~w~.");
				        }
				    }
				}
			}
			
			// Paczki
			if(PlayerCache[i][pPackage] != INVALID_PACKAGE_ID)
			{
			    if(PlayerCache[i][pCheckpoint] != CHECKPOINT_PACKAGE && PlayerCache[i][pCheckpoint] != CHECKPOINT_DOOR)
			    {
     				PlayerCache[i][pCheckpoint] 	= CHECKPOINT_NONE;
					PlayerCache[i][pPackage]	 	= INVALID_PACKAGE_ID;

					TD_ShowSmallInfo(i, 3, "Dostarczanie paczki zostalo ~r~anulowane~w~.");
			    }
			}
			
			// Boombox
			if(PlayerCache[i][pItemBoombox] != INVALID_ITEM_ID)
			{
				new areaid = GetPlayerAreaID(i);
          		foreach(new playerid : Player)
				{
				    if(PlayerCache[playerid][pLogged] && PlayerCache[playerid][pSpawned])
				    {
	 					if(playerid != i)
	   					{
							if(GetPlayerAreaID(i) == areaid)
							{
                                //PlayStreamedAudio3DForPlayer(playerid, format_url, PlayerCache[i][pPosX], PlayerCache[i][pPosY], PlayerCache[i][pPosZ]);
							}
						}
					}
			    }
			}
			
			if(!(PlayerCache[i][pAdmin] & A_PERM_BASIC))
			{
				// Anty WeaponHack
				if(PlayerCache[i][pCheckWeapon] && time > PlayerCache[i][pCheckWeapon])
				{
				    if(!PlayerCache[i][pBW])
				    {
					    if(PlayerCache[i][pItemWeapon] != INVALID_ITEM_ID)
					    {
					        if(GetPlayerWeaponID(i) > 0 && GetPlayerWeaponID(i) < 46)
					        {
					            new itemid = PlayerCache[i][pItemWeapon];
					            if(GetPlayerWeaponID(i) != PlayerItemCache[i][itemid][iValue][0])
					            {
		 							new weapon_id = GetPlayerWeaponID(i), weapon_name[32];
			    					GetWeaponName(weapon_id, weapon_name, sizeof(weapon_name));

									format(string, sizeof(string), "WeaponHack (weapID: %d, weapName: %s).", weapon_id, weapon_name);
									GivePlayerPunish(i, INVALID_PLAYER_ID, PUNISH_BAN, string, 365, 0);
									continue;
								}
							}
							
							// Zapiszmy amunicję non-onplayerweaponshot broni
							if(GetPlayerWeaponID(i) == 37 || GetPlayerWeaponID(i) == 41 || GetPlayerWeaponID(i) == 42)
							{
   								new itemid = PlayerCache[i][pItemWeapon],
									weapon_id = GetPlayerWeaponID(i), weapon_ammo;
									
 								weapon_ammo = GetPlayerWeaponAmmo(i, weapon_id);
								if(weapon_ammo > PlayerItemCache[i][itemid][iValue][1])
								{
								    format(string, sizeof(string), "AmmoCheat (%d/%d).", weapon_ammo, PlayerItemCache[i][itemid][iValue][1]);
									GivePlayerPunish(i, INVALID_PLAYER_ID, PUNISH_BAN, string, 30, 0);
									continue;
								}

								if(weapon_ammo < PlayerItemCache[i][itemid][iValue][1])
								{
									PlayerItemCache[i][itemid][iValue][1] = weapon_ammo;
								}

								if(GetPlayerWeaponState(i) == WEAPONSTATE_NO_BULLETS)
								{
								    if(PlayerItemCache[i][itemid][iValue][1] <= 0)
								    {
										ResetPlayerWeaponsEx(i);
										PlayerCache[i][pCheckWeapon] = (time + 5);

										PlayerItemCache[i][itemid][iValue][1] = 0;
										PlayerItemCache[i][itemid][iUsed] = false;

										orm_update(PlayerItemCache[i][itemid][iOrm]);

										PlayerCache[i][pItemWeapon] = INVALID_ITEM_ID;
										RemovePlayerAttachedObject(i, SLOT_WEAPON);
									}
								}
							}
						}
						else
						{
	     					if(GetPlayerWeaponID(i) > 0 && GetPlayerWeaponID(i) < 46)
					        {
					            new bool:weapon_found;
					            foreach(new itemid : PlayerItem[i])
					            {
					                if(PlayerItemCache[i][itemid][iType] == ITEM_WEAPON || PlayerItemCache[i][itemid][iType] == ITEM_INHIBITOR || PlayerItemCache[i][itemid][iType] == ITEM_PAINT)
					                {
					                    if(PlayerItemCache[i][itemid][iValue][0] == GetPlayerWeaponID(i))
					                    {
					                        weapon_found = true;
					                        break;
					                    }
					                }
					            }
					        
					            if(weapon_found == false)
					            {
									new weapon_id = GetPlayerWeaponID(i), weapon_name[32];
			    					GetWeaponName(weapon_id, weapon_name, sizeof(weapon_name));

									format(string, sizeof(string), "WeaponHack (weapID: %d, weapName: %s).", weapon_id, weapon_name);
									GivePlayerPunish(i, INVALID_PLAYER_ID, PUNISH_BAN, string, 365, 0);
									continue;
								}
					        }
						}
					}
				}

				// Anty UnFreeze
				if(PlayerCache[i][pFreeze] == -1)
				{
				    if(GetPlayerState(i) != PLAYER_STATE_PASSENGER)
				    {
						if(!IsPlayerInRangeOfPoint(i, 2.5, PlayerCache[i][pPosX], PlayerCache[i][pPosY], PlayerCache[i][pPosZ]))
						{
						    if(GetPlayerSpeed(i, true) >= 5 && PlayerCache[i][pCheckPos])
						    {
						        if(uda > 0 || uda < 0 || lra > 0 || lra < 0)
						        {
							        GivePlayerPunish(i, INVALID_PLAYER_ID, PUNISH_KICK, "UnFreeze.", 0, 0);
									continue;
								}
						    }
						}
					}
				}

				// Anty JetPack
				if(GetPlayerSpecialAction(i) == SPECIAL_ACTION_USEJETPACK)
				{
					GivePlayerPunish(i, INVALID_PLAYER_ID, PUNISH_BAN, "JetPack.", 365, 0);
					continue;
				}

				// Anty SpectateHack
				if(GetPlayerState(i) == PLAYER_STATE_SPECTATING && PlayerCache[i][pSpectate] == INVALID_PLAYER_ID)
				{
				    GivePlayerPunish(i, INVALID_PLAYER_ID, PUNISH_KICK, "SpectateHack.", 0, 0);
					continue;
				}
			}
	        
	        if(PlayerCache[i][pSpectate] == INVALID_PLAYER_ID)
	        {
		        PlayerCache[i][pPosX] = PosX;
		        PlayerCache[i][pPosY] = PosY;
		        PlayerCache[i][pPosZ] = PosZ;
			}
	        
	        if(PlayerCache[i][pCheckWeapon] < time)		PlayerCache[i][pCheckWeapon] = time;
	        if(!PlayerCache[i][pCheckPos])   			PlayerCache[i][pCheckPos] = true;
	        
			PlayerCache[i][pStatus] = GetPlayerStatus(i);
	        if(PlayerCache[i][pStatus] != status)	UpdatePlayerStatus(i);
	    }
	}
	return 1;
}

timer KillTalkingAnimation[1000](playerid)
{
    ApplyAnimation(playerid, "CARRY", "crry_prtial", 4.0, 0, 0, 0, 0, 0, 1);
	return 1;
}

timer OnDestroyReasonLabel[1000](label_id)
{
	DestroyDynamic3DTextLabel(Text3D:label_id);
	return 1;
}

timer OnVehicleEngineStarted[1000](vehicleid)
{
	new playerid = GetVehicleDriver(vehicleid);
	if(playerid == INVALID_PLAYER_ID)
	{
	    return 1;
	}
	if(GetVehicleEngineStatus(vehicleid) == 1)
	{
	    return 1;
	}
	if(CarInfo[vehicleid][cFuel] <= 0)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "W tym pojeździe nie ma paliwa.\nZatankuj pojazd, aby móc odpalić silnik.");
	    return 1;
	}
	ChangeVehicleEngineStatus(vehicleid, true);
	TD_ShowSmallInfo(playerid, 3, "Silnik zostal ~g~uruchomiony ~w~pomyslnie.");
	
	printf("[cars] %s (UID: %d, GID: %d) odpalił silnik pojazdu %s (UID: %d).", PlayerRealName(playerid), PlayerCache[playerid][pUID], PlayerCache[playerid][pGID], GetVehicleName(CarInfo[vehicleid][cModel]), CarInfo[vehicleid][cUID]);
	return 1;
}

timer OnResetPlayerNameTagColor[1000](playerid)
{
    Streamer_SetIntData(STREAMER_TYPE_3D_TEXT_LABEL, Text3D:PlayerCache[playerid][pNameTag], E_STREAMER_COLOR, PlayerCache[playerid][pNickColor]);
	return 1;
}

timer OnToggleVehicleAlarm[1000](vehicleid)
{
	if(GetVehicleAlarmStatus(vehicleid) == 1)	ChangeVehicleAlarmStatus(vehicleid, false);
	return 1;
}

timer OnKickPlayer[50](playerid)
{
	Kick(playerid);
	return 1;
}

public OnPlayerRequestClass(playerid, classid)
{
	if(PlayerCache[playerid][pLogged])
	{
	    SpawnPlayer(playerid);
	    return 1;
	}
	return 1;
}

public OnPlayerConnect(playerid)
{
	for(new session_id = 0; session_id != SESSION_COUNT; session_id++)	PlayerCache[playerid][pSession][session_id] = 0;
   	for(new sWorkData:e; e < sWorkData; ++e)							WorkInfo[playerid][e] = 0;
   	for(new sMissionData:e; e < sMissionData; ++e)                      MissionData[playerid][e] = 0;

	for(new sPlayer:e; e < sPlayer; ++e)
	{
	    if(e == pNameTag)   continue;
	    if(e == pDescTag)   continue;
	    if(e == vDescTag)   continue;
	    
		PlayerCache[playerid][e] = 0;
	}
	
	PlayerCache[playerid][pNickColor]				= COLOR_BLACK;
	
	PlayerCache[playerid][pStrength]                = 3500;
	
	PlayerCache[playerid][pTaxiVeh]                 = INVALID_VEHICLE_ID;
	PlayerCache[playerid][pTaxiPassenger]           = INVALID_PLAYER_ID;
	
	PlayerCache[playerid][pRepairVeh]               = INVALID_VEHICLE_ID;
	
	PlayerCache[playerid][pSprayVeh]                = INVALID_VEHICLE_ID;
	
	PlayerCache[playerid][pMontageVeh]              = INVALID_VEHICLE_ID;
	
	PlayerCache[playerid][pCuffedTo]                = INVALID_PLAYER_ID;
	PlayerCache[playerid][pCallingTo]               = INVALID_PLAYER_ID;
	
	PlayerCache[playerid][pCurrentArea]             = INVALID_AREA_ID;
	
	PlayerCache[playerid][pEditObject]              = INVALID_OBJECT_ID;
	PlayerCache[playerid][pEdit3DText]              = INVALID_3DTEXT_ID;
	PlayerCache[playerid][pEditActor]               = INVALID_ACTOR_ID;
	
	PlayerCache[playerid][pRadioInterview]          = INVALID_PLAYER_ID;
	
	PlayerCache[playerid][pSelectAccess]            = INVALID_ACCESS_ID;
	PlayerCache[playerid][pSelectSkin]              = INVALID_SKIN_ID;
	
	PlayerCache[playerid][pItemWeapon]              = INVALID_ITEM_ID;
	PlayerCache[playerid][pItemPlayer]              = INVALID_ITEM_ID;
	PlayerCache[playerid][pItemPass]                = INVALID_ITEM_ID;
	PlayerCache[playerid][pItemMask]                = INVALID_ITEM_ID;
	PlayerCache[playerid][pItemBoombox]             = INVALID_ITEM_ID;
	PlayerCache[playerid][pItemGloves]              = INVALID_ITEM_ID;
	
	PlayerCache[playerid][pSearches]                = INVALID_PLAYER_ID;
	
	PlayerCache[playerid][pLesson]                  = INVALID_GROUP_ID;
	
	PlayerCache[playerid][pHealing]                 = INVALID_PLAYER_ID;
	
	PlayerCache[playerid][pSpectate]                = INVALID_PLAYER_ID;
	PlayerCache[playerid][pPackage]                 = INVALID_PACKAGE_ID;
	
	PlayerCache[playerid][pGymObject]               = INVALID_OBJECT_ID;

	PlayerCache[playerid][pBusStart]                = INVALID_OBJECT_ID;
	PlayerCache[playerid][pBusTravel]               = INVALID_OBJECT_ID;
	
	PlayerCache[playerid][pBasketObject]            = INVALID_OBJECT_ID;
	PlayerCache[playerid][pBasketBall]              = INVALID_OBJECT_ID;
	
	PlayerCache[playerid][pTaggingObject]           = INVALID_OBJECT_ID;
	PlayerCache[playerid][pLogTries]        		= 3;
	
	PlayerCache[playerid][pCornerObject]            = INVALID_OBJECT_ID;
	
	PlayerCache[playerid][pLastVeh]                 = INVALID_VEHICLE_ID;
	PlayerCache[playerid][pLastW]                   = INVALID_PLAYER_ID;
	PlayerCache[playerid][pLastObject]              = INVALID_OBJECT_ID;
	PlayerCache[playerid][pAFK]                     = -5;
	PlayerCache[playerid][pOOC]                     = true;
	
	PlayerCache[playerid][pDuty][DUTY_ADMIN]        = false;
	PlayerCache[playerid][pDuty][DUTY_GROUP]        = INVALID_GROUP_ID;
	
	PlayerCache[playerid][pMainGroupSlot]           = INVALID_SLOT_ID;
 	PlayerCache[playerid][pCheckpoint]              = CHECKPOINT_NONE;
	
	PlayerCache[playerid][pFirstPersonObject]       = INVALID_OBJECT_ID;
	
	PlayerCache[playerid][pScreenShot]              = false;
	
	//for(new icon_id = 0; icon_id < 100; icon_id++)	RemovePlayerMapIcon(playerid, icon_id);
	
	// Tymczasowa edycja
	AttachEdit[playerid][aUID] = 0;
	
	// Wyczyść sloty grup
	for (new slot = 0; slot < MAX_GROUP_SLOTS; slot++)
	{
		PlayerGroup[playerid][slot][gpUID] 		= 0;
		PlayerGroup[playerid][slot][gpID] 		= 0;

		PlayerGroup[playerid][slot][gpPerm]		= 0;

		PlayerGroup[playerid][slot][gpPayment]	= 0;
		PlayerGroup[playerid][slot][gpSkin]    	= 0;
		
		PlayerGroup[playerid][slot][gpDutyMinute]   =   0;
		PlayerGroup[playerid][slot][gpPay]          =   0;
		
		PlayerGroup[playerid][slot][gpTogG]     = false;
	}
	
	OfferData[playerid][oOffererID] 			= INVALID_PLAYER_ID;
	OfferData[playerid][oType] 					= 0;

	OfferData[playerid][oValue1] 				= 0;
	OfferData[playerid][oValue2] 				= 0;

	OfferData[playerid][oPrice] 				= 0;
	OfferData[playerid][oPayType] 				= PAY_TYPE_NONE;
	
	RaceInfo[playerid][rOwner]                  = INVALID_PLAYER_ID;
	RaceInfo[playerid][rStart]                  = 0;

	RaceInfo[playerid][rPoint]                  = 0;
	RaceInfo[playerid][rTime]                   = 0;
	
	RaceInfo[playerid][rPosition]               = 0;
	
	TD_CreateForPlayer(playerid);
	
	SetPlayerVirtualWorld(playerid, playerid + 1000);
	SetPlayerColor(playerid, PlayerCache[playerid][pNickColor]);
	
	SetPlayerTime(playerid, WorldTime, 0);
	
	// Odkryj ukryte tagi & ignorowanie
	for (new i = 0; i < MAX_PLAYERS; i++)
	{
		if(!Streamer_IsInArrayData(STREAMER_TYPE_3D_TEXT_LABEL, PlayerCache[i][pDescTag], E_STREAMER_PLAYER_ID, playerid))
		{
      		Streamer_AppendArrayData(STREAMER_TYPE_3D_TEXT_LABEL, PlayerCache[i][pDescTag], E_STREAMER_PLAYER_ID, playerid);
		}
	    
	    if(!Streamer_IsInArrayData(STREAMER_TYPE_3D_TEXT_LABEL, PlayerCache[i][pNameTag], E_STREAMER_PLAYER_ID, playerid))
	    {
	        Streamer_AppendArrayData(STREAMER_TYPE_3D_TEXT_LABEL, PlayerCache[i][pNameTag], E_STREAMER_PLAYER_ID, playerid);
	    }
	    
		PlayerCache[playerid][pIgnored][i] = false;
	}
	return 1;
}

public OnPlayerLogin(playerid)
{
	/*
	new ORM:orm_id = PlayerCache[playerid][pOrm];
	switch(orm_errno(orm_id))
	{
 		case ERROR_OK:
 		{
 		    new Cache:login_password, query[256], prefix[128];
 		    printf("OnPlayerLogin(errno_ok) - %d, %d, %s", PlayerCache[playerid][pUID], PlayerCache[playerid][pGID], PlayerCache[playerid][pCharName]);
 		    
 		    orm_apply_cache(orm_id, 0);
 		    
 		    orm_setkey(orm_id, "char_uid");
 		    orm_delvar(orm_id, "char_lastpay");
 		    
 		    format(query, sizeof(query), "SELECT `name`, `members_pass_hash`, `member_premium_time`, `member_game_points`, `member_game_admin_perm`, `member_group_id` FROM `core_members` WHERE member_id = '%d' LIMIT 1", PlayerCache[playerid][pGID]);
 			login_password = mysql_query(connHandle, query);
 			
 			cache_get_value_index(0, 0, PlayerCache[playerid][pGlobName], 256);
			cache_get_value_index(0, 1, PlayerCache[playerid][pPassword], 256);
			cache_get_value_index_int(0, 2, PlayerCache[playerid][pPremium]);
			cache_get_value_index_int(0, 3, PlayerCache[playerid][pPoints]);
			cache_get_value_index_int(0, 4, PlayerCache[playerid][pAdmin]);
			cache_get_value_index_int(0, 5, PlayerCache[playerid][pAdminType]);
			
            if(cache_is_valid(login_password))	cache_delete(login_password);
            
            if(PlayerCache[playerid][pAdmin] & A_PERM_BASIC)
            {
                new admin_type = PlayerCache[playerid][pAdminType];
                
            	format(query, sizeof(query), "SELECT `prefix` FROM `core_groups` WHERE g_id = '%d' LIMIT 1", admin_type);
				login_password = mysql_query(connHandle, query);

				cache_get_value_index(0, 0, prefix, 128);
				
				new pos = strfind(prefix, "#", false);
				strmid(AdminColor[admin_type], prefix, pos + 1, pos + 7, 10);
				
				if(cache_is_valid(login_password))	cache_delete(login_password);
			}
			
            PlayerCache[playerid][pSession][SESSION_LOGIN] = gettime();
			ShowPlayerDialog(playerid, D_LOGIN, DIALOG_STYLE_PASSWORD, "Panel logowania", "Witaj na "SERVER_NAME"!\n\nWprowadź poniżej hasło do postaci, by rozpocząć grę na naszym serwerze.\nUpewnij się, że postać została założona na naszej stronie "WEB_URL".", "Zaloguj", "Wyjdź");

		}
 	 	case ERROR_NO_DATA:
  		{
  		    printf("OnPlayerLogin(errno_no) - %d, %d, %s", PlayerCache[playerid][pUID], PlayerCache[playerid][pGID], PlayerCache[playerid][pCharName]);
  		    
            ShowPlayerDialog(playerid, D_LOGIN, DIALOG_STYLE_PASSWORD, "Panel logowania", "Witaj na "SERVER_NAME"!\n\nWprowadź poniżej hasło do postaci, by rozpocząć grę na naszym serwerze.\nUpewnij się, że postać została założona na naszej stronie "WEB_URL".", "Zaloguj", "Wyjdź");
            TD_ShowSmallInfo(playerid, 5, "Postac ~r~nie istnieje ~w~lub wprowadzone haslo jest nieprawidlowe.");
		}
	}
	*/
	new ORM:orm_id = PlayerCache[playerid][pOrm];
	switch(orm_errno(orm_id))
	{
	    case ERROR_OK:
	    {
	 		new string[256];
	 		/*
			LoadPlayerBans(playerid);

			// Jeśli zbanowany
			if(PlayerCache[playerid][pBanned])
			{
			    return 1;
			}
			*/

			// Jeśli zablokowane konto
			if(PlayerCache[playerid][pBlock] & BLOCK_CHAR)
			{
		 		ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Ta postać została zablokowana, powód znajdziesz w panelu na stronie.\nZałóż nową lub ubiegaj się o odblokowanie poprzedniej.");
			    defer OnKickPlayer(playerid);
			    return 1;
			}

			/*
			// Epizod
			if(!PlayerCache[playerid][pEpisode])
			{
				ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Aktualnie trwa Epizod Palomino Creek. Nie możesz zalogować się na tą postać.\nStwórz nową postać specjalnie pod grę w trakcie trwania epizodu.\n\nWejdź na "WEB_URL", by poznać szczegóły.");
			    defer OnKickPlayer(playerid);
				return 1;
			}
			*/

			if(IsPlayerPremium(playerid))
		 	{
				SetPlayerColor(playerid, COLOR_NICK_PACC);
				TextDrawShowForPlayer(playerid, TextDrawPremium);
			}
			else
			{
				SetPlayerColor(playerid, COLOR_NICK);
			}

			SetPlayerScore(playerid, PlayerCache[playerid][pPoints]);
		    PlayerCache[playerid][pNickColor] = (COLOR_NICK & ~0xFF) | clamp(0x88, 0x00, 0xFF);

			format(string, sizeof(string), "%s (%d)", PlayerName(playerid), playerid);
			UpdateDynamic3DTextLabelText(Text3D:PlayerCache[playerid][pNameTag], PlayerCache[playerid][pNickColor], string);

			Streamer_SetIntData(STREAMER_TYPE_3D_TEXT_LABEL, Text3D:PlayerCache[playerid][pNameTag], E_STREAMER_ATTACHED_PLAYER, playerid);

			Streamer_SetFloatData(STREAMER_TYPE_3D_TEXT_LABEL, Text3D:PlayerCache[playerid][pNameTag], E_STREAMER_Z, 0.15);
			Streamer_SetFloatData(STREAMER_TYPE_3D_TEXT_LABEL, Text3D:PlayerCache[playerid][pNameTag], E_STREAMER_DRAW_DISTANCE, 15.0);

			UpdateDynamic3DTextLabelText(Text3D:PlayerCache[playerid][pDescTag], COLOR_PURPLE, " ");

			Streamer_SetIntData(STREAMER_TYPE_3D_TEXT_LABEL, Text3D:PlayerCache[playerid][pDescTag], E_STREAMER_ATTACHED_PLAYER, playerid);
			Streamer_SetFloatData(STREAMER_TYPE_3D_TEXT_LABEL, Text3D:PlayerCache[playerid][pDescTag], E_STREAMER_DRAW_DISTANCE, 10.0);

			UpdateDynamic3DTextLabelText(Text3D:PlayerCache[playerid][vDescTag], COLOR_PURPLE, " ");

			Streamer_SetIntData(STREAMER_TYPE_3D_TEXT_LABEL, Text3D:PlayerCache[playerid][vDescTag], E_STREAMER_ATTACHED_PLAYER, playerid);
			Streamer_SetFloatData(STREAMER_TYPE_3D_TEXT_LABEL, Text3D:PlayerCache[playerid][vDescTag], E_STREAMER_DRAW_DISTANCE, 10.0);

		    ResetPlayerWeaponsEx(playerid);

			SetPlayerFightingStyle(playerid, PlayerCache[playerid][pFightStyle]);
			for(new w = 0; w < 10; w++)	SetPlayerSkillLevel(playerid, w, (w == 0 || w == 4 || w == 5 || w == 6) ? 1 : 999);

		    LoadPlayerGroups(playerid);
			LoadPlayerItems(playerid);

	        EnablePlayerCameraTarget(playerid, true);

			TextDrawShowForPlayer(playerid, Text:TextDrawServerLogo);
			TextDrawShowForPlayer(playerid, Text:TextDrawMainLogo);
			TextDrawShowForPlayer(playerid, Text:TextDrawNews);

		    ClearPlayerChat(playerid);
			SendClientFormatMessage(playerid, COLOR_WHITE, "Witaj, {AFAFAF}%s (GID: %d){FFFFFF}. Zostałeś zalogowany na postać {AFAFAF}%s (UID: %d){FFFFFF}. Życzymy miłej gry!", PlayerCache[playerid][pGlobName], PlayerCache[playerid][pGID], PlayerName(playerid), PlayerCache[playerid][pUID]);
			TD_ShowHint(playerid, HINT_INTRO, 0, "Witaj ~y~%s ~w~na "SERVER_NAME"! To okno bedzie informowac Cie o wszystkich mozliwosciach naszego skryptu - wszystko krok po kroku.~n~~n~Serwer bedzie sprawdzal kazda Twoja ~p~akcje ~w~i dostosuje do niej odpowiednia tresc, by wyjasnic Ci jak dziala okreslony ~y~element ~w~gry.~n~~n~Wcisnij teraz klawisz ~r~N~w~, by zamknac to okno i zobaczyc jak bedzie to wygladac w praktyce.", PlayerCache[playerid][pGlobName]);

			TogglePlayerSpectating(playerid, false);
			SetSpawnInfo(playerid, 0, 0, 0.0, 0.0, 0.0, 0.0, 0, 0, 0, 0, 0, 0);

			SpawnPlayer(playerid);
		    PlayerCache[playerid][pLogged] = true;

			PlayerCache[playerid][pSession][SESSION_LOGIN] 	= 0;
			PlayerCache[playerid][pSession][SESSION_GAME] 	= gettime();

			PlayerCache[playerid][pAFK] = -3;

			//gpci(playerid, string, sizeof(string));
		 	printf("[part] %s (UID: %d, GID: %d, SERIAL: %s) zalogował się pomyślnie (%d/3).", PlayerRealName(playerid), PlayerCache[playerid][pUID], PlayerCache[playerid][pGID], string, PlayerCache[playerid][pLogTries]);

			mysql_format(connHandle, string, sizeof(string), "INSERT INTO `"SQL_PREF"logged_players` VALUES ('%d', '%d', '%d')", PlayerCache[playerid][pUID], PlayerCache[playerid][pGID], PlayerCache[playerid][pSession][SESSION_GAME]);
	        mysql_query(connHandle, string);
		}
		case ERROR_NO_DATA:
		{
			print("Coś nie tak!!");
		}
	}
	return 1;
}

public OnPlayerPasswordHashed(playerid)
{
	new hash[BCRYPT_HASH_LENGTH];
	bcrypt_get_hash(hash);
	
	mysql_query_format("INSERT INTO `core_members` (name, members_pass_hash) VALUES ('%s', '%s')", PlayerName(playerid), hash);
	PlayerCache[playerid][pGID] = cache_insert_id();
	
	// Wywołujemy OnPlayerFinishedDownloading
	SetPlayerVirtualWorld(playerid, PlayerCache[playerid][pGID]);
	return 1;
}

public OnPlayerPasswordChecked(playerid)
{
	new bool:match = bcrypt_is_equal();
	
	if(match == true)
	{
	    // Wyświetl jego postacie
	    new list_characters[512];
	    mysql_query_format("SELECT `char_uid`, `char_name`, `char_hours`, `char_minutes` FROM `ipb_characters` WHERE char_gid = '%d'", PlayerCache[playerid][pGID]);
	    
	    new rows, char_uid, char_name[32], char_hours, char_minutes;
	    format(list_characters, sizeof(list_characters), "Identyfikator\tImię i nazwisko\tCzas gry");
	    
	    DynamicGui_Init(playerid);
	    
		cache_get_row_count(rows);
		for(new row = 0; row < rows; row++)
		{
		    cache_get_value_index_int(row, 0, char_uid);
		    cache_get_value_index(row, 1, char_name, 32);
		    
		    cache_get_value_index_int(row, 2, char_hours);
		    cache_get_value_index_int(row, 3, char_minutes);
		    
			format(list_characters, sizeof(list_characters), "%s\n%d\t%s\t%dh %dm", list_characters, char_uid, char_name, char_hours, char_minutes);
			DynamicGui_AddRow(playerid, D_NONE, char_uid);
		}

		format(list_characters, sizeof(list_characters), "%s\n{FF0000}#\t{FF0000}Stwórz nową postać\t*", list_characters);
		DynamicGui_AddRow(playerid, D_NONE, -1);
		
		ShowPlayerDialog(playerid, D_CHAR_SELECT, DIALOG_STYLE_TABLIST_HEADERS, "Lista Twoich postaci", list_characters, "Wybierz", "Wyjdź");
	    
	}
	else
	{
	    new string[256];
	    
 		format(string, sizeof(string), "Wprowadź poniżej hasło do konta %s (GID: %d).\n\nJeśli konto nie należy do Ciebie, oznacza to\n, że takie już istnieje i nie możesz stworzyć nowego o tej nazwie.\nJeśli chcesz założyć nowe konto, wyjdź z gry i wprowadź inny nick w okno SAMP.", PlayerName(playerid), PlayerCache[playerid][pGID]);
	    ShowPlayerDialog(playerid, D_LOGIN, DIALOG_STYLE_PASSWORD, "Logowanie", string, "Dalej", "Wyjdź");
	    
	    TD_ShowSmallInfo(playerid, 5, "Wprowadzone haslo jest ~r~nieprawidlowe~w~.");
	}
	
	/*
	printf("OnPlayerPasswordChecked - %d, %d, %s", PlayerCache[playerid][pUID], PlayerCache[playerid][pGID], PlayerCache[playerid][pCharName]);
	
	if(match == true)
	{

	}
	else
	{
 		ShowPlayerDialog(playerid, D_LOGIN, DIALOG_STYLE_PASSWORD, "Panel logowania", "Witaj na "SERVER_NAME"!\n\nWprowadź poniżej hasło do postaci, by rozpocząć grę na naszym serwerze.\nUpewnij się, że postać została założona na naszej stronie "WEB_URL".", "Zaloguj", "Wyjdź");
 		TD_ShowSmallInfo(playerid, 5, "Postac ~r~nie istnieje ~w~lub wprowadzone haslo jest nieprawidlowe.");
	}
	*/
	return 1;
}

public OnPlayerDisconnect(playerid, reason)
{
    ResetPlayerWeaponsEx(playerid);
	if(!PlayerCache[playerid][pLogged])
	{
	    return 1;
	}
	
	new string[256], virtual_world, interior_id,
		Float:PosX, Float:PosY, Float:PosZ;
		
	GetPlayerPos(playerid, PosX, PosY, PosZ);
	
	virtual_world = GetPlayerVirtualWorld(playerid);
	interior_id = GetPlayerInterior(playerid);
	
	switch(reason)
	{
	    case 0:
	    {
	    	format(string, sizeof(string), "(( %s - timeout ))", PlayerRealName(playerid));
			GetPlayerPos(playerid, PlayerCache[playerid][pPosX], PlayerCache[playerid][pPosY], PlayerCache[playerid][pPosZ]);

			PlayerCache[playerid][pVirtualWorld] = GetPlayerVirtualWorld(playerid);
			PlayerCache[playerid][pInteriorID] = GetPlayerInterior(playerid);

			PlayerCache[playerid][pCrash] = gettime();
			orm_update(PlayerCache[playerid][pOrm]);
			
			// Crash po zbugowanym obiekcie
			if(PlayerCache[playerid][pLastObject] != INVALID_OBJECT_ID)	DeleteObject(PlayerCache[playerid][pLastObject]);
	    }
	    case 1: format(string, sizeof(string), "(( %s - /q ))", PlayerRealName(playerid));
	}
	
	new Text3D:reason_label = CreateDynamic3DTextLabel(string, 0xB4B5B788, PosX, PosY, PosZ + 0.3, 15.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 0, virtual_world, interior_id);
	defer OnDestroyReasonLabel[15000](_:reason_label);
	
	foreach(new i : Player)
	{
	    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	    {
     		// Oferta
	        if(OfferData[i][oOffererID] == playerid)
	        {
	            OnPlayerRejectOffer(playerid, i);
	        }
	        
	        // Jeśli skuty
	        if(PlayerCache[i][pCuffedTo] == playerid)
	        {
	            PlayerCache[i][pCuffedTo] = INVALID_PLAYER_ID;
	        }
	        
	        // Jeśli rozmawia
	        if(PlayerCache[i][pCallingTo] == playerid)
	        {
      			PlayerCache[i][pCallingTo] = INVALID_PLAYER_ID;

				SetPlayerSpecialAction(i, SPECIAL_ACTION_STOPUSECELLPHONE);
				RemovePlayerAttachedObject(i, SLOT_PHONE);

				SendClientMessage(i, COLOR_YELLOW, "Rozmowa została pomyślnie zakończona.");
	        }
	        
	        // Kierowca taxi
	        if(PlayerCache[playerid][pTaxiPassenger] == i)
	        {
				new price = PlayerCache[i][pTaxiPay];
				if(price > 0 && PlayerCache[i][pCash] >= price)
				{
 					new group_cash = floatround(0.90 * price),
						playercash = floatround(0.10 * price);

		    		crp_GivePlayerMoney(i, -price);
		      		crp_GivePlayerMoney(playerid, playercash);

					new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];

		   			GroupData[group_id][gCash] += group_cash;
					orm_update(GroupData[group_id][gOrm]);
				}
	        }
	    }
	}
	
	new doorid = GetPlayerDoorID(playerid);
	if(doorid == INVALID_DOOR_ID)
	{
		new	Float:DoorDistance,
			Float:LastDistance = 8000.0, DoorData[sDoorInfo];
			
		for (new door = 0; door < Streamer_GetUpperBound(STREAMER_TYPE_PICKUP); door++)
		{
		    if(IsValidDynamicPickup(door))
		    {
		        Streamer_GetArrayData(STREAMER_TYPE_PICKUP, door, E_STREAMER_EXTRA_ID, DoorData);
	  			if((DoorData[dOwnerType] == OWNER_PLAYER && DoorData[dOwner] == PlayerCache[playerid][pUID]))
	  			{
	  			    Streamer_GetDistanceToItem(PosX, PosY, PosZ, STREAMER_TYPE_PICKUP, door, DoorDistance);

					if((DoorDistance < LastDistance))
					{
						LastDistance = DoorDistance;
						PlayerCache[playerid][pHouse] = DoorData[dUID];
					}
				}
				else if(DoorData[dOwnerType] == OWNER_GROUP)
				{
				    if(IsPlayerInGroup(playerid, DoorData[dOwner]))
				    {
				        if((GroupData[GetPlayerGroupID(playerid, DoorData[dOwner])][gFlags] & G_FLAG_SPAWN) && (PlayerGroup[playerid][GetPlayerGroupSlot(playerid, DoorData[dOwner])][gpPerm] & G_PERM_DOORS))
						{
			   				Streamer_GetDistanceToItem(PosX, PosY, PosZ, STREAMER_TYPE_PICKUP, door, DoorDistance);

							if((DoorDistance < LastDistance))
							{
								LastDistance = DoorDistance;
								PlayerCache[playerid][pHouse] = DoorData[dUID];
							}
						}
				    }
				}
			}
		}
	}
	else
	{
	    new DoorData[sDoorInfo];
	    Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	    
		if((DoorData[dOwnerType] == OWNER_PLAYER && DoorData[dOwner] == PlayerCache[playerid][pUID]))
		{
			PlayerCache[playerid][pHouse] = DoorData[dUID];
		}
		else if(DoorData[dOwnerType] == OWNER_GROUP)
		{
  			if(IsPlayerInGroup(playerid, DoorData[dOwner]))
	    	{
				if((GroupData[GetPlayerGroupID(playerid, DoorData[dOwner])][gFlags] & G_FLAG_SPAWN) && (PlayerGroup[playerid][GetPlayerGroupSlot(playerid, DoorData[dOwner])][gpPerm] & G_PERM_DOORS))
				{
    				PlayerCache[playerid][pHouse] = DoorData[dUID];
				}
    		}
		}
	}
	
	// Ostatni pojazd
	if(PlayerCache[playerid][pLastVeh] != INVALID_VEHICLE_ID)
	{
	    new vehid = PlayerCache[playerid][pLastVeh];
	    if(Iter_Contains(Vehicles, vehid))
	    {
	        new driverid = GetVehicleDriver(vehid);
		    if(driverid == INVALID_PLAYER_ID || driverid == playerid)
		    {
				CarInfo[vehid][cLocked] = true;
	  			SetVehicleLock(vehid, CarInfo[vehid][cLocked]);

                CarInfo[vehid][cLastUsing] = gettime();
				ChangeVehicleEngineStatus(vehid, false);
		    }
			orm_update(CarInfo[vehid][cOrm]);
		}
 	}
 	
 	// Pasażer w taxi
 	if(PlayerCache[playerid][pTaxiVeh] != INVALID_VEHICLE_ID)
 	{
		new driverid = GetVehicleDriver(PlayerCache[playerid][pTaxiVeh]),
			price = PlayerCache[playerid][pTaxiPay];

		if(price > 0 && PlayerCache[playerid][pCash] >= price)
  		{
  			new group_cash = floatround(0.90 * price),
				playercash = floatround(0.10 * price);

    		crp_GivePlayerMoney(playerid, -price);
      		crp_GivePlayerMoney(driverid, playercash);

			new group_id = PlayerCache[driverid][pDuty][DUTY_GROUP];

   			GroupData[group_id][gCash] += group_cash;
			orm_update(GroupData[group_id][gOrm]);

			ShowPlayerInfoDialog(driverid, D_TYPE_INFO, "Otrzymałeś premię w wysokości $%d!\nNa konto grupy dodano: $%d", playercash, group_cash);
		}
		
		PlayerCache[driverid][pTaxiPassenger] = INVALID_PLAYER_ID;
 	}
 	
	// Zakończ transmisje na żywo
	if(PlayerCache[playerid][pRadioLive])	TextDrawSetString(Text:TextDrawNews, "~y~~h~LSN ~w~~>~ Brak sygnalu nadawania.");

	// Zakończ wywiad
	if(PlayerCache[playerid][pRadioInterview] != INVALID_PLAYER_ID)
	{
	    new interviewer_id = PlayerCache[playerid][pRadioInterview];
		PlayerCache[interviewer_id][pRadioInterview] = INVALID_PLAYER_ID;
		
		TextDrawSetString(Text:TextDrawNews, "~y~~h~LSN ~w~~>~ Brak sygnalu nadawania.");
		ShowPlayerInfoDialog(interviewer_id, D_TYPE_INFO, "Wywiad został zakończony.");
	}
	
	// 3dTekst naprawy
	if(PlayerCache[playerid][pRepairVeh] != INVALID_VEHICLE_ID)
	{
	    DestroyDynamic3DTextLabel(Text3D:PlayerCache[playerid][pRepairTag]);
	}
	
	// 3dTekst lakierowania
	if(PlayerCache[playerid][pSprayVeh] != INVALID_VEHICLE_ID)
	{
	    DestroyDynamic3DTextLabel(Text3D:PlayerCache[playerid][pSprayTag]);
	}
 	
 	// Zapisz amunicję
 	if(PlayerCache[playerid][pItemWeapon] != INVALID_ITEM_ID)
 	{
		new itemid = PlayerCache[playerid][pItemWeapon];
		PlayerItemCache[playerid][itemid][iUsed] = false;
		
		orm_update(PlayerItemCache[playerid][itemid][iOrm]);
 	}
 	
 	// Zapisz karnet
 	if(PlayerCache[playerid][pItemPass] != INVALID_ITEM_ID)
 	{
 	    new itemid = PlayerCache[playerid][pItemPass];
 	    PlayerItemCache[playerid][itemid][iValue][0] = PlayerCache[playerid][pGymTime] / 60;
 	    
 	    orm_update(PlayerItemCache[playerid][itemid][iOrm]);
 	}
 	
 	// Maska
 	if(PlayerCache[playerid][pItemMask] != INVALID_ITEM_ID)
 	{
 	    new itemid = PlayerCache[playerid][pItemMask];
		PlayerItemCache[playerid][itemid][iValue][0] --;
		
		if(PlayerItemCache[playerid][itemid][iValue][0] > 0)	orm_update(PlayerItemCache[playerid][itemid][iOrm]);
		else													DeletePlayerItem(playerid, itemid);
 	}
 	
 	// Rękawiczki
 	if(PlayerCache[playerid][pItemGloves] != INVALID_ITEM_ID)
 	{
 	    new itemid = PlayerCache[playerid][pItemGloves];
		PlayerItemCache[playerid][itemid][iValue][0] --;

		if(PlayerItemCache[playerid][itemid][iValue][0] > 0)	orm_update(PlayerItemCache[playerid][itemid][iOrm]);
		else													DeletePlayerItem(playerid, itemid);
 	}
 	
 	// Boombox
 	if(PlayerCache[playerid][pItemBoombox] != INVALID_ITEM_ID)
 	{
		new areaid = GetPlayerAreaID(playerid);
		foreach(new i : Player)
		{
			if(i != playerid)
   			{
				if(GetPlayerAreaID(i) == areaid)
				{
	   				//Audio_Stop(i, PlayerCache[playerid][pAudioHandle]);
				    PlayerCache[i][pAudioHandle] = 0;
				}
			}
		}
		new AreaData[sAreaData];
		Streamer_GetArrayData(STREAMER_TYPE_AREA, areaid, E_STREAMER_EXTRA_ID, AreaData);
		
		strmid(AreaData[aAudioURL], "", 0, 0, 128);
		Streamer_SetArrayData(STREAMER_TYPE_AREA, areaid, E_STREAMER_EXTRA_ID, AreaData);
 	}
 	
 	// Kosz
 	if(PlayerCache[playerid][pBasketObject] != INVALID_OBJECT_ID)
 	{
 	    new object_id = PlayerCache[playerid][pBasketBall];
 	    DestroyDynamicObject(object_id);
 	}
 	
  	// Zadanie
  	if(MissionData[playerid][mUID] != 0)
   	{
    	if(MissionData[playerid][mLeader])
   		{
     		foreach(new i : MissionPlayer[playerid])
       		{
         		TD_ShowHint(i, HINT_NONE, 10, "Lider grupy wykonujacej zadanie ~r~wyszedl z gry~w~. Zadanie ~r~nie zostalo ~w~wykonanie prawidlowo.");
           	}
			DeleteMission(MissionData[playerid][mUID]);
   		}
   		else
   		{
   		    new mission_leader = GetMissionLeader(MissionData[playerid][mUID]);
   		    Iter_Remove(MissionPlayer[mission_leader], playerid);
   		}
   	}

	mysql_format(connHandle, string, sizeof(string),  "DELETE FROM `"SQL_PREF"logged_players` WHERE char_uid = '%d'", PlayerCache[playerid][pUID]);
    mysql_query(connHandle, string);

 	UnloadPlayerItems(playerid);

	// Aktualizuj sesje
	if(PlayerCache[playerid][pDuty][DUTY_ADMIN])
	{
	    UpdatePlayerSession(playerid, SESSION_ADMIN, 0);
	}
	
	if(PlayerCache[playerid][pDuty][DUTY_GROUP] != INVALID_GROUP_ID)
	{
		new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
	    UpdatePlayerSession(playerid, SESSION_GROUP, GroupData[group_id][gUID]);
	}
	
	UpdatePlayerSession(playerid, SESSION_GAME, PlayerCache[playerid][pSession][SESSION_AFK]);
	
	orm_update(PlayerCache[playerid][pOrm]);
	orm_destroy(PlayerCache[playerid][pOrm]);
	return 1;
}

public OnPlayerSpawn(playerid)
{
	if(PlayerCache[playerid][pCreatingChar])
	{
	    return 1;
	}
	if(!PlayerCache[playerid][pLogged])
	{
		Kick(playerid);
	    return 1;
	}
	SetPlayerTime(playerid, WorldTime, 0);
	
	SetPlayerSpawn(playerid);
	LoadPlayerAccess(playerid);

	ResetPlayerWeaponsEx(playerid);
	PreloadPlayerAnimLib(playerid);
	return 1;
}

public SetPlayerSpawn(playerid)
{
	SetPlayerMoney(playerid, PlayerCache[playerid][pCash]);
	SetPlayerHealth(playerid, PlayerCache[playerid][pHealth]);
	
	SetPlayerSkin(playerid, (PlayerCache[playerid][pLastSkin] != 0) ? PlayerCache[playerid][pLastSkin] : PlayerCache[playerid][pSkin]);
	
	// Wczytaj obiekty drzwi
	if(PlayerCache[playerid][pVirtualWorld] != 0)
	{
		new doorid = GetDoorID(PlayerCache[playerid][pVirtualWorld]);
		if(doorid != INVALID_DOOR_ID)
		{
			new DoorData[sDoorInfo];
			Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
			
			if(DoorData[dExitVW] != 0 && !DoorData[dObjectsLoaded] && DoorData[dExitVW] != Streamer_GetIntData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_WORLD_ID))
			{
				new query[512];
				mysql_format(connHandle, query, sizeof(query), "SELECT "SQL_PREF"objects.*, "SQL_PREF"materials.material_texture FROM "SQL_PREF"objects LEFT JOIN "SQL_PREF"materials on "SQL_PREF"objects.object_uid = "SQL_PREF"materials.material_owner WHERE "SQL_PREF"objects.object_world = '%d' ORDER BY "SQL_PREF"objects.object_uid ASC", DoorData[dExitVW]);
		 		mysql_tquery(connHandle, query, "query_OnLoadObjects", "");

				DoorData[dObjectsLoaded] = true;
				Streamer_SetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
			}
		}
	}
	
	// Podgląd
	if(PlayerCache[playerid][pSpectate] != INVALID_PLAYER_ID)
	{
	    TogglePlayerSpectating(playerid, false);
		crp_SetPlayerPos(playerid, PlayerCache[playerid][pPosX], PlayerCache[playerid][pPosY], PlayerCache[playerid][pPosZ]);

		SetPlayerVirtualWorld(playerid, PlayerCache[playerid][pVirtualWorld]);
		SetPlayerInterior(playerid, PlayerCache[playerid][pInteriorID]);

		ResetPlayerCamera(playerid);
		OnPlayerFreeze(playerid, true, 3);

		PlayerCache[playerid][pSpectate] = INVALID_PLAYER_ID;
		
		TD_ShowSmallInfo(playerid, 3, "Podglad gracza zostal ~r~anulowany~w~.");
		TD_HideLargeInfo(playerid);
	    return 1;
	}
	
	// AdminJail
	if(PlayerCache[playerid][pAJ])
	{
		crp_SetPlayerPos(playerid, PosInfo[ADMIN_JAIL_POS][sPosX], PosInfo[ADMIN_JAIL_POS][sPosY], PosInfo[ADMIN_JAIL_POS][sPosZ]);

		SetPlayerInterior(playerid, PosInfo[ADMIN_JAIL_POS][sPosInterior]);
		SetPlayerVirtualWorld(playerid, playerid + 1000);
		
		ResetPlayerCamera(playerid);
	    return 1;
	}
	
	// BrutallyWounded
	if(PlayerCache[playerid][pBW] != 0)
	{
		crp_SetPlayerPos(playerid, PlayerCache[playerid][pPosX], PlayerCache[playerid][pPosY], PlayerCache[playerid][pPosZ] - 0.25);
		ApplyAnimation(playerid, "PED", "FLOOR_hit", 4.1, 0, 1, 1, 1, 1, true);
		
		SetPlayerVirtualWorld(playerid, PlayerCache[playerid][pVirtualWorld]);
		SetPlayerInterior(playerid, PlayerCache[playerid][pInteriorID]);
		
		OnPlayerFreeze(playerid, true, 0);

		SetPlayerCameraPos(playerid, PlayerCache[playerid][pPosX] + 3, PlayerCache[playerid][pPosY] + 4, PlayerCache[playerid][pPosZ] + 7);
		SetPlayerCameraLookAt(playerid, PlayerCache[playerid][pPosX], PlayerCache[playerid][pPosY], PlayerCache[playerid][pPosZ], CAMERA_CUT);
		return 1;
	}

	// Przywracanie pozycji
	if(PlayerCache[playerid][pCrash] != 0)
	{
	    if(PlayerCache[playerid][pCrash] + 600 <= gettime())
	    {
	        PlayerCache[playerid][pCrash] = 0;
	        TD_ShowSmallInfo(playerid, 10, "Minelo ponad ~r~10 minut ~w~od ostatniego zapisania pozycji. Zostales ~y~przywrocony ~w~na spawn wlasciwy.");
	        
	        SetPlayerSpawn(playerid);
	        return 1;
	    }
 		crp_SetPlayerPos(playerid, PlayerCache[playerid][pPosX], PlayerCache[playerid][pPosY], PlayerCache[playerid][pPosZ]);

		SetPlayerVirtualWorld(playerid, PlayerCache[playerid][pVirtualWorld]);
		SetPlayerInterior(playerid, PlayerCache[playerid][pInteriorID]);
		
		PlayerCache[playerid][pCrash] = 0;
		OnPlayerFreeze(playerid, true, 3);
		
		ResetPlayerCamera(playerid);
		return 1;
	}
	
	// Areszt
	if(PlayerCache[playerid][pArrest] != 0)
	{
	    if(PlayerCache[playerid][pArrest] <= gettime())
	    {
	        PlayerCache[playerid][pArrest] = 0;
	        TD_ShowSmallInfo(playerid, 10, "Odsiadka w ~r~areszcie ~w~dobiegla konca. Zostales ~y~przywrocony ~w~na spawn wlasciwy.");
	        
	        SetPlayerSpawn(playerid);
	        return 1;
	    }
   		crp_SetPlayerPos(playerid, PlayerCache[playerid][pPosX], PlayerCache[playerid][pPosY], PlayerCache[playerid][pPosZ]);

		SetPlayerVirtualWorld(playerid, PlayerCache[playerid][pVirtualWorld]);
		SetPlayerInterior(playerid, PlayerCache[playerid][pInteriorID]);

        OnPlayerFreeze(playerid, true, 3);
		ResetPlayerCamera(playerid);
		
		new	arrest_hours = floatround((PlayerCache[playerid][pArrest] - gettime()) / 3600, floatround_floor),
		    arrest_minutes = floatround((PlayerCache[playerid][pArrest] - gettime()) / 60, floatround_floor) % 60;
		    
		TD_ShowSmallInfo(playerid, 10, "Powracasz ~r~do punktu ~w~aresztowania!~n~Pozostalo: ~y~%d ~w~godz. ~y~%d ~w~min.", arrest_hours, arrest_minutes);
	    return 1;
	}
	
	// Spawn w domu/hotelu
	if(PlayerCache[playerid][pHouse])
	{
	    new doorid = GetDoorID(PlayerCache[playerid][pHouse]);
	    if(doorid != INVALID_DOOR_ID)
	    {
			new DoorData[sDoorInfo];
			Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
			
			if(DoorData[dExitVW] != 0 && !DoorData[dObjectsLoaded] && DoorData[dExitVW] != Streamer_GetIntData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_WORLD_ID))
			{
				new query[512];
				mysql_format(connHandle, query, sizeof(query), "SELECT "SQL_PREF"objects.*, "SQL_PREF"materials.material_texture FROM "SQL_PREF"objects LEFT JOIN "SQL_PREF"materials on "SQL_PREF"objects.object_uid = "SQL_PREF"materials.material_owner WHERE "SQL_PREF"objects.object_world = '%d' ORDER BY "SQL_PREF"objects.object_uid ASC", DoorData[dExitVW]);
		 		mysql_tquery(connHandle, query, "query_OnLoadObjects", "");

				DoorData[dObjectsLoaded] = true;
				Streamer_SetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
			}
			
	        if(DoorData[dOwnerType] == OWNER_GROUP)
	        {
	        	new group_id = GetGroupID(DoorData[dOwner]);
		        if(GroupData[group_id][gType] == G_TYPE_HOTEL)
		        {
          			crp_SetPlayerPos(playerid, PosInfo[HOTEL_SPAWN_POS][sPosX], PosInfo[HOTEL_SPAWN_POS][sPosY], PosInfo[HOTEL_SPAWN_POS][sPosZ]);
          			SetPlayerFacingAngle(playerid, PosInfo[HOTEL_SPAWN_POS][sPosA]);
          			
          			SetPlayerInterior(playerid, PosInfo[HOTEL_SPAWN_POS][sPosInterior]);
          			SetPlayerVirtualWorld(playerid, PlayerCache[playerid][pUID]);
          			
          			ResetPlayerCamera(playerid);
          			TD_ShowSmallInfo(playerid, 5, "Uzyj komendy ~y~/pokoj wyjdz~w~, aby opuscic pokoj.");
          			return 1;
		        }
		        
		        if(!IsPlayerInGroup(playerid, DoorData[dOwner]) || !(GroupData[group_id][gFlags] & G_FLAG_SPAWN) || !(PlayerGroup[playerid][GetPlayerGroupSlot(playerid, DoorData[dOwner])][gpPerm] & G_PERM_DOORS))
		        {
		            PlayerCache[playerid][pHouse] = 0;
		            SetPlayerSpawn(playerid);
		  			return 1;
		        }
			}
			
			crp_SetPlayerPos(playerid, DoorData[dExitX], DoorData[dExitY], DoorData[dExitZ]);

			SetPlayerVirtualWorld(playerid, DoorData[dExitVW]);
			SetPlayerInterior(playerid, DoorData[dExitInt]);

			OnPlayerFreeze(playerid, true, 3);
			ResetPlayerCamera(playerid);
			return 1;
		}
		else
		{
		    PlayerCache[playerid][pHouse] = 0;
		    SetPlayerSpawn(playerid);
		}
	    return 1;
	}
	
	crp_SetPlayerPos(playerid, PosInfo[MAIN_SPAWN_POS][sPosX], PosInfo[MAIN_SPAWN_POS][sPosY], PosInfo[MAIN_SPAWN_POS][sPosZ]);
	SetPlayerFacingAngle(playerid, PosInfo[MAIN_SPAWN_POS][sPosA]);
	
	SetPlayerInterior(playerid, PosInfo[MAIN_SPAWN_POS][sPosInterior]);
	SetPlayerVirtualWorld(playerid, PosInfo[MAIN_SPAWN_POS][sPosVirtualWorld]);
	
	ResetPlayerCamera(playerid);
	
	if(PlayerCache[playerid][pEpisode])
	{
	
	}
	else
	{
		ShowPlayerDialog(playerid, D_INTRO, DIALOG_STYLE_MSGBOX, "Wprowadzenie (1/2)", "Witaj na serwerze "SERVER_NAME"!\n\nNa sam początek zalecane jest zapoznanie się z komendą /pomoc,\ndowiesz się tam wielu ciekawych rzeczy związanych z tutejszą rozgrywką.\n\nJak widać, pojawiłeś się na Unity Station, aby jednak dostać\nsię do Urzędu będziesz musiał wykorzystać autobus, bądź taksówkę.", "Dalej", "Zamknij");
	}
	return 1;
}

public OnPlayerDeath(playerid, killerid, reason)
{
	if(killerid != INVALID_PLAYER_ID)
	{
	    if(PlayerCache[killerid][pHours] >= 10)
	    {
	    	PlayerCache[playerid][pBW] = 10 * 60;
		}
		else
		{
		    PlayerCache[playerid][pBW] = 5 * 60;
		}
		
		new killer_uid, weapon_uid;
		
		killer_uid = (PlayerCache[killerid][pItemGloves] == INVALID_ITEM_ID) ? PlayerCache[killerid][pUID] : 0;
		weapon_uid = (PlayerCache[killerid][pItemWeapon] != INVALID_ITEM_ID) ? PlayerItemCache[killerid][PlayerCache[killerid][pItemWeapon]][iUID] : 0;

		PlayerCache[playerid][pDeathKiller] = killer_uid;
		PlayerCache[playerid][pDeathWeapon] = weapon_uid;

		PlayerCache[playerid][pDeathType] 	= (weapon_uid != 0) ? DEATH_SHOOTING : DEATH_BEATING;
		
		// Zadanie
		if(MissionData[killerid][mUID] != 0)
		{
		    if(MissionData[killerid][mType] == MISSION_CHASE)
		    {
		        if(MissionData[killerid][mVictim] == PlayerCache[playerid][pUID])
		        {
					new mission_leader = GetMissionLeader(MissionData[killerid][mUID]), group_id = MissionData[killerid][mGroup];
					foreach(new i : MissionPlayer[mission_leader])
					{
						TD_ShowHint(i, HINT_NONE, 10, "Zadanie zostalo wykonane ~g~pomyslnie~w~.Na konto grupy ~y~%s (UID: %d) ~w~dodano ~g~%d", GroupData[group_id][gName], GroupData[group_id][gUID], MissionData[killerid][mAward]);
					}
					GroupData[group_id][gCash] += MissionData[killerid][mAward];
					orm_update(GroupData[group_id][gOrm]);
					
					DeleteMission(MissionData[killerid][mUID]);
		        }
		    }
		}
		
		// Jeśli lider zadania "zginie"
		if(MissionData[playerid][mUID] != 0)
		{
		    if(MissionData[playerid][mLeader])
			{
				foreach(new i : MissionPlayer[playerid])
				{
				    TD_ShowHint(i, HINT_NONE, 10, "Lider grupy wykonujacej zadanie zostal ~r~obezwladniony~w~. Zadanie ~r~nie zostalo ~w~wykonanie prawidlowo.");
				}
				DeleteMission(MissionData[playerid][mUID]);
			}
		}
	}
	else
	{
	    PlayerCache[playerid][pBW] = 5 * 60;
	    
	    PlayerCache[playerid][pDeathKiller] = 0;
	    PlayerCache[playerid][pDeathWeapon] = 0;
	    
	    PlayerCache[playerid][pDeathType]   = DEATH_SUICIDE;
	}
	
	// Jeśli ma broń
	if(PlayerCache[playerid][pItemWeapon] != INVALID_ITEM_ID)
	{
		new itemid = PlayerCache[playerid][pItemWeapon];

		PlayerItemCache[playerid][itemid][iUsed] = false;
		orm_update(PlayerItemCache[playerid][itemid][iOrm]);
		
		PlayerCache[playerid][pCheckWeapon] = (gettime() + 5);
		RemovePlayerAttachedObject(playerid, SLOT_WEAPON);
		
		ResetPlayerWeaponsEx(playerid);
		PlayerCache[playerid][pItemWeapon] = INVALID_ITEM_ID;
	}
	
	PlayerCache[playerid][pInteriorID] = GetPlayerInterior(playerid);
	PlayerCache[playerid][pVirtualWorld] = GetPlayerVirtualWorld(playerid);
	
	GetPlayerPos(playerid, PlayerCache[playerid][pPosX], PlayerCache[playerid][pPosY], PlayerCache[playerid][pPosZ]);

	PlayerCache[playerid][pHealth] = 24;
	orm_update(PlayerCache[playerid][pOrm]);
	return 1;
}

public OnVehicleSpawn(vehicleid)
{
	// Komponenty
	for(new i = 0; i < 14; i++)
	{
 		if(CarInfo[vehicleid][cComponent][i] != 0)
   		{
			AddVehicleComponent(vehicleid, CarInfo[vehicleid][cComponent][i] + 999);
   		}
	}

	if(!strlen(CarInfo[vehicleid][cRegister]))
	{
	    SetVehicleNumberPlate(vehicleid, " ");
	}
	else
	{
    	SetVehicleNumberPlate(vehicleid, CarInfo[vehicleid][cRegister]);
	}
	
	ChangeVehiclePaintjob(vehicleid, CarInfo[vehicleid][cPaintJob]);
	ChangeVehicleColor(vehicleid, CarInfo[vehicleid][cColor1], CarInfo[vehicleid][cColor2]);
	
	SetVehicleVirtualWorld(vehicleid, CarInfo[vehicleid][cWorldID]);
	LinkVehicleToInterior(vehicleid, CarInfo[vehicleid][cInteriorID]);
	
	// Pojazdy pracy dorywczej się nie psują
	if(CarInfo[vehicleid][cOwnerType] == OWNER_WORK)
	{
	    CarInfo[vehicleid][cHealth] = 1000;
	    strmid(CarInfo[vehicleid][cVisual], "0 0 0 0", 0, 7, 32);
	    
	    CarInfo[vehicleid][cFuel] = GetVehicleMaxFuel(CarInfo[vehicleid][cModel]);
		return 1;
	}
	
	// Nie może wybuchać
    if(CarInfo[vehicleid][cHealth] < 350)	CarInfo[vehicleid][cHealth] = 350;

	/*
    new Float:handling;
    GetDefaultHandlingFloat(CarInfo[vehicleid][cModel], HANDL_TR_FENGINEACCELERATION, handling);
    SetVehicleHandlingFloat(vehicleid, HANDL_TR_FENGINEACCELERATION, handling + CarInfo[vehicleid][cHandling]);

    GetDefaultHandlingFloat(CarInfo[vehicleid][cModel], HANDL_TR_FMAXVELOCITY, handling);
    SetVehicleHandlingFloat(vehicleid, HANDL_TR_FMAXVELOCITY, handling + CarInfo[vehicleid][cHandling]);
	*/
	
	SetVehicleLock(vehicleid, CarInfo[vehicleid][cLocked]);
	SetVehicleHealth(vehicleid, CarInfo[vehicleid][cHealth]);

	new veh_visual[4];

	sscanf(CarInfo[vehicleid][cVisual], "a<d>[4]", veh_visual);
	UpdateVehicleDamageStatus(vehicleid, veh_visual[0], veh_visual[1], veh_visual[2], veh_visual[3]);
	return 1;
}

public OnVehicleDeath(vehicleid, killerid)
{
	foreach(new i : Player)
	{
	    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	    {
	        if(PlayerCache[i][pLastVeh] == vehicleid)
	        {
	            if(i == killerid)
	            {
	                CarInfo[vehicleid][cHealth] = 350;
	                break;
	            }
	        }
	    }
	}
	
	if(killerid != INVALID_PLAYER_ID)
	{
	    printf("[cars] Pojazd %s (UID: %d) został całkowicie zniszczony (%.0f HP) przez %s (UID: %d, GID: %d).", GetVehicleName(CarInfo[vehicleid][cModel]), CarInfo[vehicleid][cUID], CarInfo[vehicleid][cHealth], PlayerRealName(killerid), PlayerCache[killerid][pUID], PlayerCache[killerid][pGID]);
	}
	else
	{
	    printf("[cars] Pojazd %s (UID: %d) został całkowicie zniszczony (%.0f HP).", GetVehicleName(CarInfo[vehicleid][cModel]), CarInfo[vehicleid][cUID], CarInfo[vehicleid][cHealth]);
	}
	
	CarInfo[vehicleid][cHealth] = CarInfo[vehicleid][cHealth];
	orm_update(CarInfo[vehicleid][cOrm]);
	return 1;
}

public OnPlayerText(playerid, text[])
{
	if(is_null(text))	return 0;
	if(!PlayerCache[playerid][pLogged] && !PlayerCache[playerid][pSpawned])
	{
	    return 0;
	}

	if(PlayerCache[playerid][pBW] || PlayerCache[playerid][pAJ])
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz się teraz odezwać.");
	    return 0;
	}
	
	new string[256];
	
	// Grupy - czat OOC
	if(text[0] == '@')
	{
	    new group_slot = INVALID_SLOT_ID, chat_title[128],
			pos = strfind(text, " ", true) + 1;

		strmid(chat_title, text, pos, strlen(text));
  		strdel(text, pos, strlen(text));

	    if(text[1] == '@')
	    {
			if(!strlen(chat_title))
			{
			    SendClientMessage(playerid, COLOR_GREY, "Aby posługiwać się czatem OOC podgrupy, poprzedź numer slotu znakami @@ a następnie wpisz treść wiadomości.");
			    SendClientMessage(playerid, COLOR_GREY, "Przykład: @@1 Witam! Skrypt automatycznie pobiera slot ostatnio używanego czatu, więc dalej nie musisz go definiować.");
			    return 0;
			}

			if(text[2] != ' ')	group_slot = strval(text[2]) - 1;
			else				group_slot = PlayerCache[playerid][pMainGroupSlot] - 1;

			if(group_slot < 0 || group_slot >= MAX_GROUP_SLOTS)
			{
				GameTextForPlayer(playerid, "~r~Nieprawidlowy slot grupy.", 3000, 3);
	   			return 0;
			}
			if(!PlayerGroup[playerid][group_slot][gpUID])
			{
	  			GameTextForPlayer(playerid, "~r~Nieprawidlowy slot grupy.", 3000, 3);
		    	return 0;
			}
			if(!(PlayerGroup[playerid][group_slot][gpPerm] & G_PERM_CHAT))
			{
			    GameTextForPlayer(playerid, "~r~Brak uprawnien do pisania na czacie.", 3000, 3);
			    return 0;
			}
			new group_id = PlayerGroup[playerid][group_slot][gpID];
			if(!(GroupData[group_id][gFlags] & G_FLAG_OOC))
			{
			    GameTextForPlayer(playerid, "~r~Brak dostepu do tego czatu.", 3000, 3);
			    return 0;
			}
			if(GroupData[group_id][gToggleChat])
			{
			    GameTextForPlayer(playerid, "~r~Czat ~w~OOC ~r~grupy zostal wylaczony.", 3000, 3);
			    return 0;
			}
			if(PlayerGroup[playerid][group_slot][gpTogG])
			{
			    GameTextForPlayer(playerid, "~r~Masz wylaczony czat dla tej grupy.", 3000, 3);
			    return 0;
			}
			chat_title[0] = chrtoupper(chat_title[0]);

			foreach(new i : Player)
			{
				if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
				{
					if(IsPlayerInGroup(i, GroupData[group_id][gUID]))
					{
					    group_slot = GetPlayerGroupSlot(i, GroupData[group_id][gUID]);
					    if(PlayerGroup[i][group_slot][gpTogG])	continue;
					    
					    PlayerCache[i][pMainGroupSlot] = group_slot + 1;
					    
						format(string, sizeof(string), "[@@%d %s]: (( %s [%d]: %s ))", PlayerCache[i][pMainGroupSlot], GroupData[group_id][gTag], PlayerName(playerid), playerid, chat_title);
						SendClientMessage(i, ColorFade(GroupData[group_id][gColor], 7, 10), string);
					}
					else if(GroupData[group_id][gOwner] && IsPlayerInGroup(i, GroupData[group_id][gOwner]))
					{
					    group_slot = GetPlayerGroupSlot(i, GroupData[group_id][gOwner]);
					    if(PlayerGroup[i][group_slot][gpTogG])	continue;
					
         				PlayerCache[i][pMainGroupSlot] = group_slot + 1;

						format(string, sizeof(string), "[@@%d %s]: (( %s [%d]: %s ))", PlayerCache[i][pMainGroupSlot], GroupData[group_id][gTag], PlayerName(playerid), playerid, chat_title);
						SendClientMessage(i, ColorFade(GroupData[group_id][gColor], 7, 10), string);
					}
					else
					{
						for (new slot = 0; slot < MAX_GROUP_SLOTS; slot++)
						{
						    if(PlayerGroup[i][slot][gpUID])
						    {
							    if(GroupData[PlayerGroup[i][slot][gpID]][gOwner] == GroupData[group_id][gUID])
							    {
							        if(!PlayerGroup[i][slot][gpTogG])
							        {
	             						PlayerCache[i][pMainGroupSlot] = slot + 1;

										format(string, sizeof(string), "[@@%d %s]: (( %s [%d]: %s ))", PlayerCache[i][pMainGroupSlot], GroupData[group_id][gTag], PlayerName(playerid), playerid, chat_title);
										SendClientMessage(i, ColorFade(GroupData[group_id][gColor], 7, 10), string);
										break;
									}
								}
							}
						}
					}
				}
			}
	    }
	    else
		{
			if(!strlen(chat_title))
			{
			    SendClientMessage(playerid, COLOR_GREY, "Aby posługiwać się czatem OOC grupy, poprzedź numer slotu znakiem @ a następnie wpisz treść wiadomości.");
			    SendClientMessage(playerid, COLOR_GREY, "Przykład: @1 Witam! Skrypt automatycznie pobiera slot ostatnio używanego czatu, więc dalej nie musisz go definiować.");
			    return 0;
			}

			if(text[1] != ' ')	group_slot = strval(text[1]) - 1;
			else				group_slot = PlayerCache[playerid][pMainGroupSlot] - 1;

			if(group_slot < 0 || group_slot >= MAX_GROUP_SLOTS)
			{
				GameTextForPlayer(playerid, "~r~Nieprawidlowy slot grupy.", 3000, 3);
	   			return 0;
			}
			if(!PlayerGroup[playerid][group_slot][gpUID])
			{
	  			GameTextForPlayer(playerid, "~r~Nieprawidlowy slot grupy.", 3000, 3);
		    	return 0;
			}
			if(!(PlayerGroup[playerid][group_slot][gpPerm] & G_PERM_CHAT))
			{
			    GameTextForPlayer(playerid, "~r~Brak uprawnien do pisania na czacie.", 3000, 3);
			    return 0;
			}
			new group_id = PlayerGroup[playerid][group_slot][gpID];
			if(!(GroupData[group_id][gFlags] & G_FLAG_OOC))
			{
			    GameTextForPlayer(playerid, "~r~Brak dostepu do tego czatu.", 3000, 3);
			    return 0;
			}
			if(GroupData[group_id][gToggleChat])
			{
			    GameTextForPlayer(playerid, "~r~Czat ~w~OOC ~r~grupy zostal wylaczony.", 3000, 3);
			    return 0;
			}
			if(PlayerGroup[playerid][group_slot][gpTogG])
			{
			    GameTextForPlayer(playerid, "~r~Masz wylaczony czat dla tej grupy.", 3000, 3);
			    return 0;
			}
			chat_title[0] = chrtoupper(chat_title[0]);

			foreach(new i : Player)
			{
				if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
				{
					if(IsPlayerInGroup(i, GroupData[group_id][gUID]))
					{
					    group_slot = GetPlayerGroupSlot(i, GroupData[group_id][gUID]);
					    if(PlayerGroup[i][group_slot][gpTogG])	continue;
					    
	 					PlayerCache[i][pMainGroupSlot] = group_slot + 1;

						format(string, sizeof(string), "[@%d %s]: (( %s [%d]: %s ))", PlayerCache[i][pMainGroupSlot], GroupData[group_id][gTag], PlayerName(playerid), playerid, chat_title);
						SendClientMessage(i, ColorFade(GroupData[group_id][gColor], 7, 10), string);
					}
				}
			}
	    }
		return 0;
	}
	
	// Grupy - czat IC
	if(text[0] == '!')
	{
 		new group_slot = INVALID_SLOT_ID, chat_title[128];
 		new pos = strfind(text, " ", true) + 1;

	    if(text[1] == '!')
	    {
  			strmid(chat_title, text, pos, strlen(text));
	        strdel(text, pos, strlen(text));

			if(!strlen(chat_title))
			{
			    SendClientMessage(playerid, COLOR_GREY, "Aby posługiwać się czatem IC podgrupy, poprzedź numer slotu znakami !! a następnie wpisz treść wiadomości.");
			    SendClientMessage(playerid, COLOR_GREY, "Przykład: !!1 Zgłaszam się. Skrypt automatycznie pobiera slot ostatnio używanego czatu, więc dalej nie musisz go definiować.");
			    return 0;
			}

			if(text[2] != ' ')	group_slot = strval(text[2]) - 1;
			else				group_slot = PlayerCache[playerid][pMainGroupSlot] - 1;

			if(group_slot < 0 || group_slot >= MAX_GROUP_SLOTS)
			{
				GameTextForPlayer(playerid, "~r~Nieprawidlowy slot grupy.", 3000, 3);
	   			return 0;
			}
			if(!PlayerGroup[playerid][group_slot][gpUID])
			{
	  			GameTextForPlayer(playerid, "~r~Nieprawidlowy slot grupy.", 3000, 3);
		    	return 0;
			}
			if(!(PlayerGroup[playerid][group_slot][gpPerm] & G_PERM_CHAT))
			{
			    GameTextForPlayer(playerid, "~r~Brak uprawnien do pisania na czacie.", 3000, 3);
			    return 0;
			}
			new group_id = PlayerGroup[playerid][group_slot][gpID];
			if(!(GroupData[group_id][gFlags] & G_FLAG_IC))
			{
			    GameTextForPlayer(playerid, "~r~Brak dostepu do tego czatu.", 3000, 3);
			    return 0;
			}
			chat_title[0] = chrtoupper(chat_title[0]);

			foreach(new i : Player)
			{
				if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
				{
					if(IsPlayerInGroup(i, GroupData[group_id][gUID]))
					{
 						PlayerCache[i][pMainGroupSlot] = GetPlayerGroupSlot(i, GroupData[group_id][gUID]) + 1;

						format(string, sizeof(string), "!!%d ** [%s]: %s: %s **", PlayerCache[i][pMainGroupSlot], GroupData[group_id][gTag], PlayerName(playerid), chat_title);
						SendClientMessage(i, GroupData[group_id][gColor], string);
					}
					else if(GroupData[group_id][gOwner] && IsPlayerInGroup(i, GroupData[group_id][gOwner]))
					{
					    PlayerCache[i][pMainGroupSlot] = GetPlayerGroupSlot(i, GroupData[group_id][gOwner]) + 1;

						format(string, sizeof(string), "!!%d ** [%s]: %s: %s **", PlayerCache[i][pMainGroupSlot], GroupData[group_id][gTag], PlayerName(playerid), chat_title);
						SendClientMessage(i, GroupData[group_id][gColor], string);
					}
					else
					{
						for (new slot = 0; slot < MAX_GROUP_SLOTS; slot++)
						{
						    if(PlayerGroup[i][slot][gpUID])
						    {
							    if(GroupData[PlayerGroup[i][slot][gpID]][gOwner] == GroupData[group_id][gUID])
							    {
	 					    		PlayerCache[i][pMainGroupSlot] = slot + 1;

									format(string, sizeof(string), "!!%d ** [%s]: %s: %s **", PlayerCache[i][pMainGroupSlot], GroupData[group_id][gTag], PlayerName(playerid), chat_title);
									SendClientMessage(i, GroupData[group_id][gColor], string);
									break;
								}
							}
						}
					}
				}
			}
			format(string, sizeof(string), "%s mówi (radio): %s", PlayerName(playerid), chat_title);
			ProxDetector(10.0, playerid, string, COLOR_FADE1, COLOR_FADE2, COLOR_FADE3, COLOR_FADE4, COLOR_FADE5);
		}
	    else
	    {
  			strmid(chat_title, text, pos, strlen(text));
	        strdel(text, pos, strlen(text));

			if(!strlen(chat_title))
			{
			    SendClientMessage(playerid, COLOR_GREY, "Aby posługiwać się czatem IC grupy, poprzedź numer slotu znakiem ! a następnie wpisz treść wiadomości.");
			    SendClientMessage(playerid, COLOR_GREY, "Przykład: !1 Zgłaszam się. Skrypt automatycznie pobiera slot ostatnio używanego czatu, więc dalej nie musisz go definiować.");
			    return 0;
			}

			if(text[1] != ' ')	group_slot = strval(text[1]) - 1;
			else				group_slot = PlayerCache[playerid][pMainGroupSlot] - 1;

			if(group_slot < 0 || group_slot >= MAX_GROUP_SLOTS)
			{
				GameTextForPlayer(playerid, "~r~Nieprawidlowy slot grupy.", 3000, 3);
	   			return 0;
			}
			if(!PlayerGroup[playerid][group_slot][gpUID])
			{
	  			GameTextForPlayer(playerid, "~r~Nieprawidlowy slot grupy.", 3000, 3);
		    	return 0;
			}
			if(!(PlayerGroup[playerid][group_slot][gpPerm] & G_PERM_CHAT))
			{
			    GameTextForPlayer(playerid, "~r~Brak uprawnien do pisania na czacie.", 3000, 3);
			    return 0;
			}
			new group_id = PlayerGroup[playerid][group_slot][gpID];
			if(!(GroupData[group_id][gFlags] & G_FLAG_IC))
			{
			    GameTextForPlayer(playerid, "~r~Brak dostepu do tego czatu.", 3000, 3);
			    return 0;
			}
			chat_title[0] = chrtoupper(chat_title[0]);

			foreach(new i : Player)
			{
				if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
				{
					if(IsPlayerInGroup(i, GroupData[group_id][gUID]))
					{
	 					PlayerCache[i][pMainGroupSlot] = GetPlayerGroupSlot(i, GroupData[group_id][gUID]) + 1;

						format(string, sizeof(string), "!%d ** [%s]: %s: %s **", PlayerCache[i][pMainGroupSlot], GroupData[group_id][gTag], PlayerName(playerid), chat_title);
						SendClientMessage(i, GroupData[group_id][gColor], string);
					}
				}
			}
			format(string, sizeof(string), "%s mówi (radio): %s", PlayerName(playerid), chat_title);
			ProxDetector(10.0, playerid, string, COLOR_FADE1, COLOR_FADE2, COLOR_FADE3, COLOR_FADE4, COLOR_FADE5);
	    }
		return 0;
	}
	
	if(text[0] == '.')
	{
	    new bool: found = false;
	    foreach(new anim_id : Anim)
	    {
    		if(!strcmp(text, AnimCache[anim_id][aCommand], true))
   			{
 	    		if(AnimCache[anim_id][aAction] == 0)
   	    		{
   	    		    if(PlayerCache[playerid][pEditActor] == INVALID_ACTOR_ID)
   	    		    {
    	    			ApplyAnimation(playerid, AnimCache[anim_id][aLib], AnimCache[anim_id][aName], AnimCache[anim_id][aSpeed], AnimCache[anim_id][aOpt1], AnimCache[anim_id][aOpt2], AnimCache[anim_id][aOpt3], AnimCache[anim_id][aOpt4], AnimCache[anim_id][aOpt5], true);
					}
					else
					{
					    new actorid = PlayerCache[playerid][pEditActor], ActorData[sActorData];
					    Streamer_GetArrayData(STREAMER_TYPE_ACTOR, actorid, E_STREAMER_EXTRA_ID, ActorData);
					    
					    ActorData[aAnim] = AnimCache[anim_id][aUID];
					    Streamer_SetArrayData(STREAMER_TYPE_ACTOR, actorid, E_STREAMER_EXTRA_ID, ActorData);
					    
						ClearDynamicActorAnimations(actorid);
            			ApplyDynamicActorAnimation(actorid, AnimCache[anim_id][aLib], AnimCache[anim_id][aName], AnimCache[anim_id][aSpeed], AnimCache[anim_id][aOpt1], AnimCache[anim_id][aOpt2], AnimCache[anim_id][aOpt3], AnimCache[anim_id][aOpt4], AnimCache[anim_id][aOpt5]);
						break;
					}
				}
				else
				{
    				SetPlayerSpecialAction(playerid, AnimCache[anim_id][aAction]);
				}
				PlayerCache[playerid][pPlayAnim] = true;
				found = true;
	       	}
	    }
		if(!found) PlayerPlaySound(playerid, 1085, 0.0, 0.0, 0.0);
	    return 0;
	}
	text[0] = chrtoupper(text[0]);
	
	if(PlayerCache[playerid][pCallingTo] != INVALID_PLAYER_ID)
	{
	    if(PlayerCache[playerid][pCallingTo] == NUMBER_WHOLESALE || PlayerCache[playerid][pCallingTo] == NUMBER_TAXI || PlayerCache[playerid][pCallingTo] == NUMBER_ALARM || PlayerCache[playerid][pCallingTo] == NUMBER_NEWS)
	    {
	        return 0;
	    }
	    new called_player = PlayerCache[playerid][pCallingTo];
	    if(!PlayerCache[called_player][pLogged] || !PlayerCache[called_player][pSpawned] || PlayerCache[called_player][pCallingTo] != playerid)
	    {
	        PlayerCache[playerid][pCallingTo] = INVALID_PLAYER_ID;
	        SendClientMessage(playerid, COLOR_YELLOW, "Utracono połączenie z rozmówcą.");

			SetPlayerSpecialAction(playerid, SPECIAL_ACTION_STOPUSECELLPHONE);
	        RemovePlayerAttachedObject(playerid, SLOT_PHONE);
	        return 0;
	    }
	    format(string, sizeof(string), "[Telefon, %s]: %s", GetSexName(PlayerCache[playerid][pSex]), text);
	    SendClientMessage(called_player, COLOR_YELLOW, string);

   		format(string, sizeof(string), "%s (telefon): %s", PlayerName(playerid), text);
  		ProxDetector(10.0, playerid, string, COLOR_FADE1, COLOR_FADE2, COLOR_FADE3, COLOR_FADE4, COLOR_FADE5);
	    return 0;
	}
	
	if(PlayerCache[playerid][pRadioLive])
	{
		new desc[128];
		memcpy(desc, text, 0, 128 * 4);

		escape_pl(desc);

	    format(string, sizeof(string), "~y~~h~LSN ~>~ ~p~~h~Na zywo - %s: ~w~%s", PlayerName(playerid), FormatTextDrawColors(desc));
	    TextDrawSetString(Text:TextDrawNews, string);
	    return 0;
	}

	if(PlayerCache[playerid][pRadioInterview] != INVALID_PLAYER_ID)
	{
		new desc[128];
		memcpy(desc, text, 0, 128 * 4);

		escape_pl(desc);

		format(string, sizeof(string), "~y~~h~LSN ~>~ ~r~~h~Wywiad - %s: ~w~%s", PlayerName(playerid), FormatTextDrawColors(desc));
		TextDrawSetString(Text:TextDrawNews, string);
		return 0;
	}
	
	if(!strcmp(text, ":D", true) || !strcmp(text, " :D", true) || !strcmp(text, ":D ", true))
	{
	    ApplyAnimation(playerid, "RAPPING", "Laugh_01", 4.1, 0, 0, 0, 0, 0, true);
	    
	    format(string, sizeof(string), "* %s śmieje się.", PlayerName(playerid));
        ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
		return 0;
	}
	if(!strcmp(text, ":)", true) || !strcmp(text, " :)", true) || !strcmp(text, ":) ", true))
	{
	    format(string, sizeof(string), "* %s uśmiecha się.", PlayerName(playerid));
        ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
		return 0;
	}
	if(!strcmp(text, ":/", true) || !strcmp(text, " :/", true) || !strcmp(text, ":/ ", true))
	{
	    format(string, sizeof(string), "* %s krzywi się.", PlayerName(playerid));
        ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
		return 0;
	}
	if(!strcmp(text, ":O", true) || !strcmp(text, " :O", true) || !strcmp(text, ":O ", true))
	{
	    format(string, sizeof(string), "* %s robi zdziwioną minę.", PlayerName(playerid));
        ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
		return 0;
	}
	if(!strcmp(text, ":(", true) || !strcmp(text, " :(", true) || !strcmp(text, ":( ", true))
	{
	    format(string, sizeof(string), "* %s robi smutna minę.", PlayerName(playerid));
        ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
		return 0;
	}
	if(!strcmp(text, ":P", true) || !strcmp(text, " :P", true) || !strcmp(text, ":P ", true))
	{
	    format(string, sizeof(string), "* %s wystawia język.", PlayerName(playerid));
        ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
		return 0;
	}
	
	if(strlen(text) < 78)
	{
		format(string, sizeof(string), "%s mówi: %s", PlayerName(playerid), text);
		ProxDetector(10.0, playerid, string, COLOR_FADE1, COLOR_FADE2, COLOR_FADE3, COLOR_FADE4, COLOR_FADE5);
 	}
	else
	{
	    new pos = strfind(text, " ", true, strlen(text) / 2);
		if(pos != -1)
		{
  			new text2[64];

  			strmid(text2, text, pos + 1, strlen(text));
			strdel(text, pos, strlen(text));

			format(string, sizeof(string), "%s mówi: %s...", PlayerName(playerid), text);
      		ProxDetector(10.0, playerid, string, COLOR_FADE1, COLOR_FADE2, COLOR_FADE3, COLOR_FADE4, COLOR_FADE5);

			format(string, sizeof(string), "...%s", text2);
			ProxDetector(10.0, playerid, string, COLOR_FADE1, COLOR_FADE2, COLOR_FADE3, COLOR_FADE4, COLOR_FADE5);
		}
	}
	
	if(!PlayerCache[playerid][pPlayAnim])
	{
		new talk_style = PlayerCache[playerid][pTalkStyle];

		ApplyAnimation(playerid, TalkStyleData[talk_style][0], TalkStyleData[talk_style][1], 4.1, 0, 1, 1, 1, 1, true);
		defer KillTalkingAnimation[60 * strlen(text)](playerid);
	}
	return 0;
}

public OnPlayerCommandText(playerid, cmdtext[])
{
	return 0;
}

public OnPlayerCommandPerformed(playerid, cmd[], params[], result, flags)
{
	if(result == -1)
	{
		return PlayerPlaySound(playerid, 1053, 0.0, 0.0, 0.0);
	}
	else
	{
	    if(!strcmp(cmd, "w", true))
	    {
	        return 1;
	    }
		printf("[cmmd][%d][%d] %s: /%s %s", PlayerCache[playerid][pGID], PlayerCache[playerid][pUID], PlayerRealName(playerid), cmd, params);
		return 1;
	}
}

public OnPlayerCommandReceived(playerid, cmd[], params[], flags)
{
	if(!PlayerCache[playerid][pLogged] || !PlayerCache[playerid][pSpawned])
	{
	    return 0;
	}
	return 1;
}

public OnPlayerEnterVehicle(playerid, vehicleid, ispassenger)
{
	new Float:PosX, Float:PosY, Float:PosZ;
	GetPlayerPos(playerid, PosX, PosY, PosZ);

	if(CarInfo[vehicleid][cLocked])
	{
	    crp_SetPlayerPos(playerid, PosX, PosY, PosZ);
	    GameTextForPlayer(playerid, "~n~~n~~n~~n~~n~~r~Ten pojazd jest zamkniety", 4000, 3);
	    return 1;
	}
	
	if(PlayerCache[playerid][pRoll])
	{
	    crp_SetPlayerPos(playerid, PosX, PosY, PosZ);
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz wsiąść do pojazdu mając rolki na nogach.");
	    return 1;
	}
	
	if(!ispassenger)
	{
 		if(!(PlayerCache[playerid][pAdmin] & A_PERM_CARS))
   		{
 	  		if(CarInfo[vehicleid][cOwnerType] == OWNER_NONE)
		   	{
		   	    crp_SetPlayerPos(playerid, PosX, PosY, PosZ);
		   	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz prowadzić tego pojazdu.");
		     	return 1;
		   	}
   		
  			if(CarInfo[vehicleid][cOwnerType] == OWNER_PLAYER && CarInfo[vehicleid][cOwner] != PlayerCache[playerid][pUID])
			{
				crp_SetPlayerPos(playerid, PosX, PosY, PosZ);
			    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz prowadzić tego pojazdu.");
				return 1;
			}
   		
		    if(CarInfo[vehicleid][cOwnerType] == OWNER_GROUP)
		    {
			    if(PlayerCache[playerid][pLesson] != INVALID_GROUP_ID)
			    {
	     			new group_id = PlayerCache[playerid][pLesson];
		            if(CarInfo[vehicleid][cOwner] != GroupData[group_id][gUID])
		            {
				        crp_SetPlayerPos(playerid, PosX, PosY, PosZ);
				        ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz prowadzić tego pojazdu.");
		                return 1;
		            }
			    }
			    else
			    {
					if(!HavePlayerGroupPerm(playerid, CarInfo[vehicleid][cOwner], G_PERM_CARS))
					{
	        			crp_SetPlayerPos(playerid, PosX, PosY, PosZ);
	        			ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz prowadzić tego pojazdu.");
	            		return 1;
	            	}
			    }
			}
			
	 		if(CarInfo[vehicleid][cOwnerType] == OWNER_WORK)
			{
			    if(WorkInfo[playerid][wID] != CarInfo[vehicleid][cOwner])
			    {
			        crp_SetPlayerPos(playerid, PosX, PosY, PosZ);
			        ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz prowadzić tego pojazdu.");
			        return 1;
			    }

			    if(CarInfo[vehicleid][cOwner] == JOB_COURIER && PlayerCache[playerid][pPackage] == INVALID_PACKAGE_ID)
			    {
			        crp_SetPlayerPos(playerid, PosX, PosY, PosZ);
			        ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Musisz wybrać paczkę z listy, by móc poruszać się tym pojazdem (/paczka).");
			        return 1;
			    }

			    if(CarInfo[vehicleid][cOwner] == JOB_NEWSPAPER && WorkInfo[playerid][wValue][0] <= 0)
			    {
			        crp_SetPlayerPos(playerid, PosX, PosY, PosZ);
			        ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Musisz posiadać przy sobie gazety, by skorzystać z tego pojazdu.");
			        return 1;
			    }
			}

			if(CarInfo[vehicleid][cBlockWheel])
	  		{
	    		crp_SetPlayerPos(playerid, PosX, PosY, PosZ);
	      		ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Na koło pojazdu %s (UID: %d) została nałożona blokada.\nAby zwolnić blokadę, udaj się na komisariat\ni zapytaj w jaki sposób można to zrobić.\n\nKoszt zdjęcia blokady wynosi: $%d", GetVehicleName(CarInfo[vehicleid][cModel]), CarInfo[vehicleid][cUID], CarInfo[vehicleid][cBlockWheel]);
	        	return 1;
	    	}

			if((PlayerCache[playerid][pBlock] & BLOCK_VEH))
			{
			    crp_SetPlayerPos(playerid, PosX, PosY, PosZ);
			    ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Masz nałożoną blokadę prowadzenia pojazdów!\n\nSprawdź swoje logi w panelu gry na naszym forum\nmożesz odczekać do czasu, gdy kara wygaśnie, lub też apelować.");
			    return 1;
			}
		}
	}
	else
	{
		if(!(PlayerCache[playerid][pAdmin] & A_PERM_CARS))
  		{
			if(PlayerCache[playerid][pHours] < 5)
	  		{
				new driverid = GetVehicleDriver(vehicleid);
				if(driverid == INVALID_PLAYER_ID)
				{
					crp_SetPlayerPos(playerid, PosX, PosY, PosZ);
		       		ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Mając mniej niż 5h gry możesz wsiąść jako pasażer tylko do pojazdu, w którym znajduje się kierowca.");
		  			return 1;
				}
	   		}
		}
	}
	
	if(ispassenger)
	{
	    //printf("[cars] %s (UID: %d, GID: %d) wsiadł do pojazdu %s (UID: %d) jako pasażer.", PlayerRealName(playerid), PlayerCache[playerid][pUID], PlayerCache[playerid][pGID], GetVehicleName(CarInfo[vehicleid][cModel]), CarInfo[vehicleid][cUID]);
	}
	else
	{
	    //printf("[cars] %s (UID: %d, GID: %d) wsiadł do pojazdu %s (UID: %d) jako kierowca.", PlayerRealName(playerid), PlayerCache[playerid][pUID], PlayerCache[playerid][pGID], GetVehicleName(CarInfo[vehicleid][cModel]), CarInfo[vehicleid][cUID]);
        
	}
	PlayerCache[playerid][pLastVeh] = vehicleid;
	
	new engine_status = GetVehicleEngineStatus(vehicleid);
	ChangeVehicleEngineStatus(vehicleid, (IsVehicleBike(vehicleid)) ? 1 : engine_status);
	return 1;
}

public OnPlayerExitVehicle(playerid, vehicleid)
{
	return 1;
}

public OnPlayerStateChange(playerid, newstate, oldstate)
{
	foreach(new i : Player)
	{
	    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	    {
	        if(PlayerCache[i][pSpectate] == playerid)
	        {
	            switch(newstate)
	            {
      		    	case 0, 1, 7, 8:
				    {
						PlayerSpectatePlayer(i, playerid);
					}
	    			case 2, 3:
	    			{
						PlayerSpectateVehicle(i , GetPlayerVehicleID(playerid));
					}
		   			case 9:
				    {
				        SetPlayerSpawn(i);
				    }
	            }
	        }
	    }
	}

	// Zespawnowany
	if(newstate == PLAYER_STATE_SPAWNED)
	{
	    if(!PlayerCache[playerid][pSpawned])
	    {
	        if(!PlayerCache[playerid][pLogged] && !PlayerCache[playerid][pCreatingChar])
	        {
	            Kick(playerid);
	            return 1;
	        }
	        PlayerCache[playerid][pSpawned] = true;
	    }
	}

	// Kierowca
	if(newstate == PLAYER_STATE_DRIVER)
	{
	    new vehid = GetPlayerVehicleID(playerid);
	    if(GetVehicleEngineStatus(vehid) != 1)
	    {
	        TD_ShowSmallInfo(playerid, 0, "Aby uruchomic silnik, wcisnij ~y~~k~~VEHICLE_FIREWEAPON_ALT~~w~ + ~y~~k~~SNEAK_ABOUT~~w~.~n~Klawisz ~y~~k~~VEHICLE_FIREWEAPON~ ~w~kontroluje swiatla w pojezdzie.");
	    }
	    
	    if(CarInfo[vehid][cAccess] & VEH_ACCESS_RADIO)
	    {
	        if(CarInfo[vehid][cRadioCanal])
	        {
				new string[64];
				format(string, sizeof(string), "CB radio: (%d) hz", CarInfo[vehid][cRadioCanal]);
				
				PlayerTextDrawSetString(playerid, TextDrawRadioCB[playerid], string);
				PlayerTextDrawShow(playerid, TextDrawRadioCB[playerid]);
	        }
	    }
	    /*
	    if(CarInfo[vehid][cAccess] & VEH_ACCESS_TURBO || CarInfo[vehid][cAccess] & VEH_ACCESS_COMPRESSOR || CarInfo[vehid][cAccess] & VEH_ACCESS_ECU)
	    {
	        if(!IsPlayerUsingCHandling(playerid))
	        {
	        	TD_ShowHint(playerid, HINT_NONE, 5, "Ten pojazd jest ~y~ulepszony ~w~pod wzgledem osiagow mechanicznych. Zeby moc korzystac z ~b~pelnych modyfikacji ~w~osiagow pojazdu, pobierz plugin z naszej strony: ~y~https://m-rp.net");
			}
	    }
	    */
	    
     	if(PlayerCache[playerid][pLastVeh] != vehid)
      	{
       		GivePlayerPunish(playerid, INVALID_PLAYER_ID, PUNISH_KICK, "Nieautoryzowane wejscie do pojazdu.", 0, 0);
			return 1;
       	}
	}
	
	if(oldstate == PLAYER_STATE_DRIVER && newstate == PLAYER_STATE_ONFOOT)
	{
	    new vehid = PlayerCache[playerid][pLastVeh];
	    if(GetVehicleEngineStatus(vehid) != 1)
	    {
			TD_HideSmallInfo(playerid);
		}
		
  		if(CarInfo[vehid][cAccess] & VEH_ACCESS_RADIO)
	    {
	        if(CarInfo[vehid][cRadioCanal])
	        {
				PlayerTextDrawHide(playerid, TextDrawRadioCB[playerid]);
	        }
	    }
		
  		// Jeśli kierowca taksówki wysiądzie
	    if(PlayerCache[playerid][pTaxiPassenger] != INVALID_PLAYER_ID)
	    {
	        new passenger_id = PlayerCache[playerid][pTaxiPassenger],
				price = PlayerCache[passenger_id][pTaxiPay];

	        if(price > 0 && PlayerCache[passenger_id][pCash] >= price)
	        {
      			new group_cash = floatround(0.90 * price),
					playercash = floatround(0.10 * price);

		        crp_GivePlayerMoney(passenger_id, -price);
		        crp_GivePlayerMoney(playerid, playercash);

		        new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];

		        GroupData[group_id][gCash] += group_cash;
		        orm_update(GroupData[group_id][gOrm]);

       			ShowPlayerInfoDialog(passenger_id, D_TYPE_INFO, "Zapłaciłeś $%d za przejazd taksówką.", price);
				ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Otrzymałeś premię w wysokości $%d!\nNa konto grupy dodano: $%d", playercash, group_cash);
			}

			PlayerCache[passenger_id][pTaxiVeh] 	= INVALID_VEHICLE_ID;
			PlayerCache[passenger_id][pTaxiPay] 	= 0;
			PlayerCache[passenger_id][pTaxiPrice] 	= 0;
			PlayerCache[playerid][pTaxiPassenger] 	= INVALID_PLAYER_ID;
	    }
	    
	    // GPS
	    if(CarInfo[vehid][cGPS])
	    {
		    foreach(new i : Player)
		    {
		        if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
		        {
		    		SetPlayerMarkerForPlayer(playerid, i, COLOR_NICK);
		        }
		    }
		}
	    
	    // Pasy
		PlayerCache[playerid][pBelts] = false;
	}
	
	if(oldstate == PLAYER_STATE_PASSENGER && newstate == PLAYER_STATE_ONFOOT)
	{
 		// Jeśli pasażer taksówki wysiądzie
 		if(PlayerCache[playerid][pTaxiVeh] != INVALID_VEHICLE_ID)
	    {
	        new driverid = GetVehicleDriver(PlayerCache[playerid][pTaxiVeh]),
				price = PlayerCache[playerid][pTaxiPay];

	        if(price > 0 && PlayerCache[playerid][pCash] >= price)
	        {
      			new group_cash = floatround(0.90 * price),
					playercash = floatround(0.10 * price);

		        crp_GivePlayerMoney(playerid, -price);
		        crp_GivePlayerMoney(driverid, playercash);

		        new group_id = PlayerCache[driverid][pDuty][DUTY_GROUP];

		        GroupData[group_id][gCash] += group_cash;
		        orm_update(GroupData[group_id][gOrm]);

       			ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Zapłaciłeś $%d za przejazd taksówką.", price);
				ShowPlayerInfoDialog(driverid, D_TYPE_INFO, "Otrzymałeś premię w wysokości $%d!\nNa konto grupy dodano: $%d", playercash, group_cash);
			}

			PlayerCache[playerid][pTaxiVeh] 		= INVALID_VEHICLE_ID;
			PlayerCache[playerid][pTaxiPay] 		= 0;
			PlayerCache[playerid][pTaxiPrice] 		= 0;
			PlayerCache[driverid][pTaxiPassenger] 	= INVALID_PLAYER_ID;
		}
		
  		// Pasy
		PlayerCache[playerid][pBelts] = false;
	}
	
	if(newstate == PLAYER_STATE_DRIVER || newstate == PLAYER_STATE_PASSENGER)
	{
	    new vehid = GetPlayerVehicleID(playerid);
	    if(strlen(CarInfo[vehid][cAudioURL]))
	    {
   			if(PlayerCache[playerid][pItemPlayer] != INVALID_ITEM_ID)
		    {
		        new itemid = PlayerCache[playerid][pItemPlayer];
		        PlayerItemCache[playerid][itemid][iUsed] = false;
		    }
		    PlayStreamedAudioForPlayer(playerid, CarInfo[vehid][cAudioURL]);
		}
		
		// Przyciemniona szyba
  		if(CarInfo[vehid][cAccess] & VEH_ACCESS_DIM)
	    {
			Streamer_SetFloatData(STREAMER_TYPE_3D_TEXT_LABEL, Text3D:PlayerCache[playerid][pNameTag], E_STREAMER_DRAW_DISTANCE, 5.0);
			Streamer_SetFloatData(STREAMER_TYPE_3D_TEXT_LABEL, Text3D:PlayerCache[playerid][pDescTag], E_STREAMER_DRAW_DISTANCE, 5.0);
	    }
	    
	    // GPS
	    if(CarInfo[vehid][cGPS])
	    {
		    foreach(new i : Player)
		    {
		        if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
		        {
		            if(IsPlayerInAnyVehicle(i))
		            {
						vehid = GetPlayerVehicleID(i);
						if(CarInfo[vehid][cGPS])
						{
						    SetPlayerMarkerForPlayer(playerid, i, COLOR_BLUE);
						    SetPlayerMarkerForPlayer(i, playerid, COLOR_BLUE);
						}
		            }
		        }
		    }
		}
	    
	    if(PlayerCache[playerid][pAFK] > 0)
	    {
	        GivePlayerPunish(playerid, INVALID_PLAYER_ID, PUNISH_KICK, "Nieautoryzowane wejscie do pojazdu.", 0, 0);
	    }
	}
	
	if(oldstate == PLAYER_STATE_DRIVER || oldstate == PLAYER_STATE_PASSENGER)
	{
	    new vehid = PlayerCache[playerid][pLastVeh];
	    if(strlen(CarInfo[vehid][cAudioURL]))
	    {
   			new Float:VehPosX, Float:VehPosY, Float:VehPosZ;
			GetVehiclePos(vehid, VehPosX, VehPosY, VehPosZ);
			
	        StopStreamedAudioForPlayer(playerid);
		}
		
		// Przyciemniona szyba
  		if(CarInfo[vehid][cAccess] & VEH_ACCESS_DIM)
	    {
			Streamer_SetFloatData(STREAMER_TYPE_3D_TEXT_LABEL, Text3D:PlayerCache[playerid][pNameTag], E_STREAMER_DRAW_DISTANCE, 15.0);
			Streamer_SetFloatData(STREAMER_TYPE_3D_TEXT_LABEL, Text3D:PlayerCache[playerid][pDescTag], E_STREAMER_DRAW_DISTANCE, 10.0);
	    }
	    
	    PlayerCache[playerid][pCheckWeapon] = (gettime() + 5);
	}
	return 1;
}

public OnPlayerEnterCheckpoint(playerid)
{
	switch(PlayerCache[playerid][pCheckpoint])
	{
	    case CHECKPOINT_VEHICLE:
	    {
	        DisablePlayerCheckpoint(playerid);

	        PlayerCache[playerid][pCheckpoint] = CHECKPOINT_NONE;
			TD_ShowSmallInfo(playerid, 3, "Namierzanie zostalo ~r~anulowane~w~.");
		}
	    case CHECKPOINT_PACKAGE:
	    {
	        new package_uid = PlayerCache[playerid][pPackage],
	            query[256], Cache:tmp_cache, package_dooruid;
	            
			mysql_format(connHandle, query, sizeof(query), "SELECT `package_dooruid` FROM `"SQL_PREF"packages` WHERE package_uid = '%d' LIMIT 1", package_uid);
			tmp_cache = mysql_query(connHandle, query);
			
			cache_get_value_index_int(0, 0, package_dooruid);
			if(cache_is_valid(tmp_cache))	cache_delete(tmp_cache);
			
			new doorid = GetDoorID(package_dooruid),
	            Float:PosX, Float:PosY, Float:PosZ;
	            
			if(doorid == INVALID_DOOR_ID)
			{
				pc_cmd_paczka(playerid, "");
			    return 1;
			}
			new DoorData[sDoorInfo];
			Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
			
	        GetPlayerPos(playerid, PosX, PosY, PosZ);
	        
	        Streamer_GetDistanceToItem(PosX, PosY, PosZ, STREAMER_TYPE_PICKUP, doorid, PlayerCache[playerid][pPackageDistance]);
	        ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Wziąłeś paczkę z hurtowni, szczegółowe dane:\n\nNumer paczki: %d\nWłaściciel: %s\n\nAdres: SA %d\nDystans do przebycia: %dm", package_uid, DoorData[dName], DoorData[dUID], floatround(PlayerCache[playerid][pPackageDistance]));
	        
			DisablePlayerCheckpoint(playerid);
			Streamer_GetItemPos(STREAMER_TYPE_PICKUP, doorid, PosX, PosY, PosZ);
			
   			SetPlayerCheckpoint(playerid, PosX, PosY, PosZ, 5.0);
			
			PlayerCache[playerid][pCheckpoint] 	= CHECKPOINT_DOOR;
			PlayerCache[playerid][pLastMileage] = floatround(PlayerCache[playerid][pMileage]);
			
			TD_ShowSmallInfo(playerid, 3, "Udaj sie do ~r~wyznaczonego ~w~punktu na mapie.");
	    }
	    case CHECKPOINT_DOOR:
		{
		    new package_uid = PlayerCache[playerid][pPackage],
		        price = floatround(PlayerCache[playerid][pPackageDistance]) / 20;
		        
		    DisablePlayerCheckpoint(playerid);
		    
   			PlayerCache[playerid][pCheckpoint] 	= CHECKPOINT_NONE;
			PlayerCache[playerid][pPackage]	 	= INVALID_PACKAGE_ID;
		    
		    if(floatround(PlayerCache[playerid][pMileage] - PlayerCache[playerid][pLastMileage], floatround_ceil) < floatround(PlayerCache[playerid][pPackageDistance] / 1000, floatround_floor))
		    {
				ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie przebyłeś minimalnego dystansu, kurs nie został zaliczony.\nPamiętaj, że dostarczać paczki możesz tylko pojazdem silnikowym!");
				return 1;
		    }
		    
		    new query[256], Cache:tmp_cache, rows,
		        package_dooruid, package_item_name[32], package_item_type, package_item_value1, package_item_value2, package_item_price, package_item_count, package_type;

			mysql_format(connHandle, query, sizeof(query), "SELECT * FROM `"SQL_PREF"packages` WHERE package_uid = '%d' LIMIT 1", package_uid);
		    tmp_cache = mysql_query(connHandle, query);

			cache_get_row_count(rows);
			if(rows > 0)
			{
			    cache_get_value_index_int(0, 1, package_dooruid);
			    
				cache_get_value_index(0, 2, package_item_name, 32);
				cache_get_value_index_int(0, 3, package_item_type);
				
				cache_get_value_index_int(0, 4, package_item_value1);
				cache_get_value_index_int(0, 5, package_item_value2);
				
				cache_get_value_index_int(0, 6, package_item_count);
				cache_get_value_index_int(0, 7, package_item_price);
				
				cache_get_value_index_int(0, 8, package_type);
			}
			if(cache_is_valid(tmp_cache))	cache_delete(tmp_cache);
		    
		    new doorid = GetDoorID(package_dooruid);
		    CreateDoorProduct(doorid, package_item_name, package_item_type, package_item_value1, package_item_value2, package_item_price, package_item_count);

			if(package_type == PACKAGE_PRODUCT)	crp_GivePlayerMoney(playerid, price);
			mysql_query_format("DELETE FROM `"SQL_PREF"packages` WHERE package_uid = '%d' LIMIT 1", package_uid);

			TD_ShowSmallInfo(playerid, 3, "Paczka zostala ~g~dostarczona ~w~pomyslnie.~n~Otrzymales ~y~$%d ~w~do swojego portfela.", price);
		}
		case CHECKPOINT_ACTOR:
		{
		    DisablePlayerCheckpoint(playerid);
		    PlayerCache[playerid][pCheckpoint] = CHECKPOINT_NONE;
		    
		    TD_ShowSmallInfo(playerid, 5, "Dotarles na ~r~miejsce ~w~napadu. Dokonaj ~y~interakcji ~w~z aktorem, by go przesluchac.");
		}
		case CHECKPOINT_BUSSTOP:
		{
		    TD_ShowHint(playerid, HINT_BUSSTOP, 0, "~y~Bardzo dobrze! ~w~Udalo Ci sie dotrzec do ~r~przystanku~w~, skorzystaj teraz z komendy ~p~/bus 143833~w~, by dostac sie do Ratusza.~n~~n~Mozesz pominac wpisywanie ~p~numeru przystanku ~w~i wybrac swoj cel z ~y~lotu ptaka~w~, jednak jesli nie znasz dokladnie mapy i polozenia jakiegos miejsca, zalecamy jego uzycie.~n~~n~Jako nowy gracz nie zaplacisz za kurs, jednak w przyszlosci bedzie to troche kosztowac, w zaleznosci od odleglosci.");

			DisablePlayerCheckpoint(playerid);
			PlayerCache[playerid][pCheckpoint] = CHECKPOINT_NONE;
		}
		case CHECKPOINT_NEWSPAPER:
		{
			if(WorkInfo[playerid][wValue][0] > 0)
			{
			    new Float:PosX, Float:PosY, Float:PosZ;
			    GetPlayerPos(playerid, PosX, PosY, PosZ);
			    
				new doorid = WorkInfo[playerid][wExtraID] = GetNearRandomDoorID(PosX, PosY, PosZ, OWNER_PLAYER);

				WorkInfo[playerid][wValue][0] --;
				crp_GivePlayerMoney(playerid, 8);
				
				if(WorkInfo[playerid][wValue][0] <= 0)
				{
				    TD_ShowSmallInfo(playerid, 5, "~g~Pomyslnie ~w~dostarczono komplet ~y~20 gazet~w~. Udaj sie do ~y~siedziby ~w~redakcji po kolejne gazety.");

					DisablePlayerCheckpoint(playerid);
					PlayerCache[playerid][pCheckpoint] = CHECKPOINT_NONE;
				}
				else
				{
					TD_ShowSmallInfo(playerid, 3, "Gazeta dostarczona!~n~Otrzymales ~g~$8~w~, pozostalo gazet: ~y~%d~w~.", WorkInfo[playerid][wValue][0]);

					Streamer_GetItemPos(STREAMER_TYPE_PICKUP, doorid, PosX, PosY, PosZ);
					SetPlayerCheckpoint(playerid, PosX, PosY, PosZ, 2.0);
				}
			}
		}
		case CHECKPOINT_MISSION:
		{
		    new mission_uid = MissionData[playerid][mUID], mission_type = MissionData[playerid][mType],
		        mission_leader = GetMissionLeader(mission_uid);
		        
			if(MissionData[playerid][mDate] + MissionData[playerid][mTime] < gettime())
			{
				foreach(new i : MissionPlayer[mission_leader])
				{
					TD_ShowHint(i, HINT_NONE, 15, "Czas wykonania zadania zostal ~r~przekroczony~w~. Niestety ~r~nie udalo ~w~sie go prawidlowo wykonac.");

					DisablePlayerCheckpoint(i);
					PlayerCache[i][pCheckpoint] = CHECKPOINT_NONE;
				}
				DeleteMission(mission_uid);
			    return 1;
			}
		        
			if(MissionData[playerid][mMembers] > 0)
			{
				new count_members;
			    foreach(new i : MissionPlayer[mission_leader])
			    {
       				if(PlayerToPlayer(10.0, i, playerid))
			        {
						count_members ++;
      				}
		    	}
			    if(count_members < MissionData[playerid][mMembers])
			    {
					TD_ShowSmallInfo(playerid, 5, "Zaczekaj, az wszyscy ~y~czlonkowie ~w~zadania pojawia sie na ~r~miejscu~w~.");
     				return 1;
		    	}
			}

		    if(mission_type == MISSION_FIRE_BUILD)
		    {
		        new group_id = MissionData[playerid][mGroup];
				foreach(new i : MissionPlayer[mission_leader])
				{
				    TD_ShowHint(i, HINT_NONE, 15, "Zadanie zostalo wykonane ~g~poprawnie!~n~~n~~w~Na konto grupy ~y~%s (UID: %d) ~w~zostalo dodane: ~g~$%d", GroupData[group_id][gName], GroupData[group_id][gUID], MissionData[i][mAward]);

					DisablePlayerCheckpoint(i);
					PlayerCache[i][pCheckpoint] = CHECKPOINT_NONE;
				}
				
				GroupData[group_id][gCash] += MissionData[playerid][mAward];
				orm_update(GroupData[group_id][gOrm]);
				
				DeleteMission(mission_uid);
		        return 1;
		    }
		    
		    if(mission_type == MISSION_SMUGGLE)
		    {
				// Przyniósł pakunek
				if(MissionData[playerid][mLevel] == 2)
				{
					RemovePlayerAttachedObject(playerid, SLOT_EXTRA);
					SetPlayerSpecialAction(playerid, SPECIAL_ACTION_NONE);
					
					DisablePlayerCheckpoint(playerid);
					MissionData[playerid][mLevel] = 1;
					
					foreach(new i : MissionPlayer[mission_leader])
					{
						MissionData[i][mPoints] ++;
						
						if(MissionData[i][mPoints] < MissionData[i][mNeedPoints])
						{
					    	TD_ShowHint(i, HINT_NONE, 0, "Musicie teraz zapakowac ~y~towar ~w~na busa. Na minimapie pokazano miejsca, w ktorych znajduja sie ~r~skrzynki~w~.~n~~n~Podejdz do skrzynki i wcisnij klawisz ~y~Y~w~, by ja podniesc.~n~~n~Zapakowane towary: %d~n~Pozostalo: %d", MissionData[i][mPoints], MissionData[i][mNeedPoints]);
						}
						else
						{
						    if(GetPlayerSpecialAction(i) == SPECIAL_ACTION_CARRY)
						    {
						        SetPlayerSpecialAction(i, SPECIAL_ACTION_NONE);
						        DisablePlayerCheckpoint(i);
						        
						        RemovePlayerAttachedObject(i, SLOT_EXTRA);
						    }
						
						    MissionData[i][mLevel] = 3;
						    SetPlayerMarkerForPlayer(mission_leader, i, COLOR_WHITE);
						    
							// Wysyłamy zadanie do PD
						    CreateGroupMission(INVALID_GROUP_ID, G_TYPE_POLICE, MISSION_CHASE, "Pewna grupa osób próbuje przemycić Towar. Musicie złapać lidera tej grupy (skuć go, lub obezwładnić), by odbić przemyt.", PlayerCache[mission_leader][pUID], MissionData[i][mMembers], MissionData[i][mMembers] * 300, 30 * 60);
						    TD_ShowHint(i, HINT_NONE, 15, "Towar zostal w pelni ~g~zaladowany~w~! Udajcie sie teraz do swojej ~y~siedziby ~w~(budynek grupowy).~n~~n~Ktos ~r~powiadomil ~w~policje o mozliwym przemycie.~n~~n~Oslaniajcie ~w~~h~lidera ~w~grupy (bialy znacznik na mapie).");
						}
					}
				    return 1;
				}
		        return 1;
		    }
		}
		default:
		{
			DisablePlayerCheckpoint(playerid);
			PlayerCache[playerid][pCheckpoint] = CHECKPOINT_NONE;
		}
	}
	return 1;
}

public OnPlayerLeaveCheckpoint(playerid)
{
	return 1;
}

public OnPlayerEnterRaceCheckpoint(playerid)
{
	if(GetPlayerState(playerid) != PLAYER_STATE_DRIVER)
	{
	    GameTextForPlayer(playerid, "~r~Musisz byc w pojezdzie jako kierowca!", 3000, 3);
	    return 1;
	}

	RaceInfo[playerid][rPoint] ++;
	new checkpoint = RaceInfo[playerid][rPoint];
	
	if(checkpoint < PlayerCache[playerid][pRaceCheckpoints])
	{
	    SetPlayerRaceCheckpoint(playerid, 0, RaceInfo[playerid][rCPX][checkpoint], RaceInfo[playerid][rCPY][checkpoint], RaceInfo[playerid][rCPZ][checkpoint], RaceInfo[playerid][rCPX][checkpoint + 1], RaceInfo[playerid][rCPY][checkpoint + 1], RaceInfo[playerid][rCPZ][checkpoint + 1], 10.0);
	}
	else
	{
	    SetPlayerRaceCheckpoint(playerid, 1, RaceInfo[playerid][rCPX][checkpoint], RaceInfo[playerid][rCPY][checkpoint], RaceInfo[playerid][rCPZ][checkpoint], 0.0, 0.0, 0.0, 10.0);
	}
	
	/*
	new curr_checkpoint = MAX_RACE_CP,
	    racers_count;
	    
	foreach(new i : Player)
	{
	    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	    {
	        if(RaceInfo[i][rOwner] != INVALID_PLAYER_ID && RaceInfo[i][rOwner] == RaceInfo[playerid][rOwner])
	        {
				checkpoint = RaceInfo[i][rPoint];
				if(checkpoint < curr_checkpoint)
				{
				    curr_checkpoint = checkpoint;
				    RaceInfo[i][rPosition] += 1;
				}
				racers_count ++;
	        }
	    }
	}
	*/
	new time_minutes,
		time_seconds;
		
	foreach(new i : Player)
	{
	    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	    {
	        if(RaceInfo[i][rOwner] != INVALID_PLAYER_ID && RaceInfo[i][rOwner] == RaceInfo[playerid][rOwner])
	        {
	            RaceInfo[i][rTime] = gettime();
	            
    			time_minutes = floatround((RaceInfo[i][rTime] - RaceInfo[i][rStart]) / 60, floatround_floor) % 60;
				time_seconds = floatround((RaceInfo[i][rTime] - RaceInfo[i][rStart]), floatround_floor) % 60;
				
				TD_ShowSmallInfo(i, 0, "Wyscig ~y~trwa ~w~wjezdzaj w ~r~czerwone punkty~w~.~n~Nie opuszczaj swojego pojazdu.~n~~n~Checkpoint: ~y~%d/%d~n~~w~Twoj czas: ~p~~h~%02d:%02d", RaceInfo[i][rPoint], PlayerCache[i][pRaceCheckpoints], time_minutes, time_seconds);
	        }
	    }
	}
	
	
	if(checkpoint > PlayerCache[playerid][pRaceCheckpoints])
	{
		new	race_minutes = floatround((gettime() - RaceInfo[playerid][rStart]) / 60, floatround_floor) % 60,
			race_seconds = floatround((gettime() - RaceInfo[playerid][rStart]), floatround_floor) % 60;

		foreach(new i : Player)
  		{
	      if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	      {
	          if(RaceInfo[i][rOwner] != INVALID_PLAYER_ID && RaceInfo[i][rOwner] == RaceInfo[playerid][rOwner])
	          {
              		DisablePlayerRaceCheckpoint(i);

					RaceInfo[i][rPoint] = 0;
					RaceInfo[i][rStart] = 0;
					
					TD_HideSmallInfo(i);
					TD_ShowLargeInfo(i, 20, "~b~~h~Wyscig dobiegl konca!~n~~n~~w~Zwyciezca: ~g~~h~%s~n~~w~Czas trwania wyscigu: ~y~%02d:%02d", PlayerName(playerid), race_minutes, race_seconds);
				}
     		}
	    }
	    
	    GivePlayerAchievement(playerid, ACHIEVE_FAST);
		return 1;
	}
	return 1;
}

public OnPlayerLeaveRaceCheckpoint(playerid)
{
	return 1;
}

public OnRconCommand(cmd[])
{
	return 1;
}

public OnPlayerRequestSpawn(playerid)
{
	return 1;
}

public OnObjectMoved(objectid)
{
	return 1;
}

public OnPlayerObjectMoved(playerid, objectid)
{
	return 1;
}

public OnDynamicObjectMoved(objectid)
{
	// Wycięte drzewo
	if(GetObjectModel(objectid) == OBJECT_TREE)
	{
		new objData[sObjectData],
			Float:objX, Float:objY, Float:objZ;

		GetDynamicObjectPos(objectid, objX, objY, objZ);

		mysql_query_format("INSERT INTO `"SQL_PREF"items` (item_name, item_type, item_value1, item_ownertype) VALUES ('Drewno', '%d', '%d', '%d')", ITEM_WOOD, random(400), PLACE_NONE);
		new item_uid = (cache_insert_id() * -1);

		new object_id = CreateDynamicObject(ItemTypeInfo[ITEM_WOOD][iTypeObjModel], objX, objY, objZ, ItemTypeInfo[ITEM_WOOD][iTypeObjRotX], ItemTypeInfo[ITEM_WOOD][iTypeObjRotY], random(360), 0, -1, -1, MAX_DRAW_DISTANCE);
		objData[objUID] = item_uid;

		Streamer_SetArrayData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_EXTRA_ID, objData);
		Streamer_SetIntData(STREAMER_TYPE_OBJECT, objectid, E_STREAMER_WORLD_ID, 9999);
		
		foreach(new i : Player)
		{
		    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
		    {
				if(IsPlayerInRangeOfPoint(i, MAX_DRAW_DISTANCE, objX, objY, objZ))
				{
				    Streamer_Update(i, STREAMER_TYPE_OBJECT);
				}
		    }
		}
		return 1;
	}
	
	foreach(new i : Player)
	{
	    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	    {
	        if(PlayerCache[i][pBasketBall] == objectid)
	        {
	        	new basket_object_id, string[128],
					Float:oPosX, Float:oPosY, Float:oPosZ,
				    Float:tPosX, Float:tPosY, Float:tPosZ;
	        
	            basket_object_id = PlayerCache[i][pBasketObject];
	            
	            GetDynamicObjectPos(objectid, oPosX, oPosY, oPosZ);
	            
	            GetDynamicObjectPos(basket_object_id, tPosX, tPosY, tPosZ);
            	GetXYBehindOfObject(basket_object_id, tPosX, tPosY, 0.5);
            	
            	StopDynamicObject(objectid);
            	
				if((tPosX < oPosX + 0.5) && (tPosX > oPosX - 0.5) && (tPosY < oPosY + 0.5) && (tPosY > oPosY - 0.5) && (tPosZ < (oPosZ + 2) + 0.5) && (tPosZ > (oPosZ + 2) - 0.5))
				{
				    MoveDynamicObject(objectid, tPosX, tPosY, PlayerCache[i][pPosZ], 10.0);

					format(string, sizeof(string), "* Piłka trafia do kosza. (( %s ))", PlayerName(i));
					ProxDetector(10.0, i, string, COLOR_DO, COLOR_DO, COLOR_DO, COLOR_DO, COLOR_DO);
				}
				else if((tPosX < oPosX + 2) && (tPosX > oPosX - 2) && (tPosY < oPosY + 2) && (tPosY > oPosY - 2) && (tPosZ < oPosZ + 2) && (tPosZ > oPosZ - 2))
				{
			        MoveDynamicObject(objectid, tPosX + random(5), tPosY + random(5), PlayerCache[i][pPosZ], 10.0);
				}
				return 1;
	        }
	    }
	}
	return 1;
}

public OnPlayerPickUpDynamicPickup(playerid, pickupid)
{
	new DoorData[sDoorInfo];
	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, pickupid, E_STREAMER_EXTRA_ID, DoorData);
	
 	new	string[256], lock_text[128], enter_pay[64];

	if(DoorData[dEnterPay])
	{
		format(enter_pay, sizeof(enter_pay), "~w~~n~Koszt wstepu: ~g~$%d~n~", DoorData[dEnterPay]);
 	}
  	else
  	{
 		format(enter_pay, sizeof(enter_pay), "_");
  	}
   	if(DoorData[dLocked])
    {
    	format(lock_text, sizeof(lock_text), "~r~~h~Drzwi sa zamkniete");
    }
    else
    {
   		format(lock_text, sizeof(lock_text), "~y~Aby wejsc, wcisnij jednoczesnie~n~~w~[~b~~h~~h~~k~~SNEAK_ABOUT~ + ~k~~PED_SPRINT~~w~]");
	}
	if(PlayerCache[playerid][pAdmin] & A_PERM_DOORS)
	{
 		format(string, sizeof(string), "%s (%d)~n~%s~n~%s", DoorData[dName], DoorData[dUID], enter_pay, lock_text);
	}
	else
	{
 		format(string, sizeof(string), "%s~n~%s~n~%s", DoorData[dName], enter_pay, lock_text);
	}
 	TD_ShowDoor(playerid, 5, string);
	return 1;
}

public OnVehicleMod(playerid, vehicleid, componentid)
{
	return 1;
}

public OnVehiclePaintjob(playerid, vehicleid, paintjobid)
{
	return 1;
}

public OnVehicleRespray(playerid, vehicleid, color1, color2)
{
	return 1;
}

public OnVehicleDamageStatusUpdate(vehicleid, playerid)
{
	new panels, doors, lights, tires;
    GetVehicleDamageStatus(vehicleid, panels, doors, lights, tires);
    
	if(CarInfo[vehicleid][cHealth] <= 900.0)
	{
    	format(CarInfo[vehicleid][cVisual], 32, "%d %d %d %d", panels, doors, lights, tires);
	}
	else
	{
	    format(CarInfo[vehicleid][cVisual], 32, "0 0 0 %d", panels, doors, lights, tires);
	}
	new veh_visual[4];
	
	sscanf(CarInfo[vehicleid][cVisual], "a<d>[4]", veh_visual);
	UpdateVehicleDamageStatus(vehicleid, veh_visual[0], veh_visual[1], veh_visual[2], veh_visual[3]);
	return 1;
}

public OnPlayerSelectedMenuRow(playerid, row)
{
	return 1;
}

public OnPlayerExitedMenu(playerid)
{
	return 1;
}

public OnPlayerInteriorChange(playerid, newinteriorid, oldinteriorid)
{
	// Spectate
 	foreach(new i : Player)
  	{
   		if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
     	{
      		if(PlayerCache[i][pSpectate] == playerid)
        	{
         		SetPlayerInterior(i, newinteriorid);
         	}
        }
   	}
	return 1;
}

public OnPlayerKeyStateChange(playerid, newkeys, oldkeys)
{
	if(GetPlayerState(playerid) == PLAYER_STATE_ONFOOT)
	{
		if(newkeys == KEY_WALK + KEY_SPRINT)
		{
			new Float:PosX, Float:PosY, Float:PosZ,
				virtual_world = GetPlayerVirtualWorld(playerid), interior_id = GetPlayerInterior(playerid);

			GetPlayerPos(playerid, PosX, PosY, PosZ);

			new NearDoor[MAX_VIS_DOORS],
				count_doors = Streamer_GetNearbyItems(PosX, PosY, PosZ, STREAMER_TYPE_PICKUP, NearDoor, MAX_VIS_DOORS, 2.0, virtual_world);

			if(count_doors > 0)
			{
				for (new door = 0; door < count_doors; door++)
				{
					OnPlayerEnterDoor(playerid, NearDoor[door]);
					break;
				}
			}
			else
			{
				new DoorData[sDoorInfo];
				count_doors = Streamer_GetUpperBound(STREAMER_TYPE_PICKUP);

				for (new door = 0; door <= count_doors; door++)
				{
				    if(IsValidDynamicPickup(door))
				    {
					    Streamer_GetArrayData(STREAMER_TYPE_PICKUP, door, E_STREAMER_EXTRA_ID, DoorData);
					    if(DoorData[dExitVW] == virtual_world && DoorData[dExitInt] == interior_id)
					    {
					        if(IsPlayerInRangeOfPoint(playerid, 2.0, DoorData[dExitX], DoorData[dExitY], DoorData[dExitZ]))
					        {
								OnPlayerExitDoor(playerid, door);
								break;
					        }
					    }
					}
				}
			}
		}
		/*
		if(newkeys & KEY_YES)
		{
		    print("Wcisnął Y");
		    
		    //EnablePlayerCameraTarget(playerid, true);
		
		    new object_id = GetPlayerCameraTargetDynObject(playerid);
		    if(object_id != INVALID_OBJECT_ID)
		    {
				new object_type = GetObjectModel(object_id);
				switch(object_type)
				{
				    case OBJECT_BUSSTOP:    SendClientMessage(playerid, COLOR_WHITE, "Przystanek");
				    case OBJECT_ATM:        SendClientMessage(playerid, COLOR_RED, "Bankomat");
				}
		    }
		    
		}
		if(oldkeys & KEY_YES)
		{
		    //EnablePlayerCameraTarget(playerid, false);
		    
			print("Puścił Y");
		}
		*/

		// Strefa
		if(PlayerCache[playerid][pCreatingArea])
		{
		    // PPM
		    if(newkeys & KEY_HANDBRAKE)
		    {
				if(GetPlayerVirtualWorld(playerid) == 0)
				{
			    	new Float:PosZ;
			    	GetPlayerPos(playerid, PlayerCache[playerid][pCreatingAreaPos][2], PlayerCache[playerid][pCreatingAreaPos][3], PosZ);

					new area_uid = CreateArea(PlayerCache[playerid][pCreatingAreaPos][0], PlayerCache[playerid][pCreatingAreaPos][1], PlayerCache[playerid][pCreatingAreaPos][2], PlayerCache[playerid][pCreatingAreaPos][3], 0, 0.0, 0.0);
					PlayerCache[playerid][pCreatingArea] = false;

					ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Strefa (UID: %d) została pomyślnie stworzona.\nSkorzystaj z komendy /strefa, by zarządzać wybraną strefą.", area_uid);
				}
				else
				{
					new door_uid = GetPlayerVirtualWorld(playerid),
						doorid = GetDoorID(door_uid), areaid = GetDoorAreaID(doorid);

					if(doorid == INVALID_DOOR_ID)
					{
					    PlayerCache[playerid][pCreatingArea] = false;
					    return 1;
					}
						
					new DoorData[sDoorInfo];
					Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
						
					GetPlayerPos(playerid, PlayerCache[playerid][pCreatingAreaPos][3], PlayerCache[playerid][pCreatingAreaPos][4], PlayerCache[playerid][pCreatingAreaPos][5]);

					if(areaid != INVALID_AREA_ID)	DeleteArea(areaid);
					CreateArea(PlayerCache[playerid][pCreatingAreaPos][0], PlayerCache[playerid][pCreatingAreaPos][1], PlayerCache[playerid][pCreatingAreaPos][3], PlayerCache[playerid][pCreatingAreaPos][4], door_uid, PlayerCache[playerid][pCreatingAreaPos][2], PlayerCache[playerid][pCreatingAreaPos][5]);
					
					PlayerCache[playerid][pCreatingArea] = false;
					TD_ShowHint(playerid, HINT_NONE, 5, "Pomyslnie ustalono metraz dla drzwi %s (UID: %d).", DoorData[dName], DoorData[dUID]);
				}
			}
			
			if(newkeys & KEY_SECONDARY_ATTACK)
			{
   				PlayerCache[playerid][pCreatingArea] = false;
		    	ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Tworzenie strefy zostało anulowane.");
			}
		}
		
		// Akcesorie
		if(PlayerCache[playerid][pSelectAccess] != INVALID_ACCESS_ID)
		{
		    // Zatwierdź
		    if(newkeys & KEY_SECONDARY_ATTACK)
		    {
		        new access_id = PlayerCache[playerid][pSelectAccess];
		        if(PlayerCache[playerid][pCash] < AccessData[access_id][aPrice])
		        {
		            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie stać Cię na zakup tego akcesoria.");
		            return 1;
		        }
        		if(!(PlayerCache[playerid][pAdmin] & A_PERM_ITEMS) && GetPlayerCapacity(playerid) <= 0)
				{
				    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Twoja postać nie jest w stanie unieść więcej przedmiotów.");
				    return 1;
				}
		        crp_GivePlayerMoney(playerid, -AccessData[access_id][aPrice]);
		        orm_update(PlayerCache[playerid][pOrm]);
		        
       			ResetPlayerCamera(playerid);
				OnPlayerFreeze(playerid, false, 0);
		        
		        RemovePlayerAttachedObject(playerid, SLOT_TRYING);
		        GameTextForPlayer(playerid, "_", 0, 6);
				
				PlayerCache[playerid][pSelectAccess] = INVALID_ACCESS_ID;
		        
		        CreatePlayerItem(playerid, AccessData[access_id][aName], ITEM_CLOTH_ACCESS, 0, AccessData[access_id][aUID]);
				TD_ShowSmallInfo(playerid, 3, "Akcesorie zostalo ~y~kupione ~w~pomyslnie.~n~Przedmiot znajdziesz w swoim ~b~ekwipunku~w~.");
		    }
		    
		    // Anuluj
		    if(newkeys & KEY_JUMP)
		    {
		        ResetPlayerCamera(playerid);
				OnPlayerFreeze(playerid, false, 0);
				
    			RemovePlayerAttachedObject(playerid, SLOT_TRYING);
		        GameTextForPlayer(playerid, "_", 0, 6);
				
				PlayerCache[playerid][pSelectAccess] = INVALID_ACCESS_ID;
				TD_ShowSmallInfo(playerid, 3, "Zakup akcesoria zostal ~r~anulowany~w~.");
		    }
		}
		
		// Ubranie
		if(PlayerCache[playerid][pSelectSkin] != INVALID_SKIN_ID)
		{
		    // Zatwierdź
		    if(newkeys & KEY_SECONDARY_ATTACK)
		    {
		        new skin_id = PlayerCache[playerid][pSelectSkin];
		        if(PlayerCache[playerid][pCash] < SkinData[skin_id][sPrice])
		        {
		            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie stać Cię na zakup tego ubrania.");
		            return 1;
		        }
        		if(!(PlayerCache[playerid][pAdmin] & A_PERM_ITEMS) && GetPlayerCapacity(playerid) <= 0)
				{
				    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Twoja postać nie jest w stanie unieść więcej przedmiotów.");
				    return 1;
				}
		        crp_GivePlayerMoney(playerid, -SkinData[skin_id][sPrice]);
		        orm_update(PlayerCache[playerid][pOrm]);

       			ResetPlayerCamera(playerid);
				OnPlayerFreeze(playerid, false, 0);

		        GameTextForPlayer(playerid, "_", 0, 6);
				
		        PlayerCache[playerid][pSelectSkin] = INVALID_SKIN_ID;
		        SetPlayerSkin(playerid, PlayerCache[playerid][pSkin]);
		        
		        CreatePlayerItem(playerid, SkinData[skin_id][sName], ITEM_CLOTH, SkinData[skin_id][sModel], 0);
				TD_ShowSmallInfo(playerid, 3, "Ubranie zostalo ~y~kupione ~w~pomyslnie.~n~Przedmiot znajdziesz w swoim ~b~ekwipunku~w~.");
		    }
		    
		    // Anuluj
		    if(newkeys & KEY_JUMP)
		    {
      			ResetPlayerCamera(playerid);
				OnPlayerFreeze(playerid, false, 0);

		        GameTextForPlayer(playerid, "_", 0, 6);
				PlayerCache[playerid][pSelectSkin] = INVALID_SKIN_ID;
				
    			SetPlayerSkin(playerid, PlayerCache[playerid][pSkin]);
				TD_ShowSmallInfo(playerid, 3, "Zakup ubrania zostal ~r~anulowany~w~.");
		    }
		}
		
		// Siłownia
		if(PlayerCache[playerid][pGymObject] != INVALID_OBJECT_ID)
		{
		    new object_id = PlayerCache[playerid][pGymObject],
		        anim_id = GetPlayerAnimationIndex(playerid);
            
            // Ławeczka
		    if(GetObjectModel(object_id) == OBJECT_BENCH)
		    {
		        if(newkeys == KEY_SECONDARY_ATTACK)
				{
		            ApplyAnimation(playerid, "BENCHPRESS", "gym_bp_getoff", 4.0, 0, 0, 0, 0, 0, true);
		            anim_id = GetPlayerAnimationIndex(playerid);
		        }
		    
				switch(anim_id)
				{
				    case 47:
				    {
						if(newkeys == KEY_SPRINT)
						{
						    PlayerCache[playerid][pMainTable] = gettime();
      						ApplyAnimation(playerid, "BENCHPRESS", "gym_bp_up_A", 4.0, 0, 0, 0, 1, 0, true);
						}
				    }
				    case 50:
				    {
						if(oldkeys == KEY_SPRINT)
						{
							ApplyAnimation(playerid, "BENCHPRESS", "gym_bp_down", 4.0, 0, 0, 0, 1, 0, true);
							
							if(PlayerCache[playerid][pMainTable] + 2 <= gettime())
							{
								PlayerCache[playerid][pGymRepeat] ++;
								PlayerCache[playerid][pMainTable] = gettime();
							}
							else													GameTextForPlayer(playerid, "~n~~n~~n~~r~Wyciskaj do konca!", 1000, 3);

							TD_ShowHint(playerid, HINT_NONE, 0, "Powtorzenia: ~b~~h~%d~n~~n~Mozesz sprobowac tez ~r~treningu ~w~po uzyciu ~y~odzywek~w~, ktore zakupisz w silowni.", PlayerCache[playerid][pGymRepeat]);
						}
				    }
				    default:
				    {
				        PlayerCache[playerid][pStrength] = (PlayerCache[playerid][pDrugType] == DRUG_CONDITIONER && PlayerCache[playerid][pGymRepeat] > 100) ? PlayerCache[playerid][pStrength] + ((PlayerCache[playerid][pGymRepeat] + PlayerCache[playerid][pDrugValue1]) / 8) : PlayerCache[playerid][pStrength] + (PlayerCache[playerid][pGymRepeat] / 8);
				    
				        PlayerCache[playerid][pGymObject] 	= INVALID_OBJECT_ID;
				        PlayerCache[playerid][pGymRepeat] 	= 0;
				        
				        RemovePlayerAttachedObject(playerid, SLOT_TRAIN);
				        TD_ShowSmallInfo(playerid, 3, "Trening zostal ~g~pomyslnie ~w~zakonczony.");
				        
				        TD_HideHint(playerid);
				    }
				}
		    }

		    // Hantelki
		    if(GetObjectModel(object_id) == OBJECT_BARBELL)
		    {
      			if(newkeys == KEY_SECONDARY_ATTACK)
				{
		            ApplyAnimation(playerid, "FREEWEIGHTS", "gym_free_putdown", 4.0, 0, 0, 0, 0, 0, true);
		            anim_id = GetPlayerAnimationIndex(playerid);
		        }
		    
		        switch(anim_id)
		        {
		            case 571:
		            {
           				if(oldkeys == KEY_SPRINT)
		                {
		                    ApplyAnimation(playerid, "FREEWEIGHTS", "gym_free_down", 4.0, 0, 0, 0, 1, 0, true);
		                    
   							if(PlayerCache[playerid][pMainTable] + 2 <= gettime())
							{
								PlayerCache[playerid][pGymRepeat] ++;
								PlayerCache[playerid][pMainTable] = gettime();
							}
							else													GameTextForPlayer(playerid, "~n~~n~~n~~r~Wyciskaj do konca!", 1000, 3);

							TD_ShowHint(playerid, HINT_NONE, 0, "Powtorzenia: ~b~~h~%d~n~~n~Mozesz sprobowac tez ~r~treningu ~w~po uzyciu ~y~odzywek~w~, ktore zakupisz w silowni.", PlayerCache[playerid][pGymRepeat]);
						}
		            }
		            case 573:
		            {
						if(newkeys == KEY_SPRINT)
						{
						    PlayerCache[playerid][pMainTable] = gettime();
      						ApplyAnimation(playerid, "FREEWEIGHTS", "gym_free_B", 4.0, 0, 0, 0, 1, 0, true);
						}
		            }
		            default:
		            {
		                PlayerCache[playerid][pStrength] = (PlayerCache[playerid][pDrugType] == DRUG_CONDITIONER && PlayerCache[playerid][pGymRepeat] > 100) ? PlayerCache[playerid][pStrength] + ((PlayerCache[playerid][pGymRepeat] + PlayerCache[playerid][pDrugValue1]) / 8) : PlayerCache[playerid][pStrength] + (PlayerCache[playerid][pGymRepeat] / 8);
		            
  				        PlayerCache[playerid][pGymObject] 	= INVALID_OBJECT_ID;
				        PlayerCache[playerid][pGymRepeat] 	= 0;

						RemovePlayerAttachedObject(playerid, SLOT_TRAIN);
				        TD_ShowSmallInfo(playerid, 3, "Trening zostal ~g~pomyslnie ~w~zakonczony.");
				        
				        TD_HideHint(playerid);
		            }
		        }
		    }
		}
		
		// Styl rozmowy
		if(PlayerCache[playerid][pSelectTalkStyle])
		{
		    if(newkeys & KEY_SECONDARY_ATTACK)
		    {
		        ResetPlayerCamera(playerid);
		        ClearAnimations(playerid, true);
		        
		        GameTextForPlayer(playerid, "_", 0, 6);
		        OnPlayerFreeze(playerid, false, 0);
		        
		        PlayerCache[playerid][pSelectTalkStyle] = false;
		    
				orm_update(PlayerCache[playerid][pOrm]);
				TD_ShowSmallInfo(playerid, 3, "Wybrany styl zostal ~g~pomyslnie ~w~zapisany.");
		    }
		}
		
		// Przerywanie animacji
 		if(PlayerCache[playerid][pPlayAnim])
	 	{
	 	    if(newkeys & KEY_HANDBRAKE)
	 	    {
		        PlayerCache[playerid][pPlayAnim] = false;
		    	ApplyAnimation(playerid, "CARRY", "crry_prtial", 4.1, 0, 0, 0, 0, 0, true);
			}
		}
		
		// Animacja chodzenia
		if(PlayerCache[playerid][pWalkStyle] != INVALID_ANIM_ID)
		{
  			if(newkeys & KEY_WALK)
  			{
       			new anim_id = PlayerCache[playerid][pWalkStyle];
       			if(AnimCache[anim_id][aAction])
       			{
       			    SetPlayerSpecialAction(playerid, AnimCache[anim_id][aAction]);
       			}
       			else
       			{
           			ApplyAnimation(playerid, AnimCache[anim_id][aLib], AnimCache[anim_id][aName], AnimCache[anim_id][aSpeed], AnimCache[anim_id][aOpt1], AnimCache[anim_id][aOpt2], AnimCache[anim_id][aOpt3], AnimCache[anim_id][aOpt4], AnimCache[anim_id][aOpt5], true);
				}
				PlayerCache[playerid][pPlayAnim] = true;
			}
		}
		
		// Wybór przystanku
		if(PlayerCache[playerid][pBusStart] != INVALID_OBJECT_ID && PlayerCache[playerid][pBusTravel] == INVALID_OBJECT_ID)
		{
		    if(newkeys & KEY_JUMP)
		    {
   				new object_id = GetClosestBusStop(playerid), string[128],
					Float:PosX, Float:PosY, Float:PosZ;
					
				if(object_id != INVALID_OBJECT_ID)
				{
					GetDynamicObjectPos(object_id, PosX, PosY, PosZ);

					SetPlayerCameraPos(playerid, PosX, PosY, PosZ + 30.0);
					SetPlayerCameraLookAt(playerid, PosX, PosY + 2, PosZ, CAMERA_MOVE);

					PlayerCache[playerid][pBusPosition][0] = PosX;
					PlayerCache[playerid][pBusPosition][1] = PosY;
					PlayerCache[playerid][pBusPosition][2] = PosZ;

					crp_SetPlayerPos(playerid, PosX, PosY, PosZ - 80.0);
					PlayerCache[playerid][pBusTravel] = object_id;

					new Float:Distance;
					Streamer_GetDistanceToItem(PosX, PosY, PosZ, STREAMER_TYPE_OBJECT, PlayerCache[playerid][pBusStart], Distance);
						
					PlayerCache[playerid][pBusTime] = floatround(Distance, floatround_floor) / 15;
					PlayerCache[playerid][pBusPrice] = floatround(Distance, floatround_floor) / 20;

					if(PlayerCache[playerid][pHours] < 5)	PlayerCache[playerid][pBusPrice] = 0;
						
 					format(string, sizeof(string), "Przejazd: %d <-> %d\n\nCzas trwania jazdy: %ds\nKoszt przejazdu: $%d\n\nCzy jesteś pewien, że chcesz się tutaj udać?", GetObjectUID(PlayerCache[playerid][pBusStart]), GetObjectUID(PlayerCache[playerid][pBusTravel]), PlayerCache[playerid][pBusTime], PlayerCache[playerid][pBusPrice]);
  					ShowPlayerDialog(playerid, D_BUS_ACCEPT, DIALOG_STYLE_MSGBOX, "Bus", string, "Tak", "Nie");
  					
  					TD_HideSmallInfo(playerid);
				}
		    }
		    
		    if(newkeys & KEY_SECONDARY_ATTACK)
		    {
				new object_id = PlayerCache[playerid][pBusStart],
				    Float:PosX, Float:PosY, Float:PosZ;
				    
				GetDynamicObjectPos(object_id, PosX, PosY, PosZ);
				
				crp_SetPlayerPos(playerid, PosX, PosY, PosZ);
				ResetPlayerCamera(playerid);
				
				PlayerCache[playerid][pBusStart] 	= INVALID_OBJECT_ID;
				PlayerCache[playerid][pBusTravel]   = INVALID_OBJECT_ID;
				
				OnPlayerFreeze(playerid, false, 0);
				Streamer_ToggleCameraUpdate(playerid, false);
				
				TD_ShowSmallInfo(playerid, 3, "Przejazdzka zostala ~r~anulowana~w~.");
		    }
		}
		
		// Jazda na rolkach
		if(PlayerCache[playerid][pRoll])
	    {
	        if(newkeys & KEY_SPRINT)
	        {
	     		if(GetPlayerSpeed(playerid, true) > 5)
	       		{
		        	ApplyAnimation(playerid, "SKATE", "skate_run", 3.0, 1, 1, 1, 1, 1, true);
			        PlayerCache[playerid][pPlayAnim] = true;
				}
			}
			
			if(oldkeys & KEY_SPRINT)
			{
			    ApplyAnimation(playerid, "CARRY", "crry_prtial", 4.0, 0, 0, 0, 0, 0, 1);
			}
	    }
	    
	    // Palenie jointa
	    if(PlayerCache[playerid][pDrugType] == DRUG_MARIHUANA)
	    {
			if(GetPlayerSpecialAction(playerid) == SPECIAL_ACTION_SMOKE_CIGGY)
			{
			    if(newkeys & KEY_FIRE)
			    {
					if(PlayerCache[playerid][pMainTable] + 3 <= gettime())
					{
					    PlayerCache[playerid][pDrugValue1] --;
					    if(PlayerCache[playerid][pDrugValue1] <= 0)	SetPlayerSpecialAction(playerid, SPECIAL_ACTION_NONE);
					    
						PlayerCache[playerid][pDrugLevel] ++;
						PlayerCache[playerid][pMainTable] = gettime();
						
						switch(PlayerCache[playerid][pDrugLevel])
						{
						    case 5:
						    {
								SetPlayerWeather(playerid, -2);
								SendClientMessage(playerid, COLOR_DO, "** Odczuwasz znaczne polepszenie nastroju, jesteś w fazie euforii. **");
						    }
						    case 15:
						    {
						        SetPlayerWeather(playerid, 170);
						        SendClientMessage(playerid, COLOR_DO, "** Twoje mięśnie są rozluźnione, jesteś lekko rozkojarzony. **");
						    }
						    case 20:
						    {
						        SetPlayerWeather(playerid, -38);
						        SendClientMessage(playerid, COLOR_DO, "** Odczuwasz znaczne pobudzenie wyobraźni, stajesz się bardziej wrażliwy. **");
						    }
						    case 30:
						    {
						        SetPlayerWeather(playerid, -15);
						        SetPlayerSpecialAction(playerid, SPECIAL_ACTION_NONE);
						    
                                ApplyAnimation(playerid, "CRACK" , "crckidle1", 4.1, 1, 0, 0, 1, 15000, true);
                                SendClientMessage(playerid, COLOR_DO, "** Jesteś całkowicie rozluźniony, odczuwasz lekki bezwład nóg. **");
						    }
						}
					}
			    }
			}
	    }
	    
	    /*
	    // Celowanie z broni
	    if(PlayerCache[playerid][pItemWeapon] != INVALID_ITEM_ID)
	    {
	   		if(GetPlayerWeapon(playerid) > 15 && GetPlayerWeapon(playerid) < 43)
			{
			    if(GetPlayerDrunkLevel(playerid) < 2500)
			    {
			        if(PlayerCache[playerid][pStrength] < 5000)
			        {
					    if(newkeys & 128)
						{
							SetPlayerDrunkLevel(playerid, 2500);
						}
						else
						{
							if(oldkeys & 128)
							{
								SetPlayerDrunkLevel(playerid, 0);
							}
						}
					}
				}
			}
	    }*/
	    
		// Rzuty do kosza
		if(PlayerCache[playerid][pBasketObject] != INVALID_OBJECT_ID)
		{
		    if(newkeys & KEY_HANDBRAKE)
			{
			    new object_id = PlayerCache[playerid][pBasketObject],
			        Float:oPosX, Float:oPosY, Float:oPosZ;
			        
			    GetDynamicObjectPos(object_id, oPosX, oPosY, oPosZ);
			    if(!IsPlayerInRangeOfPoint(playerid, 15.0, oPosX, oPosY, oPosZ))
			    {
  	    			DestroyDynamicObject(PlayerCache[playerid][pBasketBall]);

				    PlayerCache[playerid][pBasketObject] 	= INVALID_OBJECT_ID;
				    PlayerCache[playerid][pBasketBall]      = INVALID_OBJECT_ID;

					TD_ShowSmallInfo(playerid, 3, "Gra w kosza zostala ~r~zakonczona~w~.");
			        return 1;
			    }
			
			    new ball_object_id = PlayerCache[playerid][pBasketBall],
					Float:PosX, Float:PosY, Float:PosZ;
					
				GetPlayerPos(playerid, PosX, PosY, PosZ);
		        ApplyAnimation(playerid, "CAMERA", "camstnd_idleloop", 4.1, 0, 0, 0, 1, 0, true);
		        
		        GetXYInFrontOfPlayer(playerid, PosX, PosY, 0.2);
		        SetDynamicObjectPos(ball_object_id, PosX, PosY, PosZ + 0.3);
		        
		        TD_ShowSmallInfo(playerid, 0, "Wcisnij i przytrzymaj ~g~~k~~PED_FIREWEAPON~~w~, aby rzucic do kosza.~n~Pamietaj zeby dobrze ~y~przymierzyc!");
		    }
		    
		    if(GetPlayerAnimationIndex(playerid) == 239)
		    {
			    if(newkeys & KEY_FIRE)
			    {
					PlayerCache[playerid][pMainTable] = gettime();
			    }

			    if(oldkeys & KEY_FIRE)
			    {
			        new object_id = PlayerCache[playerid][pBasketObject], ball_object_id = PlayerCache[playerid][pBasketBall], Float:distance;
			        Streamer_GetDistanceToItem(PlayerCache[playerid][pPosX], PlayerCache[playerid][pPosY], PlayerCache[playerid][pPosZ], STREAMER_TYPE_OBJECT, object_id, distance);

					new Float:vPosX, Float:vPosY, Float:vPosZ,
					    Float:oPosX, Float:oPosY, Float:oPosZ,
					    Float:tPosX, Float:tPosY, Float:tPosZ;
					
                    GetPlayerCameraFrontVector(playerid, vPosX, vPosY, vPosZ);

					tPosX = (PlayerCache[playerid][pPosX] + floatmul(vPosX, distance));
					tPosY = (PlayerCache[playerid][pPosY] + floatmul(vPosY, distance));
					tPosZ = (PlayerCache[playerid][pPosZ] + floatmul(vPosZ, distance));
					
					GetDynamicObjectPos(object_id, oPosX, oPosY, oPosZ);
					GetXYBehindOfObject(object_id, oPosX, oPosY, 0.5);
					
					MoveDynamicObject(ball_object_id, tPosX, tPosY, tPosZ, 10.0);
					ApplyAnimation(playerid, "BSKTBALL", "BBALL_Jump_Shot", 4.1, 0, 0, 0, 0, 0, true);
			    }
			}
		}
		
		if(newkeys & KEY_NO)
		{
		    ListPlayerFavoriteItems(playerid);
		    
		    TD_HideHint(playerid);
		    TD_ShowHint(playerid, HINT_KEY_NO, 0, "Tym klawiszem bedziesz mogl ~r~zamknac ~w~kazda wyswietlona ~p~informacje ~w~w tym oknie, ale sluzy to rowniez do ~y~manipulowania ~w~ulubionymi przedmiotami, o ktorych dowiesz sie w dalszym etapie gry.~n~~n~Udaj sie teraz do najblizszego ~r~przystanku ~w~i wyrusz stamtad do Ratusza, by wyrobic niezbedne do gry ~y~dokumenty ~w~Twojej postaci.~n~~n~Na mapie zostal zaznaczony najblizszy ~r~przystanek~w~, udaj sie tam.");
		}
		
		// Drwal
		if(WorkInfo[playerid][wID] == JOB_LUMBERJACK && WorkInfo[playerid][wValue][0] != 0)
  		{
			if(newkeys & KEY_FIRE)
			{
				new areaid = WorkInfo[playerid][wValue][0], AreaData[sAreaData];
				Streamer_GetArrayData(STREAMER_TYPE_AREA, areaid, E_STREAMER_EXTRA_ID, AreaData);
				
				if(AreaData[aFlags] & A_FLAG_LUMBERJACK)
				{
				    new object_id = GetClosestObjectType(playerid, OBJECT_TREE, 2.0);
				    if(object_id == INVALID_OBJECT_ID)
					{
						TD_ShowSmallInfo(playerid, 3, "Musisz znajdowac sie w poblizu ~y~drzewa~w~.");
						return 1;
					}
					
					foreach(new i : Player)
					{
					    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
					    {
					        if(WorkInfo[i][wID] == JOB_LUMBERJACK && WorkInfo[i][wValue][0] == areaid)
					        {
					            if(WorkInfo[i][wExtraID] == object_id)
					            {
					                TD_ShowSmallInfo(playerid, 3, "Ktos aktualnie ~r~scina ~w~to drzewo.");
					                return 1;
					            }
					        }
					    }
					}
					
					WorkInfo[playerid][wExtraID] = object_id;
					WorkInfo[playerid][wValue][1] = gettime();
					
					ApplyAnimation(playerid, "CHAINSAW", "WEAPON_csaw", 4.1, 1, 0, 0, 1, 0, 1);
					TD_ShowSmallInfo(playerid, 5, "Trzymaj przycisk, dopoki drzewo nie zostanie ~r~sciete~w~.");
				}
			}
			
			if(oldkeys & KEY_FIRE)
			{
				if(WorkInfo[playerid][wExtraID] != 0)
				{
				    if(gettime() - WorkInfo[playerid][wValue][1] < 15)
				    {
				        TD_ShowSmallInfo(playerid, 5, "Za krotko trwalo ~r~scinanie ~w~drzewa. Musisz dluzej ~y~trzymac ~w~przycisk!");
                        WorkInfo[playerid][wExtraID] = 0;
					}
				    ApplyAnimation(playerid, "CARRY", "crry_prtial", 4.0, 0, 0, 0, 0, 0, 1);
				}
		    }
		}
		
		// Przemyt
		if(MissionData[playerid][mType] == MISSION_SMUGGLE)
		{
			if(MissionData[playerid][mLevel] == 1)
			{
			    if(newkeys & KEY_YES)
			    {
			        new object_id = GetClosestObjectType(playerid, OBJECT_SMUGGLE_CRATE, 2.0);
					if(object_id == INVALID_OBJECT_ID)
					{
						return 1;
					}
					if(!Streamer_IsInArrayData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_PLAYER_ID, playerid))
					{
					    return 1;
					}
					new mission_leader = GetMissionLeader(MissionData[playerid][mUID]);
					
					foreach(new i : MissionPlayer[mission_leader])
					{
						Streamer_RemoveArrayData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_PLAYER_ID, i);
						Streamer_Update(i, STREAMER_TYPE_OBJECT);
					}
					
					SetPlayerAttachedObject(playerid, SLOT_EXTRA, 2969, 6, 0.077999, 0.043999, -0.170999, -13.799953, 79.70, 0.0);
                    SetPlayerSpecialAction(playerid, SPECIAL_ACTION_CARRY);
                    
                    MissionData[playerid][mLevel] = 2;
                    
                    new vehid = MissionData[playerid][mValue][0],
                        Float:vehPosX, Float:vehPosY, Float:vehPosZ;
                        
					GetVehiclePos(vehid, vehPosX, vehPosY, vehPosZ);
                        
					SetPlayerCheckpoint(playerid, vehPosX, vehPosY, vehPosZ, 5.0);
					PlayerCache[playerid][pCheckpoint] = CHECKPOINT_MISSION;
					
					TD_ShowSmallInfo(playerid, 5, "Zanies ten ladunek w ~r~okolice ~w~pojazdu dostawczego.");
			    }
			}
		}

		if((((newkeys & (KEY_CTRL_BACK)) == (KEY_CTRL_BACK)) && ((oldkeys & (KEY_CTRL_BACK)) != (KEY_CTRL_BACK))))
		{
			new giveplayer_id = GetPlayerCameraTargetPlayer(playerid), string[128];
			if(giveplayer_id != INVALID_PLAYER_ID)
			{
			    if(!PlayerToPlayer(2.0, playerid, giveplayer_id))
			    {
			        return 1;
			    }
				for(new o = 0; o < 8; o++)
				{
					if(o == GII_OPTION_CARP || o == GII_OPTION_CART || o == GII_OPTION_KEYS)
					{
					    continue;
					}
					
					if(o == GII_OPTION_HANDCUFF)
					{
    					if(PlayerCache[playerid][pDuty][DUTY_GROUP] != INVALID_GROUP_ID && HavePlayerItemType(playerid, ITEM_HANDCUFFS))
						{
							new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
							if(!(GroupData[group_id][gFlags] & G_FLAG_HANDCUFFS) || (PlayerCache[giveplayer_id][pCuffedTo] != INVALID_PLAYER_ID && PlayerCache[giveplayer_id][pCuffedTo] != playerid))
							{
								continue;
							}
					 	}
					 	else
					 	{
					 	    continue;
						}
					}
					
	   				TextDrawShowForPlayer(playerid, Text:GII_Option[o]);
	   				format(string, sizeof(string), "Interakcja~n~%s (%d)", PlayerName(giveplayer_id), giveplayer_id);

					PlayerCache[playerid][pMainTable] = giveplayer_id;
					PlayerCache[playerid][pGII_Type] = 1;
				}
			}
			else
			{
			    new vehid = GetPlayerCameraTargetVehicle(playerid);
			    if(vehid == INVALID_VEHICLE_ID)
				{
				    return 1;
				}
				if(GetDistanceToVehicle(playerid, vehid) >= 4.0)
				{
				    return 1;
				}
				
				for(new o = 0; o < 8; o++)
				{
					if(o == GII_OPTION_HANDCUFF || o == GII_OPTION_WELCOME)
					{
					    continue;
					}
					
					if(o == GII_OPTION_CARP || o == GII_OPTION_CART || o == GII_OPTION_KEYS)
					{
				    	if(!(PlayerCache[playerid][pAdmin] & A_PERM_CARS))
					    {
						    if(CarInfo[vehid][cOwnerType] == OWNER_NONE || CarInfo[vehid][cOwnerType] == OWNER_WORK)
						    {
						        continue;
						    }
					   		if(CarInfo[vehid][cOwnerType] == OWNER_PLAYER && CarInfo[vehid][cOwner] != PlayerCache[playerid][pUID])
							{
								continue;
							}
							if(CarInfo[vehid][cOwnerType] == OWNER_GROUP)
							{
							    if(!HavePlayerGroupPerm(playerid, CarInfo[vehid][cOwner], G_PERM_CARS))
							    {
							        continue;
							    }
							}
						}
					}
	   				TextDrawShowForPlayer(playerid, Text:GII_Option[o]);
				}
				
 				PlayerCache[playerid][pGII_Type] = 2;
				format(string, sizeof(string), "Interakcja~n~%s (%d)", GetVehicleName(CarInfo[vehid][cModel]), CarInfo[vehid][cUID]);

            	PlayerCache[playerid][pMainTable] = vehid;
			}
			PlayerTextDrawSetString(playerid, PlayerText:GII_VisualItem[playerid], string);
			PlayerTextDrawShow(playerid, PlayerText:GII_VisualItem[playerid]);
			
			SelectTextDraw(playerid, COLOR_YELLOW);
		}
	    return 1;
	}
	
	if(GetPlayerState(playerid) == PLAYER_STATE_DRIVER)
	{
 		new vehid = GetPlayerVehicleID(playerid);
 		
		// Skakanie na rowerku
		new model = GetVehicleModel(vehid);
		if(model == 509 || model == 510 || model == 481)
  		{
			if(newkeys & 1)
			{
			    new areaid = GetPlayerAreaID(playerid), AreaData[sAreaData];
			    Streamer_GetArrayData(STREAMER_TYPE_AREA, areaid, E_STREAMER_EXTRA_ID, AreaData);
			    
  		    	if(!(AreaData[aFlags] & A_FLAG_BMX))
  		    	{
	                ClearAnimations(playerid);
					TD_ShowSmallInfo(playerid, 5, "~r~Skakanie ~w~na rowerze nie jest ~y~dozwolone~w~ w tym miejscu.");
				}
			}
		}
 		
 		// Odpalanie silnika
	    if(newkeys == KEY_ACTION + KEY_FIRE)
	    {
  			pc_cmd_silnik(playerid, "");
  			return 1;
	    }
	    
		// Zapalanie świateł
		if(newkeys & KEY_FIRE)
		{
  			if(GetVehicleLightsStatus(vehid) == 1)
     		{
	    		ChangeVehicleLightsStatus(vehid, false);
       		}
	        else
	        {
                ChangeVehicleLightsStatus(vehid, true);
			}
		}
		
		// Odczepianie holowanego pojazdu
		if(newkeys & KEY_NO)
		{
		    if(IsTrailerAttachedToVehicle(vehid))
		    {
		        DetachTrailerFromVehicle(vehid);
		    }
		}
		
		// Tworzenie wyścigu
		if(PlayerCache[playerid][pRaceCreating])
		{
		    if(newkeys & KEY_FIRE)
		    {
		        if(RaceInfo[playerid][rPoint] < MAX_RACE_CP - 1)
		        {
		        	new checkpoint = RaceInfo[playerid][rPoint];
			        GetVehiclePos(vehid, RaceInfo[playerid][rCPX][checkpoint], RaceInfo[playerid][rCPY][checkpoint], RaceInfo[playerid][rCPZ][checkpoint]);

					GameTextForPlayer(playerid, "~n~~n~~n~~n~~n~~n~~n~~w~Checkpoint ~g~dodany", 3000, 3);
					RaceInfo[playerid][rPoint] ++;
					
					TD_ShowHint(playerid, HINT_NONE, 0, "Rozpoczales ~r~proces ~w~tworzenia wyscigu, ~g~legenda~w~:~n~~n~~y~~k~~VEHICLE_FIREWEAPON~ ~w~- stawia checkpoint~n~~y~~k~~VEHICLE_FIREWEAPON_ALT~ ~w~- ustala linie mety~n~~n~Checkpointy: ~y~%d/%d", RaceInfo[playerid][rPoint], MAX_RACE_CP);
		        }
		        else
		        {
		            GameTextForPlayer(playerid, "~n~~n~~n~~n~~n~~n~~n~~r~Limit checkpointow przekroczony! Ustal linie mety!", 3000, 3);
		        }
		    }
		    
		    if(newkeys & KEY_ACTION)
		    {
    			if(RaceInfo[playerid][rPoint] <= 2)
				{
			        GameTextForPlayer(playerid, "~n~~n~~n~~n~~n~~n~~n~~r~Musza byc conajmniej 3 checkpointy!", 3000, 3);
			        return 1;
			    }
		        new checkpoint = RaceInfo[playerid][rPoint];
		        GetVehiclePos(vehid, RaceInfo[playerid][rCPX][checkpoint], RaceInfo[playerid][rCPY][checkpoint], RaceInfo[playerid][rCPZ][checkpoint]);

				PlayerCache[playerid][pRaceCreating] 	= false;
				PlayerCache[playerid][pRaceCheckpoints] = RaceInfo[playerid][rPoint];

                GameTextForPlayer(playerid, "~n~~n~~n~~n~~n~~n~~n~~w~Linia mety ~y~ustawiona", 3000, 3);
                TD_ShowHint(playerid, HINT_NONE, 10, "Postawiles ~y~linie mety~w~. Mozesz teraz zaprosic rywali do wyscigu komenda ~r~/wyscig zapros~w~.~n~~n~Zeby rozpoczac wyscig wpisz ~y~/wyscig start~w~.~n~Mozesz takze zapisac trase (~p~~h~/wyscig zapisz~w~).");
		    }
		}
		return 1;
	}
	
	if(GetPlayerState(playerid) == PLAYER_STATE_SPECTATING)
	{
	    if(PlayerCache[playerid][pSpectate] != INVALID_PLAYER_ID)
	    {
	        if(newkeys & KEY_WALK)
	        {
                new spectate_player = Iter_Prev(Player, PlayerCache[playerid][pSpectate]);
                if(!Iter_Contains(Player, spectate_player)) spectate_player = Iter_Last(Player);
                
				switch(GetPlayerState(spectate_player))
				{
					case 0, 1, 7, 8:	PlayerSpectatePlayer(playerid, spectate_player);
					case 2, 3:			PlayerSpectateVehicle(playerid , GetPlayerVehicleID(spectate_player));
				}
				
				SetPlayerInterior(playerid, GetPlayerInterior(spectate_player));
				SetPlayerVirtualWorld(playerid, GetPlayerVirtualWorld(spectate_player));
				
                PlayerCache[playerid][pSpectate] = spectate_player;
                
               	new sp = spectate_player, year, month, day, hour, minute, second;
				TimestampToDate(PlayerCache[sp][pSession][SESSION_GAME], year, month, day, hour, minute, second, 1);

				TD_ShowLargeInfo(playerid, 0, "Postac: ~y~%s (%d)    ~w~Globalny: ~g~%s (%d)~w~~n~Zalogowany od: ~y~%02d:%02d~w~     Czas gry: ~b~%dh %dm~w~~n~~n~HP: ~r~%.0f%%~w~     Gotowka: ~g~$%d~w~     Bank: ~g~$%d~w~", PlayerName(sp), PlayerCache[sp][pUID], PlayerCache[sp][pGlobName], PlayerCache[sp][pGID], hour, minute, PlayerCache[sp][pHours], PlayerCache[sp][pMinutes], PlayerCache[sp][pHealth], PlayerCache[sp][pCash], PlayerCache[sp][pBankCash]);
	        }
	        
	        if(newkeys & KEY_SPRINT)
	        {
         		new spectate_player = Iter_Next(Player, PlayerCache[playerid][pSpectate]);
                if(!Iter_Contains(Player, spectate_player)) spectate_player = Iter_First(Player);

				switch(GetPlayerState(spectate_player))
				{
					case 0, 1, 7, 8:	PlayerSpectatePlayer(playerid, spectate_player);
					case 2, 3:			PlayerSpectateVehicle(playerid , GetPlayerVehicleID(spectate_player));
				}
				
				SetPlayerInterior(playerid, GetPlayerInterior(spectate_player));
				SetPlayerVirtualWorld(playerid, GetPlayerVirtualWorld(spectate_player));

                PlayerCache[playerid][pSpectate] = spectate_player;
                
               	new sp = spectate_player, year, month, day, hour, minute, second;
				TimestampToDate(PlayerCache[sp][pSession][SESSION_GAME], year, month, day, hour, minute, second, 1);

				TD_ShowLargeInfo(playerid, 0, "Postac: ~y~%s (%d)    ~w~Globalny: ~g~%s (%d)~w~~n~Zalogowany od: ~y~%02d:%02d~w~     Czas gry: ~b~%dh %dm~w~~n~~n~HP: ~r~%.0f%%~w~     Gotowka: ~g~$%d~w~     Bank: ~g~$%d~w~", PlayerName(sp), PlayerCache[sp][pUID], PlayerCache[sp][pGlobName], PlayerCache[sp][pGID], hour, minute, PlayerCache[sp][pHours], PlayerCache[sp][pMinutes], PlayerCache[sp][pHealth], PlayerCache[sp][pCash], PlayerCache[sp][pBankCash]);
	        }
	        
	        // Odświeżanie
	        if(newkeys & KEY_JUMP)
	        {
	            new params[11], spectate_player = PlayerCache[playerid][pSpectate];
	            format(params, sizeof(params), "%d", spectate_player);
	            
				pc_cmd_spec(playerid, params);
	        }
	    }
	}
	
	if(PlayerCache[playerid][pFlashLight])
	{
	    if(newkeys & KEY_NO)
	    {
			ApplyAnimation(playerid, "COLT45", "colt45_fire", 4.1, 0, 0, 0, 0, 0, true);
	        //SetPlayerAttachedObject(playerid, 0, 18656, 6, 0.107000, -0.009000, -0.117999, -90.900054, -3.299999, -6.399999, 0.034000, 0.024999, 0.035000);
	    }
	    else if(oldkeys & KEY_YES)
	    {
	        //RemovePlayerAttachedObject(playerid, 0);
	    }
	}
	return 1;
}

public OnRconLoginAttempt(ip[], password[], success)
{
	if(!success)
	{
		new IP[16];
		foreach(new i : Player)
		{
			if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
			{
			    if(PlayerCache[i][pAdmin] < A_PERM_MAX)
			    {
				    GetPlayerIp(i, IP, sizeof(IP));
				    if(!strcmp(IP, ip, true))
				    {
				        Kick(i);
				        break;
				    }
				}
			}
		}
	}
	return 1;
}

public OnPlayerUpdate(playerid)
{
	// Przyczep obiekt broni do gracza
	if(PlayerCache[playerid][pItemWeapon] != INVALID_ITEM_ID)
	{
		if(GetPlayerWeapon(playerid) == 0)
		{
  			new itemid = PlayerCache[playerid][pItemWeapon], weapon_id = PlayerItemCache[playerid][itemid][iValue][0];
			if(!IsPlayerAttachedObjectSlotUsed(playerid, SLOT_WEAPON))
			{
			    switch(GetWeaponType(weapon_id))
			    {
       				case WEAPON_TYPE_LIGHT:
			        {
           				SetPlayerAttachedObject(playerid, SLOT_WEAPON, WeaponInfoData[weapon_id][wModel], 8, 0.0, -0.1, 0.15, -100.0, 0.0, 0.0);
			        }
			        case WEAPON_TYPE_MELEE:
			        {
           				SetPlayerAttachedObject(playerid, SLOT_WEAPON, WeaponInfoData[weapon_id][wModel], 7, 0.0, 0.0, -0.18, 100.0, 45.0, 0.0);
			        }
			        case WEAPON_TYPE_HEAVY:
			        {
           				SetPlayerAttachedObject(playerid, SLOT_WEAPON, WeaponInfoData[weapon_id][wModel], 1, 0.2, -0.125, -0.1, 0.0, 25.0, 180.0);
  			        }
  			    }
			}
		}
		else
		{
  			if(IsPlayerAttachedObjectSlotUsed(playerid, SLOT_WEAPON))
    		{
				RemovePlayerAttachedObject(playerid, SLOT_WEAPON);
			}
		}
	}
    // Selektor akcesorii
	if(PlayerCache[playerid][pSelectAccess] != INVALID_ACCESS_ID)
	{
		new keysa, uda, lra, string[64];
		GetPlayerKeys(playerid, keysa, uda, lra);
	
		// Strzałka w lewo
  		if(lra < 0)
    	{
			new access_id = Iter_Prev(Access, PlayerCache[playerid][pSelectAccess]);
			if(!Iter_Contains(Access, access_id))	access_id = Iter_Last(Access);

			SetPlayerAttachedObject(playerid, SLOT_TRYING, AccessData[access_id][aModel], AccessData[access_id][aBone], AccessData[access_id][aPosX], AccessData[access_id][aPosY], AccessData[access_id][aPosZ], AccessData[access_id][aRotX], AccessData[access_id][aRotY], AccessData[access_id][aRotZ], AccessData[access_id][aScaleX], AccessData[access_id][aScaleY], AccessData[access_id][aScaleZ]);

			format(string, sizeof(string), "$~g~%d", AccessData[access_id][aPrice]);
			GameTextForPlayer(playerid, string, 10000, 6);

			PlayerCache[playerid][pSelectAccess] = access_id;
		}

		// Strzałka w prawo
   		if(lra > 0)
	    {
  			new access_id = Iter_Next(Access, PlayerCache[playerid][pSelectAccess]);
  			if(!Iter_Contains(Access, access_id))	access_id = Iter_First(Access);

			SetPlayerAttachedObject(playerid, SLOT_TRYING, AccessData[access_id][aModel], AccessData[access_id][aBone], AccessData[access_id][aPosX], AccessData[access_id][aPosY], AccessData[access_id][aPosZ], AccessData[access_id][aRotX], AccessData[access_id][aRotY], AccessData[access_id][aRotZ], AccessData[access_id][aScaleX], AccessData[access_id][aScaleY], AccessData[access_id][aScaleZ]);

			format(string, sizeof(string), "$~g~%d", AccessData[access_id][aPrice]);
			GameTextForPlayer(playerid, string, 10000, 6);

			PlayerCache[playerid][pSelectAccess] = access_id;
   		}
	}

	// Selektor skinów
	if(PlayerCache[playerid][pSelectSkin] != INVALID_SKIN_ID)
	{
		new keysa, uda, lra, string[64];
		GetPlayerKeys(playerid, keysa, uda, lra);

		// Strzałka w lewo
  		if(lra < 0)
    	{
     		new skin_id = Iter_Prev(Skin, PlayerCache[playerid][pSelectSkin]);
       		if(!Iter_Contains(Skin, skin_id))   skin_id = Iter_Last(Skin);

			SetPlayerSkin(playerid, SkinData[skin_id][sModel]);

			format(string, sizeof(string), "$~g~%d", SkinData[skin_id][sPrice]);
   			GameTextForPlayer(playerid, string, 10000, 6);

			PlayerCache[playerid][pSelectSkin] = skin_id;
   		}

		// Strzałka w prawo
	 	if(lra > 0)
		{
			new skin_id = Iter_Next(Skin, PlayerCache[playerid][pSelectSkin]);
			if(!Iter_Contains(Skin, skin_id))   skin_id = Iter_First(Skin);

			SetPlayerSkin(playerid, SkinData[skin_id][sModel]);

			format(string, sizeof(string), "$~g~%d", SkinData[skin_id][sPrice]);
   			GameTextForPlayer(playerid, string, 10000, 6);

			PlayerCache[playerid][pSelectSkin] = skin_id;
   		}
	}

	// Selektor stylu rozmowy
	if(PlayerCache[playerid][pSelectTalkStyle])
	{
		new keysa, uda, lra, string[64];
		GetPlayerKeys(playerid, keysa, uda, lra);

		// Strzałka w lewo
 		if(lra < 0)
		{
  			PlayerCache[playerid][pTalkStyle] --;
			if(PlayerCache[playerid][pTalkStyle] < 0)  PlayerCache[playerid][pTalkStyle] = sizeof(TalkStyleData) - 1;

			new talk_style = PlayerCache[playerid][pTalkStyle];
			ApplyAnimation(playerid, TalkStyleData[talk_style][0], TalkStyleData[talk_style][1], 4.0, 1, 0, 0, 1, 0, true);

			format(string, sizeof(string), "~y~~h~%s", TalkStyleData[talk_style][2]);
			GameTextForPlayer(playerid, string, 10000, 6);
		}

		// Strzałka w prawo
  		if(lra > 0)
		{
  			PlayerCache[playerid][pTalkStyle] ++;
	    	if(PlayerCache[playerid][pTalkStyle] >= sizeof(TalkStyleData)) PlayerCache[playerid][pTalkStyle] = 0;

			new talk_style = PlayerCache[playerid][pTalkStyle];
			ApplyAnimation(playerid, TalkStyleData[talk_style][0], TalkStyleData[talk_style][1], 4.0, 1, 0, 0, 1, 0, true);

			format(string, sizeof(string), "~y~~h~%s", TalkStyleData[talk_style][2]);
			GameTextForPlayer(playerid, string, 10000, 6);
		}
	}

	// Wybór przystanku
	if(PlayerCache[playerid][pBusStart] != INVALID_OBJECT_ID)
	{
		new keysa, uda, lra;
		GetPlayerKeys(playerid, keysa, uda, lra);

		if(lra != 0 || uda != 0)
		{
			// Strzałka w lewo
			if(lra < 0)	PlayerCache[playerid][pBusPosition][0] -= 10.0;

			// Strzałka w prawo
 			if(lra > 0)	PlayerCache[playerid][pBusPosition][0] += 10.0;

			// Strzałka w górę
			if(uda > 0)	PlayerCache[playerid][pBusPosition][1] -= 10.0;

			// Strzałka w dół
			if(uda < 0)	PlayerCache[playerid][pBusPosition][1] += 10.0;
			
			Streamer_ToggleCameraUpdate(playerid, true);

			SetPlayerCameraPos(playerid, PlayerCache[playerid][pBusPosition][0], PlayerCache[playerid][pBusPosition][1], PlayerCache[playerid][pBusPosition][2] + 60.0);
			SetPlayerCameraLookAt(playerid, PlayerCache[playerid][pBusPosition][0], PlayerCache[playerid][pBusPosition][1] + 2, PlayerCache[playerid][pBusPosition][2]);
		}
	}
	
	// Pozycja 3D Tekstu & Aktora
	if(PlayerCache[playerid][pEdit3DText] != INVALID_3DTEXT_ID || PlayerCache[playerid][pEditActor] != INVALID_ACTOR_ID)
	{
	    new streamer_id = (PlayerCache[playerid][pEdit3DText] != INVALID_3DTEXT_ID) ? PlayerCache[playerid][pEdit3DText] : PlayerCache[playerid][pEditActor],
	        streamer_type = (PlayerCache[playerid][pEdit3DText] != INVALID_3DTEXT_ID) ? STREAMER_TYPE_3D_TEXT_LABEL : STREAMER_TYPE_ACTOR;
	
		new keysa, uda, lra,
			Float:PosX, Float:PosY, Float:PosZ, Float:PosA, Float:Multiplier = 0.5;

		GetPlayerKeys(playerid, keysa, uda, lra);

		Streamer_GetFloatData(streamer_type, streamer_id, E_STREAMER_X, PosX);
		Streamer_GetFloatData(streamer_type, streamer_id, E_STREAMER_Y, PosY);
		Streamer_GetFloatData(streamer_type, streamer_id, E_STREAMER_Z, PosZ);
		
		if(streamer_type == STREAMER_TYPE_ACTOR) GetDynamicActorFacingAngle(streamer_id, PosA);

		if((keysa & KEY_WALK))
		{
			Multiplier = 0.1;
		}
		else if((keysa & KEY_SPRINT))
		{
            Multiplier = 1.0;
		}

		if(!(keysa & KEY_JUMP))
		{
			if(uda < 0)
			{
			    Streamer_SetFloatData(streamer_type, streamer_id, E_STREAMER_Y, PosY - Multiplier);
			}
			else if(uda > 0)
			{
			    Streamer_SetFloatData(streamer_type, streamer_id, E_STREAMER_Y, PosY + Multiplier);
			}
			else if(lra < 0)
			{
			    Streamer_SetFloatData(streamer_type, streamer_id, E_STREAMER_X, PosX + Multiplier);
			}
			else if(lra > 0)
			{
			    Streamer_SetFloatData(streamer_type, streamer_id, E_STREAMER_X, PosX - Multiplier);
			}
		}

		if((keysa & KEY_JUMP))
		{
		    if(uda < 0)
		    {
		        Streamer_SetFloatData(streamer_type, streamer_id, E_STREAMER_Z, PosZ + Multiplier);
		    }
		    else if(uda > 0)
		    {
		        Streamer_SetFloatData(streamer_type, streamer_id, E_STREAMER_Z, PosZ - Multiplier);
		    }
		    else if(lra < 0 && streamer_type == STREAMER_TYPE_ACTOR)
		    {
		        SetDynamicActorFacingAngle(streamer_id, PosA - (Multiplier * 10));
		    }
		    else if(lra > 0 && streamer_type == STREAMER_TYPE_ACTOR)
		    {
		        SetDynamicActorFacingAngle(streamer_id, PosA + (Multiplier * 10));
		    }
		}
		Streamer_Update(playerid, streamer_type);

		SetPlayerCameraPos(playerid, PosX + 3, PosY + 4, PosZ + 4);
		SetPlayerCameraLookAt(playerid, PosX, PosY, PosZ);
	}
	
	if(PlayerCache[playerid][pAFK] > 0)
	{
	    if(PlayerCache[playerid][pDuty][DUTY_ADMIN])
	    {
			PlayerCache[playerid][pSession][SESSION_ADMIN] += PlayerCache[playerid][pAFK];
	    }
	    
	    if(PlayerCache[playerid][pDuty][DUTY_GROUP] != INVALID_GROUP_ID)
	    {
	        PlayerCache[playerid][pSession][SESSION_GROUP] += PlayerCache[playerid][pAFK];
	    }
	    
	    PlayerCache[playerid][pSession][SESSION_AFK] += PlayerCache[playerid][pAFK];
	}

	PlayerCache[playerid][pAFK] = -5;
	return 1;
}

public OnPlayerTakeDamage(playerid, issuerid, Float:amount, weaponid, bodypart)
{
	if(!PlayerCache[playerid][pLogged] || !PlayerCache[playerid][pSpawned])
	{
	    Kick(issuerid);
	    return 1;
	}
	
	// Admin godmode
	if(PlayerCache[playerid][pDuty][DUTY_ADMIN])
	{
	    crp_SetPlayerHealth(playerid, PlayerCache[playerid][pHealth]);
	    return 1;
	}
	
	if(issuerid != INVALID_PLAYER_ID)
	{
		if(PlayerCache[issuerid][pItemWeapon] != INVALID_ITEM_ID)
  		{
    		if(weaponid > 15 && weaponid < 39)
		    {
	 			new itemid = PlayerCache[issuerid][pItemWeapon],
					weapon_id = PlayerItemCache[issuerid][itemid][iValue][0];
					
				if(weaponid == weapon_id)
				{
    				if(PlayerItemCache[issuerid][itemid][iType] == ITEM_INHIBITOR)
				    {
						ApplyAnimation(playerid, "CRACK", "crckdeth2", 4.0, 0, 0, 0, 1, 0, true);
						crp_SetPlayerHealth(playerid, PlayerCache[playerid][pHealth]);

						OnPlayerFreeze(playerid, true, 5);
						TD_ShowSmallInfo(playerid, 3, "Zostales ~r~sparalizowany~w~. Nie mozesz sie ruszyc.");
      					return 1;
		    		}
				    if(PlayerCache[playerid][pDrugType] != DRUG_HEROIN && PlayerCache[playerid][pHealth] <= 20.0)	ApplyAnimation(playerid, "CRACK" , "crckidle1", 4.1, 1, 0, 0, 1, 0, 1);
				}
				else
				{
				   	new string[128], weapon_name[32];
					GetWeaponName(weaponid, weapon_name, sizeof(weapon_name));

					format(string, sizeof(string), "WeaponHack (weapID: %d, weapName: %s).", weaponid, weapon_name);
					GivePlayerPunish(issuerid, INVALID_PLAYER_ID, PUNISH_BAN, string, 365, 0);
				}
			}
	    }
	    
	  	if(!weaponid)
	  	{
	  	    new Float:fist_attack = (PlayerCache[issuerid][pDrugType] == DRUG_COCAINE) ? (PlayerCache[issuerid][pStrength] + (PlayerCache[issuerid][pDrugLevel] * 20)) : (PlayerCache[issuerid][pStrength]);
			if(PlayerCache[playerid][pDrugType] != DRUG_NONE)
			{
		 		if(PlayerCache[playerid][pDrugType] == DRUG_MARIHUANA)
				{
					fist_attack += 0.30;
		   		}
		   		
		   		if(PlayerCache[playerid][pDrugType] == DRUG_HEROIN)
		   		{
		   		    // fist_attack -= PlayerCache[playerid][pDrugLevel];
		   		}
			}
			fist_attack = (0.0001 * fist_attack);
			PlayerCache[playerid][pHealth] -= fist_attack;
		}
	}
	PlayerCache[playerid][pHealth] -= amount;
	SetPlayerHealth(playerid, PlayerCache[playerid][pHealth]);
	
	Streamer_SetIntData(STREAMER_TYPE_3D_TEXT_LABEL, Text3D:PlayerCache[playerid][pNameTag], E_STREAMER_COLOR, 0xFF040088);
	defer OnResetPlayerNameTagColor[500](playerid);
	return 1;
}

public OnPlayerGiveDamage(playerid, damagedid, Float:amount, weaponid, bodypart)
{
	if(damagedid != INVALID_PLAYER_ID && weaponid != 0)
	{
	    // AntyWeaponHack
		if(PlayerCache[playerid][pCheckWeapon] && gettime() > PlayerCache[playerid][pCheckWeapon])
		{
		    if(PlayerCache[playerid][pItemWeapon] != INVALID_ITEM_ID)
		    {
		        new itemid = PlayerCache[playerid][pItemWeapon];
		        if(PlayerItemCache[playerid][itemid][iValue][0] != weaponid)
		        {
					new string[128], weapon_name[32];
					GetWeaponName(weaponid, weapon_name, sizeof(weapon_name));

					format(string, sizeof(string), "WeaponHack (weapID: %d, weapName: %s).", weaponid, weapon_name);
					GivePlayerPunish(playerid, INVALID_PLAYER_ID, PUNISH_BAN, string, 365, 0);
					return 1;
		        }
		    }
		    else
		    {
				new string[128], weapon_name[32];
				GetWeaponName(weaponid, weapon_name, sizeof(weapon_name));

				format(string, sizeof(string), "WeaponHack (weapID: %d, weapName: %s).", weaponid, weapon_name);
				GivePlayerPunish(playerid, INVALID_PLAYER_ID, PUNISH_BAN, string, 365, 0);
		        return 1;
		    }
		}

	    new body_part_type = GetBodyPartType(bodypart);
	    if(!(PlayerCache[damagedid][pDeathBody] & body_part_type))	PlayerCache[damagedid][pDeathBody] += body_part_type;
	}
	return 1;
}

public OnPlayerWeaponShot(playerid, weaponid, hittype, hitid, Float:fX, Float:fY, Float:fZ)
{
	if(PlayerCache[playerid][pItemWeapon] != INVALID_ITEM_ID)
	{
		new itemid = PlayerCache[playerid][pItemWeapon];
		if(weaponid > 15 && weaponid < 44)
		{
			new weapon_ammo = GetPlayerWeaponAmmo(playerid, weaponid);
			if(weapon_ammo > PlayerItemCache[playerid][itemid][iValue][1])
			{
			    new string[128];
			    
   				format(string, sizeof(string), "AmmoCheat (%d/%d).", weapon_ammo, PlayerItemCache[playerid][itemid][iValue][1]);
				GivePlayerPunish(playerid, INVALID_PLAYER_ID, PUNISH_BAN, string, 30, 0);
				return 0;
				
			}
			
  			PlayerItemCache[playerid][itemid][iValue][1] -= (PlayerItemCache[playerid][itemid][iValue][1] - weapon_ammo);
  			
			if(PlayerItemCache[playerid][itemid][iValue][1] <= 0)
			{
				ResetPlayerWeaponsEx(playerid);
				PlayerCache[playerid][pCheckWeapon] = (gettime() + 5);

				PlayerItemCache[playerid][itemid][iValue][1] = 0;
				PlayerItemCache[playerid][itemid][iUsed] = false;

				orm_update(PlayerItemCache[playerid][itemid][iOrm]);

				PlayerCache[playerid][pItemWeapon] = INVALID_ITEM_ID;
				RemovePlayerAttachedObject(playerid, SLOT_WEAPON);
			}
		}
    }
	return 1;
}

public OnPlayerShootDynamicObject(playerid, weaponid, objectid, Float:x, Float:y, Float:z)
{
	return 1;
}


public OnPlayerStreamIn(playerid, forplayerid)
{
	Streamer_Update(forplayerid, STREAMER_TYPE_3D_TEXT_LABEL);
	return 1;
}

public OnPlayerStreamOut(playerid, forplayerid)
{
	return 1;
}

public OnVehicleStreamIn(vehicleid, forplayerid)
{
	return 1;
}

public OnVehicleStreamOut(vehicleid, forplayerid)
{
	return 1;
}

public OnDialogResponse(playerid, dialogid, response, listitem, inputtext[])
{
	// Anty Crasher
	if(strlen(inputtext))
	{
 		for(new i = 0; inputtext[i] != 0; i++)
		{
			if(inputtext[i] == '%')
			{
				inputtext[i] = '#';
			}
		}
	}

	if(dialogid == D_NONE)
	{
	    if(response)
	    {
	    	return 1;
		}
		else
		{
		    return 1;
		}
	}
	
	if(dialogid == D_REGISTER)
	{
	    if(response)
	    {
	        new string[256];
	        if(strlen(inputtext) >= 32)
	        {
			    format(string, sizeof(string), "Konto %s nie zostało znalezione w naszej bazie danych...\nJednak to nic straconego! Możesz je założyć właśnie teraz.\n\nWprowadź poniżej hasło dla swojego konta, którego będziesz używał do logowania.", PlayerName(playerid));
			    ShowPlayerDialog(playerid, D_REGISTER, DIALOG_STYLE_PASSWORD, "Rejestracja", string, "Rejestruj", "Wyjdź");
	    		
	    		TD_ShowSmallInfo(playerid, 5, "Wprowadzone haslo nie moze przekraczac ~r~32 znakow~w~!");
	            return 1;
	        }
	        new password[128];
	        
			strmid(password, inputtext, 0, 32, sizeof(password));
			bcrypt_hash(password, 12, "OnPlayerPasswordHashed", "d", playerid);
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	
	if(dialogid == D_LOGIN)
	{
	    if(response)
	    {
	        new password[256];
	        if(strlen(inputtext) >= 32 || strlen(inputtext) <= 0)
	        {
			    new string[256];

		 		format(string, sizeof(string), "Wprowadź poniżej hasło do konta %s (GID: %d).\n\nJeśli konto nie należy do Ciebie, oznacza to, że takie konto już\nistnieje i nie możesz stworzyć nowego o tej nazwie.\nJeśli chcesz założyć nowe konto, wyjdź z gry i wprowadź inny nick w okno SAMP.", PlayerName(playerid), PlayerCache[playerid][pGID]);
			    ShowPlayerDialog(playerid, D_LOGIN, DIALOG_STYLE_PASSWORD, "Logowanie", string, "Dalej", "Wyjdź");
			    
			    TD_ShowSmallInfo(playerid, 5, "Wprowadzone haslo jest ~r~nieprawidlowe~w~.");
			    PlayerCache[playerid][pLogTries] --;
				return 1;
			}
			
			mysql_escape_string(inputtext, password, 256);
			bcrypt_check(password, PlayerCache[playerid][pPassword], "OnPlayerPasswordChecked", "d", playerid);
			return 1;
		}
	    else
	    {
	        ShowPlayerDialog(playerid, D_NONE, DIALOG_STYLE_MSGBOX, "Informacja", "Opuszczasz grę - zapraszamy ponownie.\n\n\t\t\tEkipa "SERVER_NAME".", "Zamknij", "");
			defer OnKickPlayer(playerid);
			
			// Tutaj zmiana nicku...
			return 1;
		}
	}
	
	if(dialogid == D_CHAR_SELECT)
	{
	    if(response)
	    {
	        new char_uid = DynamicGui_GetDataInt(playerid, listitem), char_name[24];
	        if(char_uid > 0)
	        {
		        mysql_query_format("SELECT `char_name` FROM `"SQL_PREF"characters` WHERE char_uid = '%d' LIMIT 1", char_uid);
		        cache_get_value_index(0, 0, char_name, 24);

		        strmid(PlayerCache[playerid][pCharName], char_name, 0, strlen(char_name), 24);

		        GetPlayerName(playerid, PlayerCache[playerid][pGlobName], 24);
		        SetPlayerName(playerid, PlayerCache[playerid][pCharName]);

				new ORM:orm_id = PlayerCache[playerid][pOrm] = orm_create(""SQL_PREF"characters",  connHandle);

				orm_addvar_int(orm_id, PlayerCache[playerid][pUID], "char_uid");
				orm_addvar_int(orm_id, PlayerCache[playerid][pGID], "char_gid");

				orm_addvar_string(orm_id, PlayerCache[playerid][pCharName], 24, "char_name");

			    orm_addvar_int(orm_id, PlayerCache[playerid][pHours], "char_hours");
				orm_addvar_int(orm_id, PlayerCache[playerid][pMinutes], "char_minutes");

				orm_addvar_int(orm_id, PlayerCache[playerid][pCash], "char_cash");
			    orm_addvar_int(orm_id, PlayerCache[playerid][pBankCash], "char_bankcash");

			    orm_addvar_int(orm_id, PlayerCache[playerid][pBankNumber], "char_banknumb");

			    orm_addvar_int(orm_id, PlayerCache[playerid][pSkin], "char_skin");
			    orm_addvar_float(orm_id, PlayerCache[playerid][pHealth], "char_health");

			    orm_addvar_int(orm_id, PlayerCache[playerid][pSex], "char_sex");
			    orm_addvar_int(orm_id, PlayerCache[playerid][pBirth], "char_birth");

			    orm_addvar_float(orm_id, PlayerCache[playerid][pPosX], "char_posx");
			    orm_addvar_float(orm_id, PlayerCache[playerid][pPosY], "char_posy");
			    orm_addvar_float(orm_id, PlayerCache[playerid][pPosZ], "char_posz");
			    orm_addvar_float(orm_id, PlayerCache[playerid][pPosA], "char_posa");

			    orm_addvar_int(orm_id, PlayerCache[playerid][pVirtualWorld], "char_world");
			    orm_addvar_int(orm_id, PlayerCache[playerid][pInteriorID], "char_interior");

			    orm_addvar_int(orm_id, PlayerCache[playerid][pBlock], "block");
			    orm_addvar_int(orm_id, PlayerCache[playerid][pCrash], "char_quittime");
			    orm_addvar_int(orm_id, PlayerCache[playerid][pArrest], "char_arrest");

				orm_addvar_int(orm_id, PlayerCache[playerid][pPDP], "char_pdp");

			    orm_addvar_int(orm_id, PlayerCache[playerid][pStrength], "char_strength");
			    orm_addvar_float(orm_id, PlayerCache[playerid][pDepend], "char_depend");

			    orm_addvar_int(orm_id, PlayerCache[playerid][pBW], "char_bw");
			    orm_addvar_int(orm_id, PlayerCache[playerid][pAJ], "char_aj");

			    orm_addvar_int(orm_id, PlayerCache[playerid][pHouse], "char_house");
			    orm_addvar_int(orm_id, WorkInfo[playerid][wID], "char_job");

			    orm_addvar_int(orm_id, PlayerCache[playerid][pDocuments], "char_documents");
			    orm_addvar_int(orm_id, PlayerCache[playerid][pAchievements], "char_achievements");

			    orm_addvar_int(orm_id, PlayerCache[playerid][pTalkStyle], "char_talkstyle");
			    orm_addvar_int(orm_id, PlayerCache[playerid][pWalkStyle], "char_walkstyle");
			    orm_addvar_int(orm_id, PlayerCache[playerid][pFightStyle], "char_fightstyle");

			    orm_addvar_int(orm_id, PlayerCache[playerid][pOOC], "char_ooc");
			    orm_addvar_int(orm_id, PlayerCache[playerid][pLastSkin], "char_lastskin");

			    orm_addvar_int(orm_id, PlayerCache[playerid][pLastPayday], "char_lastpay");

			    orm_addvar_int(orm_id, PlayerCache[playerid][pHint], "char_hint");
			    //orm_addvar_float(orm_id, PlayerCache[playerid][pMileage], "char_mileage");

			    //orm_addvar_int(orm_id, PlayerCache[playerid][pEpisode], "char_episode");

			    orm_setkey(orm_id, "char_name");
			    PlayerCache[playerid][pWalkStyle] = GetAnimID(PlayerCache[playerid][pWalkStyle]);

			    printf("OnPlayerConnect - %d, %d, %s", PlayerCache[playerid][pUID], PlayerCache[playerid][pGID], PlayerCache[playerid][pCharName]);
			    orm_select(orm_id, "OnPlayerLogin", "d", playerid);
			}
			else
			{
				// Tworzenie postaci
				TextDrawShowForPlayer(playerid, Textdraw0);
				TextDrawShowForPlayer(playerid, Textdraw2);
				TextDrawShowForPlayer(playerid, Textdraw3);
				TextDrawShowForPlayer(playerid, Textdraw4);
				TextDrawShowForPlayer(playerid, Textdraw5);
				TextDrawShowForPlayer(playerid, Textdraw6);
				TextDrawShowForPlayer(playerid, Textdraw7);
				TextDrawShowForPlayer(playerid, Textdraw8);
				TextDrawShowForPlayer(playerid, Textdraw9);
				
				PlayerCache[playerid][pCreatingChar] = true;
				TogglePlayerSpectating(playerid, false);
				
				SetSpawnInfo(playerid, 0, 0, 921.5385, -951.9503, 39.9309, 193.8779, 0, 0, 0, 0, 0, 0);
				SpawnPlayer(playerid);
				
				TogglePlayerControllable(playerid, false);
				
				new Float:pos[3];
				GetPlayerPos(playerid, pos[0], pos[1], pos[2]);
				GetXYInFrontOfPlayer(playerid, pos[0], pos[1], 5.0);
				
				SetPlayerCameraPos(playerid, pos[0], pos[1], pos[2] + 2.0);
				
				GetPlayerPos(playerid, pos[0], pos[1], pos[2]);
				SetPlayerCameraLookAt(playerid, pos[0], pos[1], pos[2], CAMERA_CUT);
			}
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	
    printf("[dial] %s (UID: %d, GID: %d): [%s] (%d, %d, %d)", PlayerRealName(playerid), PlayerCache[playerid][pUID], PlayerCache[playerid][pGID], inputtext, playerid, dialogid, response);

	if(dialogid == D_STATS)
	{
	    if(response)
	    {
			if(!strval(inputtext) || PlayerCache[playerid][pBW])  return 1;
			new list_item = strval(inputtext);
			
			if(list_item == 1)
			{
  				new Float:PosX, Float:PosY, Float:PosZ, string[64];
				GetPlayerPos(playerid, PosX, PosY, PosZ);

				GetXYInFrontOfPlayer(playerid, PosX, PosY, 3.0);
				SetPlayerCameraPos(playerid, PosX, PosY, PosZ + 1.0);

				GetPlayerPos(playerid, PosX, PosY, PosZ);
				SetPlayerCameraLookAt(playerid, PosX, PosY, PosZ);

				OnPlayerFreeze(playerid, true, 0);
				PlayerCache[playerid][pSelectTalkStyle] = true;

				new talk_style = PlayerCache[playerid][pTalkStyle];
                ApplyAnimation(playerid, TalkStyleData[talk_style][0], TalkStyleData[talk_style][1], 4.0, 1, 0, 0, 1, 0, true);
                
				format(string, sizeof(string), "~y~~h~%s", TalkStyleData[talk_style][2]);
				GameTextForPlayer(playerid, string, 10000, 6);
                
				TD_ShowSmallInfo(playerid, 0, "Wybor stylu ~y~aktywny~w~. Uzywaj strzalek, by poruszac sie miedzy ~b~~h~stylami ~w~rozmowy.~n~~n~Klawisz ~r~~k~~VEHICLE_ENTER_EXIT~ ~w~zapisuje styl.");
				return 1;
			}
			
			if(list_item == 2)
			{
			    if(PlayerCache[playerid][pWalkStyle] != INVALID_ANIM_ID)
			    {
			        PlayerCache[playerid][pWalkStyle] = INVALID_ANIM_ID;
			        orm_update(PlayerCache[playerid][pOrm]);
			        
			        TD_ShowSmallInfo(playerid, 3, "Animacja chodzenia ~r~wylaczona~w~.");
			        return 1;
			    }
			
			    DynamicGui_Init(playerid);
			
  				new list_anims[1024];
				foreach(new anim_id : Anim)
				{
				    format(list_anims, sizeof(list_anims), "%s\n%s", list_anims, AnimCache[anim_id][aCommand]);
				    DynamicGui_AddRow(playerid, D_WALK_ANIM, anim_id);
				}

				if(strlen(list_anims))
				{
				    ShowPlayerDialog(playerid, D_WALK_ANIM, DIALOG_STYLE_LIST, "Lista animacji:", list_anims, "Start", "Zamknij");
				}
				else
				{
				    TD_ShowSmallInfo(playerid, 3, "Nie znaleziono ~r~zadnych ~w~animacji.");
				}
			    return 1;
			}
			
			if(list_item == 3)
			{
			    if(PlayerCache[playerid][pOOC])
			    {
			        PlayerCache[playerid][pOOC] = false;
			        TD_ShowSmallInfo(playerid, 5, "Czat OOC ~r~wylaczony~w~.~n~Wiadomosci na ~y~/b ~w~nie beda juz widoczne na czacie.");
			    }
			    else
			    {
       				PlayerCache[playerid][pOOC] = true;
			        TD_ShowSmallInfo(playerid, 5, "Czat OOC ~g~wlaczony~w~.~n~Wiadomosci na ~y~/b ~w~beda teraz widoczne na czacie.");
			    }
				orm_update(PlayerCache[playerid][pOrm]);
			    return 1;
			}
			
			if(list_item == 4)
			{
			    if(PlayerCache[playerid][pFirstPersonObject] == INVALID_OBJECT_ID)
			    {
			        new object_id = CreateObject(19300, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0);
					AttachObjectToPlayer(object_id, playerid, 0.0, 0.10, 0.65, 0.0, 0.0, 0.0);

					AttachCameraToObject(playerid, object_id);
					PlayerCache[playerid][pFirstPersonObject] = object_id;
					
					TD_ShowSmallInfo(playerid, 3, "Kamera ~y~FPS ~w~zostala pomyslnie ~g~wlaczona~w~.");
			    }
			    else
			    {
					DestroyObject(PlayerCache[playerid][pFirstPersonObject]);
					PlayerCache[playerid][pFirstPersonObject] = INVALID_OBJECT_ID;
					
					ResetPlayerCamera(playerid);
					TD_ShowSmallInfo(playerid, 3, "Kamera ~y~FPS ~w~zostala pomyslnie ~r~wylaczona~w~.");
			    }
			    return 1;
			}
	        return 1;
	    }
	    else
	    {
			return 1;
		}
	}
	if(dialogid == D_PERMS)
	{
	    if(response)
	    {
	        new giveplayer_id = strval(inputtext), list_perms[256],
				admin_perms = PlayerCache[giveplayer_id][pAdmin], admin_type = PlayerCache[giveplayer_id][pAdminType];

			format(list_perms, sizeof(list_perms), "{C0C0C0}Uprawnienia administratora {%s}%s{C0C0C0}:{FFFFFF}", AdminColor[admin_type], PlayerName(giveplayer_id));

			for(new i = 0; i < sizeof(AdminPerm); i++)
			{
			    AdminPerm[i][aName][0] = chrtolower(AdminPerm[i][aName][0]);
			    
			    if(admin_perms & AdminPerm[i][aType])
			    {
			        format(list_perms, sizeof(list_perms), "%s\n• %s", list_perms, AdminPerm[i][aName]);
			    }
			}

			ShowPlayerDialog(playerid, D_NONE, DIALOG_STYLE_LIST, "Uprawnienia", list_perms, "OK", "");
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_INTRO)
	{
	    if(response)
	    {
	        ShowPlayerDialog(playerid, D_NONE, DIALOG_STYLE_MSGBOX, "Wprowadzenie (2/2)", "Kiedy dotrzesz już na miejsce, na początek wyrób niezbędne do gry dokumenty,\nto wszystko może przydać Ci się podczas rozgrywki.\n\nJeżeli zaopatrzysz się w odpowiednie przedmioty, będziesz mógł przystąpić\ndo poszukiwania pracy, dzięki której zarobisz swoje pierwsze pieniądze.\nMożesz zrobić to za pomocą Urzędu, lub odwiedzając firmy osobiście.\n\nŻyczymy miłej gry na serwerze!", "OK", "");
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_SEND_PW)
	{
 		if(response)
	    {
	        new giveplayer_id = PlayerCache[playerid][pMainTable], string[256];
	        inputtext[0] = chrtoupper(inputtext[0]);

	        format(string, sizeof(string), "%d %s", giveplayer_id, inputtext);
	        pc_cmd_w(playerid, string);
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_PLAYER_LIST)
	{
		if(response)
		{
		    new clickedplayerid = strval(inputtext);
		    OnPlayerClickPlayer(playerid, clickedplayerid, 0);
		    return 1;
		}
		else
		{
		    return 1;
		}
	}
	if(dialogid == D_GROUP_TYPE)
	{
	    if(response)
	    {
	    	new group_id = PlayerCache[playerid][pMainTable], group_type = strval(inputtext) - 1;
	    	
	    	GroupData[group_id][gType] 	= 	group_type;
	    	GroupData[group_id][gFlags] = 	GroupTypeInfo[group_type][gTypeFlags];
	    	
			mysql_query_format("UPDATE `"SQL_PREF"game_groups` SET group_type = '%d', group_flags = '%d' WHERE group_uid = '%d' LIMIT 1", GroupData[group_id][gType], GroupData[group_id][gFlags], GroupData[group_id][gUID]);
	    	ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Typ grupy %s (UID: %d) został pomyślnie zmieniony na %s.", GroupData[group_id][gName], GroupData[group_id][gUID], GroupTypeInfo[GroupData[group_id][gType]][gTypeName]);
			return 1;
		}
		else
		{
		    return 1;
		}
	}
	if(dialogid == D_SPAWN_VEH)
	{
	    if(response)
	    {
			new veh_uid = DynamicGui_GetDataInt(playerid, listitem), veh_name[32],
				vehid = GetVehicleID(veh_uid);
				
			sscanf(inputtext, "{d}s[32]", veh_name);
			if(vehid == INVALID_VEHICLE_ID)
			{
			    if(GetPlayerSpawnedVehicles(playerid) >= ((IsPlayerPremium(playerid)) ? PACC_VEHICLES : FACC_VEHICLES))
			    {
			        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Masz już zespawnowaną maksymalną ilość pojazdów, odspawnuj jakiś pojazd.");
					return 1;
			    }
				LoadVehicle(veh_uid);
			    
			    TD_ShowSmallInfo(playerid, 3, "Zespawnowano pojazd ~y~%s ~w~(UID: %d).", veh_name, veh_uid);
			    printf("[cars] %s (UID: %d, GID: %d) zespawnował pojazd %s (UID: %d).", PlayerRealName(playerid), PlayerCache[playerid][pUID], PlayerCache[playerid][pGID], veh_name, veh_uid);
			}
			else
			{
 				DestroyVehicle(vehid);
				Iter_Remove(Vehicles, vehid);
				
			    orm_update(CarInfo[vehid][cOrm]);
			    orm_destroy(CarInfo[vehid][cOrm]);
				
				TD_ShowSmallInfo(playerid, 3, "Odspawnowano pojazd ~y~%s ~w~(UID: %d).", veh_name, veh_uid);
				printf("[cars] %s (UID: %d, GID: %d) odspawnował pojazd %s (UID: %d).", PlayerRealName(playerid), PlayerCache[playerid][pUID], PlayerCache[playerid][pGID], veh_name, veh_uid);
			}
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_TARGET_VEH)
	{
	    if(response)
	    {
	        new vehid = DynamicGui_GetDataInt(playerid, listitem), Float:VehPosX, Float:VehPosY, Float:VehPosZ;
	        GetVehiclePos(vehid, VehPosX, VehPosY, VehPosZ);

	        SetPlayerCheckpoint(playerid, VehPosX, VehPosY, VehPosZ, 5.0);
	        PlayerCache[playerid][pCheckpoint] = CHECKPOINT_VEHICLE;

	        TD_ShowSmallInfo(playerid, 3, "Pojazd ~y~%s ~w~(UID: %d) zostal ~r~namierzony~w~.~n~Komenda ~b~/v namierz ~w~anuluje namierzanie.", GetVehicleName(CarInfo[vehid][cModel]), CarInfo[vehid][cUID]);
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_ASSIGN_VEH)
	{
	    if(response)
	    {
	        new group_slot = DynamicGui_GetDataInt(playerid, listitem), vehid = GetPlayerVehicleID(playerid), string[256];
			if(vehid == INVALID_VEHICLE_ID)
  			{
  			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znajdujesz się w pojeździe, który chcesz przypisać.");
   				return 1;
    		}
		    if(CarInfo[vehid][cOwnerType] == OWNER_NONE)
		    {
	         	ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie jesteś właścicielem tego pojazdu.");
		        return 1;
		    }
	   		if(CarInfo[vehid][cOwnerType] == OWNER_PLAYER && CarInfo[vehid][cOwner] != PlayerCache[playerid][pUID])
			{
	            ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie jesteś właścicielem tego pojazdu.");
				return 1;
			}
			if(CarInfo[vehid][cOwnerType] == OWNER_GROUP)
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten pojazd jest już przypisany pod grupę.");
			    return 1;
			}
			if(!HavePlayerGroupPerm(playerid, PlayerGroup[playerid][group_slot][gpUID], G_PERM_LEADER))
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz do tego odpowiednich uprawnień.");
			    return 1;
			}
    		new group_id = PlayerGroup[playerid][group_slot][gpID];
    		PlayerCache[playerid][pMainTable] = group_id;

    		format(string, sizeof(string), "Czy chcesz przypisać pojazd %s (UID: %d) pod grupę %s (UID: %d)?", GetVehicleName(CarInfo[vehid][cModel]), CarInfo[vehid][cUID], GroupData[group_id][gName], GroupData[group_id][gUID]);
    		ShowPlayerDialog(playerid, D_ASSIGN_VEH_ACCEPT, DIALOG_STYLE_MSGBOX, "Pojazd » Przypisz pod grupę", string, "Tak", "Nie");
			return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_ASSIGN_VEH_ACCEPT)
	{
		if(response)
		{
		    new vehid = GetPlayerVehicleID(playerid);
      		if(vehid == INVALID_VEHICLE_ID)
	        {
	            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znajdujesz się w pojeździe, który chcesz przypisać.");
	            return 1;
	        }
    	    if(CarInfo[vehid][cOwnerType] == OWNER_NONE)
		    {
	         	ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie jesteś właścicielem tego pojazdu.");
		        return 1;
		    }
	   		if(CarInfo[vehid][cOwnerType] == OWNER_PLAYER && CarInfo[vehid][cOwner] != PlayerCache[playerid][pUID])
			{
	            ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie jesteś właścicielem tego pojazdu.");
				return 1;
			}
			if(CarInfo[vehid][cOwnerType] == OWNER_GROUP)
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten pojazd jest już przypisany pod grupę.");
			    return 1;
			}
			new group_id = PlayerCache[playerid][pMainTable];

	        CarInfo[vehid][cOwnerType] = OWNER_GROUP;
	        CarInfo[vehid][cOwner] = GroupData[group_id][gUID];
	        
			orm_update(CarInfo[vehid][cOrm]);
			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Pojazd %s (UID: %d) został pomyślnie przypisany pod grupyę.\nPojazd przypisano dla grupy %s (UID: %d).", GetVehicleName(CarInfo[vehid][cModel]), CarInfo[vehid][cUID], GroupData[group_id][gName], GroupData[group_id][gUID]);

            printf("[cars] %s (UID: %d, GID: %d) przypisał pojazd %s (UID: %d) pod grupę %s (UID: %d).", PlayerRealName(playerid), PlayerCache[playerid][pUID], PlayerCache[playerid][pGID], GetVehicleName(CarInfo[vehid][cModel]), CarInfo[vehid][cUID], GroupData[group_id][gName], GroupData[group_id][gUID]);
			return 1;
		}
		else
		{
		    return 1;
		}
	}
	if(dialogid == D_MANAGE_VEH)
	{
	    if(response)
	    {
	        new vehid = DynamicGui_GetDialogValue(playerid);
	        switch(listitem)
	        {
	            case 0:
	            {
	                if(GetVehicleBonnetStatus(vehid) == 1)
	                {
               			ChangeVehicleBonnetStatus(vehid, false);
	                    TD_ShowSmallInfo(playerid, 3, "Maska zostala pomyslnie ~r~zamknieta~w~.");
	                }
	                else
	                {
                 		ChangeVehicleBonnetStatus(vehid, true);
	                    TD_ShowSmallInfo(playerid, 3, "Maska zostala pomyslnie ~g~otwarta~w~.");
	                }
	            }
	            case 1:
	            {
             		if(GetVehicleBootStatus(vehid) == 1)
	                {
              			ChangeVehicleBootStatus(vehid, false);
	                    TD_ShowSmallInfo(playerid, 3, "Bagaznik zostal pomyslnie ~r~zamkniety~w~.");
	                }
	                else
	                {
                 		ChangeVehicleBootStatus(vehid, true);
	                    TD_ShowSmallInfo(playerid, 3, "Bagaznik zostal pomyslnie ~g~otwarty~w~.");
	                }
	            }
	            case 2:
	            {
          			if(GetVehicleLightsStatus(vehid) == 1)
		     		{
			    		ChangeVehicleLightsStatus(vehid, false);
			    		TD_ShowSmallInfo(playerid, 3, "Swiatla zostaly pomyslnie ~r~wylaczone~w~.", 5000, 3);
		       		}
			        else
			        {
		         		ChangeVehicleLightsStatus(vehid, true);
						TD_ShowSmallInfo(playerid, 3, "Swiatla zostaly pomyslnie ~g~wlaczone~w~.", 5000, 3);
					}
	            }
	            case 3:
	            {
	                if(CarInfo[vehid][cGlass])
	                {
	                    CarInfo[vehid][cGlass] = false;
	                    TD_ShowSmallInfo(playerid, 5, "Szyba zostala pomyslnie ~g~otwarta~w~.~n~Czat ~y~bedzie teraz ~w~widoczny poza pojazdem.", 5000, 3);
					}
					else
					{
     					CarInfo[vehid][cGlass] = true;
	                    TD_ShowSmallInfo(playerid, 5, "Szyba zostala pomyslnie ~r~zamknieta~w~.~n~Czat ~y~nie bedzie ~w~widoczny poza pojazdem.", 5000, 3);
					}
	            }
	            case 4:
	            {
             		if(!(CarInfo[vehid][cAccess] & VEH_ACCESS_RADIO))
	                {
	                    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "W tym pojeździe nie zostało zamontowane CB radio.");
	                    return 1;
	                }
	                ShowPlayerDialog(playerid, D_RADIO_OPTIONS, DIALOG_STYLE_LIST, "CB radio » Opcje", "1. Ustaw kanał\n2. Wykup kanał na własność\n3. Ustaw hasło dla kanału\n4. Definitywnie usuń kanał\n5. Przypisz kanał pod grupę", "Wybierz", "Anuluj");
	            }
	            case 5:
	            {
             		if(!strlen(CarInfo[vehid][cRegister]))
	                {
	                    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten pojazd nie został zarejestrowany w urzędzie miasta.");
	                    return 1;
	                }
	                ShowPlayerDialog(playerid, D_REGISTER_EDIT, DIALOG_STYLE_INPUT, "Własna rejestracja", "Wprowadź poniżej treść własnej rejestracji.\nNapis na rejestracji zostanie zmieniony zgodnie z podana treścią.\n\nIlość znaków w rejestracji nie może przekroczyć 12.", "Zmień", "Anuluj");
	            }
	        }
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_DOOR_PICKUP)
	{
	    if(response)
	    {

			return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_DOOR_INTERIOR)
	{
	    if(response)
	    {
	        new string[32];

	        format(string, sizeof(string), "interior %d", strval(inputtext));
	        pc_cmd_adrzwi(playerid, string);
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_DOOR_OPTIONS)
	{
		if(response)
		{
  			new doorid = PlayerCache[playerid][pMainTable], DoorData[sDoorInfo];
			Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
				    
		    switch(listitem)
		    {
		        case 0:
		        {
		    		ShowPlayerDialog(playerid, D_DOOR_NAME, DIALOG_STYLE_INPUT, "Opcje drzwi » Zmiana nazwy", "Wprowadź nową nazwę dla tych drzwi.\nOwa nazwa będzie wyświetlana po wejściu w pickup przed budynkiem.\n\nPoniżej wypisane są znaczniki zmieniające kolor tekstu:\n\n[r] - czerwony\n[g] - zielony\n[p] - różowy\n[b] - niebieski\n[w] - biały\n[h] - rozjaśnia kolor", "Zmień", "Anuluj");
				}
				case 1:
				{
				    ShowPlayerDialog(playerid, D_DOOR_ENTER_PAY, DIALOG_STYLE_INPUT, "Opcje drzwi » Koszt wstępu", "Wprowadź koszt wstępu do budynku.\nPieniądze będą przelewane bezpośrednio na konto właściciela budynku.", "Ustal", "Anuluj");
				}
				case 2:
				{
				    if(DoorData[dOwnerType] != OWNER_PLAYER)
				    {
				        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz przypisać tych drzwi.");
				        return 1;
				    }
				    DynamicGui_Init(playerid);
				    
					new list_groups[256], group_id;
					for (new group_slot = 0; group_slot < MAX_GROUP_SLOTS; group_slot++)
					{
						if(PlayerGroup[playerid][group_slot][gpUID])
			  			{
			  				group_id = PlayerGroup[playerid][group_slot][gpID];
							format(list_groups, sizeof(list_groups), "%s\n%d\t%s (%d)", list_groups, group_slot + 1, GroupData[group_id][gName], GroupData[group_id][gUID]);

							DynamicGui_AddRow(playerid, D_DOOR_ASSIGN, group_slot);
						}
					}
					ShowPlayerDialog(playerid, D_DOOR_ASSIGN, DIALOG_STYLE_LIST, "SLOT      NAZWA GRUPY", list_groups, "Wybierz", "Anuluj");
				}
				case 3:
				{
				    if(!strlen(DoorData[dAudioURL]))
				    {
				    	ShowPlayerDialog(playerid, D_DOOR_AUDIO, DIALOG_STYLE_INPUT, "Opcje drzwi » Muzyka spoza gry", "Wprowadź link do muzyki lub radia, które usłyszą wszyscy przebywający w tym budynku.\nLink nie może przekroczyć 128 znaków.\n\nUpewnij się, że link jest poprawny w innym wypadku muzyka może nie być słyszalna.", "Graj", "Anuluj");
					}
					else
					{
				        // Wyłącz muze wszystkim, którzy są w pomieszczeniu
				        foreach(new i : Player)
				        {
				            if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
				            {
				                if(GetPlayerDoorID(i) == doorid)
				                {
                                    StopAudioStreamForPlayer(i);
								}
							}
						}
					    strmid(DoorData[dAudioURL], "", 0, 0);
					    Streamer_SetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
					    
					    SaveDoor(doorid);
						ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Muzyka spoza gry dla tego budynku została wyłączona.\nAby włączyć muzykę spoza gry, wybierz tę opcję ponownie.");
					}
				}
				case 4:
				{
					new group_id = GetGroupID(DoorData[dOwner]);
					ListGroupProductsForPlayer(group_id, playerid, PRODUCT_LIST_OPTIONS);
				}
				case 5:
				{
					// Usuń stare obiekty z tego VW (jeśli są)
					new ObjectData[MAX_VIS_OBJECTS],
						object_count = Streamer_GetNearbyItems(DoorData[dExitX], DoorData[dExitY], DoorData[dExitZ], STREAMER_TYPE_OBJECT, ObjectData, MAX_VIS_OBJECTS, MAX_DRAW_DISTANCE, DoorData[dUID]);

					for (new object = 0; object < object_count; object++)
					{
						DestroyDynamicObject(ObjectData[object]);
					}

					new query[512];
					mysql_format(connHandle, query, sizeof(query), "SELECT "SQL_PREF"objects.*, "SQL_PREF"materials.material_texture FROM "SQL_PREF"objects LEFT JOIN "SQL_PREF"materials on "SQL_PREF"objects.object_uid = "SQL_PREF"materials.material_owner WHERE "SQL_PREF"objects.object_world = '%d' ORDER BY "SQL_PREF"objects.object_uid ASC", DoorData[dExitVW]);
				    mysql_tquery(connHandle, query, "query_OnLoadObjects", "");

					DoorData[dObjectsLoaded] = true;
					Streamer_SetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
					
			        ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Wnętrze drzwi %s (UID: %d) zostało pomyślnie przeładowane.", DoorData[dName], DoorData[dUID]);
				}
				case 6:
				{
					if(!DoorData[dGarage])
					{
					    DoorData[dGarage] = true;
						ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Możliwość przejazdu samochodem przez drzwi została włączona.\n\nOd tej pory będziesz mógł wjechać dowolnym pojazdem do budynku.\nAby wjechać pojazdem do budynku skorzystaj z komendy /przejazd.");
					}
					else
					{
	    				DoorData[dGarage] = false;
						ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Możliwość przejazdu samochodem przez drzwi została wyłączona.");
					}
					Streamer_SetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
					SaveDoor(doorid);
				}
				case 7:
				{
				    GetPlayerPos(playerid, DoorData[dExitX], DoorData[dExitY], DoorData[dExitZ]);
				    DoorData[dExitInt] = GetPlayerInterior(playerid);
				    
				    Streamer_SetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
				    SaveDoor(doorid);
				    
				    ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Pozycja wyjścia z drzwi została pomyślnie ustalona.\nWyjście na zewnątrz znajduje się teraz w miejscu, którym właśnie stoisz.");
				}
				case 8:
				{
					new query[256];

					mysql_format(connHandle, query, sizeof(query), "SELECT `item_uid`, `item_name` FROM `"SQL_PREF"items` WHERE item_ownertype = '%d' AND item_owner = '%d'", PLACE_CLOSET, DoorData[dUID]);
					mysql_tquery(connHandle, query, "query_OnListPlayerNearItems", "dd", playerid, PLACE_CLOSET);
					
					PlayerCache[playerid][pMainTable] = doorid;
				}
				case 9:
				{
				    if(PlayerCache[playerid][pUID] > 0)
				    {
				        ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Wkrótce!");
				        return 1;
				    }
				    PlayerCache[playerid][pCreatingArea] = true;
					GetPlayerPos(playerid, PlayerCache[playerid][pCreatingAreaPos][0], PlayerCache[playerid][pCreatingAreaPos][1], PlayerCache[playerid][pCreatingAreaPos][2]);
					
					TD_ShowHint(playerid, HINT_NONE, 0, "W miejscu, w ktorym stoisz wyznaczono wierzcholek prostopadloscianu dla tego budynku. Teraz udaj sie na drugi wierzcholek (przekatna - zaznacz takze wysokosc budynku).~n~~n~Gdy bedziesz juz na miejscu wcisnij klawsz PPM, by ustalic metraz lub ENTER, by anulowac zmiane metrazu.");
				}
				case 10:
				{
				    new list_hours[256];
				    DynamicGui_Init(playerid);
				    
					for(new hour = 1; hour <= 23; hour++)
					{
						format(list_hours, sizeof(list_hours), "%s\n%02d:00", list_hours, hour);
						DynamicGui_AddRow(playerid, D_NONE, hour);
					}

					ShowPlayerDialog(playerid, D_DOOR_HOUR, DIALOG_STYLE_LIST, "Wybierz godzinę dla tego wnętrza:", list_hours, "Wybierz", "Anuluj");
				}
			}
			return 1;
		}
		else
		{
		    return 1;
		}
	}
	if(dialogid == D_DOOR_NAME)
	{
		if(response)
		{
  			new doorid = PlayerCache[playerid][pMainTable], door_name[32],
  			    DoorData[sDoorInfo];

			Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	        if(strlen(inputtext) > 32)
	        {
	            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podana nazwa przekracza maksymalną ilość znaków.\nSpróbuj ponownie, wpisując inną nazwę.");
	            return 1;
	        }
       		strmid(door_name, FormatTextDrawColors(inputtext), 0, strlen(inputtext));
			strmid(DoorData[dName], door_name, 0, strlen(door_name), 32);
			
			Streamer_SetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
			SaveDoor(doorid);

			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Nazwa drzwi (UID: %d) została zmieniona pomyślnie.\nNowa nazwa drzwi: %s.", DoorData[dUID], door_name);
			return 1;
		}
		else
		{
		    return 1;
		}
	}
	if(dialogid == D_DOOR_ENTER_PAY)
	{
	    if(response)
	    {
	        new doorid = PlayerCache[playerid][pMainTable], price = strval(inputtext),
	            DoorData[sDoorInfo];
	            
			Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
			if(strlen(inputtext) > 3 || price > 100 || price < 0)
	        {
	            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłową kwotę.\nMaksymalny koszt wstępu jaki możesz ustalić: $100");
	            return 1;
	        }
	        DoorData[dEnterPay] = price;

	        if(DoorData[dEnterPay])
	        {
				ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS,  "Koszt wstępu do budynku został zmieniony.\nOpłata $%d będzie pobierana po wejściu do środka.", DoorData[dEnterPay]);
			}
			else
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS,  "Opłata za wstęp nie będzie już więcej pobierana.");
			}
			Streamer_SetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
			SaveDoor(doorid);
			return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_DOOR_ASSIGN)
	{
	    if(response)
	    {
	        new group_slot = DynamicGui_GetDataInt(playerid, listitem), doorid = PlayerCache[playerid][pMainTable], string[256];
			if(!HavePlayerGroupPerm(playerid, PlayerGroup[playerid][group_slot][gpUID], G_PERM_LEADER))
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie posiadasz uprawnień lidera tej grupy.");
			    return 1;
			}
    		new group_id = PlayerGroup[playerid][group_slot][gpID];
			PlayerCache[playerid][pMainTable] = group_id;
			
			DynamicGui_Init(playerid);
			DynamicGui_SetDialogValue(playerid, doorid);

    		format(string, sizeof(string), "Czy chcesz przypisać budynek %s (UID: %d) pod grupę %s (UID: %d)?", DoorName(doorid), GetDoorUID(doorid), GroupData[group_id][gName], GroupData[group_id][gUID]);
    		ShowPlayerDialog(playerid, D_DOOR_ASSIGN_ACCEPT, DIALOG_STYLE_MSGBOX, "Opcje drzwi » Przypisz pod grupę", string, "Tak", "Nie");
	        return 1;
	    }
	    else
	    {
	        return 1;
		}
	}
	if(dialogid == D_DOOR_ASSIGN_ACCEPT)
	{
		if(response)
		{
		    new doorid = DynamicGui_GetDialogValue(playerid),
				group_id = PlayerCache[playerid][pMainTable];
				
			new DoorData[sDoorInfo];
			Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);

	        DoorData[dOwnerType] = OWNER_GROUP;
	        DoorData[dOwner] = GroupData[group_id][gUID];

			Streamer_SetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);

			SaveDoor(doorid);
			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Budynek %s (UID: %d) został pomyślnie przypisany pod grupę.\nBudynek przypisano dla grupy %s (UID: %d).", DoorData[dName], DoorData[dUID], GroupData[group_id][gName], GroupData[group_id][gUID]);
		    return 1;
		}
		else
		{
		    return 1;
		}
	}
	if(dialogid == D_DOOR_AUDIO)
	{
	    if(response)
	    {
	        new doorid = PlayerCache[playerid][pMainTable];

	        if(strfind(inputtext, "http://", true))
	        {
	            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzony link nie jest poprawny.\nLink powinien rozpoczynać się od \"http://\".");
	            return 1;
	        }
	        if(strlen(inputtext) > 128)
	        {
	            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzony link do muzyki jest za długi.\nMaksymalnie dopuszczalne jest 128 znaków.");
	            return 1;
	        }
			new DoorData[sDoorInfo];
			Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
			
	        strmid(DoorData[dAudioURL], inputtext, 0, strlen(inputtext), 128);
	        Streamer_SetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	        
	        SaveDoor(doorid);

	        // Załącz muze dla wszystkich, którzy są w pomieszczeniu
	        foreach(new i : Player)
	        {
	            if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	            {
	                if(GetPlayerDoorID(i) == doorid)
	                {
	           	 		StopStreamedAudioForPlayer(i);
	           	 		PlayStreamedAudioForPlayer(i, DoorData[dAudioURL]);
					}
				}
			}

	        ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Link do audio został pomyślnie wprowadzony.\nMuzyka powinna być od teraz słyszalna - jeśli nie jest, oznacza to że link nie jest poprawny.");
			return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_DOOR_HOUR)
	{
	    if(response)
	    {
	        new doorid = PlayerCache[playerid][pMainTable], DoorData[sDoorInfo],
 				hour = DynamicGui_GetDataInt(playerid, listitem);
 				
			Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
			
			DoorData[dHour] = hour;
	        Streamer_SetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	        
	        SaveDoor(doorid);
	        
	        foreach(new i : Player)
	        {
	            if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	            {
	                if(GetPlayerDoorID(i) == doorid)
	                {
	                    SetPlayerTime(i, hour, 0);
	                }
	            }
	        }
	        
	        ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Pomyślnie zmieniono czas w interiorze na %02d:00.\nKażdy, kto wejdzie do interioru będzie miał ustalony ten czas.", hour);
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_ITEM_PLAYER_LIST)
	{
		if(response)
		{
			// Funkcja zaznaczania
			if(listitem == 0)
			{
				ListPlayerCheckedItems(playerid);
				return 1;
		 	}

			// Przedmioty w pobliżu
			if(listitem == 1)
			{
				ListPlayerNearItems(playerid);
				return 1;
			}

			if(listitem == 2)
			{
				ListPlayerItems(playerid);
				return 1;
			}

			new itemid = DynamicGui_GetDataInt(playerid, listitem);
			OnPlayerUseItem(playerid, itemid);
			return 1;
		}
		else
		{
			if(listitem <= 2)   return 1;

			new itemid = DynamicGui_GetDataInt(playerid, listitem), title[128];
			format(title, sizeof(title), "Opcje przedmiotu: %s (UID: %d)", PlayerItemCache[playerid][itemid][iName], PlayerItemCache[playerid][itemid][iUID]);

			PlayerCache[playerid][pItemArray][ITEM_NONE] = itemid;
			ShowPlayerDialog(playerid, D_ITEM_OPTIONS, DIALOG_STYLE_TABLIST_HEADERS, title, "*\tAkcja\n01\tOdłóż w pobliżu\n02\tPokaż informacje\n03\tSprzedaj innemu graczowi\n04\tWłóż do przedmiotu\n05\tDodaj do craftingu\n06\tWsadź do schowka\n07\tOddaj innemu graczowi za darmo\n08\tRozdziel przedmiot\n09\tDodaj do ulubionych", "Wybierz", "Zamknij");
			return 1;
		}
	}
	if(dialogid == D_ITEM_OPTIONS)
	{
		if(response)
		{
		    new itemid = PlayerCache[playerid][pItemArray][ITEM_NONE];
			switch(listitem)
			{
			    case 0:
			    {
					OnPlayerDropItem(playerid, itemid);
			    }
			    case 1:
			    {
			        ShowPlayerItemInfo(playerid, PlayerItemCache[playerid][itemid][iUID]);
			    }
			    case 2:
			    {
	   				if(PlayerItemCache[playerid][itemid][iUsed])
			  		{
			  		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz sprzedać tego przedmiotu.");
					    return 1;
					}

					new list_players[256], string[128];
					
					DynamicGui_Init(playerid);
					
					foreach(new i : Player)
					{
					    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned] && PlayerCache[i][pSpectate] == INVALID_PLAYER_ID)
					    {
					        if(i != playerid)
					        {
						        if(PlayerToPlayer(5.0, playerid, i))
						        {
						            format(list_players, sizeof(list_players), "%s\n%d\t\t%s", list_players, i, PlayerName(i));
									DynamicGui_AddRow(playerid, D_ITEM_OFFER, i);
								}
							}
					    }
					}

					if(strlen(list_players))
		            {
		                format(string, sizeof(string), "%s (UID: %d) » Sprzedaj innemu graczowi", PlayerItemCache[playerid][itemid][iName], PlayerItemCache[playerid][itemid][iUID]);
		                ShowPlayerDialog(playerid, D_ITEM_OFFER, DIALOG_STYLE_LIST, string, list_players, "Wybierz", "Anuluj");
		            }
		            else
		            {
		                ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znaleziono żadnych graczy w pobliżu.");
		            }
			    }
			    case 3:
			    {
			        if(PlayerItemCache[playerid][itemid][iType] == ITEM_BAG)
			        {
			            new format_input[48];

			            format(format_input, sizeof(format_input), "%d\t%s", PlayerItemCache[playerid][itemid][iUID], PlayerItemCache[playerid][itemid][iName]);
			            CallLocalFunction("OnDialogResponse", "dddds", playerid, D_ITEM_PLAYER_LIST, 0, 3, format_input);

			            TD_ShowSmallInfo(playerid, 5, "Nie mozesz ~r~wlozyc ~w~tego przedmiotu.");
			            return 1;
			        }
			        new list_bags[512] = "Identyfikator\tNazwa przedmiotu", item_count;
					foreach(new i : PlayerItem[playerid])
					{
					    if(PlayerItemCache[playerid][i][iUID])
					    {
					        if(PlayerItemCache[playerid][i][iType] == ITEM_BAG)
					        {
					            item_count ++;
								format(list_bags, sizeof(list_bags), "%s\n%d\t%s", list_bags, PlayerItemCache[playerid][i][iUID], PlayerItemCache[playerid][i][iName]);

							}
					    }
					}

					if(item_count > 0)
					{
	    				ShowPlayerDialog(playerid, D_ITEM_PUT_BAG, DIALOG_STYLE_TABLIST_HEADERS, "Włóż do przedmiotu:", list_bags, "Włóż", "Wróć");
					}
					else
					{
		   				TD_ShowSmallInfo(playerid, 5, "Nie posiadasz ~r~zadnych ~w~przedmiotow do ktorych mozna cos wlozyc.");
					}
			    }
			    case 4:
			    {
	   				if(PlayerItemCache[playerid][itemid][iType] != ITEM_CRAFT)
					{
					    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz dodać tego przedmiotu do craftingu.");
					    return 1;
					}
					new object_id = GetClosestObjectType(playerid, OBJECT_CRAFT);
					if(object_id == INVALID_OBJECT_ID)
					{
						ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znaleziono obiektu stołu do craftingu w pobliżu.");
					    return 1;
					}
					new object_uid = GetObjectUID(object_id);

					PlayerItemCache[playerid][itemid][iPlace] = PLACE_CRAFT;
					PlayerItemCache[playerid][itemid][iOwner] = object_uid;

					orm_update(PlayerItemCache[playerid][itemid][iOrm]);
					ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Przedmiot %s (UID: %d) został dodany do listy craftingu dla obiektu (UID: %d).\nSkorzystaj z komendy /craft, by wyjąć przedmioty znajdujące się na obiekcie.", PlayerItemCache[playerid][itemid][iName], PlayerItemCache[playerid][itemid][iUID], object_uid);

					UnloadPlayerItem(playerid, itemid);
			    }
			    case 5:
			    {

			    }
			    case 6:
			    {
			        /*
   					if(PlayerItemCache[playerid][itemid][iUsed])
			  		{
			  		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz sprzedać tego przedmiotu.");
					    return 1;
					}

					new list_players[256], string[128];

					DynamicGui_Init(playerid);

					foreach(new i : Player)
					{
					    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned] && PlayerCache[i][pSpectate] == INVALID_PLAYER_ID)
					    {
					        if(i != playerid)
					        {
						        if(PlayerToPlayer(5.0, playerid, i))
						        {
						            format(list_players, sizeof(list_players), "%s\n%d\t\t%s", list_players, i, PlayerName(i));
									DynamicGui_AddRow(playerid, D_ITEM_OFFER_FREE, i);
								}
							}
					    }
					}

					if(strlen(list_players))
		            {
		                format(string, sizeof(string), "%s (UID: %d) » Oddaj graczu za darmo", PlayerItemCache[playerid][itemid][iName], PlayerItemCache[playerid][itemid][iUID]);
		                ShowPlayerDialog(playerid, D_ITEM_OFFER_FREE, DIALOG_STYLE_LIST, string, list_players, "Wybierz", "Anuluj");
		            }
		            else
		            {
		                ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znaleziono żadnych graczy w pobliżu.");
		            }
		            */
			    }
			    case 7:
			    {
			        if(PlayerItemCache[playerid][itemid][iType] != ITEM_CIGGY && PlayerItemCache[playerid][itemid][iType] != ITEM_DRUG)
			        {
           				new format_input[48];
			            format(format_input, sizeof(format_input), "%d\t%s", PlayerItemCache[playerid][itemid][iUID], PlayerItemCache[playerid][itemid][iName]);
			            CallLocalFunction("OnDialogResponse", "dddds", playerid, D_ITEM_PLAYER_LIST, 0, 3, format_input);

			            TD_ShowSmallInfo(playerid, 5, "Nie mozesz ~r~rozdzielic ~w~tego przedmiotu.");
			            return 1;
			        }

			        ShowPlayerDialog(playerid, D_ITEM_SEPARATE, DIALOG_STYLE_INPUT, "Rozdziel przedmiot", "Wprowadź poniżej ile sztuk chcesz pozyskać z tego przedmiotu.\nPo poprawnie wykonanej akcji przedmiot zostanie podzielony.", "Rozdziel", "Wróć");
			    }
			    case 8:
			    {
			        if(PlayerItemCache[playerid][itemid][iFavorite])
			        {
			            PlayerItemCache[playerid][itemid][iFavorite] = false;
			            TD_ShowSmallInfo(playerid, 5, "Przedmiot ~y~%s (%d) ~w~zostal ~r~usuniety ~w~z ulubionych.", PlayerItemCache[playerid][itemid][iName], PlayerItemCache[playerid][itemid][iUID]);
			        }
			        else
			        {
			            PlayerItemCache[playerid][itemid][iFavorite] = true;
						TD_ShowSmallInfo(playerid, 5, "Przedmiot ~y~%s (%d) ~w~zostal ~g~dodany ~w~do ulubionych.~n~Klawisz ~p~~k~~CONVERSATION_NO~~w~, wyswietli menu szybkiego uzywania przedmiotow.", PlayerItemCache[playerid][itemid][iName], PlayerItemCache[playerid][itemid][iUID]);
			        }
			        CallLocalFunction("ListPlayerItems", "d", playerid);
			        orm_update(PlayerItemCache[playerid][itemid][iOrm]);
			    }
			}
		    return 1;
		}
		else
		{
		    return 1;
		}
	}
	if(dialogid == D_ITEM_SEPARATE)
	{
	    if(response)
	    {
	        new itemid = PlayerCache[playerid][pItemArray][ITEM_NONE],
				item_count = strval(inputtext);

			if(!Iter_Contains(PlayerItem[playerid], itemid))	return 1;
	        if(item_count <= 0 || item_count >= PlayerItemCache[playerid][itemid][iValue][1])
	        {
	            ShowPlayerDialog(playerid, D_ITEM_SEPARATE, DIALOG_STYLE_INPUT, "Rozdziel przedmiot", "Wprowadź poniżej ile sztuk chcesz pozyskać z tego przedmiotu.\nPo poprawnie wykonanej akcji przedmiot zostanie podzielony.", "Rozdziel", "Wróć");
				TD_ShowSmallInfo(playerid, 5, "Nie mozesz ~r~pozyskac ~w~tylu sztuk z tego przedmiotu.");
	            return 1;
			}
			new item_name[32];

			strmid(item_name, PlayerItemCache[playerid][itemid][iName], 0, 32, 32);
			CreatePlayerItem(playerid, item_name, PlayerItemCache[playerid][itemid][iType], PlayerItemCache[playerid][itemid][iValue][0], item_count);

			PlayerItemCache[playerid][itemid][iValue][1] -= item_count;
			orm_update(PlayerItemCache[playerid][itemid][iOrm]);

			CallLocalFunction("ListPlayerItems", "d", playerid);
			TD_ShowSmallInfo(playerid, 5, "Przedmiot ~y~%s (%d) ~w~zostal ~g~pomyslnie ~w~rozdzielony.", PlayerItemCache[playerid][itemid][iName], PlayerItemCache[playerid][itemid][iUID]);
		   	return 1;
	    }
	    else
	    {
     		new itemid = PlayerCache[playerid][pItemArray][ITEM_NONE], format_input[48];

	        format(format_input, sizeof(format_input), "%d\t%s", PlayerItemCache[playerid][itemid][iUID], PlayerItemCache[playerid][itemid][iName]);
			CallLocalFunction("OnDialogResponse", "dddds", playerid, D_ITEM_PLAYER_LIST, 0, 3, format_input);
	        return 1;
	    }
	}
	if(dialogid == D_ITEM_CHECK)
	{
	    if(response)
    	{
    	    if(PlayerCache[playerid][pPuttingBag])
    	    {
    	        new bag_item_id = PlayerCache[playerid][pItemArray][ITEM_BAG] = GetPlayerItemID(playerid, strval(inputtext));
				if(!Iter_Contains(PlayerItem[playerid], bag_item_id))
    	        {
    	            return 1;
				}

				if(PlayerItemCache[playerid][bag_item_id][iType] != ITEM_BAG)
				{
				    return 1;
				}

    	        listitem = 2;
				goto putting_bag;

				return 1;
    	    }

    	    if(listitem == 0)
    	    {
    	        CallLocalFunction("ListPlayerCheckedItems", "d", playerid);
    	        return 1;
    	    }

	        if(listitem <= 5)
	        {
	            new checked_items, last_itemid = INVALID_ITEM_ID, item_sum_value;
	            foreach(new itemid : PlayerItem[playerid])
	            {
	                //printf("%d,%s,%d", PlayerItemCache[playerid][itemid][iUID], PlayerItemCache[playerid][itemid][iName], itemid);

	                if(PlayerItemCache[playerid][itemid][iChecked])
	                {
	                    checked_items ++;

						// CRAFTING PRZEDMIOTÓW
						if(listitem == 4)
						{
					 		if(PlayerItemCache[playerid][itemid][iType] != ITEM_CRAFT)
					 		{
				    			CallLocalFunction("ListPlayerCheckedItems", "d", playerid);
    							TD_ShowSmallInfo(playerid, 5, "Dodac do ~b~craftingu ~w~mozesz tylko ~g~przedmioty ~w~o specjalnym typie.");
					 		    return 1;
					 		}
						}

	                    // ŁĄCZENIE PRZEDMIOTÓW
	                    if(listitem == 5)
	                    {
							if(last_itemid != INVALID_ITEM_ID)
       						{
								if(PlayerItemCache[playerid][itemid][iType] != PlayerItemCache[playerid][last_itemid][iType] || PlayerItemCache[playerid][itemid][iValue][0] != PlayerItemCache[playerid][last_itemid][iValue][0])
								{
								    CallLocalFunction("ListPlayerCheckedItems", "d", playerid);
				    				TD_ShowSmallInfo(playerid, 5, "Do ~y~polaczenia ~w~przedmiotow musisz ~g~zaznaczyc ~w~tylko tego samego typu.");
								    return 1;
								}
							}
							last_itemid = itemid;
							item_sum_value += PlayerItemCache[playerid][itemid][iValue][1];
	                    }
	                }
	            }

	            if(checked_items < 2)
	            {
	                CallLocalFunction("ListPlayerCheckedItems", "d", playerid);
	                TD_ShowSmallInfo(playerid, 5, "Musisz ~g~zaznaczyc ~w~przynajmniej ~y~dwa ~w~przedmioty, by nimi manipulowac.");
	                return 1;
	            }

	            if(listitem == 5)
	            {
	                if(PlayerItemCache[playerid][last_itemid][iType] != ITEM_CIGGY && PlayerItemCache[playerid][last_itemid][iType] != ITEM_DRUG)
	                {
	                    ListPlayerCheckedItems(playerid);
	                    TD_ShowSmallInfo(playerid, 5, "Nie mozesz ~y~polaczyc ~w~ze soba tego typu przedmiotow.");
	                    return 1;
	                }
	            }

				new main_query[2048], query[128], string_lenght, next_player_item, bag_item_id,
     				Float:PosX, Float:PosY, Float:PosZ, Float:PosA, virtual_world, interior_id;

				new items_list_info[512];

				switch(listitem)
				{
				    case 1:
				    {
				        if(IsPlayerInAnyVehicle(playerid))
				        {
				            new vehid = GetPlayerVehicleID(playerid), veh_uid = CarInfo[vehid][cUID];
				            ApplyAnimation(playerid, "BOMBER", "BOM_Plant", 4.1, 0, 0, 0, 0, 0, 1);

							format(main_query, sizeof(main_query), "UPDATE `"SQL_PREF"items` SET item_ownertype = '%d', item_owner = '%d' WHERE ", PLACE_VEHICLE, veh_uid);
							format(items_list_info, sizeof(items_list_info), "Przedmioty odłożone w pojeździe %s (UID: %d):\n", GetVehicleName(CarInfo[vehid][cModel]), veh_uid);
				        }
				        else
				        {
	  						GetPlayerPos(playerid, PosX, PosY, PosZ);
							GetPlayerFacingAngle(playerid, PosA);

							virtual_world = GetPlayerVirtualWorld(playerid);
							interior_id = GetPlayerInterior(playerid);

					        ApplyAnimation(playerid, "BOMBER", "BOM_Plant", 4.1, 0, 0, 0, 0, 0, 1);

							format(main_query, sizeof(main_query), "UPDATE `"SQL_PREF"items` SET item_ownertype = '%d', item_owner = '0', item_posx = '%f', item_posy = '%f', item_posz = '%f', item_world = '%d', item_interior = '%d' WHERE ", PLACE_NONE, PosX, PosY, PosZ, virtual_world, interior_id);
	                        format(items_list_info, sizeof(items_list_info), "Przedmioty zostały odłożone w pobliżu:\n");
						}
					}
					case 2:
					{
					    if(!PlayerCache[playerid][pPuttingBag])
					    {
	  						new list_bags[512] = "Identyfikator\tNazwa przedmiotu", item_count;
							foreach(new i : PlayerItem[playerid])
							{
							    if(PlayerItemCache[playerid][i][iType] == ITEM_BAG)
							    {
							        item_count ++;
							        format(list_bags, sizeof(list_bags), "%s\n%d\t%s", list_bags, PlayerItemCache[playerid][i][iUID], PlayerItemCache[playerid][i][iName]);
								}
							}

							if(item_count > 0)
							{
							    ShowPlayerDialog(playerid, D_ITEM_CHECK, DIALOG_STYLE_TABLIST_HEADERS, "Włóż do przedmiotu:", list_bags, "Włóż", "Wróć");
								PlayerCache[playerid][pPuttingBag] = true;
							}
							else
							{
                                CallLocalFunction("ListPlayerCheckedItems", "d", playerid);
							    TD_ShowSmallInfo(playerid, 5, "Nie posiadasz ~r~zadnych ~w~przedmiotow do ktorych mozna cos wlozyc.");
							}
							return 1;
						}

						putting_bag:
						bag_item_id = PlayerCache[playerid][pItemArray][ITEM_BAG];

						format(main_query, sizeof(main_query), "UPDATE `"SQL_PREF"items` SET item_ownertype = '%d', item_owner = '%d' WHERE ", PLACE_BAG, PlayerItemCache[playerid][bag_item_id][iUID]);
                        format(items_list_info, sizeof(items_list_info), "Przedmioty zostały włożone do przedmiotu %s (UID: %d):\n", PlayerItemCache[playerid][bag_item_id][iName], PlayerItemCache[playerid][bag_item_id][iUID]);

                        PlayerCache[playerid][pPuttingBag] = false;
					}
					case 3:
					{
						new doorid = GetPlayerDoorID(playerid);
				 		if(doorid == INVALID_DOOR_ID)
					    {
					        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w budynku, aby móc schować przedmiot.");
					        return 1;
						}
						new DoorData[sDoorInfo];
						Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
						
				   		if(DoorData[dOwnerType] == OWNER_NONE)
						{
						    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie jesteś właścicielem tego budynku.");
						    return 1;
						}
						if(DoorData[dOwnerType] == OWNER_PLAYER && DoorData[dOwner] != PlayerCache[playerid][pUID])
						{
						    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie jesteś właścicielem tego budynku.");
						    return 1;
						}
						if(DoorData[dOwnerType] == OWNER_GROUP)
						{
							if(!HavePlayerGroupPerm(playerid, DoorData[dOwner], G_PERM_LEADER))
							{
							    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie jesteś właścicielem tego budynku.");
							    return 1;
							}
						}
						
						format(main_query, sizeof(main_query), "UPDATE `"SQL_PREF"items` SET item_ownertype = '%d', item_owner = '%d' WHERE ", PLACE_CLOSET, DoorData[dUID]);
                        format(items_list_info, sizeof(items_list_info), "Przedmioty zostały schowane w schowku %s (UID: %d):\n", DoorData[dName], DoorData[dUID]);
					}
					case 4:
					{
						
						new craft_object_id = GetClosestObjectType(playerid, OBJECT_CRAFT);
						if(craft_object_id == INVALID_OBJECT_ID)
						{
						    CallLocalFunction("ListPlayerCheckedItems", "d", playerid);
	      					TD_ShowSmallInfo(playerid, 5, "Nie znaleiono obiektu ~y~stolu ~w~do craftingu w poblizu (model: %d).", OBJECT_CRAFT);
						    return 1;
						}
						new craft_object_uid = GetObjectUID(craft_object_id);
						
						format(main_query, sizeof(main_query), "UPDATE `"SQL_PREF"items` SET item_ownertype = '%d', item_owner = '%d' WHERE ", PLACE_CRAFT, craft_object_uid);
                        format(items_list_info, sizeof(items_list_info), "Przedmioty zostały dodane do stołu craftingowego (UID: %d):\n", craft_object_uid);
					}
					case 5:
					{
					    new item_name[32];
					    strmid(item_name, PlayerItemCache[playerid][last_itemid][iName], 0, 32, 32);

					    format(main_query, sizeof(main_query), "DELETE FROM `"SQL_PREF"items` WHERE ");
					    last_itemid = CreatePlayerItem(playerid, item_name, PlayerItemCache[playerid][last_itemid][iType], PlayerItemCache[playerid][last_itemid][iValue][0], item_sum_value);

                    	format(items_list_info, sizeof(items_list_info), "Przedmioty zostały połączone tworząc %s (UID: %d):\n", PlayerItemCache[playerid][last_itemid][iName], PlayerItemCache[playerid][last_itemid][iUID]);
					}
				}
	            string_lenght = strlen(main_query);

	            new object_id, objData[sObjectData], item_type;
             	foreach(new itemid : PlayerItem[playerid])
	            {
	                if(PlayerItemCache[playerid][itemid][iChecked])
	                {
	                    format(query, sizeof(query), "item_uid = %d", PlayerItemCache[playerid][itemid][iUID]);
						if(strlen(main_query) > string_lenght)
						{
							if(strlen(main_query) + strlen(query) < sizeof(main_query))
   				    		{
				   				strcat(main_query, " OR ", sizeof(main_query));
							}
							else
							{
					    		strcat(main_query, ";", sizeof(main_query));
					    		mysql_query(connHandle, main_query);

					    		strdel(main_query, string_lenght, strlen(main_query));
							}
						}
						strcat(main_query, query, sizeof(main_query));

						if(listitem == 1)
						{
						    if(!IsPlayerInAnyVehicle(playerid))
						    {
								item_type = PlayerItemCache[playerid][itemid][iType];
								if(item_type == ITEM_WEAPON || item_type == ITEM_PAINT || item_type == ITEM_INHIBITOR)
								{
								    object_id = CreateDynamicObject(WeaponInfoData[PlayerItemCache[playerid][itemid][iValue][0]][wModel], PosX, PosY, PosZ - 1.0, 80.0, 0.0, -PosA, virtual_world, interior_id, -1, MAX_DRAW_DISTANCE, MAX_DRAW_DISTANCE);
								}
								else if(item_type == ITEM_TUNING)
								{
						  			object_id = CreateDynamicObject(PlayerItemCache[playerid][itemid][iValue][0], PosX + random(2), PosY + random(2), PosZ - 0.5, 0.0, 0.0, -PosA, virtual_world, interior_id, -1, MAX_DRAW_DISTANCE, MAX_DRAW_DISTANCE);
								}
								else
								{
								    object_id = CreateDynamicObject(ItemTypeInfo[item_type][iTypeObjModel], PosX + random(2), PosY + random(2), PosZ - 1.0, ItemTypeInfo[item_type][iTypeObjRotX], ItemTypeInfo[item_type][iTypeObjRotY], -PosA, virtual_world, interior_id, -1, MAX_DRAW_DISTANCE, MAX_DRAW_DISTANCE);
								}
								objData[objUID] = (PlayerItemCache[playerid][itemid][iUID] * -1);

								Streamer_SetArrayData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_EXTRA_ID, objData);
								Streamer_UpdateEx(playerid, PosX, PosY, PosZ, virtual_world, interior_id, STREAMER_TYPE_OBJECT);
							}
						}

						if(listitem == 2)
						{
						    PlayerItemCache[playerid][bag_item_id][iValue][0] += GetPlayerItemWeight(playerid, itemid);
						}

						format(items_list_info, sizeof(items_list_info), "%s\n• %s (%d)", items_list_info, PlayerItemCache[playerid][itemid][iName], PlayerItemCache[playerid][itemid][iUID]);

						orm_destroy(PlayerItemCache[playerid][itemid][iOrm]);
						for(new sPlayerItem:e; e < sPlayerItem; ++e)	PlayerItemCache[playerid][itemid][e] = 0;
                        
                        next_player_item = itemid;
						Iter_SafeRemove(PlayerItem[playerid], next_player_item, itemid);
						
	                }
	            }

	            if(listitem == 2)
	            {
	                orm_update(PlayerItemCache[playerid][bag_item_id][iOrm]);
	            }

	            mysql_query(connHandle, main_query);
	            ShowPlayerDialog(playerid, D_NONE, DIALOG_STYLE_MSGBOX, "Informacja", items_list_info, "OK", "");
	            return 1;
	        }

			new itemid = DynamicGui_GetDataInt(playerid, listitem);
			if(PlayerItemCache[playerid][itemid][iChecked])
			{
				PlayerItemCache[playerid][itemid][iChecked] = false;
				TD_ShowSmallInfo(playerid, 3, "Przedmiot zostal ~r~odznaczony~w~.");
			}
			else
			{
				PlayerItemCache[playerid][itemid][iChecked] = true;
				TD_ShowSmallInfo(playerid, 3, "Przedmiot zostal ~g~zaznaczony~w~.");
			}
			CallLocalFunction("ListPlayerCheckedItems", "d", playerid);
	        return 1;
	    }
	    else
	    {
	        new callback[24];
	        if(PlayerCache[playerid][pPuttingBag])
	        {
	        	PlayerCache[playerid][pPuttingBag] = false;
	        	callback = "ListPlayerCheckedItems";
			}
	        else
			{
       			callback = "ListPlayerItems";
			}
			CallLocalFunction(callback, "d", playerid);
	        return 1;
	    }
	}
	if(dialogid == D_ITEM_FAVORITE)
	{
	    if(response)
	    {
			new itemid = DynamicGui_GetDataInt(playerid, listitem);
			OnPlayerUseItem(playerid, itemid);
	        return 1;
	    }
	    else
	    {
			return 1;
	    }
	}
	if(dialogid == D_ITEM_OFFER)
	{
	    if(response)
	    {
	        new string[256], itemid = PlayerCache[playerid][pItemArray][ITEM_NONE];

			DynamicGui_SetDialogValue(playerid, DynamicGui_GetDataInt(playerid, listitem));
		    
	        format(string, sizeof(string), "Wprowadź poniżej kwotę, jaką pragniesz otrzymać za przedmiot %s (UID: %d).", PlayerItemCache[playerid][itemid][iName], PlayerItemCache[playerid][itemid][iUID]);
			ShowPlayerDialog(playerid, D_ITEM_OFFER_PRICE, DIALOG_STYLE_INPUT, "Sprzedaż przedmiotu » Cena", string, "Oferuj", "Anuluj");
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_ITEM_OFFER_FREE)
	{
	    if(response)
	    {
	        new itemid = PlayerCache[playerid][pItemArray][ITEM_NONE], giveplayer_id = DynamicGui_GetDataInt(playerid, listitem);
            OnPlayerSendOffer(playerid, giveplayer_id, PlayerItemCache[playerid][itemid][iName], OFFER_ITEM, PlayerItemCache[playerid][itemid][iUID], 0, 0);
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_ITEM_OFFER_PRICE)
	{
	    if(response)
	    {
    		new price = strval(inputtext),
				itemid = PlayerCache[playerid][pItemArray][ITEM_NONE], giveplayer_id = DynamicGui_GetDialogValue(playerid);
				
		    if(price < 0 || strlen(inputtext) > 11)
		    {
		       	ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłową kwotę.");
		        return 1;
		    }
		    OnPlayerSendOffer(playerid, giveplayer_id, PlayerItemCache[playerid][itemid][iName], OFFER_ITEM, PlayerItemCache[playerid][itemid][iUID], 0, price);
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_ITEM_RAISE)
	{
	    if(response)
	    {
	        new bool:select_all = false;
	    
	        // Podnieś zaznaczone
	        if(listitem == 0)
	        {
				OnPlayerRaiseItems(playerid);
	            return 1;
	        }
	        
	        // Zaznacz wszystkie
	        if(listitem == 1)
	        {
				select_all = true;
	        }

	        if(listitem == 2)
	        {
       			ClearExternalItemCache(playerid);
				Iter_Clear(CheckedPlayerItem[playerid]);
				return 1;
	        }

	        new add_row = DynamicGui_GetDataInt(playerid, listitem);
	        if(!select_all)
	        {
	         	if(!Iter_Contains(CheckedPlayerItem[playerid], add_row))
				{
					Iter_Add(CheckedPlayerItem[playerid], add_row);
				}
				else
				{
				    Iter_Remove(CheckedPlayerItem[playerid], add_row);
				}
			}

        	new list_items[1024], item_uid, item_name[32], rows,
				item_place = GetExternalItemCachePlace(playerid), action_string[12];
				
			switch(item_place)
			{
			    case PLACE_NONE, PLACE_VEHICLE: action_string = "Podnieś";
			    case PLACE_CLOSET, PLACE_BAG:   action_string = "Wyjmij";
			    case PLACE_ACTOR:               action_string = "Ukradnij";
			}

			DynamicGui_Init(playerid);

			DynamicGui_AddRow(playerid, D_ITEM_RAISE, 0);
			DynamicGui_AddRow(playerid, D_ITEM_RAISE, 0);
            DynamicGui_AddRow(playerid, D_ITEM_RAISE, 0);

			cache_set_active(external_items_cache[playerid][item_place]);

		    cache_get_row_count(rows);
		    format(list_items, sizeof(list_items), "Identyfikator\t*\tNazwa przedmiotu\n» %s\t%d\tprzedmioty/ów\n» Zaznacz wszystkie\n---\n", action_string, (select_all) ? rows : Iter_Count(CheckedPlayerItem[playerid]));

			for(new row = 0; row != rows; row++)
			{
				cache_get_value_index_int(row, 0, item_uid);
				cache_get_value_index(row, 1, item_name, 32);
				
				if(select_all)
    			{
				    if(!Iter_Contains(CheckedPlayerItem[playerid], row))
				    {
						Iter_Add(CheckedPlayerItem[playerid], row);
     				}
    			}

				if(Iter_Contains(CheckedPlayerItem[playerid], row))
				{
					format(list_items, sizeof(list_items), "%s\n%d\t[X]\t%s", list_items, item_uid, item_name);
				}
				else
				{
				    format(list_items, sizeof(list_items), "%s\n%d\t[ ]\t%s", list_items, item_uid, item_name);
				}
				DynamicGui_AddRow(playerid, D_ITEM_RAISE, row);
			}
			cache_unset_active();
			ShowPlayerDialog(playerid, D_ITEM_RAISE, DIALOG_STYLE_TABLIST_HEADERS, "Lista przedmiotów:", list_items, "Wybierz", "Anuluj");
	        return 1;
	    }
	    else
	    {
    		ClearExternalItemCache(playerid);
			Iter_Clear(CheckedPlayerItem[playerid]);
	        return 1;
	    }
	}
	if(dialogid == D_ITEM_PUT_BAG)
	{
	    if(response)
	    {
	        new itemid = PlayerCache[playerid][pItemArray][ITEM_NONE],
				bag_item_uid = strval(inputtext), bag_item_id = GetPlayerItemID(playerid, bag_item_uid);

			if(!Iter_Contains(PlayerItem[playerid], itemid))    return 1;

			PlayerItemCache[playerid][itemid][iPlace] = PLACE_BAG;
			PlayerItemCache[playerid][itemid][iOwner] = bag_item_uid;

			PlayerItemCache[playerid][bag_item_id][iValue][0] += GetPlayerItemWeight(playerid, itemid);

			orm_update(PlayerItemCache[playerid][itemid][iOrm]);
			orm_update(PlayerItemCache[playerid][bag_item_id][iOrm]);

			TD_ShowSmallInfo(playerid, 5, "Przedmiot ~y~%s (%d) ~w~zostal wlozony do ~y~%s (%d)~w~ pomyslnie.", PlayerItemCache[playerid][itemid][iName], PlayerItemCache[playerid][itemid][iUID], PlayerItemCache[playerid][bag_item_id][iName], PlayerItemCache[playerid][bag_item_id][iUID]);

			Iter_Remove(PlayerItem[playerid], itemid);
			UnloadPlayerItem(playerid, itemid);

   			CallLocalFunction("ListPlayerItems", "d", playerid);
	        return 1;
	    }
	    else
	    {
	        new itemid = PlayerCache[playerid][pItemArray][ITEM_NONE], format_input[48];

	        format(format_input, sizeof(format_input), "%d\t%s", PlayerItemCache[playerid][itemid][iUID], PlayerItemCache[playerid][itemid][iName]);
			CallLocalFunction("OnDialogResponse", "dddds", playerid, D_ITEM_PLAYER_LIST, 0, 3, format_input);
	        return 1;
	    }
	}
	if(dialogid == D_ITEM_REMOVE_BAG)
	{
	    if(response)
	    {
     		new item_uid = DynamicGui_GetDataInt(playerid, listitem), bag_item_id = PlayerCache[playerid][pItemArray][ITEM_BAG], query[256];
			if(!Iter_Contains(PlayerItem[playerid], bag_item_id))
			{
			    return 1;
			}
			mysql_format(connHandle, query, sizeof(query), "UPDATE `"SQL_PREF"items` SET item_ownertype = '%d', item_owner = '%d' WHERE item_ownertype = '%d' AND item_owner = '%d' AND item_uid = '%d' LIMIT 1", PLACE_PLAYER, PlayerCache[playerid][pUID], PLACE_BAG, PlayerItemCache[playerid][bag_item_id][iUID], item_uid);
			new Cache:tmp_cache = mysql_query(connHandle, query, true);

			if(cache_affected_rows() <= 0)
			{
		    	ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Tego przedmiotu już tutaj nie ma.");
		    	return 1;
			}
			if(cache_is_valid(tmp_cache))	cache_delete(tmp_cache);

			new itemid = LoadPlayerItem(playerid, item_uid);
			TD_ShowSmallInfo(playerid, 5, "Przedmiot zostal ~g~pomyslnie ~w~wyjety.");

			PlayerItemCache[playerid][bag_item_id][iValue][0] -= GetPlayerItemWeight(playerid, itemid);
			orm_update(PlayerItemCache[playerid][bag_item_id][iOrm]);

   			CallLocalFunction("ListPlayerItems", "d", playerid);
			return 1;
	    }
	    else
	    {
	        CallLocalFunction("ListPlayerItems", "d", playerid);
	        return 1;
	    }
	}
	if(dialogid == D_ITEM_REMOVE_CLOSET)
	{
	    if(response)
	    {
   			if(!strval(inputtext))	return 1;
   			
     		new itemid, item_uid = DynamicGui_GetDataInt(playerid, listitem), query[256];
     		
	        mysql_format(connHandle, query, sizeof(query), "UPDATE `"SQL_PREF"items` SET item_ownertype = '%d', item_owner = '%d' WHERE item_uid = '%d' LIMIT 1", PLACE_PLAYER, PlayerCache[playerid][pUID], item_uid);
			mysql_query(connHandle, query);

	        itemid = LoadPlayerItem(playerid, item_uid);
	        ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Przedmiot %s (UID: %d) został wyjęty.\nPojawił się on w Twoim ekwipunku.", PlayerItemCache[playerid][itemid][iName], PlayerItemCache[playerid][itemid][iUID]);
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_ITEM_RELOAD_WEAPON)
	{
	    if(response)
	    {
	        new itemid = PlayerCache[playerid][pItemArray][ITEM_WEAPON],
			 	weapon_itemid = DynamicGui_GetDataInt(playerid, listitem), string[128];
				
 			if(PlayerItemCache[playerid][weapon_itemid][iUsed])
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz przeładować broni, która jest w użyciu.");
			    return 1;
			}
			
			PlayerItemCache[playerid][weapon_itemid][iValue][1] += PlayerItemCache[playerid][itemid][iValue][1];
			orm_update(PlayerItemCache[playerid][weapon_itemid][iOrm]);
			
			format(string, sizeof(string), "* %s przeładowuje %s.", PlayerName(playerid), PlayerItemCache[playerid][weapon_itemid][iName]);
			ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);

			ApplyAnimation(playerid, "COLT45", "colt45_reload", 4.0, 0, 0, 0, 0, 0, 1);
			DeletePlayerItem(playerid, itemid);
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_ITEM_ADD_CHIT)
	{
	    if(response)
	    {
     		new itemid = PlayerCache[playerid][pItemArray][ITEM_NOTEBOOK], chit_desc[128], string[128],
	            chit_uid;

	        if(strlen(inputtext) <= 0)
	        {
         		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Pole tekstowe nie może być puste!");
	            return 1;
	        }
	        
	        if(strlen(inputtext) > 64)
	        {
	            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Tekst nie może przekroczyć ciągu 64 znaków.");
				return 1;
	        }
	        new query[512];
			mysql_escape_string(inputtext, chit_desc);
			
			mysql_format(connHandle, query, sizeof(query), "INSERT INTO `"SQL_PREF"chits` (`chit_desc`, `chit_writer`, `chit_time`) VALUES ('%s', '%s', NOW())", chit_desc, PlayerName(playerid));
			mysql_query(connHandle, query);
			
			chit_uid = cache_insert_id();
			CreatePlayerItem(playerid, "Karteczka", ITEM_CHIT, chit_uid, 0);

			PlayerItemCache[playerid][itemid][iValue][0] --;
			if(PlayerItemCache[playerid][itemid][iValue][0] > 0)
			{
			    orm_update(PlayerItemCache[playerid][itemid][iOrm]);
			}
			else
			{
			    DeletePlayerItem(playerid, itemid);
			}

			format(string, sizeof(string), "* %s wyrywa karteczkę z notatnika.", PlayerName(playerid));
			ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);

			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Treść została pomyślnie zapisana na karteczce.\nKarteczka pojawiła się w Twoim ekwipunku.");
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_ITEM_WRITE_A_CHECK)
	{
	    if(response)
	    {
  			new itemid = PlayerCache[playerid][pItemArray][ITEM_CHECK], check_price = strval(inputtext), string[128], item_name[32];
			if(strlen(inputtext) > 11 || check_price <= 0 || check_price > PlayerCache[playerid][pBankCash])
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłową kwotę.");
			    return 1;
			}
			
			PlayerCache[playerid][pBankCash] -= check_price;
			orm_update(PlayerCache[playerid][pOrm]);

			format(item_name, sizeof(item_name), "Czek na $%d", check_price);
            CreatePlayerItem(playerid, item_name, ITEM_CHECK, check_price, 0);

			PlayerItemCache[playerid][itemid][iValue][0] --;
			if(PlayerItemCache[playerid][itemid][iValue][0] > 0)
			{
				orm_update(PlayerItemCache[playerid][itemid][iOrm]);
			}
			else
			{
			    DeletePlayerItem(playerid, itemid);
			}

 			format(string, sizeof(string), "* %s wypisuje czek na $%d.", PlayerName(playerid), check_price);
			ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);

			ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Czek został wypisany pomyślnie.\nPieniądze zostały pobrane z Twojego konta bankowego i wypisane na czeku.");
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_PRODUCT_OFFER)
	{
	    if(response)
	    {
     		new product_uid = DynamicGui_GetDataInt(playerid, listitem), product_id = GetProductID(product_uid), customerid = PlayerCache[playerid][pMainTable],
     		    product_price = DynamicGui_GetValue(playerid, listitem);
     		if(product_id == INVALID_PRODUCT_ID)    return 1;
     		
			OnPlayerSendOffer(playerid, customerid, ProductData[product_id][pName], OFFER_PRODUCT, ProductData[product_id][pUID], 0, product_price);
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_PRODUCT_BUY)
	{
	    if(response)
	    {
	        new product_uid = DynamicGui_GetDataInt(playerid, listitem), product_id = GetProductID(product_uid),
	            group_id = PlayerCache[playerid][pMainTable], itemid;

 			if(product_id == INVALID_PRODUCT_ID)
 			{
 			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Tego produktu nie ma już w magazynie.");
 			    return 1;
 			}
			
   			if(ProductData[product_id][pPrice] > PlayerCache[playerid][pCash])
      		{
        		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz takiej ilości gotówki.");
        		return 1;
        	}
        	
       		if(!(PlayerCache[playerid][pAdmin] & A_PERM_ITEMS) && GetPlayerCapacity(playerid) <= 0)
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Twoja postać nie jest w stanie unieść więcej przedmiotów.");
			    return 1;
			}
			
   			if(ProductData[product_id][pPrice] > 0)
      		{
        		new group_cash = floatround(0.90 * ProductData[product_id][pPrice]);

				crp_GivePlayerMoney(playerid, -ProductData[product_id][pPrice]);
				orm_update(PlayerCache[playerid][pOrm]);
				
				GroupData[group_id][gCash] += group_cash;
				orm_update(GroupData[group_id][gOrm]);
    		}
    		
      		ProductData[product_id][pCount] --;
      		ProductData[product_id][pPrice] = DynamicGui_GetValue(playerid, listitem);
      		
        	itemid = CreatePlayerItem(playerid, ProductData[product_id][pName], ProductData[product_id][pType], ProductData[product_id][pValue1], ProductData[product_id][pValue2]);

			PlayerItemCache[playerid][itemid][iGroup] = ProductData[product_id][pOwner];
			orm_update(PlayerItemCache[playerid][itemid][iOrm]);

			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Zakupiłeś produkt %s.\nKoszt: $%d\n\nPrzedmiot (UID: %d) pojawił się w Twoim ekwipunku.\nSkorzystaj z komendy /p, by wyświetlić listę posiadanych przedmiotów.", ProductData[product_id][pName], ProductData[product_id][pPrice], PlayerItemCache[playerid][itemid][iUID]);
      		
        	if(ProductData[product_id][pCount] <= 0)	DeleteProduct(product_id);
	        else                                        orm_update(ProductData[product_id][pOrm]);
	        
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_PRODUCT_SELECT)
	{
	    if(response)
	    {
     		new product_uid = DynamicGui_GetDataInt(playerid, listitem), product_id = GetProductID(product_uid), string[128];
  			if(product_id == INVALID_PRODUCT_ID)
     		{
     		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Tego produktu nie ma w magazynie.");
     		    return 1;
     		}
	        format(string, sizeof(string), "%s (%d, %d) %d szt.", ProductData[product_id][pName], ProductData[product_id][pValue1], ProductData[product_id][pValue2], ProductData[product_id][pCount]);

			ShowPlayerDialog(playerid, D_PRODUCT_OPTIONS, DIALOG_STYLE_LIST, string, "1. Wyjmij produkt\n2. Zmień cenę\n3. Usuń z magazynu", "Wybierz", "Anuluj");
	        PlayerCache[playerid][pMainTable] = product_uid;
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_PRODUCT_OPTIONS)
	{
	    if(response)
	    {
     		new product_uid = PlayerCache[playerid][pMainTable], product_id = GetProductID(product_uid), string[256];
     		if(product_id == INVALID_PRODUCT_ID)
     		{
     		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Tego produktu nie ma w magazynie.");
     		    return 1;
     		}
     		
	        switch(listitem)
	        {
	            case 0:
	            {
           			if(!(PlayerCache[playerid][pAdmin] & A_PERM_ITEMS) && GetPlayerCapacity(playerid) <= 0)
					{
					    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Twoja postać nie jest w stanie unieść więcej przedmiotów.");
					    return 1;
					}
					
					new itemid;
					if(ProductData[product_id][pType] == ITEM_DRUG)
					{
					    itemid = CreatePlayerItem(playerid, ProductData[product_id][pName], ProductData[product_id][pType], ProductData[product_id][pValue1], ProductData[product_id][pCount]);
					    ProductData[product_id][pCount] = 0;
					}
					else
					{
	               		itemid = CreatePlayerItem(playerid, ProductData[product_id][pName], ProductData[product_id][pType], ProductData[product_id][pValue1], ProductData[product_id][pValue2]);
					}
					PlayerItemCache[playerid][itemid][iGroup] = ProductData[product_id][pOwner];
					orm_update(PlayerItemCache[playerid][itemid][iOrm]);

					ProductData[product_id][pCount] --;
					if(ProductData[product_id][pCount] <= 0)	DeleteProduct(product_id);
					else										orm_update(ProductData[product_id][pOrm]);

					new group_id = GetGroupID(ProductData[product_id][pOwner]);

                    AddGroupTransactionLog(playerid, group_id, TRANSACTION_REMOVE, 0, 0, ProductData[product_id][pUID]);
					ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Wyjąłeś produkt z magazynu.\nNazwa produktu: %s (%d, %d)\n\nProdukt pojawił się w Twoim ekwipunku.", ProductData[product_id][pName], ProductData[product_id][pValue1], ProductData[product_id][pValue2]);
	            }
	            case 1:
				{
				    format(string, sizeof(string), "Wprowadź nową cenę, która będzie pobierana za kupno produktu.\n\nWybrałeś produkt: %s\nCena produktu: $%d/$%d", ProductData[product_id][pName], ProductData[product_id][pPrice], ProductData[product_id][pMaxPrice]);
	                ShowPlayerDialog(playerid, D_PRODUCT_PRICE, DIALOG_STYLE_INPUT, "Zmień cenę produktu", string, "Zmień", "Anuluj");
	            }
	            case 2:
	            {
					format(string, sizeof(string), "Czy jesteś pewien, że chcesz usunąć produkt?\n\nNazwa produktu: %s\nUID: %d", ProductData[product_id][pName], ProductData[product_id][pUID]);
					ShowPlayerDialog(playerid, D_PRODUCT_DELETE, DIALOG_STYLE_MSGBOX, "Usuń produkt z magazynu", string, "Usuń", "Anuluj");
	            }
	        }
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_PRODUCT_PRICE)
	{
	    if(response)
	    {
     		new price = strval(inputtext), product_id = PlayerCache[playerid][pMainTable];
     		if(product_id == INVALID_PRODUCT_ID)
     		{
     		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Tego produktu nie ma w magazynie.");
     		    return 1;
     		}
	        if(price < 0 || strlen(inputtext) > 6 || price > ProductData[product_id][pMaxPrice])
	        {
	            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłową kwotę.");
	            return 1;
	        }
			ProductData[product_id][pPrice] = price;
			orm_update(ProductData[product_id][pOrm]);

			ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Produkt o nazwie %s kosztuje teraz $%d.", ProductData[product_id][pName], ProductData[product_id][pPrice]);
	        return 1;
	    }
		else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_PRODUCT_DELETE)
	{
	    if(response)
	    {
  			new product_id = PlayerCache[playerid][pMainTable];
   			if(product_id == INVALID_PRODUCT_ID)
     		{
     		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Tego produktu nie ma w magazynie.");
     		    return 1;
     		}
     		
			DeleteProduct(product_id);
			ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Produkt został całkowicie usunięty z magazynu.");
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_OFFER_SEND)
	{
	    if(response)
	    {
	        new offererid = OfferData[playerid][oOffererID];
	        if(OfferData[playerid][oPrice] > 0)
	        {
	            if(PlayerCache[playerid][pBankNumber])
	            {
	                ShowPlayerDialog(playerid, D_OFFER_PAY_TYPE, DIALOG_STYLE_MSGBOX, "Rodzaj płatności", "Wybierz sposób zapłaty za daną ofertę.", "Gotówka", "Karta");
	            }
	            else
	            {
	                OfferData[playerid][oPayType] = PAY_TYPE_CASH;
	                OnPlayerAcceptOffer(playerid, offererid);
	            }
	        }
	        else
	        {
	            OfferData[playerid][oPayType] = PAY_TYPE_CASH;
	            OnPlayerAcceptOffer(playerid, offererid);
	        }
	        return 1;
	    }
	    else
	    {
	        OnPlayerRejectOffer(playerid, OfferData[playerid][oOffererID]);
	        return 1;
	    }
	}
	if(dialogid == D_OFFER_PAY_TYPE)
	{
	    if(response)
	    {
	        OfferData[playerid][oPayType] = PAY_TYPE_CASH;
	        OnPlayerAcceptOffer(playerid, OfferData[playerid][oOffererID]);
	        return 1;
	    }
	    else
	    {
	        OfferData[playerid][oPayType] = PAY_TYPE_CARD;
	        OnPlayerAcceptOffer(playerid, OfferData[playerid][oOffererID]);
	        return 1;
	    }
	}
	if(dialogid == D_OFFER_LIST)
	{
	    if(response)
	    {
     		new offer_name[24];
	        sscanf(inputtext, "'•'s[24]", offer_name);

	        pc_cmd_oferuj(playerid, offer_name);
	        return 1;
	    }
	    else
	    {
			return 1;
	    }
	}
	if(dialogid == D_PHONE_OPTIONS)
	{
	    if(response)
	    {
	        new list_item = strval(inputtext);
	        
	        if(list_item == 1)
	        {
	            ShowPlayerDialog(playerid, D_PHONE_CALL_NUMBER, DIALOG_STYLE_INPUT, "Telefon » Wybierz numer", "Wprowadź numer telefonu komórkowego, na który chcesz zadzwonić:", "Połącz", "Anuluj");
	            return 1;
	        }
	        
	        if(list_item == 2)
	        {
	            ShowPlayerDialog(playerid, D_PHONE_SMS_NUMBER, DIALOG_STYLE_INPUT, "Telefon » Wyślij SMS", "Wprowadź numer telefonu, na który chcesz wysłać wiadomość SMS:", "Dalej", "Anuluj");
	            return 1;
	        }
	        
	        if(list_item == 3)
	        {
	            new list_players[256];
	            foreach(new i : Player)
	            {
	                if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	                {
	                    if(i != playerid)
	                    {
	                        if(PlayerToPlayer(5.0, playerid, i))
	                        {
	                            format(list_players, sizeof(list_players), "%s\n%d\t\t%s", list_players, i, PlayerName(i));
	                        }
	                    }
	                }
	            }
	            
	            if(strlen(list_players))
	            {
	                ShowPlayerDialog(playerid, D_PHONE_SEND_VCARD, DIALOG_STYLE_LIST, "Telefon » Wyślij vCard", list_players, "Wybierz", "Anuluj");
	            }
	            else
	            {
	                ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znaleziono żadnych graczy w pobliżu.");
	            }
	            return 1;
	        }
	        
	        if(list_item == 4)
	        {
 				new list_contacts[1024], contacts,
     				contact_number, contact_name[24];

				new rows, Cache:tmp_cache, query[256];

				mysql_format(connHandle, query, sizeof(query), "SELECT `contact_number`, `contact_name` FROM `"SQL_PREF"contacts` WHERE contact_owner = '%d'", PlayerCache[playerid][pPhoneNumber]);
				tmp_cache = mysql_query(connHandle, query);
				
				format(list_contacts, sizeof(list_contacts), "911\t\tNumer alarmowy\n333\t\tHurtownia\n777\t\tTaxi\n444\t\tLos Santos News\n888\t\tGastronomie\n-----");

				cache_get_row_count(rows);
				for(new row = 0; row != rows; row++)
				{
				    contacts ++;
				    
				    cache_get_value_index_int(row, 0, contact_number);
				    cache_get_value_index(row, 1, contact_name, 24);
				
					format(list_contacts, sizeof(list_contacts), "%s\n%d\t\t%s", list_contacts, contact_number, contact_name);
    }
				if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
				
				if(strlen(list_contacts))
				{
				    if(contacts >= 20)  GivePlayerAchievement(playerid, ACHIEVE_VCARDS);
    				ShowPlayerDialog(playerid, D_CONTACT_LIST, DIALOG_STYLE_LIST, "Kontakty w telefonie", list_contacts, "Wybierz", "Anuluj");
				}
				else
				{
    				ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znaleziono żadnych kontaktów w telefonie.");
				}
	            return 1;
	        }
	        
	        if(list_item == 5)
	        {
 				new itemid = PlayerCache[playerid][pItemArray][ITEM_PHONE];

				PlayerItemCache[playerid][itemid][iUsed] = false;
				orm_update(PlayerItemCache[playerid][itemid][iOrm]);

				PlayerCache[playerid][pPhoneNumber] = 0;
				TD_ShowSmallInfo(playerid, 3, "Telefon zostal pomyslnie ~r~wylaczony~w~.");
	            return 1;
	        }
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_PHONE_CALL_NUMBER)
	{
		if(response)
		{
  			new string[12];
		    if(strval(inputtext) <= 0 || strlen(inputtext) > 6)
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzony numer telefonu jest nieprawidłowy.");
		        return 1;
			}
			
		    format(string, sizeof(string), "%d", strval(inputtext));
			pc_cmd_tel(playerid, string);
		    return 1;
		}
		else
		{
		    return 1;
		}
	}
	if(dialogid == D_PHONE_SMS_NUMBER)
	{
		if(response)
		{
  			new phone_number = strval(inputtext), string[128];
		    if(strval(inputtext) <= 0 || strlen(inputtext) > 6)
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzony numer telefonu jest nieprawidłowy.");
		        return 1;
			}
			
			PlayerCache[playerid][pMainTable] = phone_number;

   			format(string, sizeof(string), "Wprowadź treść wiadomości SMS, która zostanie wysłana na numer %d.", phone_number);
     		ShowPlayerDialog(playerid, D_PHONE_SEND_SMS, DIALOG_STYLE_INPUT, "Telefon » Wyślij SMS", string, "Wyślij", "Anuluj");
		    return 1;
		}
		else
		{
		    return 1;
		}
	}
	if(dialogid == D_PHONE_SEND_SMS)
	{
	    if(response)
	    {
     		new phone_number = PlayerCache[playerid][pMainTable], string[128];
	        format(string, sizeof(string), "%d %s", phone_number, inputtext);

	        pc_cmd_sms(playerid, string);
	        return 1;
	    }
		else
		{
		    return 1;
		}
	}
	if(dialogid == D_PHONE_SEND_VCARD)
	{
	    if(response)
	    {
     		new giveplayer_id = strval(inputtext);
     		if(!PlayerCache[giveplayer_id][pLogged] || !PlayerCache[giveplayer_id][pSpawned])
     		{
     		    return 1;
     		}
     		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
     		{
     		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
     		    return 1;
     		}
	        if(!PlayerCache[giveplayer_id][pPhoneNumber])
	        {
	            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz nie posiada telefonu w użyciu.");
	            return 1;
	        }
	        OnPlayerSendOffer(playerid, giveplayer_id, "vCard", OFFER_VCARD, PlayerCache[playerid][pPhoneNumber], 0, 0);
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_CONTACT_LIST)
	{
	    if(response)
	    {
	        new phone_number = strval(inputtext);
	        if(!strval(inputtext)) return 1;
	        
	        if(phone_number == NUMBER_WHOLESALE || phone_number == NUMBER_TAXI || phone_number == NUMBER_ALARM || phone_number == NUMBER_NEWS || phone_number == NUMBER_GASTRONOMY)
	        {
	            pc_cmd_tel(playerid, inputtext);
	            return 1;
	        }
	        new string[128], contact_name[32];
	        sscanf(inputtext, "ds[32]", phone_number, contact_name);
	        
	        PlayerCache[playerid][pMainTable] = phone_number;
	        
	        format(string, sizeof(string), "%s (%d) » Opcje kontaktu", contact_name, phone_number);
	        ShowPlayerDialog(playerid, D_CONTACT_OPTIONS, DIALOG_STYLE_LIST, string, "1. Połącz\n2. Wyślij SMS\n3. Usuń kontakt", "Wybierz", "Anuluj");
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_CONTACT_OPTIONS)
	{
	    if(response)
	    {
	        new list_items = strval(inputtext), string[128],
	            phone_number = PlayerCache[playerid][pMainTable];
	        
	        if(list_items == 1)
	        {
	            format(string, sizeof(string), "%d", phone_number);
	            pc_cmd_tel(playerid, string);
	            return 1;
	        }
	        
	        if(list_items == 2)
	        {
      			format(string, sizeof(string), "Wprowadź treść wiadomości SMS, która zostanie wysłana na numer %d.", phone_number);
     			ShowPlayerDialog(playerid, D_PHONE_SEND_SMS, DIALOG_STYLE_INPUT, "Telefon » Wyślij SMS", string, "Wyślij", "Anuluj");
	            return 1;
	        }
	        
	        if(list_items == 3)
	        {
	            format(string, sizeof(string), "Jesteś pewien, że chcesz usunąć kontakt z numerem %d?\nKontakt zostanie nieodwracalnie usunięty z książki telefonicznej.", phone_number);
	            ShowPlayerDialog(playerid, D_CONTACT_DELETE, DIALOG_STYLE_MSGBOX, "Telefon » Usuń kontakt", string, "Tak", "Nie");
	            return 1;
	        }
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_CONTACT_DELETE)
	{
	    if(response)
	    {
     		new phone_number = PlayerCache[playerid][pMainTable], query[256];
     		
	        mysql_format(connHandle, query, sizeof(query), "DELETE FROM `"SQL_PREF"contacts` WHERE contact_number = '%d' AND contact_owner = '%d' LIMIT 1", phone_number, PlayerCache[playerid][pPhoneNumber]);
			mysql_query(connHandle, query);

			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Kontakt z numerem %d został pomyślnie usunięty z listy kontaktów.", phone_number);
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_BANK_CREATE_ACCOUNT)
	{
	    if(response)
	    {
     		new bank_number = 100000000 + random(999999999);
     		
	        PlayerCache[playerid][pBankNumber] = bank_number;
			orm_update(PlayerCache[playerid][pOrm]);

	        ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Konto bankowe zostało założone pomyślnie.\nTwój nowy numer konta: %d.\n\nTeraz możesz swobodnie korzystać z bankomatów rozmieszczonych w mieście.", PlayerCache[playerid][pBankNumber]);
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_BANK_SELECT_OPTIONS)
	{
	    if(response)
	    {
     		new string[256];
	        switch(listitem)
	        {
				case 0:
				{
				    if(PlayerCache[playerid][pBankCash] >= 5000) 	GivePlayerAchievement(playerid, ACHIEVE_SAVINGS);
				    if(PlayerCache[playerid][pBankCash] >= 100000)  GivePlayerAchievement(playerid, ACHIEVE_RICH);
				
				    format(string, sizeof(string), "Właściciel:\t\t%s\nNumer konta:\t\t%d\nStan konta:\t\t$%d", PlayerRealName(playerid), PlayerCache[playerid][pBankNumber], PlayerCache[playerid][pBankCash]);
				    ShowPlayerDialog(playerid, D_NONE, DIALOG_STYLE_MSGBOX, "Konto bankowe", string, "OK", "");
				}
				case 1:
				{
				    ShowPlayerDialog(playerid, D_BANK_DEPOSIT, DIALOG_STYLE_INPUT, "Konto bankowe » Wpłać gotówkę", "Wprowadź kwotę jaką chcesz wpłacić na swoje konto bankowe:", "Wpłać", "Anuluj");
				}
				case 2:
				{
				    ShowPlayerDialog(playerid, D_BANK_WITHDRAW, DIALOG_STYLE_INPUT, "Konto bankowe » Wypłać gotówkę", "Wprowadź kwotę jaką chcesz wypłacić z konta bankowego:", "Wypłać", "Anuluj");
				}
				case 3:
				{
				    if(PlayerCache[playerid][pHours] < 5)
				    {
				        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz dokonać przelewu mając na koncie poniżej 5h gry.");
				        return 1;
				    }
				    ShowPlayerDialog(playerid, D_BANK_TRANSFER_NUMBER, DIALOG_STYLE_INPUT, "Konto bankowe » Dokonaj przelewu", "Wprowadź numer konta bankowego, na który chcesz przelać gotówkę:", "Dalej", "Anuluj");
				}
	        }
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_BANK_DEPOSIT)
	{
	    if(response)
	    {
			new deposit_cash = strval(inputtext);
			if(strlen(inputtext) > 11 || deposit_cash <= 0 || deposit_cash > PlayerCache[playerid][pCash])
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłową kwotę.");
			    return 1;
			}
   			crp_GivePlayerMoney(playerid, -deposit_cash);
			PlayerCache[playerid][pBankCash] += deposit_cash;

			orm_update(PlayerCache[playerid][pOrm]);
			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Na konto bankowe wpłacono kwotę $%d.\nNowy stan konta: $%d", deposit_cash, PlayerCache[playerid][pBankCash]);

			printf("[cash] %s (UID: %d, GID: %d) wpłacił $%d na swoje konto bankowe (bank: $%d, portfel: $%d).", PlayerRealName(playerid), PlayerCache[playerid][pUID], PlayerCache[playerid][pGID], deposit_cash, PlayerCache[playerid][pBankCash], PlayerCache[playerid][pCash]);
			return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_BANK_WITHDRAW)
	{
	    if(response)
	    {
  			new withdraw_cash = strval(inputtext);
			if(strlen(inputtext) > 11 || withdraw_cash <= 0 || withdraw_cash > PlayerCache[playerid][pBankCash])
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłową kwotę.");
			    return 1;
			}
			PlayerCache[playerid][pBankCash] -= withdraw_cash;
			crp_GivePlayerMoney(playerid, withdraw_cash);

			orm_update(PlayerCache[playerid][pOrm]);
			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Z konta bankowego wypłacono kwotę $%d.\nNowy stan konta: $%d", withdraw_cash, PlayerCache[playerid][pBankCash]);

            printf("[cash] %s (UID: %d, GID: %d) wypłacił $%d ze swojego konta bankowego (bank: $%d, portfel: $%d).", PlayerRealName(playerid), PlayerCache[playerid][pUID], PlayerCache[playerid][pGID], withdraw_cash, PlayerCache[playerid][pBankCash], PlayerCache[playerid][pCash]);
			return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_BANK_TRANSFER_NUMBER)
	{
	    if(response)
	    {
     		new bank_number = strval(inputtext),
	            char_uid = -1, char_gid = -1;

	        if(strlen(inputtext) > 9 || strlen(inputtext) < 9)
	        {
	            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłowy numer konta bankowego.");
	            return 1;
	        }
			new rows, Cache:tmp_cache, query[256];

			mysql_format(connHandle, query, sizeof(query), "SELECT `char_uid`, `char_gid` FROM `"SQL_PREF"characters` WHERE char_banknumb = '%d' LIMIT 1", bank_number);
			tmp_cache = mysql_query(connHandle, query);

            cache_get_row_count(rows);
			if(rows > 0)
			{
			    cache_get_value_index_int(0, 0, char_uid);
			    cache_get_value_index_int(0, 1, char_gid);
			}
			if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);

			if(char_uid == -1 || char_gid == -1)
			{
				ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłowy numer konta bankowego.");
				return 1;
			}
			if(char_uid == PlayerCache[playerid][pUID])
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz przelewać pieniędzy na własne konto bankowe.");
			    return 1;
			}
			if(char_gid == PlayerCache[playerid][pGID])
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz przelewać pieniędzy między własnymi postaciami!");
			    return 1;
			}
			PlayerCache[playerid][pMainTable] = char_uid;
			ShowPlayerDialog(playerid, D_BANK_TRANSFER_CASH, DIALOG_STYLE_INPUT, "Dokonaj przelewu » Kwota", "Wprowadź kwotę, jaką chcesz przelać na wybrane konto bankowe.\n\nUWAGA!\nGotówka jest pobierana bezpośrednio ze stanu konta bankowego, nie z portfela!", "Przelej", "Anuluj");
			return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_BANK_TRANSFER_CASH)
	{
	    if(response)
	    {
	    	new transfer_cash = strval(inputtext), char_uid = PlayerCache[playerid][pMainTable], giveplayer_id = GetPlayerID(char_uid);
			if(strlen(inputtext) > 11 || transfer_cash <= 0 || transfer_cash > PlayerCache[playerid][pBankCash])
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłową kwotę.");
			    return 1;
			}
			if(giveplayer_id != INVALID_PLAYER_ID && PlayerCache[giveplayer_id][pLogged] && PlayerCache[giveplayer_id][pSpawned])
			{
                PlayerCache[giveplayer_id][pBankCash] += transfer_cash;
                orm_update(PlayerCache[giveplayer_id][pOrm]);
			}
			else
			{
   				mysql_query_format("UPDATE `"SQL_PREF"characters` SET char_bankcash = char_bankcash + %d WHERE char_uid = '%d' LIMIT 1", transfer_cash, char_uid);
			}
			PlayerCache[playerid][pBankCash] -= transfer_cash;
			orm_update(PlayerCache[playerid][pOrm]);

			if(transfer_cash >= 10000)  GivePlayerAchievement(playerid, ACHIEVE_INTEREST);
			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Pieniądze zostały pomyślnie przelane.\nPrzelana ilość gotówki: %d\n\nGotówka została pobrana z Twojego konta bankowego.", transfer_cash);

            printf("[cash] %s (UID: %d, GID: %d) przelał $%d na konto bankowe gracza (UID: %d) (bank: $%d, portfel: $%d).", PlayerRealName(playerid), PlayerCache[playerid][pUID], PlayerCache[playerid][pGID], transfer_cash, char_uid, PlayerCache[playerid][pBankCash], PlayerCache[playerid][pCash]);
			return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_DISC_INSERT)
	{
	    if(response)
	    {
     		new itemid = PlayerCache[playerid][pItemArray][ITEM_DISC], player_itemid = DynamicGui_GetDataInt(playerid, listitem), string[128];
	        if(PlayerItemCache[playerid][player_itemid][iUsed])
	        {
	            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten odtwarzacz jest w użyciu, przestań pierw go używać.");
				return 1;
	        }
	        
 			PlayerItemCache[playerid][player_itemid][iValue][0] = PlayerItemCache[playerid][itemid][iValue][0];
	        orm_update(PlayerItemCache[playerid][player_itemid][iOrm]);

			format(string, sizeof(string), "* %s umieszcza płytę w odtwarzaczu.", PlayerName(playerid));
			ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);

			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Płyta została pomyślnie umieszczona w odtwarzaczu.\nUżyj tego odtwarzacza, by rozpocząć słuchanie muzyki.");
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_DISC_RECORD)
	{
	    if(response)
	    {
	    	new itemid = PlayerCache[playerid][pItemArray][ITEM_DISC], format_url[128], audio_uid;
	        if(strfind(inputtext, "http://", true))
	        {
	            ShowPlayerDialog(playerid, D_DISC_RECORD, DIALOG_STYLE_INPUT, "Czysta płyta » Nagrywanie", "To jest czysta płyta, na której możesz nagrać dowolny kawałek.\nWklej w pole tekstowe poniżej link do muzyki, która ma być odtwarzana poprzez urządzenia.\n\nUpewnij się, że link jest poprawny w innym wypadku muzyka może nie być słyszalna.\n\nDługość linku nie może przekroczyć 64 znaków.\n\n{FF0000}* Link musi rozpoczynać się na \"http://\".", "Nagraj", "Anuluj");
				return 1;
	        }
	        if(strlen(inputtext) <= 0)
	        {
	            ShowPlayerDialog(playerid, D_DISC_RECORD, DIALOG_STYLE_INPUT, "Czysta płyta » Nagrywanie", "To jest czysta płyta, na której możesz nagrać dowolny kawałek.\nWklej w pole tekstowe poniżej link do muzyki, która ma być odtwarzana poprzez urządzenia.\n\nUpewnij się, że link jest poprawny w innym wypadku muzyka może nie być słyszalna.\n\nDługość linku nie może przekroczyć 64 znaków.\n\n{FF0000}* Te pole nie może być puste!", "Nagraj", "Anuluj");
				return 1;
	        }
	        if(strlen(inputtext) > 64)
	        {
	            ShowPlayerDialog(playerid, D_DISC_RECORD, DIALOG_STYLE_INPUT, "Czysta płyta » Nagrywanie", "To jest czysta płyta, na której możesz nagrać dowolny kawałek.\nWklej w pole tekstowe poniżej link do muzyki, która ma być odtwarzana poprzez urządzenia.\n\nUpewnij się, że link jest poprawny w innym wypadku muzyka może nie być słyszalna.\n\nDługość linku nie może przekroczyć 64 znaków.\n\n{FF0000}* Link nie może przekroczyć 64 znaków!", "Nagraj", "Anuluj");
				return 1;
	        }
	        mysql_escape_string(inputtext, format_url);
			mysql_query_format("INSERT INTO `"SQL_PREF"audiourls` (`audio_url`) VALUES ('%s')", format_url);

			audio_uid = cache_insert_id();

			PlayerItemCache[playerid][itemid][iValue][0] = audio_uid;
			orm_update(PlayerItemCache[playerid][itemid][iOrm]);

			ShowPlayerDialog(playerid, D_DISC_NAME, DIALOG_STYLE_INPUT, "Czysta płyta » Nagrywanie » Nazwa", "Wprowadź w pole poniżej nazwę Twojej płyty, która będzie rozpoznawana w ekwipunku.\n\nNazwa nie może przekroczyć 12 znaków.", "Nagraj", "Pomiń");
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_DISC_NAME)
	{
	    if(response)
	    {
	    	new itemid = PlayerCache[playerid][pItemArray][ITEM_DISC], item_name[24];
	    	
      		if(strlen(inputtext) <= 0)
	        {
	            ShowPlayerDialog(playerid, D_DISC_NAME, DIALOG_STYLE_INPUT, "Czysta płyta » Nagrywanie » Nazwa", "Wprowadź w pole poniżej nazwę Twojej płyty, która będzie rozpoznawana w ekwipunku.\n\nNazwa nie może przekroczyć 12 znaków.\n\n{FF0000}* Te pole nie może być puste!", "Nagraj", "Pomiń");
	            return 1;
	        }
	        if(strlen(inputtext) >= 12)
	        {
	            ShowPlayerDialog(playerid, D_DISC_NAME, DIALOG_STYLE_INPUT, "Czysta płyta » Nagrywanie » Nazwa", "Wprowadź w pole poniżej nazwę Twojej płyty, która będzie rozpoznawana w ekwipunku.\n\nNazwa nie może przekroczyć 12 znaków.\n\n{FF0000}* Nazwa nie może przekroczyć więcej niż 12 znaków!", "Nagraj", "Pomiń");
	            return 1;
	        }
	        mysql_escape_string(inputtext, item_name);
	        
	        format(item_name, sizeof(item_name), "(CD) %s", item_name);
	        strmid(PlayerItemCache[playerid][itemid][iName], item_name, 0, strlen(item_name), 32);
	        
	        orm_update(PlayerItemCache[playerid][itemid][iOrm]);
	        ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Płyta została pomyślnie nagrana.\nPłytę nazwałeś następująco: %s.\n\nPłyty tej możesz odsłuchać w odtwarzaczu lub za pomocą sprzętu audio w pojeździe.", PlayerItemCache[playerid][itemid][iName]);
	        return 1;
	    }
	    else
	    {
	        new itemid = PlayerCache[playerid][pItemArray][ITEM_DISC];
	        
			strmid(PlayerItemCache[playerid][itemid][iName], "Plyta", 0, 5, 32);
			orm_update(PlayerItemCache[playerid][itemid][iOrm]);
			
			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Ustalono domyślną nazwę płyty.\n\nPłyty tej możesz odsłuchać w odtwarzaczu lub za pomocą sprzętu audio w pojeździe.");
	        return 1;
	    }
	}
	if(dialogid == D_RADIO_OPTIONS)
	{
	    if(response)
	    {
     		switch(listitem)
	        {
	            case 0:
	            {
	                ShowPlayerDialog(playerid, D_RADIO_SET_CANAL, DIALOG_STYLE_INPUT, "CB radio » Ustaw kanał", "Wprowadź numer kanału, z którym pragniesz się połączyć:", "Dalej", "Anuluj");
	            }
	            case 1:
	            {
	                ShowPlayerDialog(playerid, D_RADIO_BUY_CANAL, DIALOG_STYLE_INPUT, "CB radio » Wykup kanał na własność", "Wprowadź numer kanału, jaki zamierzasz zakupić na własność:", "Dalej", "Anuluj");
	            }
	            case 2:
	            {
	                ShowPlayerDialog(playerid, D_RADIO_CANAL_PASSWORD, DIALOG_STYLE_INPUT, "CB radio » Ustaw hasło dla kanału", "Wprowadź numer kanału, dla którego chcesz zmienić hasło:", "Dalej", "Anuluj");
	            }
	            case 3:
	            {
	                ShowPlayerDialog(playerid, D_RADIO_DELETE_CANAL, DIALOG_STYLE_INPUT, "CB radio » Definitywnie usuń kanał", "Wprowadź numer kanału, który chcesz usunąć:", "Dalej", "Anuluj");
	            }
	            case 4:
	            {
	                ShowPlayerDialog(playerid, D_RADIO_ASSIGN_CANAL, DIALOG_STYLE_INPUT, "CB radio » Przypisz kanał pod grupę", "Wprowadź numer kanału, który chcesz przypisać:", "Dalej", "Anuluj");
	            }
	        }
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_RADIO_SET_CANAL)
	{
	    if(response)
	    {
	        if(strlen(inputtext) > 11 || strval(inputtext) <= 0)
	        {
             	ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędny numer kanału.");
	            return 1;
	        }
	        new vehid = GetPlayerVehicleID(playerid), radio_canal = strval(inputtext), string[128],
				channel_ownertype, channel_owner, channel_password[32];

	        new rows, Cache:tmp_cache, query[256];

			mysql_format(connHandle, query, sizeof(query), "SELECT `channel_ownertype`, `channel_owner`, `channel_password`  FROM `"SQL_PREF"radio_channels` WHERE channel_canal = '%d' LIMIT 1", radio_canal);
			tmp_cache = mysql_query(connHandle, query);

            cache_get_row_count(rows);
	        if(rows > 0)
	        {
	            cache_get_value_index_int(0, 0, channel_ownertype);
	            cache_get_value_index_int(0, 1, channel_owner);
	            
	            cache_get_value_index(0, 2, channel_password, 32);
	            
	            if(channel_ownertype == OWNER_PLAYER || (channel_ownertype == OWNER_GROUP && IsPlayerInGroup(playerid, channel_owner)))
	            {
	                if(strlen(channel_password))
					{
					    PlayerCache[playerid][pMainTable] = radio_canal;

					    format(string, sizeof(string), "Wprowadź poniżej hasło dostępu dla kanału %d:", radio_canal);
	                	ShowPlayerDialog(playerid, D_RADIO_PASSWORD, DIALOG_STYLE_INPUT, "Wprowadź hasło", "Wprowadź poniżej hasło dostępu dla tego kanału:", "Połącz", "Anuluj");
					}
					else
					{
					    SetPlayerVehicleRadioCanal(playerid, vehid, radio_canal);
     					ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Pomyślnie połączyłeś się z kanałem %d.\nUżyj komendy /cb, by porozumiewać się na kanale z innymi.", radio_canal);
					}
				}
	            else
	            {
                    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz odpowiednich uprawnień, by móc połączyć się z tym kanałem.");
	            }
			}
	        else
	        {
	            SetPlayerVehicleRadioCanal(playerid, vehid, radio_canal);
	            ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Pomyślnie połączyłeś się z kanałem %d.\nUżyj komendy /cb, by porozumiewać się na kanale z innymi.", radio_canal);
			}
	        if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
	        return 1;
	    }
		else
		{
		    return 1;
		}
	}
	if(dialogid == D_RADIO_PASSWORD)
	{
	    if(response)
	    {
	        if(strlen(inputtext) >= 32 || strlen(inputtext) <= 0)
	        {
	            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzone hasło jest nieprawidłowe.");
	            return 1;
	        }
	        new vehid = GetPlayerVehicleID(playerid), radio_canal = PlayerCache[playerid][pMainTable], channel_password[128];
	        
            mysql_escape_string(inputtext, channel_password);
	        new rows, Cache:tmp_cache, query[256];

			mysql_format(connHandle, query, sizeof(query), "SELECT `channel_uid` FROM `"SQL_PREF"radio_channels` WHERE channel_canal = '%d' AND channel_password = '%s' LIMIT 1", radio_canal, channel_password);
			tmp_cache = mysql_query(connHandle, query);

            cache_get_row_count(rows);
			if(rows > 0)
			{
			    SetPlayerVehicleRadioCanal(playerid, vehid, radio_canal);
				ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Pomyślnie połączyłeś się z kanałem %d.\nUżyj komendy /cb, by porozumiewać się na kanale z innymi.", radio_canal);
			}
			else
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzone hasło jest nieprawidłowe.");
			}
			if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
			return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_RADIO_BUY_CANAL)
	{
	    if(response)
	    {
     		if(strlen(inputtext) > 11 || strval(inputtext) <= 0)
	        {
             	ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędny numer kanału.");
	            return 1;
	        }
	        new radio_canal = strval(inputtext), string[128];
	        new rows, Cache:tmp_cache, query[256];

			mysql_format(connHandle, query, sizeof(query), "SELECT `channel_uid` FROM `"SQL_PREF"radio_channels` WHERE channel_canal = '%d' LIMIT 1", radio_canal);
			tmp_cache = mysql_query(connHandle, query);

            cache_get_row_count(rows);
	        if(rows > 0)
	        {
	            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten kanał jest niedostępny.");
	        }
	        else
	        {
	            PlayerCache[playerid][pMainTable] = radio_canal;

	            format(string, sizeof(string), "Czy jesteś pewien, że chcesz kupić kanał %d na własność? Koszt: $250.", radio_canal);
	            ShowPlayerDialog(playerid, D_RADIO_ACCEPT_CANAL, DIALOG_STYLE_MSGBOX, "CB radio » Wykup kanał na własność", string, "Tak", "Nie");
	        }
	        if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_RADIO_ACCEPT_CANAL)
	{
	    if(response)
	    {
	        if(PlayerCache[playerid][pCash] < 250)
	        {
	            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz takiej ilości gotówki.");
	            return 1;
	        }
	        new radio_canal = PlayerCache[playerid][pMainTable];
	        mysql_query_format("INSERT INTO `"SQL_PREF"radio_channels` VALUES ('', '%d', '%d', '%d', '')", radio_canal, OWNER_PLAYER, PlayerCache[playerid][pUID]);

			crp_GivePlayerMoney(playerid, -250);
			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Wykupiłeś kanał %d na własność. W opcjach CB radio możesz nim zarządzać.", radio_canal);
			return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_RADIO_CANAL_PASSWORD)
	{
	    if(response)
	    {
   			if(strlen(inputtext) > 11 || strval(inputtext) <= 0)
	        {
             	ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędny numer kanału.");
	            return 1;
	        }
	        new radio_canal = strval(inputtext), string[256],
				channel_ownertype, channel_owner;

	        new rows, Cache:tmp_cache, query[256];

			mysql_format(connHandle, query, sizeof(query), "SELECT `channel_ownertype`, `channel_owner` FROM `"SQL_PREF"radio_channels` WHERE channel_canal = '%d' LIMIT 1", radio_canal);
	        tmp_cache = mysql_query(connHandle, query);
	        
	        cache_get_row_count(rows);
			if(rows > 0)
			{
				cache_get_value_index_int(0, 0, channel_ownertype);
				cache_get_value_index_int(0, 1, channel_owner);
				
    			if((channel_ownertype == OWNER_PLAYER && channel_owner == PlayerCache[playerid][pUID]) || (channel_ownertype == OWNER_GROUP && HavePlayerGroupPerm(playerid, channel_owner, G_PERM_LEADER)))
	            {
	                PlayerCache[playerid][pMainTable] = radio_canal;

	                format(string, sizeof(string), "Wprowadź poniżej hasło, jakie chcesz ustawić dla kanału %d.\nPuste pole całkowicie zdejmuje hasło dla kanału.\n\nHasło nie może przekroczyć 32 znaków.", radio_canal);
	                ShowPlayerDialog(playerid, D_RADIO_SET_PASSWORD, DIALOG_STYLE_INPUT, "CB radio » Ustaw hasło dla kanału", string, "Ustaw", "Anuluj");
				}
				else
				{
				    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie masz odpowiednich uprawnień, by móc zmienić hasło dla tego kanału.");
				}
			}
			else
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie masz odpowiednich uprawnień, by móc zmienić hasło dla tego kanału.");
			}
	        if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_RADIO_SET_PASSWORD)
	{
		if(response)
		{
  			if(strlen(inputtext) >= 32)
	        {
	            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wystąpił błąd", "Podane hasło jest za długie.");
	            return 1;
	        }
	        new radio_canal = PlayerCache[playerid][pMainTable];

   	        if(strlen(inputtext))
	        {
	            new channel_password[64];
           		mysql_escape_string(inputtext, channel_password);

	            mysql_query_format("UPDATE `"SQL_PREF"radio_channels` SET channel_password = '%s' WHERE channel_canal = '%d' LIMIT 1", channel_password, radio_canal);
				ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Hasło dla kanału %d zostało pomyślnie zmienione.\nNowe hasło: %s", radio_canal, channel_password);
			}
			else
			{
			    mysql_query_format("UPDATE `"SQL_PREF"radio_channels` SET channel_password = '' WHERE channel_canal = '%d' LIMIT 1", radio_canal);
				ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Hasło dla kanału %d zostało pomyślnie zdjęte.", radio_canal);
			}
			return 1;
		}
		else
		{
		    return 1;
		}
	}
	if(dialogid == D_RADIO_DELETE_CANAL)
	{
		if(response)
		{
			if(strlen(inputtext) > 11 || strval(inputtext) <= 0)
	        {
             	ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędny numer kanału.");
	            return 1;
	        }
	        new radio_canal = strval(inputtext), string[128],
				channel_ownertype, channel_owner;

	        new rows, Cache:tmp_cache, query[256];

			mysql_format(connHandle, query, sizeof(query), "SELECT `channel_ownertype`, `channel_owner` FROM `"SQL_PREF"radio_channels` WHERE channel_canal = '%d' LIMIT 1", radio_canal);
			tmp_cache = mysql_query(connHandle, query);

            cache_get_row_count(rows);
			if(rows > 0)
			{
				cache_get_value_index_int(0, 0, channel_ownertype);
				cache_get_value_index_int(0, 1, channel_owner);
				
    			if((channel_ownertype == OWNER_PLAYER && channel_owner == PlayerCache[playerid][pUID]) || (channel_ownertype == OWNER_GROUP && HavePlayerGroupPerm(playerid, channel_owner, G_PERM_LEADER)))
	            {
	                PlayerCache[playerid][pMainTable] = radio_canal;

					format(string, sizeof(string), "Czy jesteś pewien, że chcesz definitywnie usunąć kanał %d?", radio_canal);
					ShowPlayerDialog(playerid, D_RADIO_DELETE_ACCEPT, DIALOG_STYLE_MSGBOX, "CB radio » Definitywnie usuń kanał", string, "Tak", "Nie");
				}
				else
				{
				    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz odpowiednich uprawnień, by móc usunąć ten kanał.");
				}
			}
			else
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz odpowiednich uprawnień, by móc usunąć ten kanał.");
			}
	        if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
		    return 1;
		}
		else
		{
		    return 1;
		}
	}
	if(dialogid == D_RADIO_DELETE_ACCEPT)
	{
	    if(response)
	    {
	        new radio_canal = PlayerCache[playerid][pMainTable];
	        mysql_query_format("DELETE FROM `"SQL_PREF"radio_channels` WHERE channel_canal = '%d' LIMIT 1", radio_canal);
	        
			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Kanał %d został definitywnie usunięty.", radio_canal);
			return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_RADIO_ASSIGN_CANAL)
	{
	    if(response)
	    {
  			if(strlen(inputtext) > 11 || strval(inputtext) <= 0)
	        {
             	ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędny numer kanału.");
	            return 1;
	        }
	        new radio_canal = strval(inputtext),
				channel_ownertype, channel_owner;

	        new rows, Cache:tmp_cache, query[256];

			mysql_format(connHandle, query, sizeof(query), "SELECT `channel_ownertype`, `channel_owner` FROM `"SQL_PREF"radio_channels` WHERE channel_canal = '%d' LIMIT 1", radio_canal);
            tmp_cache = mysql_query(connHandle, query);

            cache_get_row_count(rows);
			if(rows > 0)
			{
				cache_get_value_index_int(0, 0, channel_ownertype);
				cache_get_value_index_int(0, 1, channel_owner);
				
    			if(channel_ownertype == OWNER_PLAYER && channel_owner == PlayerCache[playerid][pUID])
	            {
	                PlayerCache[playerid][pMainTable] = radio_canal;

					DynamicGui_Init(playerid);

					new list_groups[256], group_id;
					for (new group_slot = 0; group_slot < MAX_GROUP_SLOTS; group_slot++)
					{
						if(PlayerGroup[playerid][group_slot][gpUID])
			  			{
			  				group_id = PlayerGroup[playerid][group_slot][gpID];
							format(list_groups, sizeof(list_groups), "%s\n%d\t%s (%d)", list_groups, group_slot + 1, GroupData[group_id][gName], GroupData[group_id][gUID]);

							DynamicGui_AddRow(playerid, D_RADIO_ASSIGN_ACCEPT, group_slot);
						}
					}
					ShowPlayerDialog(playerid, D_RADIO_ASSIGN_ACCEPT, DIALOG_STYLE_LIST, "SLOT      NAZWA GRUPY", list_groups, "Wybierz", "Anuluj");
				}
				else
				{
				    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz odpowiednich uprawnień, by móc przypisać ten kanał.");
				}
			}
			else
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz odpowiednich uprawnień, by móc przypisać ten kanał.");
			}
	        if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_RADIO_ASSIGN_ACCEPT)
	{
	    if(response)
	    {
	        new group_slot = DynamicGui_GetDataInt(playerid, listitem), radio_canal = PlayerCache[playerid][pMainTable];
			if(group_slot < 0)
			{
			    TD_ShowSmallInfo(playerid, 3, "Przypisywanie kanalu zostalo ~r~anulowane~w~.");
			    return 1;
			}
			new group_id = PlayerGroup[playerid][group_slot][gpID];
			if(!HavePlayerGroupPerm(playerid, GroupData[group_id][gUID], G_PERM_LEADER))
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz odpowiednich uprawnień dla tej grupy.");
			    return 1;
			}
			
			mysql_query_format("UPDATE `"SQL_PREF"radio_channels` SET channel_ownertype = '%d', channel_owner = '%d' WHERE channel_canal = '%d' LIMIT 1", OWNER_GROUP, GroupData[group_id][gUID], radio_canal);
			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Kanał %d został pomyślnie przypisany pod grupę.\nKanał przypisano dla grupy %s (UID: %d).", radio_canal, GroupData[group_id][gName], GroupData[group_id][gUID]);
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_ROOM_PRICE)
	{
		if(response)
		{
		    new price = strval(inputtext);
		    if(price < 0 || strlen(inputtext) > 11 || price > 100)
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłową kwotę.");
		        return 1;
		    }
		    new doorid = GetPlayerDoorID(playerid);
		    if(doorid == INVALID_DOOR_ID)
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w hotelu.");
		        return 1;
		    }
   			new DoorData[sDoorInfo];
			Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
			
		    if(DoorData[dOwnerType] != OWNER_GROUP || !HavePlayerGroupPerm(playerid, DoorData[dOwner], G_PERM_LEADER))
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz odpowiednich uprawnień do użycia tej funkcji.");
		        return 1;
		    }
		    new group_id = GetGroupID(DoorData[dOwner]);

			GroupData[group_id][gValue1] = price;
			orm_update(GroupData[group_id][gOrm]);

			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Koszt wynajmu pokoju został pomyślnie zmieniony.\nNowy koszt za wynajem pokoju wynosi: $%d.", GroupData[group_id][gValue1]);
		    return 1;
		}
		else
		{
		    return 1;
		}
	}
	if(dialogid == D_TUNING_UNMOUNT)
	{
	    if(response)
	    {
  			new item_uid = DynamicGui_GetValue(playerid, listitem), componentid = DynamicGui_GetDataInt(playerid, listitem), vehid = GetPlayerVehicleID(playerid);
			mysql_query_format("UPDATE `"SQL_PREF"items` SET item_ownertype = '%d', item_owner = '%d', item_vehuid = '0' WHERE item_uid = '%d' LIMIT 1", PLACE_PLAYER, PlayerCache[playerid][pUID], item_uid);

			LoadPlayerItem(playerid, item_uid);
			crp_RemoveVehicleComponent(vehid, componentid);

			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Część została odmontowana pomyślnie.\nOdmontowaną część znajdziesz w swoim ekwipunku.");
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_ACCESS_APPLY)
	{
		if(IsPlayerInAnyVehicle(playerid))
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz tego zrobić siedząc w pojeździe.");
	    	return 1;
		}

		new itemid = PlayerCache[playerid][pItemArray][ITEM_CLOTH_ACCESS],
			slot_index = GetPlayerFreeSlotAccess(playerid);
			
		if(slot_index == INVALID_SLOT_ID)
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znaleziono żadnego wolnego slotu dla akcesoria.");
	    	return 1;
		}

		new access_uid, access_model, access_bone,
  			Float:access_posx, Float:access_posy, Float:access_posz,
			Float:access_rotx, Float:access_roty, Float:access_rotz,
			Float:access_scalex, Float:access_scaley, Float:access_scalez;
			
		if(PlayerItemCache[playerid][itemid][iValue][0])			access_uid = PlayerItemCache[playerid][itemid][iValue][0];
		else if(PlayerItemCache[playerid][itemid][iValue][1]) 		access_uid = PlayerItemCache[playerid][itemid][iValue][1];

		new rows, Cache:tmp_cache, query[512];
		
		mysql_format(connHandle, query, sizeof(query), "SELECT `attach_model`, `attach_bone`, `attach_x`, `attach_y`, `attach_z`, `attach_rx`, `attach_ry`, `attach_rz`, `attach_sx`, `attach_sy`, `attach_sz` FROM `"SQL_PREF"attached_objects` WHERE attach_uid = '%d' LIMIT 1", access_uid);
		tmp_cache = mysql_query(connHandle, query);

        cache_get_row_count(rows);
		if(rows > 0)
		{
		    cache_get_value_index_int(0, 0, access_model);
		    cache_get_value_index_int(0, 1, access_bone);
		    
		    cache_get_value_index_float(0, 2, access_posx);
		    cache_get_value_index_float(0, 3, access_posy);
		    cache_get_value_index_float(0, 4, access_posz);
		    
		    cache_get_value_index_float(0, 5, access_rotx);
		    cache_get_value_index_float(0, 6, access_roty);
		    cache_get_value_index_float(0, 7, access_rotz);
		    
		    cache_get_value_index_float(0, 8, access_scalex);
		    cache_get_value_index_float(0, 9, access_scaley);
		    cache_get_value_index_float(0, 10, access_scalez);
		
			SetPlayerAttachedObject(playerid, slot_index, access_model, access_bone, access_posx, access_posy, access_posz, access_rotx, access_roty, access_rotz, access_scalex, access_scaley, access_scalez);
		}
		if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
		
  		PlayerItemCache[playerid][itemid][iUsed] = true;
    	orm_update(PlayerItemCache[playerid][itemid][iOrm]);
	
	    if(response)
	    {
	        TD_ShowSmallInfo(playerid, 3, "Akcesorie zostalo ~g~pomyslnie ~w~zalozone.");
	        return 1;
	    }
	    else
		{
			EditAttachedObject(playerid, slot_index);
			TD_ShowSmallInfo(playerid, 3, "Dopasuj ~y~akcesorie ~w~wzgledem swojego skina.");
	        return 1;
	    }
	}
	if(dialogid == D_CLOTH_TYPE_SELECT)
	{
	    if(response)
	    {
    		new Float:PosX, Float:PosY, Float:PosZ;
			GetPlayerPos(playerid, PosX, PosY, PosZ);
			
			GetXYInFrontOfPlayer(playerid, PosX, PosY, 3.5);
			
			switch(listitem)
			{
			    case 0:
			    {
			        SetPlayerCameraPos(playerid, PosX, PosY, PosZ + 0.5);
			    
			        PlayerCache[playerid][pSelectSkin] = 0;
			        TD_ShowSmallInfo(playerid, 0, "Uzywaj ~y~strzalek~w~, aby wybrac ~g~ubranie~w~.~n~~n~~y~~k~~VEHICLE_ENTER_EXIT~ ~w~- dokonaj zakupu~n~~y~~k~~PED_JUMPING~ ~w~- anuluj zakup");
			    }
			    case 1:
			    {
			        SetPlayerCameraPos(playerid, PosX, PosY, PosZ + 1.5);
			    
			        PlayerCache[playerid][pSelectAccess] = 0;
			        TD_ShowSmallInfo(playerid, 0, "Uzywaj ~y~strzalek~w~, aby wybrac ~g~akcesorie~w~.~n~~n~~y~~k~~VEHICLE_ENTER_EXIT~ ~w~- dokonaj zakupu~n~~y~~k~~PED_JUMPING~ ~w~- anuluj zakup");
			    }
			}
			
			GetPlayerPos(playerid, PosX, PosY, PosZ);
			SetPlayerCameraLookAt(playerid, PosX, PosY, PosZ);

            OnPlayerFreeze(playerid, true, 0);
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_DIRECTORY_LIST)
	{
	    if(response)
	    {
			if(!strfind(inputtext, "Dodaj nowy wpis...", true))
			{
				ShowPlayerDialog(playerid, D_DIRECTORY_ADD, DIALOG_STYLE_INPUT, "Kartoteka » Dodaj nowy wpis", "Wprowadź poniżej treść wpisu, który zostanie dodany do kartoteki tego gracza.\nMaksymalna ilość znaków wynosi: 64.", "Dodaj", "Anuluj");
			    return 1;
			}
			
			new directory_uid = DynamicGui_GetDataInt(playerid, listitem);
			if(directory_uid == 0)  return 1;
			
			new string[256], title[64],
				giver_name[32], directory_reason[64], directory_date[32], directory_pdp;
				
			new rows, Cache:tmp_cache, query[256];

			mysql_format(connHandle, query, sizeof(query), "SELECT `char_name`, `directory_reason`, `directory_date`, `directory_pdp` FROM `"SQL_PREF"directory`, `"SQL_PREF"characters` WHERE char_uid = directory_giver AND directory_uid = '%d' LIMIT 1", directory_uid);
            tmp_cache = mysql_query(connHandle, query);

            cache_get_row_count(rows);
			if(rows > 0)
			{
			    cache_get_value_index(0, 0, giver_name, 32);
			    
			    cache_get_value_index(0, 1, directory_reason, 64);
			    cache_get_value_index(0, 2, directory_date, 32);
			    
			    cache_get_value_index_int(0, 3, directory_pdp);
			    
		    	new pos = strfind(giver_name, "_", true);

				while(pos != -1)	{ giver_name[pos] = ' ';	pos = strfind(giver_name, "_", true); }
			    format(string, sizeof(string), "Funkcjonariusz: %s\nPunkty karne: %d\n\nTreść wpisu:\n%s\n\nCzas: %s", giver_name, directory_pdp, directory_reason, directory_date);

				format(title, sizeof(title), "Szczegóły wpisu (identyfikator: %d)", directory_uid);
				ShowPlayerDialog(playerid, D_NONE, DIALOG_STYLE_MSGBOX, title, string, "OK", "");
			}
			else
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znaleziono wpisu o danym identyfikatorze.");
			}
			if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
			return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_DIRECTORY_ADD)
	{
	    if(response)
	    {
     		if(strlen(inputtext) > 64)
	        {
	            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podana treść przekracza maksymalną ilość znaków.\nSpróbuj ponownie, wpisując inną treść.");
	            return 1;
	        }
	        
	        new directory_owner = PlayerCache[playerid][pMainTable],
	            directory_giver = PlayerCache[playerid][pUID],
	            directory_reason[128], directory_uid;

            mysql_escape_string(inputtext, directory_reason);
            mysql_query_format("INSERT INTO `"SQL_PREF"directory` VALUES ('', '%d', '%d', '%s', '0', NOW())", directory_owner, directory_giver, directory_reason);

			directory_uid = cache_insert_id();
			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Pomyślnie dodano nowy wpis do kartoteki.\nIdentyfikator wpisu: %d", directory_uid);
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_BLOCK_WHEEL)
	{
	    if(response)
	    {
     		new price = strval(inputtext), vehid = PlayerCache[playerid][pMainTable];
	        if(strlen(inputtext) > 6 || price <= 0 || price > 25000)
	        {
				ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłową kwotę.");
	            return 1;
	        }
	        CarInfo[vehid][cBlockWheel] = price;

	        CarInfo[vehid][cWorldID] = GetVehicleVirtualWorld(vehid);
	        CarInfo[vehid][cInteriorID] = GetPlayerInterior(playerid);

	        GetVehiclePos(vehid, CarInfo[vehid][cPosX], CarInfo[vehid][cPosY], CarInfo[vehid][cPosZ]);
	        GetVehicleZAngle(vehid, CarInfo[vehid][cPosA]);

			orm_update(CarInfo[vehid][cOrm]);
			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Blokada na koło została założona.\n\nZablokowany pojazd: %s\nKoszt zdjęcia blokady: $%d\n\nPojazd został automatycznie zaparkowany w tym miejscu.", GetVehicleName(CarInfo[vehid][cModel]), price);
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_REGISTER_EDIT)
	{
	    if(response)
	    {
	        if(strlen(inputtext) > 12)
	        {
        		ShowPlayerDialog(playerid, D_REGISTER_EDIT, DIALOG_STYLE_INPUT, "Własna rejestracja", "Wprowadź poniżej treść własnej rejestracji.\nNapis na rejestracji zostanie zmieniony zgodnie z podana treścią.\n\nIlość znaków w rejestracji nie może przekroczyć 12.\n\n{FF0000}* Podana treść nie może przekroczyć liczby 12 znaków", "Zmień", "Anuluj");
	            return 1;
	        }
	        if(!strfind(inputtext, "LS", true))
	        {
                ShowPlayerDialog(playerid, D_REGISTER_EDIT, DIALOG_STYLE_INPUT, "Własna rejestracja", "Wprowadź poniżej treść własnej rejestracji.\nNapis na rejestracji zostanie zmieniony zgodnie z podana treścią.\n\nIlość znaków w rejestracji nie może przekroczyć 12.\n\n{FF0000}* Nie możesz wpisać tej treści w rejestracji", "Zmień", "Anuluj");
	            return 1;
	        }
	        new vehid = GetPlayerVehicleID(playerid),
				register_desc[32];

			if(!strlen(inputtext))		format(register_desc, sizeof(register_desc), "LS%d", CarInfo[vehid][cUID]);
			else						mysql_escape_string(inputtext, register_desc);

			strmid(CarInfo[vehid][cRegister], register_desc, 0, strlen(register_desc), 12);
			SetVehicleNumberPlate(vehid, CarInfo[vehid][cRegister]);

			orm_update(CarInfo[vehid][cOrm]);
         	ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Treść rejestracji została pomyślnie zmodyfikowana.\n\nTreść rejestracji: %s", CarInfo[vehid][cRegister]);
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_PLAY_ANIM)
	{
	    if(response)
	    {
     		new anim_id = DynamicGui_GetDataInt(playerid, listitem);
	        if(!AnimCache[anim_id][aAction])
	        {
	        	ApplyAnimation(playerid, AnimCache[anim_id][aLib], AnimCache[anim_id][aName], AnimCache[anim_id][aSpeed], AnimCache[anim_id][aOpt1], AnimCache[anim_id][aOpt2], AnimCache[anim_id][aOpt3], AnimCache[anim_id][aOpt4], AnimCache[anim_id][aOpt5], true);
				TD_ShowSmallInfo(playerid, 3, "~g~PPM ~w~anuluje gre animacji.");
			}
			else
			{
			    SetPlayerSpecialAction(playerid, AnimCache[anim_id][aAction]);
				TD_ShowSmallInfo(playerid, 3, "~g~~k~~VEHICLE_ENTER_EXIT~ ~w~anuluje gre animacji.");
			}
			PlayerCache[playerid][pPlayAnim] = true;
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_WALK_ANIM)
	{
	    if(response)
	    {
			new anim_id = DynamicGui_GetDataInt(playerid, listitem);
			
			PlayerCache[playerid][pWalkStyle] = AnimCache[anim_id][aUID];
			orm_update(PlayerCache[playerid][pOrm]);
			
			PlayerCache[playerid][pWalkStyle] = anim_id;
			TD_ShowSmallInfo(playerid, 3, "Animacja chodzenia zostala ~g~pomyslnie ~w~wybrana.~n~Klawisz ~r~~k~~SNEAK_ABOUT~ ~w~aktywuje animacje.");
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_ORDER_CATEGORY)
	{
	    if(response)
	    {
	        new doorid = PlayerCache[playerid][pMainTable],
	            list_orders[1024], order_category = strval(inputtext), order_uid, order_name[32], order_price;

			new DoorData[sDoorInfo];
			Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
			
			new group_id = GetGroupID(DoorData[dOwner]);
			new rows, Cache:tmp_cache, query[512];
			
			mysql_format(connHandle, query, sizeof(query), "SELECT `order_uid`, `order_name`, `order_price` FROM `"SQL_PREF"orders` WHERE order_cat = '%d' AND order_owner = '%d' AND order_extraid = '0' OR order_cat = '%d' AND order_owner = '0' AND order_extraid = '%d'", order_category, GroupData[group_id][gType], order_category, GroupData[group_id][gUID]);
			tmp_cache = mysql_query(connHandle, query);
			
			cache_get_row_count(rows);
			for(new row = 0; row != rows; row++)
			{
			    cache_get_value_index_int(row, 0, order_uid);
                cache_get_value_index(row, 1, order_name, 32);
                
                cache_get_value_index_int(row, 2, order_price);
			    
			    format(list_orders, sizeof(list_orders), "%s\n%d\t$%d\t%s", list_orders, order_uid, order_price, order_name);
   			}
			if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
			
			if(strlen(list_orders))
			{
			    ShowPlayerDialog(playerid, D_ORDER_PRODUCT, DIALOG_STYLE_LIST, "Wybierz produkt:", list_orders, "Wybierz", "Anuluj");
			}
			else
			{
   				TD_ShowSmallInfo(playerid, 3, "Nie posiadasz tutaj ~r~dostepu~w~.");

				PlayerCache[playerid][pMainTable] = 0;
				PlayerCache[playerid][pCallingTo] = INVALID_PLAYER_ID;

				SetPlayerSpecialAction(playerid, SPECIAL_ACTION_STOPUSECELLPHONE);
				RemovePlayerAttachedObject(playerid, SLOT_PHONE);
			}
	        return 1;
	    }
	    else
	    {
	        TD_ShowSmallInfo(playerid, 3, "Zamawianie zostalo ~r~anulowane~w~.");
	    
			PlayerCache[playerid][pMainTable] = 0;
			PlayerCache[playerid][pCallingTo] = INVALID_PLAYER_ID;

			SetPlayerSpecialAction(playerid, SPECIAL_ACTION_STOPUSECELLPHONE);
			RemovePlayerAttachedObject(playerid, SLOT_PHONE);
	        return 1;
	    }
	}
	if(dialogid == D_ORDER_PRODUCT)
	{
	    if(response)
	    {
     		new string[256];
	        sscanf(inputtext, "d'$'ds[32]", OrderCache[playerid][oUID], OrderCache[playerid][oPrice], OrderCache[playerid][oName]);

			format(string, sizeof(string), "Wprowadź poniżej, ile produktów tego typu chcesz zamówić.\nJeżeli zamawiasz hurtowo, cena maleje aż o 10%%.\n\nNazwa produktu: %s\nKoszt za sztukę: $%d", OrderCache[playerid][oName], OrderCache[playerid][oPrice]);
			ShowPlayerDialog(playerid, D_ORDER_COUNT, DIALOG_STYLE_INPUT, "Ilość sztuk", string, "Dalej", "Anuluj");
	        return 1;
	    }
	    else
	    {
     		TD_ShowSmallInfo(playerid, 3, "Zamawianie zostalo ~r~anulowane~w~.");

			PlayerCache[playerid][pMainTable] = 0;
			PlayerCache[playerid][pCallingTo] = INVALID_PLAYER_ID;

			SetPlayerSpecialAction(playerid, SPECIAL_ACTION_STOPUSECELLPHONE);
			RemovePlayerAttachedObject(playerid, SLOT_PHONE);
	        return 1;
	    }
	}
	if(dialogid == D_ORDER_COUNT)
	{
	    if(response)
	    {
   			new product_count = strval(inputtext), string[256];
			if(strlen(inputtext) > 11 || product_count <= 0)
			{
				format(string, sizeof(string), "Wprowadź poniżej, ile produktów tego typu chcesz zamówić.\nJeżeli zamawiasz hurtowo, cena maleje aż o 10%%.\n\nNazwa produktu: %s\nKoszt za sztukę: $%d", OrderCache[playerid][oName], OrderCache[playerid][oPrice]);
				ShowPlayerDialog(playerid, D_ORDER_COUNT, DIALOG_STYLE_INPUT, "Ilość sztuk", string, "Dalej", "Anuluj");

				TD_ShowSmallInfo(playerid, 3, "Wprowadzono ~r~bledna ~w~ilosc sztuk.");
			    return 1;
			}
			new doorid = PlayerCache[playerid][pMainTable], DoorData[sDoorInfo];
			Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);

			new group_id = GetGroupID(DoorData[dOwner]);
			if(HavePlayerGroupPerm(playerid, GroupData[group_id][gUID], G_PERM_CAPITAL) && PlayerCache[playerid][pDuty][DUTY_GROUP] == group_id)
			{
				if(GroupData[group_id][gCapital] < OrderCache[playerid][oPrice] * product_count)
				{
					format(string, sizeof(string), "Wprowadź poniżej, ile produktów tego typu chcesz zamówić.\nJeżeli zamawiasz hurtowo, cena maleje aż o 10%%.\n\nNazwa produktu: %s\nKoszt za sztukę: $%d", OrderCache[playerid][oName], OrderCache[playerid][oPrice]);
					ShowPlayerDialog(playerid, D_ORDER_COUNT, DIALOG_STYLE_INPUT, "Ilość sztuk", string, "Dalej", "Anuluj");

					TD_ShowSmallInfo(playerid, 3, "Grupa ~r~nie posiada ~w~takiej ilosci pieniedzy w kapitale.");
				    return 1;
				}
			}
			else
			{
				if(PlayerCache[playerid][pCash] < OrderCache[playerid][oPrice] * product_count)
				{
					format(string, sizeof(string), "Wprowadź poniżej, ile produktów tego typu chcesz zamówić.\nJeżeli zamawiasz hurtowo, cena maleje aż o 10%%.\n\nNazwa produktu: %s\nKoszt za sztukę: $%d", OrderCache[playerid][oName], OrderCache[playerid][oPrice]);
					ShowPlayerDialog(playerid, D_ORDER_COUNT, DIALOG_STYLE_INPUT, "Ilość sztuk", string, "Dalej", "Anuluj");

					TD_ShowSmallInfo(playerid, 3, "Nie posiadasz tyle ~r~gotowki~w~.");
				    return 1;
				}
			}
			OrderCache[playerid][oCount] = product_count;
			ShowPlayerDialog(playerid, D_ORDER_PRICE, DIALOG_STYLE_INPUT, "Koszt produktu", "Wprowadź oferowaną cenę produktu.\nCena jaką wprowadzisz będzie pobierana za zakup produktu w Twojej instytucji.\n\nCena powinna być wyższa niż hurtowa, byś miał profit z wyprzedanych produktów.\nKoszt danego produktu możesz zmienić za pomocą /drzwi opcje, bądź w panelu.", "Zamów", "Anuluj");
	        return 1;
	    }
	    else
	    {
   			TD_ShowSmallInfo(playerid, 3, "Zamawianie zostalo ~r~anulowane~w~.");

			PlayerCache[playerid][pMainTable] = 0;
			PlayerCache[playerid][pCallingTo] = INVALID_PLAYER_ID;

			SetPlayerSpecialAction(playerid, SPECIAL_ACTION_STOPUSECELLPHONE);
			RemovePlayerAttachedObject(playerid, SLOT_PHONE);
	        return 1;
	    }
	}
	if(dialogid == D_ORDER_PRICE)
	{
		if(response)
		{
  			new price = strval(inputtext), doorid = PlayerCache[playerid][pMainTable];
	        if(price <= 0 || strlen(inputtext) >= 10 || price < OrderCache[playerid][oPrice] || price > (OrderCache[playerid][oPrice] + floatround(OrderCache[playerid][oPrice] * 1.5)))
	        {
				ShowPlayerDialog(playerid, D_ORDER_PRICE, DIALOG_STYLE_INPUT, "Koszt produktu", "Wprowadź oferowaną cenę produktu.\nCena jaką wprowadzisz będzie pobierana za zakup produktu w Twojej instytucji.\n\nCena powinna być wyższa niż hurtowa, byś miał profit z wyprzedanych produktów.\nKoszt danego produktu możesz zmienić za pomocą /drzwi opcje, bądź w panelu.", "Zamów", "Anuluj");
				TD_ShowSmallInfo(playerid, 3, "Wprowadzono ~r~bledna ~w~cene produktu.");
	            return 1;
	        }
  			new order_price = OrderCache[playerid][oPrice] * OrderCache[playerid][oCount], string[256],
			    order_item_type, order_item_value1, order_item_value2, order_type, order_limit, order_time_limit;

			// Jednak weźmiemy mu o 10% mniej gotówki, niech zarobi
			if(OrderCache[playerid][oCount] >= 20)	order_price = floatround(order_price * 0.9);
			new rows, Cache:tmp_cache, query[256];

			mysql_format(connHandle, query, sizeof(query), "SELECT `order_item_type`, `order_item_value1`, `order_item_value2`, `order_type`, `order_limit`, `order_time_limit` FROM `"SQL_PREF"orders` WHERE order_uid = '%d' LIMIT 1", OrderCache[playerid][oUID]);
            tmp_cache = mysql_query(connHandle, query);

            cache_get_row_count(rows);
			if(rows > 0)
			{
				cache_get_value_index_int(0, 0, order_item_type);
				
				cache_get_value_index_int(0, 1, order_item_value1);
				cache_get_value_index_int(0, 2, order_item_value2);
				
				cache_get_value_index_int(0, 3, order_type);
				
				cache_get_value_index_int(0, 4, order_limit);
				cache_get_value_index_int(0, 5, order_time_limit);
			}
			if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
			
			new DoorData[sDoorInfo];
			Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
			
			// Limity na zamawianie
			if(order_limit > 0 && order_time_limit > 0)
			{
			    new transaction_sum;
			    
			    // Sprawdzamy transakcje grupy dla tego produktu
			    mysql_format(connHandle, query, sizeof(query), "SELECT SUM(transaction_value) FROM `"SQL_PREF"group_transactions` WHERE transaction_type = '%d' AND transaction_group = '%d' AND transaction_extraid = '%d' AND transaction_date > %d - %d", TRANSACTION_ORDER, DoorData[dOwner], OrderCache[playerid][oUID], gettime(), (86400 * order_time_limit));
			    tmp_cache = mysql_query(connHandle, query);
			    
			    cache_get_row_count(rows);
			    
			    if(rows > 0)    cache_get_value_index_int(0, 0, transaction_sum);
			    if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
			    
			    // Jeśli przekroczył limit
			    if(transaction_sum + OrderCache[playerid][oCount] > order_limit)
			    {
					format(string, sizeof(string), "Wprowadź poniżej, ile produktów tego typu chcesz zamówić.\nJeżeli zamawiasz hurtowo, cena maleje aż o 10%%.\n\nNazwa produktu: %s\nKoszt za sztukę: $%d", OrderCache[playerid][oName], OrderCache[playerid][oPrice]);
					ShowPlayerDialog(playerid, D_ORDER_COUNT, DIALOG_STYLE_INPUT, "Ilość sztuk", string, "Dalej", "Anuluj");
					
					TD_ShowSmallInfo(playerid, 10, "Na ten produkt zostal narzucony ~r~limit zamawiania~w~.~n~Mozesz zamowic ~y~%d sztuk ~w~tego produktu na ~y~%d dni~w~.~n~~n~Pozostala ilosc sztuk tego produktu to: ~y~%d~w~.", order_limit, order_time_limit, order_limit - transaction_sum);
			        return 1;
			    }
			}

			new group_id = GetGroupID(DoorData[dOwner]);
			if(HavePlayerGroupPerm(playerid, GroupData[group_id][gUID], G_PERM_CAPITAL) && PlayerCache[playerid][pDuty][DUTY_GROUP] == group_id)
			{
				GroupData[group_id][gCapital] -= order_price;
				orm_update(GroupData[group_id][gOrm]);
			}
			else
			{
				crp_GivePlayerMoney(playerid, -order_price);
				orm_update(PlayerCache[playerid][pOrm]);
			}
			
			mysql_query_format("INSERT INTO `"SQL_PREF"packages` (`package_dooruid`, `package_item_name`, `package_item_type`, `package_item_value1`, `package_item_value2`, `package_item_count`, `package_item_price`, `package_type`) VALUES ('%d', '%s', '%d', '%d', '%d', '%d', '%d', '%d')", DoorData[dUID], OrderCache[playerid][oName], order_item_type, order_item_value1, order_item_value2, OrderCache[playerid][oCount], price, order_type);
			AddGroupTransactionLog(playerid, group_id, TRANSACTION_ORDER, -order_price, OrderCache[playerid][oCount], OrderCache[playerid][oUID]);

			PlayerCache[playerid][pMainTable] = 0;
			PlayerCache[playerid][pCallingTo] = INVALID_PLAYER_ID;

			SetPlayerSpecialAction(playerid, SPECIAL_ACTION_STOPUSECELLPHONE);
			RemovePlayerAttachedObject(playerid, SLOT_PHONE);
			
			switch(order_type)
			{
			    case PACKAGE_PRODUCT:   ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Złożyłeś zamówienie dla produktu.\n\nZostanie od przywieziony przez jednego z kurierów.\nAby sprawdzić zawartość magazynu, użyj komendy /drzwi opcje.");
			    case PACKAGE_DRUGS:     ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Złożyłeś zamówienie dla narkotyku.\n\nSkorzystaj z komendy /hurtownia, by je osobiście odebrać.\nMożesz też wysłać jednego z członków Twojej grupy.\nAby sprawdzić zawartość magazynu, użyj komendy /drzwi opcje.");
				case PACKAGE_WEAPON:    ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Złożyłeś zamówienie dla broni.\n\nSkorzystaj z komendy /hurtownia, by odebrać broń osobiście.\nMożesz też wysłać jednego z członków Twojej grupy.\nAby sprawdzić zawartość magazynu, użyj komendy /drzwi opcje.");
			}
		    return 1;
		}
		else
		{
			TD_ShowSmallInfo(playerid, 3, "Zamawianie zostalo ~r~anulowane~w~.");

			PlayerCache[playerid][pMainTable] = 0;
			PlayerCache[playerid][pCallingTo] = INVALID_PLAYER_ID;

			SetPlayerSpecialAction(playerid, SPECIAL_ACTION_STOPUSECELLPHONE);
			RemovePlayerAttachedObject(playerid, SLOT_PHONE);
		    return 1;
		}
	}
	if(dialogid == D_BUS_ACCEPT)
	{
	    if(response)
	    {
  			new price = PlayerCache[playerid][pBusPrice];
			if(PlayerCache[playerid][pCash] < price)
			{
			    PlayerCache[playerid][pBusTravel] = INVALID_OBJECT_ID;
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz takiej ilości gotówki.");
			    
			    if(PlayerCache[playerid][pBusStart] == INVALID_OBJECT_ID)   return 1;

				SetPlayerCameraPos(playerid, PlayerCache[playerid][pBusPosition][0], PlayerCache[playerid][pBusPosition][1], PlayerCache[playerid][pBusPosition][2] + 60.0);
				SetPlayerCameraLookAt(playerid, PlayerCache[playerid][pBusPosition][0], PlayerCache[playerid][pBusPosition][1] + 2, PlayerCache[playerid][pBusPosition][2], CAMERA_MOVE);

				TD_ShowSmallInfo(playerid, 0, "Uzywaj klawiszy ~y~strzalek, ~w~by dowolnie zmieniac pozycje widoku z lotu ptaka.~n~~n~~y~~k~~PED_JUMPING~ ~w~- wybierz najblizszy przystanek~n~~y~~k~~VEHICLE_ENTER_EXIT~ ~w~- anuluj przejazdzke");
       			return 1;
			}
			new object_id = PlayerCache[playerid][pBusTravel],
			    Float:PosX, Float:PosY, Float:PosZ, string[128];

			format(string, sizeof(string), "* %s wsiada do autobusu odjeżdżającego w stronę przystanku nr %d.", PlayerName(playerid), GetObjectUID(object_id));
			ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
			    
			GetDynamicObjectPos(object_id, PosX, PosY, PosZ);
			    
			crp_GivePlayerMoney(playerid, -price);
			SetPlayerVirtualWorld(playerid, 1000 + playerid);
			
			SetPlayerInterior(playerid, 1);
			crp_SetPlayerPos(playerid, 1.5648, 23.8641, 1199.5938);
			
			ResetPlayerCamera(playerid);
			PlayerCache[playerid][pBusStart] 	= INVALID_OBJECT_ID;

			OnPlayerFreeze(playerid, false, 0);
			Streamer_ToggleCameraUpdate(playerid, false);

			PlayerPlaySound(playerid, 1076, 0.0, 0.0, 0.0);
			PlayerCache[playerid][pBusRide] = true;
	        return 1;
	    }
	    else
	    {
	        PlayerCache[playerid][pBusTravel] = INVALID_OBJECT_ID;
	        if(PlayerCache[playerid][pBusStart] == INVALID_OBJECT_ID)   return 1;
	    
	        SetPlayerCameraPos(playerid, PlayerCache[playerid][pBusPosition][0], PlayerCache[playerid][pBusPosition][1], PlayerCache[playerid][pBusPosition][2] + 60.0);
			SetPlayerCameraLookAt(playerid, PlayerCache[playerid][pBusPosition][0], PlayerCache[playerid][pBusPosition][1] + 2, PlayerCache[playerid][pBusPosition][2], CAMERA_MOVE);

			TD_ShowSmallInfo(playerid, 0, "Uzywaj klawiszy ~y~strzalek, ~w~by dowolnie zmieniac pozycje widoku z lotu ptaka.~n~~n~~y~~k~~PED_JUMPING~ ~w~- wybierz najblizszy przystanek~n~~y~~k~~VEHICLE_ENTER_EXIT~ ~w~- anuluj przejazdzke");
	        return 1;
	    }
	}
	if(dialogid == D_PACKAGE_GET)
	{
	    if(response)
	    {
	        new package_uid = DynamicGui_GetDataInt(playerid, listitem);
	        foreach(new i : Player)
	        {
	            if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	            {
	                if(PlayerCache[i][pPackage] == package_uid)
	                {
	                    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ta paczka jest już dostarczana przez %s.", PlayerName(i));
	                    return 1;
	                }
	            }
	        }
	        
	        new package_type = DynamicGui_GetValue(playerid, listitem),
				Float:pointX, Float:pointY, Float:pointZ;
				
			switch(package_type)
			{
			    case PACKAGE_PRODUCT:
			    {
					pointX = 1333.5702;
					pointY = 287.2783;
					pointZ = 19.4063;
				}
				case PACKAGE_DRUGS:
				{
				    pointX = 2846.3840;
				    pointY = 983.6556;
				    pointZ = 10.7500;
				}
				case PACKAGE_WEAPON:
				{
				    pointX = -1862.0475;
				    pointY = -144.4339;
				    pointZ = 11.8984;
				}
			}
			PlayerCache[playerid][pCheckpoint] = CHECKPOINT_PACKAGE;
			PlayerCache[playerid][pPackage] = package_uid;
			
			SetPlayerCheckpoint(playerid, pointX, pointY, pointZ, 5.0);
			TD_ShowSmallInfo(playerid, 3, "Udaj sie do ~r~wyznaczonego ~w~punktu na mapie.");
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_WORK_SELECT)
	{
	    if(response)
	    {
	        switch(listitem)
	        {
	            case 0:
	            {
					PlayerCache[playerid][pMainTable] = JOB_MECHANIC;
					ShowPlayerDialog(playerid, D_WORK_ACCEPT, DIALOG_STYLE_MSGBOX, "Dorywcza » Mechanik", "Praca mechanika polega na naprawianiu, lakierowaniu, bądź tankowaniu\npojazdów. Za każdą zaoferowaną usługę zarabiasz konkretny procent.\n\nJest to praca dla miłośników motoryzacji, aby móc przelakierować\nkomuś pojazd, potrzebował będziesz do tego lakieru, który zakupić możesz w jakimś warsztacie.\n\nCzy jesteś pewien że chcesz podjąć się tej pracy?", "Tak", "Nie");
	            }
	            case 1:
	            {
	                PlayerCache[playerid][pMainTable] = JOB_COURIER;
             		ShowPlayerDialog(playerid, D_WORK_ACCEPT, DIALOG_STYLE_MSGBOX, "Dorywcza » Kurier", "Praca kuriera polega na rozwożeniu paczek do poszczególnych\ninstytucji. Za każdą paczkę otrzymasz odpowiednią sumę gotówki.\n\nKurier może udać się do hurtowni, a następnie odebrać z niej\npaczkę i dostarczyć pod wskazany na mapie adres.\n\nCzy jesteś pewien że chcesz podjąć się tej pracy?", "Tak", "Nie");
	            }
	            case 2:
	            {
	                PlayerCache[playerid][pMainTable] = JOB_SELLER;
	                ShowPlayerDialog(playerid, D_WORK_ACCEPT, DIALOG_STYLE_MSGBOX, "Dorywcza » Sprzedawca", "Praca sprzedawcy polega na handlu żywnością stojąc przy budkach.\nZa każdy sprzedany produkt otrzymujesz należną prowizję.\n\nCzy jesteś pewien, że chcesz podjąć się tej pracy?", "Tak", "Nie");
	            }
	            case 3:
	            {
	                PlayerCache[playerid][pMainTable] = JOB_NEWSPAPER;
	                ShowPlayerDialog(playerid, D_WORK_ACCEPT, DIALOG_STYLE_MSGBOX, "Dorywcza » Rozwoziciel gazet", "W każdym mieście codziennie pojawia się gazeta lokalna, w której znajdują się\nwydarzenia z okolicy. Twoim zadaniem będzie takie gazety dostarczyć\ndo mieszkańców, możesz to robić piechotą, albo za pomocą roweru.\n\nCzy chcesz spróbować swoich sił w tej pracy dorywczej?", "Tak", "Nie");
	            }
	            case 4:
	            {
					PlayerCache[playerid][pMainTable] = JOB_LUMBERJACK;
					ShowPlayerDialog(playerid, D_WORK_ACCEPT, DIALOG_STYLE_MSGBOX, "Dorywcza » Drwal", "Drwale zdobywają drewno potrzebne na opał\ni nie tylko. Jest to jedna z najcięższych (fizycznie) prac.\n\nDo Twoich obowiązków należeć będzie ścinanie drzew,\na zdobyte drewno będziesz mógł sprzedać u pobliskiego aktora.\nPo dotarciu na miejsce wycinki drzwi otrzymasz sprzęt niezbędny do pracy.\n\nCzy chcesz podjąć się tej pracy dorywczej?", "Tak", "Nie");
	            }
	        }
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_WORK_ACCEPT)
	{
	    if(response)
	    {
	        WorkInfo[playerid][wID] = PlayerCache[playerid][pMainTable];
	        orm_update(PlayerCache[playerid][pOrm]);
	        
	        TD_ShowHint(playerid, HINT_WORK, 15, "Wlasnie zatrudniles sie w swojej ~y~pierwszej pracy~w~! Dostales dodatkowe przywileje, ktore mozesz wykorzystac do ~g~zarabiania ~w~pierwszych oszczednosci.~n~~n~Skorzystaj z komendy ~p~/pomoc ~>~ praca dorywcza~w~ i zapoznaj sie z mozliwosciami dotyczacymi tego rodzaju pracy.~n~~n~Otzymales rowniez ~y~akcesorie ~w~do swojego ekwipunku, by wykonywanie pracy bylo przyjemniejsze.");
	        ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Gratulacje! Podjąłeś się nowej pracy dorywczej.\nSkorzystaj z komendy /pomoc, by zobaczyć dodatkowe przywileje.");
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_HELP_MAIN)
	{
	    if(response)
	    {
	        new list_item = PlayerCache[playerid][pMainTable];
	        
	        if(!list_item)
	        {
				new help_type[24];
				sscanf(inputtext, "'»'s[24]", help_type);
				
				if(!strcmp(help_type, "Wprowadzenie", true))
				{
        			ShowPlayerDialog(playerid, D_INTRO, DIALOG_STYLE_MSGBOX, "Wprowadzenie (1/2)", "Witaj na serwerze "SERVER_NAME"!\n\nNa sam początek zalecane jest zapoznanie się z komendą /pomoc,\ndowiesz się tam wielu ciekawych rzeczy związanych z tutejszą rozgrywką.\n\nJak widać, pojawiłeś się na Unity Station, aby jednak dostać\nsię do Urzędu będziesz musiał wykorzystać autobus, bądź taksówkę.", "Dalej", "Zamknij");
				    return 1;
				}
				
				if(!strcmp(help_type, "Komendy podstawowe", true))
				{
				    ShowPlayerDialog(playerid, D_NONE, DIALOG_STYLE_MSGBOX, "Pomoc » Komendy podstawowe", "(/p)rzedmiot, (/o)feruj, (/tel)efon, /sms /stats, (/a)dmins\n/kup, /pokoj, /opis, /bank, /id, /pokaz, /tog, /pay, /tankuj\n(/anim)acje, /wyrzuc, /report, /qs, /przebierz, /bus\n\nRodzaje czatów:\n(/k)rzycz, /c, /l, /b, /me, /do, /w, /re, /m", "OK", "");
					return 1;
				}
				
				if(!strcmp(help_type, "Pojazd", true))
				{
				    ShowPlayerDialog(playerid, D_NONE, DIALOG_STYLE_MSGBOX, "Pomoc » Pojazd", "Jak każdy szary obywatel miasta, możesz posiadać pojazd na własność.\nZakupisz go w salonie samochodowym, lub też (trochę gorszy) na złomowisku.\n\nPracownik jednej z firm, zaoferuje Ci pojazd jakiego potrzebujesz,\na po zaakceptowaniu oferty będzie on już należał do Ciebie.\n\nKomendy dla pojazdu:\n/pojazd [namierz, zaparkuj, tuning, przypisz, zamknij, info, opis]", "OK", "");
				    return 1;
				}
				
				if(!strcmp(help_type, "Ekwipunek", true))
				{
				    ShowPlayerDialog(playerid, D_NONE, DIALOG_STYLE_MSGBOX, "Pomoc » Ekwipunek", "Aby zarządzać swoimi przedmiotami w ekwipunku, użyj komendy (/p)rzedmioty.\nJest to bardzo prosty interfejs, który pozwala na szybkie zarządzanie nimi.\n\nWybrany przedmiot (w zależności od rodzaju) możesz:\n   • odłożyć\n   • sprzedać\n   • złączyć\n   • rozłączyć\n\nDostępne komendy dla przedmiotów:\n/p [lista, podnies, pokaz]", "OK", "");
				    return 1;
				}
				
				if(!strcmp(help_type, "Praca dorywcza", true))
				{
				    if(WorkInfo[playerid][wID] != JOB_NONE)
				    {
						switch(WorkInfo[playerid][wID])
						{
							case JOB_MECHANIC, JOB_LUMBERJACK:
							{
							    new flag_type;
							    if(WorkInfo[playerid][wID] == JOB_MECHANIC)
								{
								    flag_type = A_FLAG_SERVICE;
									ShowPlayerDialog(playerid, D_NONE, DIALOG_STYLE_MSGBOX, "Pomoc » Praca dorywcza", "Jako mechanik możesz naprawiać pojazdy innych graczy,\ntankować je oraz przelakierowywać (potrzebny lakier).\n\nŻeby móc dokonywać interakcji jako mechanik, musisz\nznajdować się w strefie, która na to pozwala (flaga serwisu).\n\nNa mapie powinieneś ujrzeć strefy, w których możesz pracować jako mechanik." , "OK", "");
								}
								else
								{
								    flag_type = A_FLAG_LUMBERJACK;
								    ShowPlayerDialog(playerid, D_NONE, DIALOG_STYLE_MSGBOX, "Pomoc » Praca dorywcza", "Praca drwala polega na wycince drzew, a następnie\nzbiorze materiałów i sprzedaży ich u pobliskiego pracownika.\n\nPo wejściu w strefę wycinki drzew otrzymasz\nodpowiednie narzędzia, którymi będziesz mógł pracować (flaga wycinki drzew).\n\nNa mapie powinieneś ujrzeć strefy, w których możesz pracować jako drwal.", "OK", "");
								}
								
								new AreaData[sAreaData],
									count_areas = Streamer_GetUpperBound(STREAMER_TYPE_PICKUP);

								for (new area = 0; area <= count_areas; area++)
								{
					   				if(IsValidDynamicArea(area))
								    {
										Streamer_GetArrayData(STREAMER_TYPE_AREA, area, E_STREAMER_EXTRA_ID, AreaData);
										if(AreaData[aFlags] & flag_type)
										{
										    GangZoneShowForPlayer(playerid, AreaData[aExtraID], COLOR_GREEN);
											GangZoneFlashForPlayer(playerid, AreaData[aExtraID], COLOR_RED);
										}
								    }
								}
							}
							case JOB_SELLER:
							{
								ShowPlayerDialog(playerid, D_NONE, DIALOG_STYLE_MSGBOX, "Pomoc » Praca dorywcza", "Sprzedawcy wykorzystują budki z jedzeniem postawione nieopodal\nbiznesów gastronomicznych do sprzedaży produktów i pobierają za nie prowizję.\n\nMusisz stać przy budce i skorzystać z komendy /o produkt\noferując je innym graczom. Zarabiają na tym i firma, do której należą produkty i Ty.\n\nZaznaczono na mapie budki, w których możesz oferować produkty (ikonka burgera).", "OK", "");
								for(new icon_id = 0; icon_id < 100; icon_id++) RemovePlayerMapIcon(playerid, icon_id);
								
								new Float:PosX, Float:PosY, Float:PosZ, icon_id,
									count_objects = Streamer_GetUpperBound(STREAMER_TYPE_OBJECT);
									
								for (new object_id = 0; object_id < count_objects; object_id++)
								{
								    if(IsValidDynamicObject(object_id))
								    {
								        if(Streamer_GetIntData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_WORLD_ID) == 0)
								        {
											if(GetObjectModel(object_id) == OBJECT_FOOD_BOX)
											{
											    GetDynamicObjectPos(object_id, PosX, PosY, PosZ);
												SetPlayerMapIcon(playerid, icon_id, PosX, PosY, PosZ, 10, 0, MAPICON_GLOBAL);

												icon_id ++;
												if(icon_id >= 100)  break;
											}
										}
									}
								}
							}
						    case JOB_COURIER:
						    {
								ShowPlayerDialog(playerid, D_NONE, DIALOG_STYLE_MSGBOX, "Pomoc » Praca dorywcza", "Aktualnie jesteś zatrudniony jako kurier. W tej pracy dorywczej\nchodzi o to, by dostarczać paczki do przedsiębiorstw.\n\nMożesz skorzystać z pojazdu rządowego, jednak najpierw musisz wybrać paczkę z komendy /paczka,\njeśli nie ma obecnie żadnych paczek na stanie - musisz zaczekać aż ktoś coś zamówi.\n\nNa mapie zaznaczono pozycję pojazdu, którego możesz użyć.", "OK", "");
								
								foreach(new vehid : Vehicle)
								{
									if(CarInfo[vehid][cOwnerType] == OWNER_WORK && CarInfo[vehid][cOwner] == WorkInfo[playerid][wID])
									{
										if(IsVehicleInRangeOfPoint(vehid, 5.0, CarInfo[vehid][cPosX], CarInfo[vehid][cPosY], CarInfo[vehid][cPosZ]))
										{
											SetPlayerCheckpoint(playerid, CarInfo[vehid][cPosX], CarInfo[vehid][cPosY], CarInfo[vehid][cPosZ], 5.0);
		                                    PlayerCache[playerid][pCheckpoint] = CHECKPOINT_VEHICLE;
		                                    break;
										}
									}
								}
							}
							case JOB_NEWSPAPER:
							{
							    if(WorkInfo[playerid][wValue][0] == 0)
							    {
									ShowPlayerDialog(playerid, D_NONE, DIALOG_STYLE_MSGBOX, "Pomoc » Praca dorywcza", "Rozwoziciel gazet zajmuje się dostarczaniem prasy do\ndomów innych graczy. Musisz jednak najpierw odebrać gazety z\nlokalnej siedziby radia, by zacząć zarabiać.\n\nMożesz także skorzystać z pojazdów do rozwożenia gazet,\njednak musisz mieć przy sobie gazety.\n\nNa mapie zaznaczono miejsce, skąd odbierzesz gazety (czerwony znacznik).", "OK", "");

									new DoorData[sDoorInfo], group_id, group_type = G_TYPE_NEWS, Float:door_pos[3],
										count_doors = Streamer_GetUpperBound(STREAMER_TYPE_PICKUP);

									for (new door = 0; door <= count_doors; door++)
									{
						   				if(IsValidDynamicPickup(door))
									    {
									    	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, door, E_STREAMER_EXTRA_ID, DoorData);
										    if(DoorData[dOwnerType] == OWNER_GROUP)
										    {
												group_id = GetGroupID(DoorData[dOwner]);
												if(GroupData[group_id][gType] == group_type)
												{
												    Streamer_GetItemPos(STREAMER_TYPE_PICKUP, door, door_pos[0], door_pos[1], door_pos[2]);
												    SetPlayerCheckpoint(playerid, door_pos[0], door_pos[1], door_pos[2], 2.0);
													break;
												}
										    }
										}
									}
								}
								else
								{
								    ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Masz przy sobie %d gazet(/y). Dostarcz je w zaznaczone na mapie miejsce.", WorkInfo[playerid][wValue][0]);
								}
							}
						}
						return 1;
					}

					ShowPlayerDialog(playerid, D_NONE, DIALOG_STYLE_MSGBOX, "Pomoc » Praca dorywcza", "Oprócz pracy w firmach lub organizacjach, możesz również\nzarobić trochę gotówki korzystając z prac dorywczych.\n\nUdaj się do urzędu miasta i porozmawiaj z urzędnikiem,\na z pewnością znajdziesz coś co Ci odpowiada i będziesz mógł zarobić.\n\nDostępne prace:\n   • mechanik\n   • kurier\n   • sprzedawca\n   • rozwoziciel gazet", "OK", "");
					return 1;
				}
				
				if(!strcmp(help_type, "Animacje", true))
				{
				    pc_cmd_anim(playerid, "");
				    return 1;
				}
				
				if(!strcmp(help_type, "Dostępne oferty", true))
				{
				    pc_cmd_oferuj(playerid, "");
				    return 1;
				}
			}
			else
			{
			
			}
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_GROUP_SELECT)
	{
		if(response)
		{
		    new group_id = DynamicGui_GetDataInt(playerid, listitem), title[128], string[256];
		    PlayerCache[playerid][pCallingTo] = group_id;
		    
		    format(title, sizeof(title), "Telefon do %s", GroupData[group_id][gName]);
		    format(string, sizeof(string), "Opisz proszę rodzaj zgłoszenia oraz jego sytuację.", GroupData[group_id][gName]);
		    
			ShowPlayerDialog(playerid, D_CALL_GROUP, DIALOG_STYLE_INPUT, title, string, "Dalej", "Anuluj");
		    return 1;
		}
		else
		{
			TD_ShowSmallInfo(playerid, 3, "Zakonczono ~r~polaczenie ~w~z tym numerem.");
			PlayerCache[playerid][pCallingTo] = INVALID_PLAYER_ID;

			SetPlayerSpecialAction(playerid, SPECIAL_ACTION_STOPUSECELLPHONE);
			RemovePlayerAttachedObject(playerid, SLOT_PHONE);
		    return 1;
		}
	}
	if(dialogid == D_CALL_GROUP)
	{
	    if(response)
	    {
  			new group_id = PlayerCache[playerid][pCallingTo], string[256];
  			CreateGroupMission(group_id, G_TYPE_NONE, MISSION_NOTIFICATION, inputtext, PlayerCache[playerid][pUID], 0, 0, 5 * 60);
			
			format(string, sizeof(string), "%s (telefon): %s",  PlayerName(playerid), inputtext);
          	ProxDetector(10.0, playerid, string, COLOR_FADE1, COLOR_FADE2, COLOR_FADE3, COLOR_FADE4, COLOR_FADE5);

			PlayerCache[playerid][pCallingTo] = INVALID_PLAYER_ID;

			SetPlayerSpecialAction(playerid, SPECIAL_ACTION_STOPUSECELLPHONE);
			RemovePlayerAttachedObject(playerid, SLOT_PHONE);
	        return 1;
	    }
	    else
	    {
  			TD_ShowSmallInfo(playerid, 3, "Zakonczono ~r~polaczenie ~w~z tym numerem.");
			PlayerCache[playerid][pCallingTo] = INVALID_PLAYER_ID;

			SetPlayerSpecialAction(playerid, SPECIAL_ACTION_STOPUSECELLPHONE);
			RemovePlayerAttachedObject(playerid, SLOT_PHONE);
	        return 1;
	    }
	}
	if(dialogid == D_SALON_CATEGORY)
	{
	    if(response)
	    {
	        new category = listitem + 1, veh_list[1024],
	            dealer_model, dealer_price;
	            
			// Pojazdy premium
			if(category == 8 && !IsPlayerPremium(playerid))
			{
				new actorid = PlayerCache[playerid][pMainTable];
				OnPlayerInteractActor(playerid, actorid);
				
				TD_ShowSmallInfo(playerid, 3, "Ta kategoria ~g~dostepna ~w~jest tylko dla ~y~kont premium~w~.");
			    return 1;
			}
	            
	        new rows, Cache:tmp_cache, query[256];

			mysql_format(connHandle, query, sizeof(query), "SELECT `dealer_model`, `dealer_price` FROM `"SQL_PREF"veh_dealer` WHERE dealer_category = '%d'", category);
	        tmp_cache = mysql_query(connHandle, query);
	        
	        DynamicGui_Init(playerid);
	        
	        cache_get_row_count(rows);
            for(new row = 0; row != rows; row++)
	        {
	            cache_get_value_index_int(row, 0, dealer_model);
	            cache_get_value_index_int(row, 1, dealer_price);

	            if(dealer_price < 100000)
	            {
	            	format(veh_list, sizeof(veh_list), "%s\n$%d\t\t%s", veh_list, dealer_price, GetVehicleName(dealer_model));
				}
				else
				{
				    format(veh_list, sizeof(veh_list), "%s\n$%d\t%s", veh_list, dealer_price, GetVehicleName(dealer_model));
				}
				DynamicGui_AddRow(playerid, dealer_model, dealer_price);
	        }
	        if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
	        
	        if(strlen(veh_list))
	        {
	            new title[64];
	            format(title, sizeof(title), "Cennik » %s:", inputtext);
	            
	            ShowPlayerDialog(playerid, D_ACTOR_CARDEALER, DIALOG_STYLE_LIST, title, veh_list, "Zakup", "Auluj");
	        }
	        else
	        {
	            TD_ShowSmallInfo(playerid, 3, "Brak ~r~pojazdow ~w~w wybranej kategorii.");
	        }
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_ITEM_CRAFT)
	{
	    if(response)
	    {
   			if(!(PlayerCache[playerid][pAdmin] & A_PERM_ITEMS) && GetPlayerCapacity(playerid) <= 0)
			{
   				ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Twoja postać nie jest w stanie unieść więcej przedmiotów.");
			    return 1;
			}
	        new object_uid = PlayerCache[playerid][pMainTable], itemid;
	        if(inputtext[0] != 'W')
	        {
				if(!strval(inputtext))	return 1;
				new item_uid = strval(inputtext);
				
	   			mysql_query_format("UPDATE `"SQL_PREF"items` SET item_ownertype = '%d', item_owner = '%d' WHERE item_uid = '%d' LIMIT 1", PLACE_PLAYER, PlayerCache[playerid][pUID], item_uid);
		        itemid = LoadPlayerItem(playerid, item_uid);
			}
			else
			{
			    if(inputtext[0] == '#')	return 1;
			    new weapon_id = strval(inputtext[1]), item_name[32];
			    mysql_query_format("DELETE FROM `"SQL_PREF"items` WHERE item_ownertype = '%d' AND item_owner = '%d'", PLACE_CRAFT, object_uid);
			    
			    strmid(item_name, inputtext, 5, strlen(inputtext), 32);
                itemid = CreatePlayerItem(playerid, item_name, ITEM_WEAPON, weapon_id, 0);
			}
			
			ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Wyjąłeś przedmiot %s (UID: %d) z listy craftingu.\nPrzedmiot pojawił się w Twoim ekwipunku.", PlayerItemCache[playerid][itemid][iName], PlayerItemCache[playerid][itemid][iUID]);
			return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_RACE_SAVE)
	{
		if(response)
		{
 			if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby skorzystać z tej komendy, musisz być na służbie grupy.");
			    return 1;
			}
		    if(strlen(inputtext) > 64 || strlen(inputtext) <= 0)
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłową nazwę wyścigu.");
		        return 1;
		    }
		
			new esc_race_title[128], group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
			mysql_escape_string(inputtext, esc_race_title);
			mysql_query_format("INSERT INTO `"SQL_PREF"races` VALUES ('', '%s', '%d')", esc_race_title, GroupData[group_id][gUID]);
			
			new route_owner = cache_insert_id(), main_query[2048], query[256];
			format(main_query, sizeof(main_query), "INSERT INTO `"SQL_PREF"races_route` VALUES ");
			
			for (new checkpoint = 0; checkpoint <= RaceInfo[playerid][rPoint]; checkpoint++)
			{
       			format(query, sizeof(query), "('',%d,%f,%f,%f)",
				route_owner,
				
   				RaceInfo[playerid][rCPX][checkpoint],
  	 			RaceInfo[playerid][rCPY][checkpoint],
			   	RaceInfo[playerid][rCPZ][checkpoint]);
			   	
   				if(strlen(main_query) > 64)
   				{
   				    if(strlen(main_query) + strlen(query) < sizeof(main_query))
   				    {
				   		strcat(main_query, ",", sizeof(main_query));
					}
					else
					{
					    strcat(main_query, ";", sizeof(main_query));
					    
					    print(main_query);
					    mysql_query(connHandle, main_query);
					    
					    strdel(main_query, 37, strlen(main_query));
					}
				}
			  	strcat(main_query, query, sizeof(main_query));
			}
			
			print(main_query);
			mysql_query(connHandle, main_query);
			
			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Wyścig został pomyślnie zapisany.\nSkorzystaj z komendy /wyscig wczytaj, by nim zarządzać.\n\nWyścig został podpisany pod grupę, co oznacza\nże wczytać go może każdy jej członek.");
		    return 1;
		}
		else
		{
		    return 1;
		}
	}
	if(dialogid == D_RACE_SELECT)
	{
	    if(response)
	    {
	        new race_uid, race_title[64], string[128];
	        sscanf(inputtext, "ds[64]", race_uid, race_title);
	        
	        PlayerCache[playerid][pMainTable] = race_uid;
	        format(string, sizeof(string), "Wyścig » %s (UID: %d)", race_title, race_uid);
	        
	        ShowPlayerDialog(playerid, D_RACE_OPTIONS, DIALOG_STYLE_LIST, string, "1. Załaduj wyścig\n2. Usuń całkowicie\n3. Zmień nazwę", "Wybierz", "Anuluj");
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_RACE_OPTIONS)
	{
	    if(response)
	    {
			if(PlayerCache[playerid][pRaceCreating])
	    	{
       			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aktualnie tworzysz już jakiś wyścig.");
       			return 1;
	    	}
	    	if(RaceInfo[playerid][rStart])
	    	{
       			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aktualnie uczestniczysz już w jakimś wyścigu.");
       			return 1;
 			}
 			
			new list_item = strval(inputtext), string[256],
			    race_uid = PlayerCache[playerid][pMainTable];
			
			if(list_item == 1)
			{
 				for (new checkpoint = 0; checkpoint < MAX_RACE_CP; checkpoint++)
				{
				    RaceInfo[playerid][rCPX][checkpoint] = 0.0;
				    RaceInfo[playerid][rCPY][checkpoint] = 0.0;
				    RaceInfo[playerid][rCPZ][checkpoint] = 0.0;
				}
			
			    new checkpoint;
			    new rows, Cache:tmp_cache, query[128];

				mysql_format(connHandle, query, sizeof(query), "SELECT `route_cpx`, `route_cpy`, `route_cpz` FROM `"SQL_PREF"races_route` WHERE route_owner = '%d'", race_uid);
			    tmp_cache = mysql_query(connHandle, query);
			    
			    cache_get_row_count(rows);
			    for(new row = 0; row != rows; row++)
			    {
					cache_get_value_index_float(row, 0, RaceInfo[playerid][rCPX][checkpoint]);
					cache_get_value_index_float(row, 1, RaceInfo[playerid][rCPX][checkpoint]);
					cache_get_value_index_float(row, 2, RaceInfo[playerid][rCPX][checkpoint]);

     				checkpoint ++;
			    }
			    if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
			    
				RaceInfo[playerid][rOwner] = playerid;
				RaceInfo[playerid][rPoint] = 0;
				
				PlayerCache[playerid][pRaceCheckpoints] = checkpoint - 1;
				TD_ShowSmallInfo(playerid, 10, "Wyscig zostal ~g~pomyslnie ~w~zaladowany. Mozesz teraz zaprosic rywali do wyscigu komenda ~r~/wyscig zapros~w~.~n~~n~Zeby rozpoczac wyscig wpisz ~y~/wyscig start~w~.");
			    return 1;
			}
			
			if(list_item == 2)
			{
			    format(string, sizeof(string), "Czy jesteś pewien, że chcesz usunąć ten wyścig (UID: %d)?\nTa opcja usunie całą zawartość bezpowrotnie!", race_uid);
				ShowPlayerDialog(playerid, D_RACE_DELETE, DIALOG_STYLE_MSGBOX, "Wyścig » Usuń całkowicie", string, "Tak", "Nie");
			    return 1;
			}
			
			if(list_item == 3)
			{
				format(string, sizeof(string), "Wprowadź poniżej nową nazwę dla wyścigu (UID: %d).\nNazwa nie może przekroczyć 64 znaków.", race_uid);
				ShowPlayerDialog(playerid, D_RACE_RENAME, DIALOG_STYLE_INPUT, "Wyścig » Zmień nazwę", string, "Zmień", "Anuluj");
				return 1;
			}
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_RACE_DELETE)
	{
	    if(response)
	    {
	        new race_uid = PlayerCache[playerid][pMainTable];
	        
	        mysql_query_format("DELETE FROM `"SQL_PREF"races` WHERE race_uid = '%d' LIMIT 1", race_uid);
	        mysql_query_format("DELETE FROM `"SQL_PREF"races_route` WHERE route_owner = '%d'", race_uid);
	        
	        ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Wyścig (UID: %d) został całkowicie usunięty.", race_uid);
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_RACE_RENAME)
	{
		if(response)
		{
  			if(strlen(inputtext) > 64 || strlen(inputtext) <= 0)
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłową nazwę wyścigu.");
		        return 1;
		    }
		    
   			new race_uid = PlayerCache[playerid][pMainTable], esc_race_title[128];
			mysql_escape_string(inputtext, esc_race_title);

			mysql_query_format("UPDATE `"SQL_PREF"races` SET race_title = '%s' WHERE race_uid = '%d' LIMIT 1", esc_race_title, race_uid);
			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Nazwa wyścigu (UID: %d) została pomyślnie zmieniona.\nNowa nazwa: %s", race_uid, esc_race_title);
		    return 1;
		}
		else
		{
		    return 1;
		}
	}
	if(dialogid == D_ACTOR_ANIM)
	{
	    if(response)
	    {
     		new anim_id = DynamicGui_GetDataInt(playerid, listitem), ActorData[sActorData],
			 	actorid = PlayerCache[playerid][pEditActor], actor_uid = GetActorUID(actorid);

			Streamer_GetArrayData(STREAMER_TYPE_ACTOR, actorid, E_STREAMER_EXTRA_ID, ActorData);

			ActorData[aAnim] = AnimCache[anim_id][aUID];
			Streamer_SetArrayData(STREAMER_TYPE_ACTOR, actorid, E_STREAMER_EXTRA_ID, ActorData);

			ClearDynamicActorAnimations(actorid);
            ApplyDynamicActorAnimation(actorid, AnimCache[anim_id][aLib], AnimCache[anim_id][aName], AnimCache[anim_id][aSpeed], AnimCache[anim_id][aOpt1], AnimCache[anim_id][aOpt2], AnimCache[anim_id][aOpt3], AnimCache[anim_id][aOpt4], AnimCache[anim_id][aOpt5]);
			return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_ACTOR_TYPE)
	{
 		if(response)
	    {
			new actorid = PlayerCache[playerid][pEditActor], actor_type = strval(inputtext) - 1,
			    ActorData[sActorData];

			Streamer_GetArrayData(STREAMER_TYPE_ACTOR, actorid, E_STREAMER_EXTRA_ID, ActorData);

			ActorData[aType] = actor_type;
			Streamer_SetArrayData(STREAMER_TYPE_ACTOR, actorid, E_STREAMER_EXTRA_ID, ActorData);
			
			TD_ShowSmallInfo(playerid, 5, "Typ aktora zostal ~g~pomyslnie ~w~ustalony - ~y~%s~w~.", ActorTypeInfo[actor_type][aTypeName]);
			return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_ACTOR_WORKSHOP)
	{
		if(response)
		{
		    new actorid = PlayerCache[playerid][pMainTable],
				veh_uid = DynamicGui_GetValue(playerid, listitem), price = DynamicGui_GetDataInt(playerid, listitem);
			
			OnPlayerSendOffer((actorid * -1), playerid, "Naprawa", OFFER_REPAIR, veh_uid, listitem, price);
		    return 1;
		}
		else
		{
		    return 1;
		}
	}
	if(dialogid == D_ACTOR_GOV)
	{
	    if(response)
	    {
	        new actorid = PlayerCache[playerid][pMainTable];
	        if(listitem == 0)
	        {
			    OnPlayerSendOffer((actorid * -1), playerid, "Identyfikator", OFFER_DOCUMENT, DOC_PROOF, 0, 80);
	            return 1;
	        }
	        if(listitem == 1)
	        {
	            OnPlayerSendOffer((actorid * -1), playerid, "Licencja", OFFER_DOCUMENT, DOC_DRIVER, 0, 350);
	            return 1;
	        }
	        if(listitem == 2)
	        {
	        	ShowPlayerDialog(playerid, D_WORK_SELECT, DIALOG_STYLE_LIST, "Dostępne prace dorywcze:", "1. Mechanik\n2. Kurier\n3. Sprzedawca\n4. Rozwoziciel gazet\n5. Drwal\n6. Rybak", "Wybierz", "Anuluj");
				return 1;
			}
			
			if(listitem == 3)
			{
 				new vehid = PlayerCache[playerid][pLastVeh], string[128];
				if(vehid == INVALID_VEHICLE_ID || CarInfo[vehid][cUID] == 0)
				{
				    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz przyjechać pojazdem, który chcesz zarejestrować.");
				    return 1;
				}
				if(strlen(CarInfo[vehid][cRegister]))
				{
				    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Pojazd %s (UID: %d) jest już zarejestrowany.", GetVehicleName(CarInfo[vehid][cModel]), CarInfo[vehid][cUID]);
				    return 1;
				}
				format(string, sizeof(string), "Rejestracja pojazdu %s (UID: %d)", GetVehicleName(CarInfo[vehid][cModel]), CarInfo[vehid][cUID]);
				OnPlayerSendOffer((actorid * -1), playerid, string, OFFER_REGISTER, CarInfo[vehid][cUID], 0, 150);
			    return 1;
			}
			return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_ACTOR_CORPSE)
	{
	    if(response)
	    {
			if(!strfind(inputtext, "1. Zabezpiecz zwłoki (zapakuj w folie)", true))
			{
				if(!(PlayerCache[playerid][pAdmin] & A_PERM_ITEMS) && GetPlayerCapacity(playerid) <= 0)
				{
				    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Twoja postać nie jest w stanie unieść więcej przedmiotów.");
	   				return 1;
				}
			    new actorid = PlayerCache[playerid][pMainTable], ActorData[sActorData];
			    Streamer_GetArrayData(STREAMER_TYPE_ACTOR, actorid, E_STREAMER_EXTRA_ID, ActorData);
			    
			    DeleteActor(actorid);
			    CreatePlayerItem(playerid, ActorData[aName], ITEM_CORPSE, 0, 0);
			    
				ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Przedmiot %s zostały pomyślnie zabezpieczone, okryte folią.\nPojawiły się one w Twoim ekwpunku, dzięki czemu możesz je teraz swobodnie transportować.", ActorData[aName]);
			    return 1;
			}
			return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	if(dialogid == D_ACTOR_CARDEALER)
	{
		if(response)
		{
		    new actorid = PlayerCache[playerid][pMainTable],
		        dealer_model = DynamicGui_GetValue(playerid, listitem), dealer_price = DynamicGui_GetDataInt(playerid, listitem);

            OnPlayerSendOffer((actorid * -1), playerid, GetVehicleName(dealer_model), OFFER_SALON, dealer_model, 0, dealer_price);
		    return 1;
		}
		else
		{
		    return 1;
		}
	}
	if(dialogid == D_ACTOR_TRADER)
	{
	    if(response)
	    {
	        new item_type;
	        switch(listitem)
	        {
	            case 0: item_type = ITEM_WOOD;
	        }
	        
	        new weight_sum, next_player_item;
	        foreach(new itemid : PlayerItem[playerid])
	        {
	            if(PlayerItemCache[playerid][itemid][iType] == item_type)
	            {
	                weight_sum += GetPlayerItemWeight(playerid, itemid);
	                
					orm_delete(PlayerItemCache[playerid][itemid][iOrm]);
					for(new sPlayerItem:e; e < sPlayerItem; ++e)	PlayerItemCache[playerid][itemid][e] = 0;

					next_player_item = itemid;
					Iter_SafeRemove(PlayerItem[playerid], next_player_item, itemid);
	            }
	        }
	        
	        new price;
			if(item_type == ITEM_WOOD)
			{
			    price = weight_sum / 20;
			}
			
			/*
			if(item_type == ITEM_FISH)
			{
			    // TODO
			}
			*/
	        
	        if(weight_sum > 0)
	        {
	            crp_GivePlayerMoney(playerid, price);
	            orm_update(PlayerCache[playerid][pOrm]);
	            
	            TD_ShowHint(playerid, HINT_NONE, 10, "Pomyslnie ~g~sprzedano ~y~%dg ~w~przedmiotu ~y~%s ~w~za ~g~$%d~w~.~n~~n~Pieniadze zostaly dodane do Twojego ~p~portfela~w~.", weight_sum, ItemTypeInfo[item_type][iTypeName], price);
			}
	        else
	        {
	            TD_ShowSmallInfo(playerid, 5, "Nie posiadasz ~r~tego typu ~w~przedmiotow przy sobie.");
	        }
	        return 1;
	    }
	    else
	    {
			return 1;
	    }
	}
	if(dialogid == D_OBJECT_PRIORITY)
	{
 		if(response)
	    {
			new modelid = PlayerCache[playerid][pMainTable], params[12];
			
			format(params, sizeof(params), "%d %d", modelid, true);
			pc_cmd_mc(playerid, params);
			return 1;
	    }
	    else
	    {
	        TD_ShowSmallInfo(playerid, 5, "Obiekt ~r~nie zostal ~w~stworzony.");
	        return 1;
	    }
	}
	if(dialogid == D_CORNER_OFFER)
	{
	    if(response)
	    {
	        if(PlayerCache[playerid][pCornerObject] == INVALID_OBJECT_ID)   return 1;
	        
	        new itemid = PlayerCache[playerid][pItemArray][ITEM_DRUG];
	        if(PlayerItemCache[playerid][itemid][iType] != ITEM_DRUG)       return 1;
	    
			new drug_type = PlayerItemCache[playerid][itemid][iValue][0], object_id = PlayerCache[playerid][pCornerObject], object_model = GetObjectModel(object_id),
				price = PlayerCache[playerid][pCornerPrice], drug_value = PlayerCache[playerid][pMainTable], drug_limit, price_limit;

			if(drug_type > 6)   return 1;
			switch(object_model)
			{
			    case OBJECT_CORNER_RED:
				{
					drug_limit = 20;
					price_limit = (price / drug_value) + random(floatround(DrugTypeInfo[drug_type][dCornerPrice] * 0.9));
				}
			    case OBJECT_CORNER_BLUE:
				{
					drug_limit = 30;
					price_limit = (price / drug_value) + random(floatround(DrugTypeInfo[drug_type][dCornerPrice] * 0.5));
				}
			    case OBJECT_CORNER_GREEN:
				{
					drug_limit = 50;
					price_limit = (price / drug_value) + random(floatround(DrugTypeInfo[drug_type][dCornerPrice] * 0.3));
				}
			}
				
			if(!is_null(inputtext))
			{
				new new_price = strval(inputtext);
			    if((new_price * drug_value) <= price || new_price > price_limit || random(2) == 1)
			    {
       				PlayerCache[playerid][pCornerPrice] = 0;
	        		TD_ShowSmallInfo(playerid, 3, "Transakcja ~r~nieudana~w~.");
			        return 1;
			    }
			    new string[512];

				format(string, sizeof(string), "Pojawił się nowy klient chętny na zakup %s (%dg). Jego oferta: $%d ($%d za gram).", PlayerItemCache[playerid][itemid][iName], drug_value, (new_price * drug_value), new_price);
				format(string, sizeof(string), "%s\n\nMożesz zaakceptować tę ofertę, lub podać swoją cenę (co niekoniecznie\nmoże się udać), bądź odrzucić tę ofertę i poczekać na korzystniejszą.\n\nWprowadź poniżej ile oczekujesz za gram tego produktu\njeśli natomiast akceptujesz złożoną ofertę przez klienta - zostaw okno puste.", string);
			    
          		ShowPlayerDialog(playerid, D_CORNER_OFFER, DIALOG_STYLE_INPUT, "Handel » Nowy klient", string, "Negocjuj", "Odrzuć");

				PlayerCache[playerid][pItemArray][ITEM_DRUG] = itemid;
				PlayerCache[playerid][pCornerPrice] = (new_price * drug_value);

				PlayerCache[playerid][pMainTable] = drug_value;
				TD_ShowSmallInfo(playerid, 5, "Klient ~g~przyjal ~w~Twoja oferte. Mozesz to zaakceptowac, lub jeszcze ~y~zawyzyc ~w~oferte (ryzyko!).");
				return 1;
			}
			else
			{
				if(PlayerItemCache[playerid][itemid][iValue][1] >= drug_value)
				{
    				PlayerItemCache[playerid][itemid][iValue][1] -= drug_value;
					    
    				if(PlayerItemCache[playerid][itemid][iValue][1] <= 0)   DeletePlayerItem(playerid, itemid);
    				else                                                    orm_update(PlayerItemCache[playerid][itemid][iOrm]);
					    
					crp_GivePlayerMoney(playerid, price);
					TD_ShowSmallInfo(playerid, 5, "Pomyslnie dokonano ~g~transakcji~w~. Sprzedales ~y~%s (%dg) ~w~za ~g~$%d~w~.", PlayerItemCache[playerid][itemid][iName], drug_value, price);

					PlayerCache[playerid][pCornerPrice] = 0;
                        
					new ObjectData[sObjectData];
					Streamer_GetArrayData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_EXTRA_ID, ObjectData);

					ObjectData[objExtraID] += drug_value;
					if(ObjectData[objExtraID] >= drug_limit)    SetDynamicObjectPos(object_id, 0.0, 0.0, 0.0);
						
					Streamer_SetArrayData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_EXTRA_ID, ObjectData);
      				return 1;
				}
				
				PlayerCache[playerid][pCornerPrice] = 0;
                TD_ShowSmallInfo(playerid, 3, "Transakcja zostala ~r~odrzucona~w~.");
			}
	        return 1;
	    }
	    else
	    {
	        PlayerCache[playerid][pCornerPrice] = 0;
	        TD_ShowSmallInfo(playerid, 3, "Transakcja zostala ~r~odrzucona~w~.");
	        return 1;
	    }
	}
	
	if(dialogid == D_AREA_FLAGS)
	{
	    if(response)
	    {
	        new AreaData[sAreaData], flag_type = DynamicGui_GetDataInt(playerid, listitem),
				areaid = PlayerCache[playerid][pMainTable], area_uid = GetAreaUID(areaid), params[24];
				
			Streamer_GetArrayData(STREAMER_TYPE_AREA, areaid, E_STREAMER_EXTRA_ID, AreaData);
			
			if(AreaData[aFlags] & flag_type)
			{
			    AreaData[aFlags] -= flag_type;
			    TD_ShowSmallInfo(playerid, 3, "Flaga zostala ~r~odznaczona~w~.");
			}
			else
			{
			    AreaData[aFlags] += flag_type;
			    TD_ShowSmallInfo(playerid, 3, "Flaga zostala ~g~zaznaczona~w~.");
			}
			Streamer_SetArrayData(STREAMER_TYPE_AREA, areaid, E_STREAMER_EXTRA_ID, AreaData);
			
			format(params, sizeof(params), "flagi %d", area_uid);
			pc_cmd_strefa(playerid, params);
    		return 1;
	    }
	    else
		{
			new areaid = PlayerCache[playerid][pMainTable];
			SaveArea(areaid);
			
			TD_ShowSmallInfo(playerid, 3, "Flagi strefy (UID: %d) zostaly ~g~pomyslnie ~w~zapisane.", GetAreaUID(areaid));
  			return 1;
		}
	}
	if(dialogid == D_TAG_TEXT)
	{
	    if(response)
	    {
	        new fontface[24], text[256], object_id = PlayerCache[playerid][pTaggingObject];
	        if(sscanf(inputtext, "p<:>s[24]s[128]", fontface, text))
	        {
	            fontface = "Times";
	            text = "ERROR";
	        }
	        new fontsize = 100 - strlen(text);

			new query[512];
			mysql_format(connHandle, query, sizeof(query), "UPDATE `"SQL_PREF"materials` SET material_texture = '1^0:140:%d:1:%x:0:1:%e:%e' WHERE material_owner = %d AND material_index = 0", fontsize, COLOR_WHITE, fontface, text, GetObjectUID(object_id));
			mysql_query(connHandle, query);

			if(cache_affected_rows() <= 0)
			{
				mysql_format(connHandle, query, sizeof(query), "INSERT INTO `"SQL_PREF"materials` SET material_texture = '1^0:140:%d:1:%x:0:1:%e:%e', material_owner = %d, material_index = 0", fontsize, COLOR_WHITE, fontface, text, GetObjectUID(object_id));
    			mysql_query(connHandle, query);
			}
			format(text, sizeof(text), "%s", WordWrap(text, WRAP_MANUAL));

			SetDynamicObjectMaterialText(object_id, 0, text, 140, fontface, fontsize, 1, COLOR_WHITE, 0, 1);
			new modelid = GetObjectModel(object_id), Float:PosX, Float:PosY, Float:PosZ;
			
			GetDynamicObjectPos(object_id, PosX, PosY, PosZ);
			OnPlayerSelectDynamicObject(playerid, object_id, modelid, PosX, PosY, PosZ);
			
			TD_ShowSmallInfo(playerid, 5, "Tagowanie zostalo ~g~pomyslnie ~w~zakonczone. Mozesz teraz ustawic ~y~rotacje ~w~TAG'u.");
	        return 1;
	    }
	    else
	    {
			PlayerCache[playerid][pTaggingObject] 	= INVALID_OBJECT_ID;
			PlayerCache[playerid][pTaggingTime]    	= 0;
			return 1;
	    }
	}
	if(dialogid == D_MISSION_DESC)
	{
	    if(response)
	    {
	        new mission_uid = DynamicGui_GetDataInt(playerid, listitem), group_id = DynamicGui_GetDialogValue(playerid),
	            query[512], Cache:tmp_cache;

			if(mission_uid == 0)    return 1;

			mysql_format(connHandle, query, sizeof(query), "SELECT `mission_desc`, `mission_type`, `mission_victim`, `mission_members`, `mission_award`, `mission_date`, `mission_limit`, `mission_time` FROM `"SQL_PREF"group_missions` WHERE mission_uid = '%d' LIMIT 1", mission_uid);
			tmp_cache = mysql_query(connHandle, query);
			
			new mission_desc[256], mission_limit;

			cache_get_value_index(0, 0, mission_desc, 256);
			cache_get_value_index_int(0, 1, MissionData[playerid][mType]);
			
			cache_get_value_index_int(0, 2, MissionData[playerid][mVictim]);
			cache_get_value_index_int(0, 3, MissionData[playerid][mMembers]);
			
			cache_get_value_index_int(0, 4, MissionData[playerid][mAward]);
			
			cache_get_value_index_int(0, 5, MissionData[playerid][mDate]);
			cache_get_value_index_int(0, 6, mission_limit);
			
			cache_get_value_index_int(0, 7, MissionData[playerid][mTime]);
			
			
            if(cache_is_valid(tmp_cache))	cache_delete(tmp_cache);
			
			new mission_string[512];
			strcat(mission_string, WordWrap(mission_desc, WRAP_AUTO, 8), sizeof(mission_string));
			
			if(MissionData[playerid][mMembers] > 0)
			{
				format(mission_string, sizeof(mission_string), "%s\n\nIlość osób potrzebna do zadania: %d\n(wyznaczona grupa osób musi znajdować się w pobliżu Ciebie na służbie)", mission_string, MissionData[playerid][mMembers]);
			}
			
			if(MissionData[playerid][mAward] > 0)
			{
			    format(mission_string, sizeof(mission_string), "%s\n\nNagroda pieniężna: $%d\n(gotówka trafi do budżetu grupy)", mission_string, MissionData[playerid][mAward]);
			}
			
			if(MissionData[playerid][mTime] > 0)
			{
			    format(mission_string, sizeof(mission_string), "%s\n\nCzas: %dh %dm\n(w tym czasie zadanie musi zostać wykonane)", mission_string, MissionData[playerid][mTime] / 3600, (MissionData[playerid][mTime] / 60) % 60);
			}
			
			switch(MissionData[playerid][mType])
			{
			    case MISSION_SMUGGLE:
			    {
			        strcat(mission_string, "\n\nDo tego typu zadania wymagany jest pojazd o typie BUS (np. Rumpo).", sizeof(mission_string));
			    }
			}
			
			// Jeśli zadanie codzienne
			if(mission_limit > 0)   MissionData[playerid][mDate] = gettime();
			
			MissionData[playerid][mGroup] = group_id;
			PlayerCache[playerid][pMainTable] = mission_uid;
			
			ShowPlayerDialog(playerid, D_MISSION_START, DIALOG_STYLE_MSGBOX, "Zadanie", mission_string, "Start", "Anuluj");
	        return 1;
	    }
	    else
	    {
	        return 1;
		}
	}
	if(dialogid == D_MISSION_START)
	{
	    if(response)
	    {
	        new mission_uid = PlayerCache[playerid][pMainTable];
	        OnPlayerStartMission(playerid, mission_uid);
	        return 1;
	    }
	    else
	    {
	        return 1;
	    }
	}
	return 1;
}

public OnPlayerClickPlayer(playerid, clickedplayerid, source)
{
	if(PlayerCache[playerid][pSpectate] != INVALID_PLAYER_ID)
	{
		new string[12];
		
		format(string, sizeof(string), "%d", clickedplayerid);
		pc_cmd_spec(playerid, string);
		return 1;
	}

	if(!PlayerCache[playerid][pLogged])
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz wysyłać prywatnych wiadomości będąc niezalogowanym.");
	    return 1;
	}
	if(clickedplayerid == playerid || !PlayerCache[clickedplayerid][pLogged])
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz wysłać prywatnej wiadomości do tego gracza.");
	    return 1;
	}
	if((PlayerCache[playerid][pBlock] & BLOCK_OOC) && (PlayerCache[clickedplayerid][pAdmin] & A_PERM_BASIC))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Twoja postać ma nałożoną blokadę czatu OOC.");
	    return 1;
	}
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_BASIC) && PlayerCache[clickedplayerid][pTogW])
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz ma wyłączone otrzymywanie prywatnych wiadomości.");
	    return 1;
	}
	if(PlayerCache[playerid][pBW] && !PlayerToPlayer(25.0, playerid, clickedplayerid) && (PlayerCache[clickedplayerid][pAdmin] & A_PERM_BASIC))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podczas stanu nieprzytomności, wiadomości prywatne możesz wysyłać na określoną odległość.");
    	return 1;
	}
	if(PlayerCache[playerid][pAJ])
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz wysyłać prywatnych wiadomości w chwili obecnej.");
	    return 1;
	}
	new string[128];
	PlayerCache[playerid][pMainTable] = clickedplayerid;

	format(string, sizeof(string), "Wprowadź treść prywatnej wiadomości, która zostanie wysłana do gracza %s.", PlayerName(clickedplayerid));
	ShowPlayerDialog(playerid, D_SEND_PW, DIALOG_STYLE_INPUT, "Wysyłanie prywatnej wiadomości", string, "Wyślij", "Anuluj");
	return 1;
}

public OnPlayerClickMap(playerid, Float:fX, Float:fY, Float:fZ)
{
	if(PlayerCache[playerid][pDuty][DUTY_ADMIN])
	{
	    SetPlayerPosFindZ(playerid, fX, fY, fZ);
	    return 1;
	}
	return 1;
}

public OnPlayerClickTextDraw(playerid, Text:clickedid)
{
	// Screenshot
	if(PlayerCache[playerid][pScreenShot])
	{
	    if(_:clickedid == INVALID_TEXT_DRAW)
	    {
			PlayerTextDrawHide(playerid, TextDrawScreenShot[playerid]);
			PlayerCache[playerid][pScreenShot] = false;
            return 1;
		}
	}
	
	if(PlayerCache[playerid][pGII_Type] != 0)
	{
	    if(_:clickedid != INVALID_TEXT_DRAW)
	    {
			for(new i = 0; i < 8; i++)
			{
			    if(clickedid == GII_Option[i])
			    {
					new interaction_id = PlayerCache[playerid][pMainTable];
		     		if(PlayerCache[playerid][pGII_Option] == i)
		       		{
		         		// Interakcja
						switch(i)
						{
						    case GII_OPTION_CARP:
						    {
						        ChangeVehicleBonnetStatus(interaction_id, !GetVehicleBonnetStatus(interaction_id));
						    }
						    case GII_OPTION_CART:
						    {
						        ChangeVehicleBootStatus(interaction_id, !GetVehicleBootStatus(interaction_id));
						    }
						    case GII_OPTION_KEYS:
						    {
						        pc_cmd_pojazd(playerid, "zamknij");
						    }
						    case GII_OPTION_WELCOME:
						    {
						        pc_cmd_yo(playerid, "1");
						    }
						    case GII_OPTION_HANDCUFF:
						    {
          						new params[6];
          						format(params, sizeof(params), "%d", interaction_id);
						            
						        if(PlayerCache[interaction_id][pCuffedTo] == playerid)
						        {
									pc_cmd_rozkuj(playerid, params);
						        }
						        else
						        {
						            pc_cmd_skuj(playerid, params);
						        }
						    }
						}
		         		
      					for(new o = 0; o < 8; o++)	TextDrawHideForPlayer(playerid, Text:GII_Option[o]);
						PlayerTextDrawHide(playerid, PlayerText:GII_VisualItem[playerid]);

						PlayerCache[playerid][pGII_Option] = 0;
						CancelSelectTextDraw(playerid);
		         	}
		          	else
		           	{
						new string[256], info[32];
						switch(i)
						{
						    case GII_OPTION_INFO:
							{
								info = "Pokaz informacje~n~";
							}
						    case GII_OPTION_CARP:
							{
							    if(GetVehicleBonnetStatus(interaction_id) == 1)
							    {
									info = "Zamknij maske~n~";
								}
								else
								{
								    info = "Otworz maske~n~";
								}
							}
						    case GII_OPTION_CART:
							{
		   						if(GetVehicleBootStatus(interaction_id) == 1)
			                	{
									info = "Zamknij bagaznik~n~";
								}
								else
								{
								    info = "Otworz bagaznik~n~";
								}
							}
						    case GII_OPTION_KEYS:
							{
							    if(CarInfo[interaction_id][cLocked])
								{
									info = "Otworz pojazd~n~";
								}
								else
								{
								    info = "Zamknij pojazd~n~";
								}
							}
						    case GII_OPTION_HANDCUFF:
							{
								if(PlayerCache[interaction_id][pCuffedTo] == playerid)
								{
									info = "Rozkuj gracza~n~";
								}
								else
								{
								    info = "Skuj gracza~n~";
								}
							}
						    case GII_OPTION_WELCOME:    info = "Przywitaj sie~n~";
						    case GII_OPTION_GIVE:       info = "Podaj przedmiot~n~";
						    case GII_OPTION_GET:        info = "Zabierz przedmiot~n~";
						}

						if(PlayerCache[playerid][pGII_Type] == 2)
						{
						    new vehid = PlayerCache[playerid][pMainTable];
							format(string, sizeof(string), "%s%s (%d)", info, GetVehicleName(CarInfo[vehid][cModel]), CarInfo[vehid][cUID]);
						}
						else
						{
						    new giveplayer_id = PlayerCache[playerid][pMainTable];
						    format(string, sizeof(string), "%s%s (%d)", info, PlayerName(giveplayer_id), giveplayer_id);
						}
						PlayerTextDrawSetString(playerid, GII_VisualItem[playerid], string);
						PlayerCache[playerid][pGII_Option] = i;
					}
			        return 1;
			    }
			}
		}
		else
		{
		
			for(new o = 0; o < 8; o++)	TextDrawHideForPlayer(playerid, Text:GII_Option[o]);
			PlayerTextDrawHide(playerid, PlayerText:GII_VisualItem[playerid]);
			
			PlayerCache[playerid][pGII_Option] = 0;
		}
	}

	// Okno opcji grup
	if(PlayerCache[playerid][pListPlayerGroups])
	{
		if(clickedid != Text:INVALID_TEXT_DRAW)
		{
			for(new group_slot = 0; group_slot < MAX_GROUP_SLOTS; group_slot++)
			{
				for(new group_option = 0; group_option < 6; group_option++)
				{
					if(TD_GroupOption[group_option][group_slot] == clickedid)
					{
					    new option[24];
					    switch(group_option)
					    {
					        case 0: format(option, sizeof(option), "%d info", group_slot + 1);
					        case 1: format(option, sizeof(option), "%d magazyn", group_slot + 1);
					        case 2:	format(option, sizeof(option), "%d sluzba", group_slot + 1);
					        case 3: format(option, sizeof(option), "%d pojazdy", group_slot + 1);
					        case 4: format(option, sizeof(option), "%d online", group_slot + 1);
					        case 5: format(option, sizeof(option), "%d zadania", group_slot + 1);
					    }
					    pc_cmd_g(playerid, option);
					}
				}
			}
		}
		CallLocalFunction("HidePlayerGroupOptions", "d", playerid);
	}
	
	new offererid = OfferData[playerid][oOffererID];
	if(offererid != INVALID_PLAYER_ID)
	{
	    if(clickedid == TextDrawOfferAccept)
	    {
	        if(OfferData[playerid][oPayType] == PAY_TYPE_NONE)
	        {
	     		if(OfferData[playerid][oPrice] > 0)
		        {
		            if(PlayerCache[playerid][pBankNumber])
		            {
	            		ShowPlayerDialog(playerid, D_OFFER_PAY_TYPE, DIALOG_STYLE_MSGBOX, "Rodzaj płatności", "Wybierz sposób zapłaty za daną ofertę.", "Gotówka", "Karta");
	                  	return 1;
					}
		            else
		            {
		                OfferData[playerid][oPayType] = PAY_TYPE_CASH;
		                OnPlayerAcceptOffer(playerid, offererid);
		            }
		        }
		        else
		        {
		            OfferData[playerid][oPayType] = PAY_TYPE_CASH;
		            OnPlayerAcceptOffer(playerid, offererid);
		        }
   			}
			else
			{
			    OnPlayerAcceptOffer(playerid, offererid);
			}
	        return 1;
	    }

		if(clickedid == TextDrawOfferReject)
		{
		    OnPlayerRejectOffer(playerid, offererid);
      		return 1;
		}

  		if(_:clickedid == INVALID_TEXT_DRAW)
		{
		    OnPlayerRejectOffer(playerid, offererid);
		    return 1;
		}
	}
	return 0;
}

public OnPlayerEditObject(playerid, playerobject, objectid, response, Float:fX, Float:fY, Float:fZ, Float:fRotX, Float:fRotY, Float:fRotZ)
{
/*
	if(response == EDIT_RESPONSE_CANCEL)
	{
	    StopPlayerObject(playerid, objectid);
	    return 1;
	}

	PlayerCache[playerid][pMainTable] = playerobject;
    MovePlayerObject(playerid, playerobject, fX, fY, fZ, 10.0, fRotX, fRotY, fRotZ);
*/
	return 1;
}

public OnPlayerSelectDynamicObject(playerid, objectid, modelid, Float:x, Float:y, Float:z)
{
	foreach(new i : Player)
	{
	    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	    {
	        if(i != playerid)
	        {
		        if(PlayerCache[i][pEditObject] == objectid)
		        {
		            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ktoś aktualnie edytuje ten obiekt.");
		            return 1;
		        }
			}
	    }
	}
	
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_OBJECTS))
	{
		if(Streamer_IsToggleItemStatic(STREAMER_TYPE_OBJECT, objectid))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz edytować tego obiektu.");
		    return 1;
		}
	    new areaid = PlayerCache[playerid][pCurrentArea];
	    if(areaid != INVALID_AREA_ID && !IsPointInDynamicArea(areaid, x, y, z))
	    {
     		TD_ShowSmallInfo(playerid, 3, "Ten ~y~obiekt ~w~znajduje sie poza ~r~strefa~w~.");
     		return 1;
		}
	}
	new Float:RotX, Float:RotY, Float:RotZ;
	
 	Streamer_GetFloatData(STREAMER_TYPE_OBJECT, objectid, E_STREAMER_R_X, RotX);
	Streamer_GetFloatData(STREAMER_TYPE_OBJECT, objectid, E_STREAMER_R_Y, RotY);
	Streamer_GetFloatData(STREAMER_TYPE_OBJECT, objectid, E_STREAMER_R_Z, RotZ);
	
	TD_ShowLargeInfo(playerid, 0, "Model: ~y~%d          ~w~Identyfikator: ~y~%d~n~~n~~b~PX: ~w~%05.1f            ~b~PY: ~w~%05.1f          ~b~PZ: ~w~%05.1f~n~~n~~r~RX: ~w~%05.1f          ~r~RY: ~w~%05.1f         ~r~RZ: ~w~%05.1f", GetObjectModel(objectid), GetObjectUID(objectid), x, y, z, RotX, RotY, RotZ);
 	EditDynamicObject(playerid, objectid);
 	
  	PlayerCache[playerid][pEditObject] = objectid;
  	PlayerCache[playerid][pMainTable] = Streamer_GetItemInternalID(playerid, STREAMER_TYPE_OBJECT, objectid);
	return 1;
}

public OnPlayerEditDynamicObject(playerid, objectid, response, Float:x, Float:y, Float:z, Float:rx, Float:ry, Float:rz)
{
	switch(response)
	{
		case EDIT_RESPONSE_CANCEL:
	    {
	        ResetDynamicObjectPos(objectid);
			PlayerCache[playerid][pCurrentArea] = INVALID_AREA_ID;
			
	        PlayerCache[playerid][pEditObject] = INVALID_OBJECT_ID;
	        PlayerCache[playerid][pLastObject] = INVALID_OBJECT_ID;
	        
	        TD_ShowSmallInfo(playerid, 3, "Edycja ~y~obiektu ~w~zostala ~r~zakonczona~w~.~n~Obiekt ~g~powrocil ~w~na swoje miejsce.");
	        TD_HideLargeInfo(playerid);
	    }
	    case EDIT_RESPONSE_FINAL:
		{
			if(!(PlayerCache[playerid][pAdmin] & A_PERM_OBJECTS))
			{
			    new areaid = PlayerCache[playerid][pCurrentArea];
   				if(areaid != INVALID_AREA_ID && !IsPointInDynamicArea(areaid, x, y, z))
       			{
          			ResetDynamicObjectPos(objectid);
          			TD_ShowSmallInfo(playerid, 3, "Ten ~b~obiekt ~w~wykracza poza granice ~r~strefy~w~.");
          			return 1;
		        }
			}
			
			if(PlayerCache[playerid][pTaggingObject] != INVALID_OBJECT_ID)
			{
				if(objectid == PlayerCache[playerid][pTaggingObject])
				{
				    new Float:ObjPosX, Float:ObjPosY, Float:ObjPosZ;

   					Streamer_GetFloatData(STREAMER_TYPE_OBJECT, objectid, E_STREAMER_X, ObjPosX);
					Streamer_GetFloatData(STREAMER_TYPE_OBJECT, objectid, E_STREAMER_Y, ObjPosY);
					Streamer_GetFloatData(STREAMER_TYPE_OBJECT, objectid, E_STREAMER_Z, ObjPosZ);

					if(x != ObjPosX || y != ObjPosY || z != ObjPosZ)
					{
					    SetDynamicObjectPos(objectid, ObjPosX, ObjPosY, ObjPosZ);
					    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podczas tagowania możesz modyfikować tylko rotacje.\nPozycja została przywrócona, rotacja zapisana.");
					}

					PlayerCache[playerid][pTaggingObject] 	= INVALID_OBJECT_ID;
					PlayerCache[playerid][pTaggingTime]    	= 0;
				}
			}
			
			new player_object = Streamer_GetItemInternalID(playerid, STREAMER_TYPE_OBJECT, objectid);
			GetPlayerObjectRot(playerid, player_object, rx, ry, rz);
			
			SetDynamicObjectPos(objectid, x, y, z);
			SetDynamicObjectRot(objectid, rx, ry, rz);

			SaveObjectPos(objectid);
			TD_ShowSmallInfo(playerid, 3, "Pozycja ~b~obiektu ~w~zostala ~g~pomyslnie ~w~zapisana.");
			
			PlayerCache[playerid][pCurrentArea] = INVALID_AREA_ID;
			
	        PlayerCache[playerid][pEditObject] = INVALID_OBJECT_ID;
	        PlayerCache[playerid][pLastObject] = INVALID_OBJECT_ID;
			
			TD_HideLargeInfo(playerid);
	    }
	    case EDIT_RESPONSE_UPDATE:
	    {
         	//MovePlayerObject(playerid, PlayerCache[playerid][pMainTable], x, y, z, 3.0, rx, ry, rz);
         	
         	new player_object = Streamer_GetItemInternalID(playerid, STREAMER_TYPE_OBJECT, objectid);
         	MovePlayerObject(playerid, player_object, x, y, z, 3.0, rx, ry, rz);
         	
	        TD_ShowLargeInfo(playerid, 0, "Model: ~y~%d          ~w~Identyfikator: ~y~%d~n~~n~~b~PX: ~w~%05.1f            ~b~PY: ~w~%05.1f          ~b~PZ: ~w~%05.1f~n~~n~~r~RX: ~w~%05.1f          ~r~RY: ~w~%05.1f         ~r~RZ: ~w~%05.1f", GetObjectModel(objectid), GetObjectUID(objectid), x, y, z, rx, ry, rz);
	    }
	}
	return 1;
}

public OnPlayerEditAttachedObject(playerid, response, index, modelid, boneid, Float:fOffsetX, Float:fOffsetY, Float:fOffsetZ, Float:fRotX, Float:fRotY, Float:fRotZ, Float:fScaleX, Float:fScaleY, Float:fScaleZ)
{
	// Tymczasowa edycja
	if(AttachEdit[playerid][aUID] != 0)
	{
	    if(response == EDIT_RESPONSE_CANCEL)
		{
			AttachEdit[playerid][aUID] = 0;
			TD_ShowSmallInfo(playerid, 5, "Anulowano edycje akcesoria - powtorz /attach, by ponownie edtowac ten model.");
			return 1;
		}
		if(response == EDIT_RESPONSE_FINAL)
		{
		    new query[512];
		    mysql_format(connHandle, query, sizeof(query), "UPDATE `"SQL_PREF"attached_objects` SET attach_bone = '%d', attach_x = '%f', attach_y = '%f', attach_z = '%f', attach_rx = '%f', attach_ry = '%f', attach_rz = '%f', attach_sx = '%f', attach_sy = '%f', attach_sz = '%f' WHERE attach_uid = '%d' LIMIT 1", boneid, fOffsetX, fOffsetY, fOffsetZ, fRotX, fRotY, fRotZ, fScaleX, fScaleY, fScaleZ, AttachEdit[playerid][aUID]);
		    mysql_query(connHandle, query);
		    
			TD_ShowSmallInfo(playerid, 10, "Pomyslnie zapisano domyslna pozycje dla akcesoria (UID: %d). Dzieki!", AttachEdit[playerid][aUID]);
            AttachEdit[playerid][aUID] = 0;
			return 1;
		}
	    return 1;
	}
	switch(response)
	{
	    case EDIT_RESPONSE_CANCEL:
	    {
	        new itemid = PlayerCache[playerid][pItemArray][ITEM_CLOTH_ACCESS];
	        
	        PlayerItemCache[playerid][itemid][iUsed] = false;
			orm_update(PlayerItemCache[playerid][itemid][iOrm]);
	    
            RemovePlayerAttachedObject(playerid, index);
			TD_ShowSmallInfo(playerid, 3, "Edycja akcesoria zostala ~r~anulowana~w~.");
	    }
	    case EDIT_RESPONSE_FINAL:
	    {
	        new itemid = PlayerCache[playerid][pItemArray][ITEM_CLOTH_ACCESS];
	        if((fOffsetX > 0.2 || fOffsetX < -0.1) || (fOffsetY > 0.15 || fOffsetY < -0.15) || (fOffsetZ > 0.025 || fOffsetZ < -0.025) || (fScaleX > 1.5 || fScaleX < 0.5) || (fScaleY > 1.5 || fScaleY < 0.5) || (fScaleZ > 1.5 || fScaleZ < 0.5))
	        {
	            if(PlayerItemCache[playerid][itemid][iValue][0] != 0)
	            {
	                // Pobieranie pozycji z bazy względem value1
	                new access_uid = PlayerItemCache[playerid][itemid][iValue][0],
	                    Float:access_posx, Float:access_posy, Float:access_posz,
	                    Float:access_rotx, Float:access_roty, Float:access_rotz,
	                    Float:access_scalex, Float:access_scaley, Float:access_scalez;
	                    
	                new rows, Cache:tmp_cache, query[512];

					mysql_format(connHandle, query, sizeof(query), "SELECT `attach_x`, `attach_y`, `attach_z`, `attach_rx`, `attach_ry`, `attach_rz`, `attach_sx`, `attach_sy`, `attach_sz` FROM `"SQL_PREF"attached_objects` WHERE attach_uid = '%d' LIMIT 1", access_uid);
	                tmp_cache = mysql_query(connHandle, query);
	                
	                cache_get_row_count(rows);
					if(rows > 0)
					{
					    cache_get_value_index_float(0, 0, access_posx);
					    cache_get_value_index_float(0, 1, access_posy);
					    cache_get_value_index_float(0, 2, access_posz);

					    cache_get_value_index_float(0, 3, access_rotx);
					    cache_get_value_index_float(0, 4, access_roty);
					    cache_get_value_index_float(0, 5, access_rotz);

					    cache_get_value_index_float(0, 6, access_scalex);
					    cache_get_value_index_float(0, 7, access_scaley);
					    cache_get_value_index_float(0, 8, access_scalez);
					
					    SetPlayerAttachedObject(playerid, index, modelid, boneid, access_posx, access_posy, access_posz, access_rotx, access_roty, access_rotz, access_scalex, access_scaley, access_scalez);
					}
					if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
				}
				else
				{
				    // Pobieranie pozycji z cache względem value2
				    new access_id = GetAccessID(PlayerItemCache[playerid][itemid][iValue][1]);
				    SetPlayerAttachedObject(playerid, index, modelid, boneid, AccessData[access_id][aPosX], AccessData[access_id][aPosY], AccessData[access_id][aPosZ], AccessData[access_id][aRotX], AccessData[access_id][aRotY], AccessData[access_id][aRotZ], AccessData[access_id][aScaleX], AccessData[access_id][aScaleY], AccessData[access_id][aScaleZ]);
				}
				
				EditAttachedObject(playerid, index);
				TD_ShowSmallInfo(playerid, 5, "Gabaryty ~y~akcesoria ~w~nie sa odpowiednie.~n~Zostal on ~r~przywrocony ~w~na wczesniejsza pozycje.");
				return 1;
	        }
	        
	        // Zapisz pozycję
	        if(PlayerItemCache[playerid][itemid][iValue][0] != 0)
	        {
	            new access_uid = PlayerItemCache[playerid][itemid][iValue][0];
	            mysql_query_format("UPDATE `"SQL_PREF"attached_objects` SET attach_x = '%f', attach_y = '%f', attach_z = '%f', attach_rx = '%f', attach_ry = '%f', attach_rz = '%f', attach_sx = '%f', attach_sy = '%f', attach_sz = '%f' WHERE attach_uid = '%d' LIMIT 1", fOffsetX, fOffsetY, fOffsetZ, fRotX, fRotY, fRotZ, fScaleX, fScaleY, fScaleZ, access_uid);
			}
	        else
	        {
	            mysql_query_format("INSERT INTO `"SQL_PREF"attached_objects` VALUES ('', '1', '%d', '%d', '%f', '%f', '%f', '%f', '%f', '%f', '%f', '%f', '%f', '-', '0')", modelid, boneid, fOffsetX, fOffsetY, fOffsetZ, fRotX, fRotY, fRotZ, fScaleX, fScaleY, fScaleZ);
	        
	            PlayerItemCache[playerid][itemid][iValue][0] = cache_insert_id();
	            PlayerItemCache[playerid][itemid][iValue][1] = 0;
	            
	            orm_update(PlayerItemCache[playerid][itemid][iOrm]);
	        }
	        TD_ShowSmallInfo(playerid, 3, "Pozycja akcesoria zostala ~g~pomyslnie ~w~zapisana.");
	    }
	}

	return 1;
}

public OnUnoccupiedVehicleUpdate(vehicleid, playerid, passenger_seat)
{
	if(passenger_seat)
	{
	    return 1;
	}
	if(GetPlayerState(playerid) != PLAYER_STATE_ONFOOT)
	{
	    return 1;
	}
	
	new Float:vPosX, Float:vPosY, Float:vPosZ;
	GetVehiclePos(vehicleid, vPosX, vPosY, vPosZ);
	
	if(IsPlayerInRangeOfPoint(playerid, 3.0, vPosX, vPosY, vPosZ))
	{
	    if(!(CarInfo[vehicleid][cAccess] & VEH_ACCESS_ALARM))
	    {
	        return 1;
	    }
	    if(!CarInfo[vehicleid][cLocked])
	    {
	        return 1;
	    }
	    if(GetVehicleAlarmStatus(vehicleid) == 1 || GetVehicleEngineStatus(vehicleid) == 1)
	    {
			return 1;
	    }
		new keysa, uda, lra;
		GetPlayerKeys(playerid, keysa, uda, lra);
		
		if(keysa & KEY_FIRE)
		{
			ChangeVehicleAlarmStatus(vehicleid, true);
			defer OnToggleVehicleAlarm[15000](vehicleid);
		}
		return 1;
	}
	return 1;
}

public OnIncomingPacket(playerid, packetid, BitStream:bs)
{
/*
    new onFootData[PR_OnFootSync];

    BS_IgnoreBits(bs, 8);
    BS_ReadOnFootSync(bs, onFootData);

    if(IsPlayerConnected(playerid))
    {
    	if(PlayerCache[playerid][pLogged] && PlayerCache[playerid][pHours] < 1 && PlayerCache[playerid][pPoints] < 500)
    	{
    		if(onFootData[PR_velocity][0] != 0 && onFootData[PR_velocity][1] != 0)
    		{
    			if(onFootData[PR_velocity][0] == floatabs(PlayerCache[playerid][pPRVelocity][0] ) && onFootData[PR_velocity][1] == floatabs(PlayerCache[playerid][pPRVelocity][1]) && onFootData[PR_velocity][0] != PlayerCache[playerid][pPRVelocity][0])
    			{
					if(GetPlayerCameraTargetPlayer(playerid) != INVALID_PLAYER_ID)
					{
						GivePlayerPunish(playerid, INVALID_PLAYER_ID, PUNISH_BAN, "JohnnyProject.", 365, 0);
						return 1;
					}
    			}

	    		PlayerCache[playerid][pPRVelocity][0] = onFootData[PR_velocity][0];
    			PlayerCache[playerid][pPRVelocity][1] = onFootData[PR_velocity][1];
    			PlayerCache[playerid][pPRVelocity][2] = onFootData[PR_velocity][2];
    		}

    		//printf("Velocity %s: %f, %f, %f", pInfo[playerid][player_name], pInfo[playerid][player_velocity][0], pInfo[playerid][player_velocity][1], pInfo[playerid][player_velocity][2]);
    	}
    }
    */
	return 1;
}


public UpdatePlayerSession(playerid, session_type, session_extraid)
{
	new session_start = PlayerCache[playerid][pSession][session_type], session_end = gettime(), session_ip[16];
	GetPlayerIp(playerid, session_ip, sizeof(session_ip));
	
	mysql_query_format("INSERT INTO `"SQL_PREF"game_sessions` (session_owner, session_extraid, session_type, session_start, session_end, session_ip) VALUES ('%d', '%d', '%d', '%d', '%d', '%s')", PlayerCache[playerid][pUID], session_extraid, session_type, session_start, session_end, session_ip);
	return 1;
}

public ShowPlayerStatsForPlayer(playerid, giveplayer_id)
{
	new list_stats[1024], string[128], IP[16];
	GetPlayerIp(playerid, IP, sizeof(IP));
		
	format(list_stats, sizeof(list_stats), "Identyfikator\t\t\t%d\n", PlayerCache[playerid][pUID]);
	format(list_stats, sizeof(list_stats), "%sGlobalnie\t\t\t%d (%s)\n", list_stats, PlayerCache[playerid][pGID], PlayerCache[playerid][pGlobName]);
		
	format(list_stats, sizeof(list_stats), "%sCzas gry\t\t\t%dh %dm\n", list_stats, PlayerCache[playerid][pHours], PlayerCache[playerid][pMinutes]);

	if(PlayerCache[playerid][pHealth] <= 40)
	{
		format(list_stats, sizeof(list_stats), "%sZdrowie\t\t\t{FB5006}%.0f%%\n", list_stats, PlayerCache[playerid][pHealth]);
	}
	else
	{
	    format(list_stats, sizeof(list_stats), "%sZdrowie\t\t\t%.0f%%\n", list_stats, PlayerCache[playerid][pHealth]);
	}
	
	format(list_stats, sizeof(list_stats), "%sPortfel\t\t\t\t$%d\n", list_stats, PlayerCache[playerid][pCash]);

	format(list_stats, sizeof(list_stats), "%sBank\t\t\t\t$%d\n", list_stats, PlayerCache[playerid][pBankCash]);
	format(list_stats, sizeof(list_stats), "%sNumer konta\t\t\t%d\n", list_stats, PlayerCache[playerid][pBankNumber]);
	
	format(list_stats, sizeof(list_stats), "%sSkin\t\t\t\t%d\n", list_stats, PlayerCache[playerid][pSkin]);
	
	format(list_stats, sizeof(list_stats), "%sBW\t\t\t\t%dm\n", list_stats, PlayerCache[playerid][pBW] / 60);
	format(list_stats, sizeof(list_stats), "%sAJ\t\t\t\t%dm\n", list_stats, PlayerCache[playerid][pAJ] / 60);
	
	format(list_stats, sizeof(list_stats), "%sSiła\t\t\t\t%dj\n", list_stats, (PlayerCache[playerid][pDrugType] == DRUG_COCAINE) ? (PlayerCache[playerid][pStrength] + (PlayerCache[playerid][pDrugLevel] * 20)) : (PlayerCache[playerid][pStrength]));
	format(list_stats, sizeof(list_stats), "%sUzależnienie\t\t\t%.1f\n", list_stats, PlayerCache[playerid][pDepend]);
	
	new doorid = GetPlayerDoorID(playerid);
	if(doorid != INVALID_DOOR_ID)
	{
		format(list_stats, sizeof(list_stats), "%sDrzwi\t\t\t\t%d\n", list_stats, GetDoorUID(doorid));
	}
	else
	{
	    format(list_stats, sizeof(list_stats), "%sDrzwi\t\t\t\t0\n", list_stats);
	}
	
	new areaid = GetPlayerAreaID(playerid);
	if(areaid != INVALID_AREA_ID)
	{
	    format(list_stats, sizeof(list_stats), "%sStrefa\t\t\t\t%d\n", list_stats, GetAreaUID(areaid));
	}
	else
	{
	    format(list_stats, sizeof(list_stats), "%sStrefa\t\t\t\t0\n", list_stats);
	}
	
	format(list_stats, sizeof(list_stats), "%sPrzejechane\t\t\t%.1fkm\n", list_stats, PlayerCache[playerid][pMileage]);
	
	new fight_style = (PlayerCache[playerid][pFightStyle] != 15) ? (PlayerCache[playerid][pFightStyle] - 4) : 0;
	format(list_stats, sizeof(list_stats), "%sStyl walki\t\t\t%s\n", list_stats, FightStyleData[fight_style][0]);
	
	if(IsPlayerInAnyGroup(playerid))
	{
	    new list_groups[256], group_id;
    	for (new group_slot = 0; group_slot < MAX_GROUP_SLOTS; group_slot++)
		{
		    if(PlayerGroup[playerid][group_slot][gpUID])
		    {
				group_id = PlayerGroup[playerid][group_slot][gpID];
				if(PlayerCache[playerid][pDuty][DUTY_GROUP] == group_id)
				{
					format(list_groups, sizeof(list_groups), "%s {7CB342}» Slot %d\t\t\t%s (%d)\n", list_groups, group_slot + 1, GroupData[group_id][gName], GroupData[group_id][gUID]);
				}
				else
				{
				    format(list_groups, sizeof(list_groups), "%s » Slot %d\t\t\t%s (%d)\n", list_groups, group_slot + 1, GroupData[group_id][gName], GroupData[group_id][gUID]);
				}
		    }
		}
		format(list_stats, sizeof(list_stats), "%sGrupy:\n%s", list_stats, list_groups);
	}
	
	format(list_stats, sizeof(list_stats), "%s-----\n", list_stats);
	
	new talk_style = PlayerCache[playerid][pTalkStyle],
		walk_style = PlayerCache[playerid][pWalkStyle];
		
	format(list_stats, sizeof(list_stats), "%s1\tStyl rozmowy:\t\t%s\n", list_stats, TalkStyleData[talk_style][2]);
	
	if(walk_style == INVALID_ANIM_ID)
	{
		format(list_stats, sizeof(list_stats), "%s2\tAnimacja chodzenia:\tBrak\n", list_stats);
	}
	else
	{
	    format(list_stats, sizeof(list_stats), "%s2\tAnimacja chodzenia:\t%s\n", list_stats, AnimCache[walk_style][aCommand]);
	}
	
	if(PlayerCache[playerid][pOOC])
	{
	    format(list_stats, sizeof(list_stats), "%s3\tCzat OOC:\t\tWłączony\n", list_stats);
	}
	else
	{
	    format(list_stats, sizeof(list_stats), "%s3\tCzat OOC:\t\tWyłączony\n", list_stats);
	}
	
	if(PlayerCache[playerid][pFirstPersonObject] == INVALID_OBJECT_ID)
	{
	    format(list_stats, sizeof(list_stats), "%s4\tKamera FPS:\t\tNie\n", list_stats);
	}
	else
	{
	    format(list_stats, sizeof(list_stats), "%s4\tKamera FPS:\t\tTak\n", list_stats);
	}
	
	if(PlayerCache[giveplayer_id][pStrength] >= 7000) 	GivePlayerAchievement(giveplayer_id, ACHIEVE_MYOMA);
	if(PlayerCache[giveplayer_id][pDepend] >= 45.0)     GivePlayerAchievement(giveplayer_id, ACHIEVE_DRUGGIE);
	if(PlayerCache[giveplayer_id][pMileage] >= 2500)    GivePlayerAchievement(giveplayer_id, ACHIEVE_DRIVER);
	
	format(string, sizeof(string), "Statystyki postaci %s (ID: %d) [IP: %s]", PlayerOriginalName(playerid), playerid, IP);
	ShowPlayerDialog(giveplayer_id, D_STATS, DIALOG_STYLE_LIST, string, list_stats, "OK", "");
	return 1;
}

public CreateGroup(GroupName[], group_type)
{
	new query[512], group_uid;
	
	mysql_format(connHandle, query, sizeof(query), "INSERT INTO `"SQL_PREF"game_groups` (group_name, group_dotation, group_type, group_flags, group_date, group_last_tax) VALUES ('%e', '%d', '%d', '%d', '%d', '%d')", GroupName, GroupTypeInfo[group_type][gTypeMaxDotation], group_type, GroupTypeInfo[group_type][gTypeFlags], gettime(), gettime());
	mysql_query(connHandle, query);
	
	group_uid = cache_insert_id();
	
	mysql_format(connHandle, query, sizeof(query), "SELECT * FROM `"SQL_PREF"game_groups` WHERE group_uid = '%d' LIMIT 1", group_uid);
	mysql_tquery(connHandle, query, "query_OnLoadGroups", "");
	
	return group_uid;
}

public DeleteGroup(group_id)
{
	// Zwolnij członków
	mysql_query_format("DELETE FROM `"SQL_PREF"char_groups` WHERE group_belongs = '%d'", GroupData[group_id][gUID]);

	new group_slot;
	foreach(new i : Player)
	{
	    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	    {
	        if(IsPlayerInGroup(i, GroupData[group_id][gUID]))
	        {
	            group_slot = GetPlayerGroupSlot(i, GroupData[group_id][gUID]);

	            PlayerGroup[i][group_slot][gpUID] = 0;
	            PlayerGroup[i][group_slot][gpID] = 0;

	            PlayerGroup[i][group_slot][gpPerm] = 0;
	            strmid(PlayerGroup[i][group_slot][gpTitle], "Brak", 0, 4, 32);

				PlayerGroup[i][group_slot][gpPayment] = 0;
				
				if(PlayerCache[i][pDuty][DUTY_GROUP] == group_id)
				{
				    PlayerCache[i][pDuty][DUTY_GROUP] = INVALID_GROUP_ID;
				    PlayerCache[i][pSession][SESSION_GROUP] = 0;
				}
	        }
	    }
	}
	
	// Usuń pojazdy
	for(new vehid = 0; vehid < MAX_VEHICLES; vehid++)
	{
	    if(CarInfo[vehid][cUID])
	    {
	        if(CarInfo[vehid][cOwnerType] == OWNER_GROUP && CarInfo[vehid][cOwner] == GroupData[group_id][gUID])
	        {
    			DeleteVehicle(vehid);
	        }
	    }
	}

	// Odpisz drzwi
	new count_doors = Streamer_GetUpperBound(STREAMER_TYPE_PICKUP),
		DoorData[sDoorInfo], query[256];
		
	mysql_format(connHandle, query, sizeof(query), "UPDATE `"SQL_PREF"doors` SET door_ownertype = 0, door_owner = 0 WHERE door_owner = '%d' AND door_ownertype = '%d'", GroupData[group_id][gUID], OWNER_GROUP);
	mysql_query(connHandle, query);
	
	for (new door = 0; door <= count_doors; door++)
	{
 		if(IsValidDynamicPickup(door))
   		{
	    	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, door, E_STREAMER_EXTRA_ID, DoorData);
     		if(DoorData[dOwnerType] == OWNER_GROUP && DoorData[dOwner] == GroupData[group_id][gUID])
	        {
	            DoorData[dOwnerType] = OWNER_NONE;
	            DoorData[dOwner] = 0;
	            
	            Streamer_SetArrayData(STREAMER_TYPE_PICKUP, door, E_STREAMER_EXTRA_ID, DoorData);
	        }
	    }
	}

	// Usuń podgrupy
	if(!GroupData[group_id][gOwner])
	{
	    for(new g = 0; g < MAX_GROUPS; g++)
	    {
	        if(GroupData[g][gUID])
	        {
	            if(GroupData[g][gOwner] == GroupData[group_id][gUID])
	            {
	                DeleteGroup(g);
	            }
	        }
	    }
	}
	
	orm_delete(GroupData[group_id][gOrm]);
	Iter_Remove(Groups, group_id);
	return 1;
}

public query_OnLoadGroups()
{
	new rows, group_id, ORM:orm_id, group_color[12];
	
	cache_get_row_count(rows);
	for(new row = 0; row != rows; row++)
	{
 		group_id = Iter_Free(Groups);
   		orm_id = GroupData[group_id][gOrm] = orm_create(""SQL_PREF"game_groups", connHandle);

		orm_addvar_int(orm_id, GroupData[group_id][gUID], "group_uid");
		orm_addvar_string(orm_id, GroupData[group_id][gName], 32, "group_name");

		orm_addvar_int(orm_id, GroupData[group_id][gType], "group_type");
		orm_addvar_int(orm_id, GroupData[group_id][gCash], "group_cash");
		
		orm_addvar_int(orm_id, GroupData[group_id][gCapital], "group_capital");
		orm_addvar_int(orm_id, GroupData[group_id][gMaxPay], "group_dotation");

		orm_addvar_string(orm_id, GroupData[group_id][gTag], 5, "group_tag");

		orm_addvar_string(orm_id, group_color, 12, "group_color");
		orm_addvar_int(orm_id, GroupData[group_id][gFlags], "group_flags");
		
		orm_addvar_int(orm_id, GroupData[group_id][gValue1], "group_value1");
		orm_addvar_int(orm_id, GroupData[group_id][gValue2], "group_value2");

		orm_addvar_int(orm_id, GroupData[group_id][gOwner], "group_owner");
		orm_addvar_int(orm_id, GroupData[group_id][gLastTax], "group_last_tax");
		
		sscanf(group_color, "x", GroupData[group_id][gColor]);

		orm_setkey(orm_id, "group_uid");
		orm_apply_cache(orm_id, row);
		
		// Nie chcę zapisywać tych danych
		orm_delvar(orm_id, "group_color");
		orm_delvar(orm_id, "group_flags");

		Iter_Add(Groups, group_id);
	}
	printf("[load] Proces wczytywania grup został zakończony (count: %d).", Iter_Count(Groups));
	return 1;
}

public ShowPlayerGroupInfo(playerid, group_id)
{
	new list_stats[256], string[128];
	format(list_stats, sizeof(list_stats), "Typ grupy:\t\t%s", GroupTypeInfo[GroupData[group_id][gType]][gTypeName]);
	format(list_stats, sizeof(list_stats), "%s\nBudżet:\t\t\t$%d", list_stats, GroupData[group_id][gCash]);

    format(list_stats, sizeof(list_stats), "%s\nMaksymalna pensja:\t$%d", list_stats, GroupData[group_id][gMaxPay]);
    format(list_stats, sizeof(list_stats), "%s\nKapitał:\t\t\t$%d", list_stats, GroupData[group_id][gCapital]);

    if(GroupData[group_id][gOwner])
    {
        new group_owner_id = GetGroupID(GroupData[group_id][gOwner]);
		format(list_stats, sizeof(list_stats), "%s\nNadrzędna:\t\t%s (UID: %d)", list_stats, GroupData[group_owner_id][gName], GroupData[group_owner_id][gUID]);
	}
	
	if(PlayerCache[playerid][pDuty][DUTY_GROUP] == group_id)
	{
		new	duty_hours = floatround((gettime() - PlayerCache[playerid][pSession][SESSION_GROUP]) / 3600, floatround_floor),
					duty_minutes = floatround((gettime() - PlayerCache[playerid][pSession][SESSION_GROUP]) / 60, floatround_floor) % 60;
					
	    format(list_stats, sizeof(list_stats), "%s\nCzas służby:\t\t%dh %dm", list_stats, duty_hours, duty_minutes);
	}
	format(list_stats, sizeof(list_stats), "%s\nTag:\t\t\t%s", list_stats, GroupData[group_id][gTag]);
	
	if(GroupData[group_id][gFlags] & G_FLAG_TAX)
	{
 		new year, month, day, hour, minute, second;
		TimestampToDate(GroupData[group_id][gLastTax] + (7 * 86000), year, month, day, hour, minute, second, 1);
		
		format(list_stats, sizeof(list_stats), "%s\nPodatek:\t\t%02d/%02d/%d - %02d:%02d", list_stats, day, month, year, hour, minute);
	}

	format(string, sizeof(string), "%s (UID: %d) » Informacje", GroupData[group_id][gName], GroupData[group_id][gUID]);
	ShowPlayerDialog(playerid, D_NONE, DIALOG_STYLE_LIST, string, list_stats, "OK", "");
	return 1;
}

public ShowPlayerGroupOptions(playerid)
{
	new string[256], group_id;
	for (new slot = 0; slot < MAX_GROUP_SLOTS; slot++)
	{
	    if(PlayerGroup[playerid][slot][gpUID])
	    {
			group_id = PlayerGroup[playerid][slot][gpID];

			if(PlayerCache[playerid][pDuty][DUTY_GROUP] == group_id)
			{
		    	format(string, sizeof(string), "~>~ %s~w~ (%d) ~o~~n~~n~~n~~n~~n~~n~~n~", GroupData[group_id][gTag], slot + 1);
			}
			else
			{
	   			format(string, sizeof(string), "~>~ %s~w~ (%d) ~n~~n~~n~~n~~n~~n~~n~", GroupData[group_id][gTag], slot + 1);
			}
			
			PlayerTextDrawSetString(playerid, TD_MainGroupTag[playerid][slot], string);
			PlayerTextDrawColor(playerid, TD_MainGroupTag[playerid][slot], GroupData[group_id][gColor]);

			format(string, sizeof(string), "%s (%d)", GroupData[group_id][gName], GroupData[group_id][gUID]);
			PlayerTextDrawSetString(playerid, TD_MainGroupName[playerid][slot], string);

			PlayerTextDrawShow(playerid, TD_MainGroupTag[playerid][slot]);
			PlayerTextDrawShow(playerid, TD_MainGroupName[playerid][slot]);

			for(new group_option = 0; group_option != 6; group_option++)	TextDrawShowForPlayer(playerid, TD_GroupOption[group_option][slot]);
		}
	}
	SelectTextDraw(playerid, COLOR_GREEN);
	PlayerCache[playerid][pListPlayerGroups] = true;
	return 1;
}

public HidePlayerGroupOptions(playerid)
{
	for (new slot = 0; slot < MAX_GROUP_SLOTS; slot++)
	{
		PlayerTextDrawHide(playerid, TD_MainGroupTag[playerid][slot]);
		PlayerTextDrawHide(playerid, TD_MainGroupName[playerid][slot]);

		for(new group_option = 0; group_option != 6; group_option++)	TextDrawHideForPlayer(playerid, TD_GroupOption[group_option][slot]);
	}
	CancelSelectTextDraw(playerid);
	PlayerCache[playerid][pListPlayerGroups] = false;
	return 1;
}

public LoadPlayerGroups(playerid)
{
	new query[1024], rows, Cache:tmp_cache,
	    group_slot, group_id, group_uid, group_color[12];

	mysql_format(connHandle, query, sizeof(query), "SELECT `group_uid`, `group_perm`, `group_title`, `group_payment`, `group_advertise`, `group_skin`, `group_tag`, `group_color`, `group_flags` FROM `"SQL_PREF"game_groups`, `"SQL_PREF"char_groups` WHERE "SQL_PREF"game_groups.group_uid = "SQL_PREF"char_groups.group_belongs AND char_uid = '%d' LIMIT %d", PlayerCache[playerid][pUID], MAX_GROUP_SLOTS);
	tmp_cache = mysql_query(connHandle, query);
	
	cache_get_row_count(rows);
	for(new row = 0; row != rows; row++)
	{
	    cache_get_value_index_int(row, 0, group_uid);
        group_id = GetGroupID(group_uid);

		if(group_id == INVALID_GROUP_ID)    continue;
		PlayerGroup[playerid][group_slot][gpUID] = GroupData[group_id][gUID];

		cache_get_value_index_int(row, 1, PlayerGroup[playerid][group_slot][gpPerm]);
		cache_get_value_index(row, 2, PlayerGroup[playerid][group_slot][gpTitle], 32);

		cache_get_value_index_int(row, 3, PlayerGroup[playerid][group_slot][gpPayment]);
		cache_get_value_index(row, 4, GroupData[group_id][gAdvertise], 128);
		
		cache_get_value_index_int(row, 5, PlayerGroup[playerid][group_slot][gpSkin]);

        cache_get_value_index(row, 6, GroupData[group_id][gTag], 5);

        cache_get_value_index(row, 7, group_color, 12);
        cache_get_value_index_int(row, 8, GroupData[group_id][gFlags]);

        sscanf(group_color, "x", GroupData[group_id][gColor]);

		PlayerGroup[playerid][group_slot][gpID] = group_id;
		group_slot ++;
	}
	if(cache_is_valid(tmp_cache))	cache_delete(tmp_cache);
	return 1;
}

public CheckPlayerPayday(playerid)
{
	if(gettime() - PlayerCache[playerid][pLastPayday] < 3600)
	{
	    return 1;
	}
	
 	if(IsPlayerInAnyGroup(playerid))
 	{
 	    if(PlayerCache[playerid][pDuty][DUTY_GROUP] != INVALID_GROUP_ID)
 	    {
 	        // Zaktualizuj sesje
      		UpdatePlayerSession(playerid, SESSION_GROUP, GroupData[PlayerCache[playerid][pDuty][DUTY_GROUP]][gUID]);
        	PlayerCache[playerid][pSession][SESSION_GROUP] = gettime();
 	    }
 	
	    new query[1024], Cache:tmp_cache, rows, group_last_uid = 0,
	        group_slot, group_id, last_payday = PlayerCache[playerid][pLastPayday];

		mysql_format(connHandle, query, sizeof(query), "SELECT g.group_belongs, g.group_payment, (s.session_end - s.session_start) FROM `"SQL_PREF"char_groups` g LEFT JOIN `"SQL_PREF"game_sessions` s on g.char_uid = s.session_owner WHERE s.session_type = 2 AND s.session_extraid = g.group_belongs AND s.session_end > %d AND s.session_start < (%d + %d) AND g.char_uid = %d", last_payday, last_payday, gettime() - last_payday, PlayerCache[playerid][pUID]);
 		tmp_cache = mysql_query(connHandle, query);
 		
		cache_get_row_count(rows);
		for(new row = 0; row != rows; row++)
		{
			new session_sum, group_payment, group_belongs;

			cache_get_value_index_int(row, 2, session_sum);
			cache_get_value_index_int(row, 1, group_payment);
			cache_get_value_index_int(row, 0, group_belongs);

			// Nie powtarzaj funkcji
			if(group_last_uid == 0 || group_belongs != group_last_uid)	group_slot = GetPlayerGroupSlot(playerid, group_belongs);

			PlayerGroup[playerid][group_slot][gpDutyMinute] += floatround(session_sum / 60);
			PlayerGroup[playerid][group_slot][gpPay] = group_payment;

			// Maksymalnie 3h służby
			//if(PlayerGroup[playerid][group_slot][gpDutyMinute] >= 180)	PlayerGroup[playerid][group_slot][gpDutyMinute] = 180;

			group_last_uid = group_belongs;
		}
		if(cache_is_valid(tmp_cache))	cache_delete(tmp_cache);

		new list_pay[512], year[2], month[2], day[2], hour[2], minute[2], second[2],
  			payday_sum, duty_hours_sum, duty_minutes_sum;

		TimestampToDate(gettime(), year[0], month[0], day[0], hour[0], minute[0], second[0], 1);
   		TimestampToDate(last_payday, year[1], month[1], day[1], hour[1], minute[1], second[1], 1);

		format(list_pay, sizeof(list_pay), "~y~Wyplata za sluzby: ~n~%02d:%02d - %02d:%02d (%02d/%02d/%d)~w~~n~", hour[1], minute[1], hour[0], minute[0], day[1], month[1], year[1]);

		for(new slot = 0; slot < MAX_GROUP_SLOTS; slot++)
		{
   			if(PlayerGroup[playerid][slot][gpUID] != 0)
   			{
       			if(PlayerGroup[playerid][slot][gpDutyMinute])
       			{
			   		new	duty_pay = floatround(PlayerGroup[playerid][slot][gpDutyMinute] * PlayerGroup[playerid][slot][gpPay]) / 60,
						duty_hours = floatround(PlayerGroup[playerid][slot][gpDutyMinute] / 60, floatround_floor),
						duty_minutes = floatround(PlayerGroup[playerid][slot][gpDutyMinute], floatround_floor) % 60;

					group_id = PlayerGroup[playerid][slot][gpID];
					format(list_pay, sizeof(list_pay), "%s~n~%s (%d) - ~g~$%d ~w~(%dg %dm)~w~", list_pay, GroupData[group_id][gTag], PlayerGroup[playerid][slot][gpUID], duty_pay, duty_hours, duty_minutes);

					duty_hours_sum += duty_hours;
      				duty_minutes_sum += duty_minutes;

					payday_sum += duty_pay;
				}
			}
		}
/*
		// Opłata za hotel
		if(PlayerCache[playerid][pHouse] != 0)
		{
			new doorid = GetDoorID(PlayerCache[playerid][pHouse]);
			if(doorid != INVALID_DOOR_ID)
			{
				new DoorData[sDoorInfo];
				Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);

				if(DoorData[dOwnerType] == OWNER_GROUP)
				{
	    			group_id = GetGroupID(DoorData[dOwner]);
	    			if(GroupData[group_id][gType] == G_TYPE_HOTEL)
	    			{
	        			payday_sum -= GroupData[group_id][gValue1];
	        			format(list_pay, sizeof(list_pay), "%s~n~~n~Oplata za wynajem: ~r~$%d~w~", list_pay, GroupData[group_id][gValue1]);
						break;
	 				}
				}
			}
		}
*/
		format(list_pay, sizeof(list_pay), "%s~n~~n~Suma: ~g~$%d~n~~w~Lacznie: %dg %dm~n~~n~~w~Pieniadze zostaly przelane na Twoje ~y~konto bankowe~w~.", list_pay, payday_sum, duty_hours_sum, duty_minutes_sum);

		if(payday_sum > 0)
		{
			TD_ShowHint(playerid, HINT_NONE, 20, list_pay);
			PlayerCache[playerid][pBankCash] += payday_sum;
		}
	}

	PlayerCache[playerid][pLastPayday] = gettime();
	mysql_query_format("UPDATE `"SQL_PREF"characters` SET char_lastpay = '%d' WHERE char_uid = '%d' LIMIT 1", PlayerCache[playerid][pLastPayday], PlayerCache[playerid][pUID]);
	return 1;
}

public OnPlayerStartMission(playerid, mission_uid)
{
	if(MissionData[playerid][mUID] != 0)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aktualnie wykonujesz już jakieś zadanie.");
	    return 1;
	}
	
	foreach(new i : Player)
	{
	    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	    {
	        if(MissionData[i][mUID] == mission_uid)
	        {
	            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ktoś aktualnie wykonuje to zadanie.");
	            return 1;
	        }
	    }
	}
	
	new group_id = MissionData[playerid][mGroup], count_members;
	if(MissionData[playerid][mMembers] > 0)
	{
	    foreach(new i : Player)
	    {
			if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
			{
			    if(PlayerCache[i][pDuty][DUTY_GROUP] == group_id)
			    {
					if(PlayerToPlayer(10.0, i, playerid))
					{
						count_members ++;
						Iter_Add(MissionPlayer[playerid], i);
					}
			    }
			}
	    }
	    if(count_members < MissionData[playerid][mMembers])
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Do rozpoczęcia tego zadania potrzebujesz %d osób.\nOsoby te muszą znajdować się w pobliżu Ciebie będąc na służbie tej samej grupy.", MissionData[playerid][mMembers]);
			Iter_Clear(MissionPlayer[playerid]);
			return 1;
	    }
	    
	    new list_members[128];
	    
	    // Rozpoczynamy zadanie wszystkim
		foreach(new i : MissionPlayer[playerid])
		{
  			MissionData[i][mUID] = mission_uid;
			MissionData[i][mType] = MissionData[playerid][mType];

			MissionData[i][mVictim] = MissionData[playerid][mVictim];
			MissionData[i][mMembers] = MissionData[playerid][mMembers];

			MissionData[i][mAward] = MissionData[playerid][mAward];

			MissionData[i][mDate] = MissionData[playerid][mDate];
			MissionData[i][mTime] = MissionData[playerid][mTime];

			MissionData[i][mGroup] = MissionData[playerid][mGroup];
			MissionData[i][mLeader] = false;
			
			format(list_members, sizeof(list_members), "%s~n~~y~%s (%d)", list_members, PlayerName(i), i);
			TD_ShowHint(i, HINT_NONE, 0, "~p~%s ~w~rozpoczal nowe ~g~zadanie. ~w~Lista czlonkow:~n~~n~%s~n~~n~~w~Podazajcie za ~r~znacznikami~w~, by otrzymywac dalsze ~b~wskazowki ~w~dotyczace zadania.", PlayerName(playerid), list_members);
		}
		
		// Przywódca
		MissionData[playerid][mLeader] = true;
	}
	
	new mission_type = MissionData[playerid][mType], time = gettime();

	// Zgłoszenie
	if(mission_type == MISSION_NOTIFICATION)
	{
	    if(MissionData[playerid][mDate] + MissionData[playerid][mTime] < time)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "To zadanie przedawniło się.");
	        DeleteMission(mission_uid);
	        return 1;
	    }
		new giveplayer_id = GetPlayerID(MissionData[playerid][mVictim]);
		if(giveplayer_id == INVALID_PLAYER_ID)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "To zadanie przedawniło się.");
		    DeleteMission(mission_uid);
		    return 1;
		}
		new Float:posX, Float:posY, Float:posZ;
		GetPlayerPos(giveplayer_id, posX, posY, posZ);
		
		SetPlayerCheckpoint(playerid, posX, posY, posZ, 2.0);
		PlayerCache[playerid][pCheckpoint] = CHECKPOINT_MISSION;
		
		TD_ShowHint(giveplayer_id, HINT_NONE, 5, "Gracz ~y~%s ~w~zaakceptowal Twoje zgloszenie i juz do Ciebie jedzie.~n~~n~Czekaj tutaj cierpliwie.", PlayerName(playerid));
		TD_ShowHint(playerid, HINT_NONE, 5, "Zaakceptowales zgloszenie od ~y~%s~w~.~n~~n~Udaj sie do ~r~zaznaczonego ~w~na mapie punktu.", PlayerName(giveplayer_id));

		DeleteMission(mission_uid);
		return 1;
	}
	
	// Palący budynek
	if(mission_type == MISSION_FIRE_BUILD)
	{
	    if(MissionData[playerid][mVictim] == 0)
	    {
  			new Float:PosX, Float:PosY, Float:PosZ,
				virtual_world, interior_id;
	    
	        GetPlayerPos(playerid, PosX, PosY, PosZ);
	    
	        new doorid = GetNearRandomDoorID(PosX, PosY, PosZ, OWNER_NONE), DoorData[sDoorInfo];
	        Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);

			Streamer_GetItemPos(STREAMER_TYPE_PICKUP, doorid, PosX, PosY, PosZ);

			virtual_world = Streamer_GetIntData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_WORLD_ID);
			interior_id = Streamer_GetIntData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_INTERIOR_ID);

			DoorData[dFireData][FIRE_OBJECT] = CreateDynamicObject(18690, PosX, PosY, PosZ - 2.0, 0.0, 0.0, 0.0, virtual_world, interior_id, -1, MAX_DRAW_DISTANCE);
			DoorData[dFireData][FIRE_LABEL] = _:CreateDynamic3DTextLabel("Ten budynek stanął w płomieniach!\nSzacowane zniszczenia: 0%", 0x33AA33FF, PosX, PosY, PosZ + 0.3, 15.0);

			foreach(new i : Player)
			{
	  			if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	   			{
	     			if(GetPlayerDoorID(i) == doorid)
	        		{
	          			SendClientMessage(i, COLOR_DO, "** W tym budynku z niewiadomych przyczyn wybucha pożar. Wszyscy powinni zacząć się ewakuować. **");
			        }
			    }
			}
			
			CreateExplosion(PosX, PosY, PosZ, 1, 10.0);

			DoorData[dFireData][FIRE_TIME] = 1;
			Streamer_SetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
			
			foreach(new i : MissionPlayer[playerid])    MissionData[i][mVictim] = DoorData[dUID];
	    }
	    else
	    {
   			// Budynek podpalony
   			if(MissionData[playerid][mDate] + MissionData[playerid][mTime] < time)
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "To zadanie przedawniło się.");
		        DeleteMission(mission_uid);
		        return 1;
			}
	    }
		new doorid = GetDoorID(MissionData[playerid][mVictim]), Float:door_enter[3];
  		Streamer_GetItemPos(STREAMER_TYPE_PICKUP, doorid, door_enter[0], door_enter[1], door_enter[2]);

		foreach(new i : MissionPlayer[playerid])
		{
  			ShowPlayerInfoDialog(i, D_TYPE_INFO, "Na mapie zaznaczono punkt, w którym prawdopodobnie płonie budynek.\nUdaj się tam razem z drużyną, by otrzymywać dalsze wskazówki.\n\n\t\t\t\tNagroda: $%d\n\t\t\t\tCzas: %dh %dm", MissionData[playerid][mAward], MissionData[playerid][mTime] / 3600, MissionData[playerid][mTime] / 60 % 60);

			SetPlayerCheckpoint(i, door_enter[0], door_enter[1], door_enter[2], 5.0);
			PlayerCache[i][pCheckpoint] = CHECKPOINT_MISSION;
		}
	    return 1;
	}

	if(mission_type == MISSION_SMUGGLE)
	{
	    new areaid = (MissionData[playerid][mVictim] != 0) ? GetAreaID(MissionData[playerid][mVictim]) : GetRandomAreaID(A_FLAG_MISSION);
	    if(areaid == INVALID_AREA_ID)
	    {
	    	ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "To zadanie przedawniło się.");
		    DeleteMission(mission_uid);
	        return 1;
	    }
	    new AreaData[sAreaData];
	    Streamer_GetArrayData(STREAMER_TYPE_AREA, areaid, E_STREAMER_EXTRA_ID, AreaData);

		foreach(new i : MissionPlayer[playerid])
		{
		    MissionData[i][mVictim] = AreaData[aUID];
  			ShowPlayerInfoDialog(i, D_TYPE_INFO, "Dostańcie się w strefę, którą zaznaczono na mapie.\nNa miejscu dostaniecie wskazówki odnośnie przemytu.\n\n\t\t\t\tNagroda: $%d (+ rzeczy z przemytu)\n\t\t\t\tCzas: %dh %dm", MissionData[playerid][mAward], MissionData[playerid][mTime] / 3600, MissionData[playerid][mTime] / 60 % 60);

		   	GangZoneShowForPlayer(i, AreaData[aExtraID], COLOR_GREEN);
			GangZoneFlashForPlayer(i, AreaData[aExtraID], COLOR_RED);
		}
	    return 1;
	}
	
	if(mission_type == MISSION_CHASE)
	{
 		if(MissionData[playerid][mDate] + MissionData[playerid][mTime] < time)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "To zadanie przedawniło się.");
	        DeleteMission(mission_uid);
	        return 1;
	    }
	    new giveplayer_id = GetPlayerID(MissionData[playerid][mVictim]);
	    if(giveplayer_id == INVALID_PLAYER_ID)
	    {
    		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "To zadanie przedawniło się.");
		    DeleteMission(mission_uid);
	        return 1;
	    }
	    new string[256];
     	format(string, sizeof(string), "Musicie obezwładnić (lub skuć w kajdanki) lidera grupy.\nPoniżej przedstawiono potrzebne dane nt. pościgu:\n\nCzłonkowie grupy:");

		foreach(new g : MissionPlayer[giveplayer_id])
  		{
    		if(g == giveplayer_id)
      		{
        		format(string, sizeof(string), "%s\n\t%s (lider)", string, PlayerName(g));
          	}
           	else
           	{
				format(string, sizeof(string), "%s\n\t%s", string, PlayerName(g));
			}
  		}

		if(MissionData[giveplayer_id][mValue][0] != 0)
		{
			new vehid = MissionData[giveplayer_id][mValue][0];

			strcat(string, "\n\nPojazd:", sizeof(string));
			format(string, sizeof(string), "%s\n\t%s (NR. Rej: %s)", string, GetVehicleName(CarInfo[vehid][cModel]), CarInfo[vehid][cRegister]);
		}
	    
	    format(string, sizeof(string), "%s\n\n\t\t\t\tNagroda: $%d\n\t\t\t\tCzas: %dh %dm", string,  MissionData[playerid][mAward], MissionData[playerid][mTime] / 3600, MissionData[playerid][mTime] / 60 % 60);
	    
	    foreach(new i : MissionPlayer[playerid])
	    {
	        ShowPlayerInfoDialog(i, D_TYPE_INFO, string);
	    }
	    return 1;
	}
	return 1;
}

public OnPlayerStopMission(playerid)
{
	//new mission_type = MissionData[playerid][mType];
    if(MissionData[playerid][mPoints] >= MissionData[playerid][mNeedPoints])
    {
        // Zadanie przebiegło pomyślnie
    }
    else
    {
        // Zadanie nie przebiegło pomyślnie
    }

	// Wyczyścić i ukryć znacznik
	new mission_leader = GetMissionLeader(MissionData[playerid][mUID]);
    if(mission_leader != playerid)	for(new sMissionData:e; e < sMissionData; ++e)                      MissionData[playerid][e] = 0;
	return 1;
}

public CreateGroupMission(group_id, group_type, mission_type, mission_desc[], mission_victim, mission_members, mission_award, mission_time)
{
	new query[512];
	mysql_format(connHandle, query, sizeof(query), "INSERT INTO `"SQL_PREF"group_missions` VALUES ('', '%d', '%d', '%d', '%e', '%d', '%d', '%d', '%d', '0', '%d')", mission_type, group_type, (group_id != INVALID_GROUP_ID) ? GroupData[group_id][gUID] : 0, mission_desc, mission_victim, mission_members, mission_award, gettime(), mission_time);
	mysql_query(connHandle, query);

	// Wyświetlamy info o zadaniu
	foreach(new i : Player)
	{
 		if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	    {
     		if(PlayerCache[i][pDuty][DUTY_GROUP] != INVALID_GROUP_ID)
       		{
	        	if(group_id != INVALID_GROUP_ID)
	        	{
		            if(PlayerCache[i][pDuty][DUTY_GROUP] == group_id)
		            {
						SendClientFormatMessage(i, COLOR_GREEN, "Grupa %s (UID: %d) ma nowe zadanie! Sprawdź /g %d zadania, po więcej szczegółów.", GroupData[group_id][gName], GroupData[group_id][gUID], GetPlayerGroupSlot(i, GroupData[group_id][gUID]) + 1);
					}
				}
				else
				{
				    group_id = PlayerCache[i][pDuty][DUTY_GROUP];
				    if(GroupData[group_id][gType] == group_type)
				    {
				        SendClientFormatMessage(i, COLOR_GREEN, "Grupa %s (UID: %d) ma nowe zadanie! Sprawdź /g %d zadania, po więcej szczegółów.", GroupData[group_id][gName], GroupData[group_id][gUID], GetPlayerGroupSlot(i, GroupData[group_id][gUID]) + 1);
				    }
				}
			}
	    }
	}
	return 1;
}

public DeleteMission(mission_uid)
{
	mysql_query_format("UPDATE `"SQL_PREF"group_missions` SET mission_date = '%d' WHERE mission_uid = %d AND mission_limit != 0 LIMIT 1", gettime(), mission_uid);

	if(cache_affected_rows() <= 0)
	{
		mysql_query_format("DELETE FROM `"SQL_PREF"group_missions` WHERE mission_uid = '%d' LIMIT 1", mission_uid);
	}
	
	foreach(new i : Player)
	{
	    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	    {
	        if(MissionData[i][mUID] == mission_uid)
	        {
				OnPlayerStopMission(i);
			}
	    }
	}
	
	new mission_leader = GetMissionLeader(mission_uid);
	
	for(new sMissionData:e; e < sMissionData; ++e)                      MissionData[mission_leader][e] = 0;
	Iter_Clear(MissionPlayer[mission_leader]);
	return 1;
}

public CreateStaticVehicle(modelid, Float:PosX, Float:PosY, Float:PosZ, Float:PosA, color1, color2, respawn_delay)
{
	new veh_uid, vehid;
	mysql_query_format("INSERT INTO `"SQL_PREF"vehicles` (vehicle_model, vehicle_posx, vehicle_posy, vehicle_posz, vehicle_posa, vehicle_color1, vehicle_color2, vehicle_fuel) VALUES ('%d', '%f', '%f', '%f', '%f', '%d', '%d', '%d')", modelid, PosX, PosY, PosZ, PosA, color1, color2, GetVehicleMaxFuel(modelid));

	veh_uid = cache_insert_id();
	vehid = LoadVehicle(veh_uid);
	
	return vehid;
}

public query_OnLoadVehicles()
{
	new rows, vehid, ORM:orm_id;
	
	cache_get_row_count(rows);
	for(new row = 0; row != rows; row++)
	{
		vehid = Iter_Free(Vehicles);
		orm_id = CarInfo[vehid][cOrm] = orm_create(""SQL_PREF"vehicles", connHandle);

		orm_addvar_int(orm_id, CarInfo[vehid][cUID], "vehicle_uid");
		orm_addvar_int(orm_id, CarInfo[vehid][cModel], "vehicle_model");

		orm_addvar_float(orm_id, CarInfo[vehid][cPosX], "vehicle_posx");
		orm_addvar_float(orm_id, CarInfo[vehid][cPosY], "vehicle_posy");
		orm_addvar_float(orm_id, CarInfo[vehid][cPosZ], "vehicle_posz");
		orm_addvar_float(orm_id, CarInfo[vehid][cPosA], "vehicle_posa");

		orm_addvar_int(orm_id, CarInfo[vehid][cWorldID], "vehicle_world");
		orm_addvar_int(orm_id, CarInfo[vehid][cInteriorID], "vehicle_interior");

		orm_addvar_int(orm_id, CarInfo[vehid][cColor1], "vehicle_color1");
		orm_addvar_int(orm_id, CarInfo[vehid][cColor2], "vehicle_color2");

		orm_addvar_float(orm_id, CarInfo[vehid][cFuel], "vehicle_fuel");
		orm_addvar_int(orm_id, CarInfo[vehid][cFuelType], "vehicle_fueltype");

		orm_addvar_float(orm_id, CarInfo[vehid][cHealth], "vehicle_health");
		orm_addvar_float(orm_id, CarInfo[vehid][cMileage], "vehicle_mileage");

		orm_addvar_int(orm_id, CarInfo[vehid][cLocked], "vehicle_locked");

		orm_addvar_string(orm_id, CarInfo[vehid][cVisual], 32, "vehicle_visual");

		orm_addvar_int(orm_id, CarInfo[vehid][cPaintJob], "vehicle_paintjob");
		orm_addvar_int(orm_id, CarInfo[vehid][cAccess], "vehicle_access");

		orm_addvar_int(orm_id, CarInfo[vehid][cBlockWheel], "vehicle_blockwheel");
		orm_addvar_string(orm_id, CarInfo[vehid][cRegister], 12, "vehicle_register");

	    orm_addvar_int(orm_id, CarInfo[vehid][cOwner], "vehicle_owner");
	    orm_addvar_int(orm_id, CarInfo[vehid][cOwnerType], "vehicle_ownertype");

	    orm_setkey(orm_id, "vehicle_uid");
	    orm_apply_cache(orm_id, row);

	    Iter_Add(Vehicles, vehid);
	    
	    new bool:siren = false;
	    if(CarInfo[vehid][cOwnerType] == OWNER_GROUP)
	    {
			new group_id = GetGroupID(CarInfo[vehid][cOwner]);
			if(GroupData[group_id][gType] == G_TYPE_POLICE)
			{
				siren = true;
			}
	    }
	    CreateVehicle(CarInfo[vehid][cModel], CarInfo[vehid][cPosX], CarInfo[vehid][cPosY], CarInfo[vehid][cPosZ], CarInfo[vehid][cPosA], CarInfo[vehid][cColor1], CarInfo[vehid][cColor2], (CarInfo[vehid][cOwnerType] == OWNER_WORK) ? 120 : 3600, siren);

		// Usuń opis
		for (new i = 0; i < MAX_PLAYERS; i++)
		{
			if(Streamer_GetIntData(STREAMER_TYPE_3D_TEXT_LABEL, Text3D:PlayerCache[i][vDescTag], E_STREAMER_ATTACHED_VEHICLE) == vehid)
			{
				UpdateDynamic3DTextLabelText(Text3D:PlayerCache[i][vDescTag], COLOR_DESC, " ");
				Streamer_SetIntData(STREAMER_TYPE_3D_TEXT_LABEL, Text3D:PlayerCache[i][vDescTag], E_STREAMER_ATTACHED_PLAYER, i);
			}
		}

		for(new i = 0; i < 14; i++)	CarInfo[vehid][cComponent][i] = 0;
		
		// Tuning mechaniczny
		if(CarInfo[vehid][cAccess] & VEH_ACCESS_TURBO)		CarInfo[vehid][cHandling] += 2.0;
		if(CarInfo[vehid][cAccess] & VEH_ACCESS_COMPRESSOR)	CarInfo[vehid][cHandling] += 2.0;
		if(CarInfo[vehid][cAccess] & VEH_ACCESS_ECU)		CarInfo[vehid][cHandling] += 3.0;

		CarInfo[vehid][cDistTicker] = 0;
		CarInfo[vehid][cSavePoint] = 0;

		strmid(CarInfo[vehid][cAudioURL], "", 0, 0, 32);
		CarInfo[vehid][cRadioCanal] = 4444;

		CarInfo[vehid][cGPS] = false;
		CarInfo[vehid][cLastUsing] = 0;

		CarInfo[vehid][cGlass] = false;
		SetVehicleToRespawn(vehid);
	}
	return 1;
}

public DeleteVehicle(vehid)
{
	orm_delete(CarInfo[vehid][cOrm]);
	
	DestroyVehicle(vehid);
	Iter_Remove(Vehicles, vehid);
	return 1;
}

public query_OnLoadVehicleComponents()
{
	new vehid, veh_uid, componentid, rows;
	
	cache_get_row_count(rows);
	for(new row = 0; row != rows; row++)
	{
		cache_get_value_index_int(row, 0, veh_uid);
		cache_get_value_index_int(row, 1, componentid);
		
		vehid = GetVehicleID(veh_uid);
		if(vehid == INVALID_VEHICLE_ID) continue;
		
		crp_AddVehicleComponent(vehid, componentid);
	}
	return 1;
}

public LoadVehicle(veh_uid)
{
	new query[256],
		rows, vehid = INVALID_VEHICLE_ID, ORM:orm_id, Cache:tmp_cache;
		
	mysql_format(connHandle, query, sizeof(query), "SELECT * FROM `"SQL_PREF"vehicles` WHERE vehicle_uid = '%d' LIMIT 1", veh_uid);
	tmp_cache = mysql_query(connHandle, query);
	
	cache_get_row_count(rows);
	if(rows > 0)
	{
		vehid = Iter_Free(Vehicles);
		orm_id = CarInfo[vehid][cOrm] = orm_create(""SQL_PREF"vehicles", connHandle);

		orm_addvar_int(orm_id, CarInfo[vehid][cUID], "vehicle_uid");
		orm_addvar_int(orm_id, CarInfo[vehid][cModel], "vehicle_model");

		orm_addvar_float(orm_id, CarInfo[vehid][cPosX], "vehicle_posx");
		orm_addvar_float(orm_id, CarInfo[vehid][cPosY], "vehicle_posy");
		orm_addvar_float(orm_id, CarInfo[vehid][cPosZ], "vehicle_posz");
		orm_addvar_float(orm_id, CarInfo[vehid][cPosA], "vehicle_posa");

		orm_addvar_int(orm_id, CarInfo[vehid][cWorldID], "vehicle_world");
		orm_addvar_int(orm_id, CarInfo[vehid][cInteriorID], "vehicle_interior");

		orm_addvar_int(orm_id, CarInfo[vehid][cColor1], "vehicle_color1");
		orm_addvar_int(orm_id, CarInfo[vehid][cColor2], "vehicle_color2");

		orm_addvar_float(orm_id, CarInfo[vehid][cFuel], "vehicle_fuel");
		orm_addvar_int(orm_id, CarInfo[vehid][cFuelType], "vehicle_fueltype");

		orm_addvar_float(orm_id, CarInfo[vehid][cHealth], "vehicle_health");
		orm_addvar_float(orm_id, CarInfo[vehid][cMileage], "vehicle_mileage");

		orm_addvar_int(orm_id, CarInfo[vehid][cLocked], "vehicle_locked");

		orm_addvar_string(orm_id, CarInfo[vehid][cVisual], 32, "vehicle_visual");

		orm_addvar_int(orm_id, CarInfo[vehid][cPaintJob], "vehicle_paintjob");
		orm_addvar_int(orm_id, CarInfo[vehid][cAccess], "vehicle_access");

		orm_addvar_int(orm_id, CarInfo[vehid][cBlockWheel], "vehicle_blockwheel");
		orm_addvar_string(orm_id, CarInfo[vehid][cRegister], 12, "vehicle_register");

	    orm_addvar_int(orm_id, CarInfo[vehid][cOwner], "vehicle_owner");
	    orm_addvar_int(orm_id, CarInfo[vehid][cOwnerType], "vehicle_ownertype");

	    orm_setkey(orm_id, "vehicle_uid");
	    orm_apply_cache(orm_id, 0);

	    Iter_Add(Vehicles, vehid);
	    CreateVehicle(CarInfo[vehid][cModel], CarInfo[vehid][cPosX], CarInfo[vehid][cPosY], CarInfo[vehid][cPosZ], CarInfo[vehid][cPosA], CarInfo[vehid][cColor1], CarInfo[vehid][cColor2], (CarInfo[vehid][cOwnerType] == OWNER_WORK) ? 120 : 3600);

		// Usuń opis
		for (new i = 0; i < MAX_PLAYERS; i++)
		{
			if(Streamer_GetIntData(STREAMER_TYPE_3D_TEXT_LABEL, Text3D:PlayerCache[i][vDescTag], E_STREAMER_ATTACHED_VEHICLE) == vehid)
			{
				UpdateDynamic3DTextLabelText(Text3D:PlayerCache[i][vDescTag], COLOR_DESC, " ");
				Streamer_SetIntData(STREAMER_TYPE_3D_TEXT_LABEL, Text3D:PlayerCache[i][vDescTag], E_STREAMER_ATTACHED_PLAYER, i);
			}
		}

		for(new i = 0; i < 14; i++)	CarInfo[vehid][cComponent][i] = 0;
		
		// Tuning mechaniczny
		if(CarInfo[vehid][cAccess] & VEH_ACCESS_TURBO)		CarInfo[vehid][cHandling] += 2.0;
		if(CarInfo[vehid][cAccess] & VEH_ACCESS_COMPRESSOR)	CarInfo[vehid][cHandling] += 2.0;
		if(CarInfo[vehid][cAccess] & VEH_ACCESS_ECU)		CarInfo[vehid][cHandling] += 3.0;

		CarInfo[vehid][cDistTicker] = 0;
		CarInfo[vehid][cSavePoint] = 0;

		strmid(CarInfo[vehid][cAudioURL], "", 0, 0, 32);
		CarInfo[vehid][cRadioCanal] = 4444;

		CarInfo[vehid][cGPS] = false;
		CarInfo[vehid][cLastUsing] = 0;

		CarInfo[vehid][cGlass] = false;
		SetVehicleToRespawn(vehid);
	}
	if(cache_is_valid(tmp_cache))	cache_delete(tmp_cache);
	
	// Komponenty
	if(vehid != INVALID_VEHICLE_ID)
	{
		mysql_format(connHandle, query, sizeof(query), "SELECT `item_vehuid`, `item_value1` FROM `"SQL_PREF"items` WHERE item_vehuid = '%d'", veh_uid);
		mysql_tquery(connHandle, query, "query_OnLoadVehicleComponents", "");
	}
	return vehid;
}

public ShowPlayerVehicleInfo(playerid, vehid)
{
    new list_info[512], string[128];
    
	format(list_info, sizeof(list_info), "Model:\t\t\t%d\n", CarInfo[vehid][cModel]);
	format(list_info, sizeof(list_info), "%sKolory:\t\t\t%d:%d\n", list_info, CarInfo[vehid][cColor1], CarInfo[vehid][cColor2]);
	
	format(list_info, sizeof(list_info), "%sPaliwo:\t\t\t%.0f/%dL\n", list_info, CarInfo[vehid][cFuel], GetVehicleMaxFuel(CarInfo[vehid][cModel]));
	format(list_info, sizeof(list_info), "%sRodzaj paliwa:\t\t%s\n", list_info, FuelTypeName[CarInfo[vehid][cFuelType]]);
	
	if(CarInfo[vehid][cHealth] <= 650)
	{
		format(list_info, sizeof(list_info), "%sStan techniczny:\t{FB5006}%.1f{FFFFFF} HP\n", list_info, CarInfo[vehid][cHealth]);
	}
	else
	{
 		format(list_info, sizeof(list_info), "%sStan techniczny:\t%.1f HP\n", list_info, CarInfo[vehid][cHealth]);
	}
	format(list_info, sizeof(list_info), "%sPrzebieg:\t\t%.0f km\n", list_info, CarInfo[vehid][cMileage]);
	
	switch(CarInfo[vehid][cOwnerType])
	{
	    case OWNER_NONE:
	    {
	        format(list_info, sizeof(list_info), "%sTyp właściciela:\t\tBrak\n", list_info);
	    }
	    case OWNER_PLAYER:
	    {
	       	format(list_info, sizeof(list_info), "%sTyp właściciela:\t\tGracz\n", list_info);
			format(list_info, sizeof(list_info), "%sUID gracza:\t\t%d\n", list_info, CarInfo[vehid][cOwner]);
	    }
	    case OWNER_GROUP:
	    {
   			format(list_info, sizeof(list_info), "%sTyp właściciela:\t\tGrupa\n", list_info);
   			format(list_info, sizeof(list_info), "%sUID grupy:\t\t%d\n", list_info, CarInfo[vehid][cOwner]);
	    }
	    case OWNER_WORK:
	    {
  			format(list_info, sizeof(list_info), "%sTyp właściciela:\t\tPraca\n", list_info);
   			format(list_info, sizeof(list_info), "%sID Pracy:\t\t%d (%s)\n", list_info, CarInfo[vehid][cOwner], WorkTypeName[CarInfo[vehid][cOwner]]);
	    }
	}
	
	if(strlen(CarInfo[vehid][cRegister]))
	{
	    format(list_info, sizeof(list_info), "%sRejestracja:\t\t%s\n", list_info, CarInfo[vehid][cRegister]);
	}
	else
	{
	    format(list_info, sizeof(list_info), "%sRejestracja:\t\t-\n", list_info);
	}
	
    format(list_info, sizeof(list_info), "%sMoc (KM):\t\t%d (+0)\n", list_info, GetVehicleMaxSpeed(CarInfo[vehid][cModel]));
	format(list_info, sizeof(list_info), "%s \nParking:\n\t\tX: %.4f\tY: %.4f\tZ: %.4f", list_info, CarInfo[vehid][cPosX], CarInfo[vehid][cPosY], CarInfo[vehid][cPosZ]);
	
	format(string, sizeof(string), "%s (UID: %d) » Informacje", GetVehicleName(CarInfo[vehid][cModel]), CarInfo[vehid][cUID]);
	ShowPlayerDialog(playerid, D_NONE, DIALOG_STYLE_LIST, string, list_info, "OK", "");
	return 1;
}

public CreateDoor(Float:DoorEnterX, Float:DoorEnterY, Float:DoorEnterZ, Float:DoorEnterA, DoorEnterInt, DoorEnterVW, DoorName[])
{
	new door_uid, door_name[64], query[256];

    mysql_escape_string(DoorName, door_name, 64);
	mysql_query_format("INSERT INTO `"SQL_PREF"doors` (door_name, door_enterx, door_entery, door_enterz, door_entera, door_enterint, door_entervw) VALUES ('%s', '%f', '%f', '%f', '%f', '%d', '%d')", door_name, DoorEnterX, DoorEnterY, DoorEnterZ, DoorEnterA, DoorEnterInt, DoorEnterVW);

	door_uid = cache_insert_id();
	
	mysql_format(connHandle, query, sizeof(query), "SELECT * FROM `"SQL_PREF"doors` WHERE door_uid = '%d' LIMIT 1", door_uid);
	mysql_tquery(connHandle, query, "query_OnLoadDoors", "");

	return door_uid;
}


public SaveDoor(doorid)
{
	new DoorData[sDoorInfo], Float:door_enter[3], door_entervw, door_enterint, door_pickupid;
	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	
	Streamer_GetItemPos(STREAMER_TYPE_PICKUP, doorid, door_enter[0], door_enter[1], door_enter[2]);
	
	door_entervw = Streamer_GetIntData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_WORLD_ID);
	door_enterint = Streamer_GetIntData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_INTERIOR_ID);
	
	door_pickupid = Streamer_GetIntData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_MODEL_ID);
	
	new query[1024];
	mysql_format(connHandle, query, sizeof(query), "UPDATE `"SQL_PREF"doors` SET door_name = '%e', door_ownertype = %d, door_owner = %d,  door_enterx = %f, door_entery = %f, door_enterz = %f, door_entera = %f, door_entervw = %d, door_enterint = %d, door_exitx = %f, door_exity = %f, door_exitz = %f, door_exita = %f, door_exitvw = %d, door_exitint = %d, door_pickupid = %d, door_lock = %d, door_garage = %d, door_enterpay = %d, door_audiourl = '%e', door_access = %d WHERE door_uid = %d LIMIT 1",
	DoorData[dName],
	
	DoorData[dOwnerType],
	DoorData[dOwner],

	door_enter[0],
	door_enter[1],
	door_enter[2],
	DoorData[dEnterA],
	
	door_entervw,
	door_enterint,
	
	DoorData[dExitX],
	DoorData[dExitY],
	DoorData[dExitZ],
	DoorData[dExitA],
	
	DoorData[dExitVW],
	DoorData[dExitInt],
	
	door_pickupid,

	DoorData[dLocked],
	DoorData[dGarage],

	DoorData[dEnterPay],
	DoorData[dAudioURL],
	
	DoorData[dAccess],
	DoorData[dUID]);
	
	mysql_query(connHandle, query);
	return 1;
}

public DeleteDoor(doorid)
{
	new DoorData[sDoorInfo];
	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);

	// Usuń stare obiekty z tego VW (jeśli są)
	new ObjectData[MAX_VIS_OBJECTS],
		object_count = Streamer_GetNearbyItems(DoorData[dExitX], DoorData[dExitY], DoorData[dExitZ], STREAMER_TYPE_OBJECT, ObjectData, MAX_VIS_OBJECTS, MAX_DRAW_DISTANCE, DoorData[dUID]);

	mysql_query_format("DELETE FROM `"SQL_PREF"objects` WHERE object_world = '%d'", DoorData[dUID]);

	for (new object = 0; object < object_count; object++)
	{
		DestroyDynamicObject(ObjectData[object]);
	}
	
	// Usuń 3d teksty z tych drzwi
	new LabelData[MAX_VIS_LABELS],
		label_count = Streamer_GetNearbyItems(DoorData[dExitX], DoorData[dExitY], DoorData[dExitZ], STREAMER_TYPE_3D_TEXT_LABEL, LabelData, MAX_VIS_LABELS, MAX_DRAW_DISTANCE, DoorData[dUID]);

	mysql_query_format("DELETE FROM `"SQL_PREF"3dlabels` WHERE label_world = '%d'", DoorData[dUID]);

	for (new label = 0; label < label_count; label++)
	{
		DestroyDynamic3DTextLabel(Text3D:LabelData[label]);
	}
	
	// Usuń aktorów z tych drzwi
	new ActorData[MAX_VIS_ACTORS],
		actor_count = Streamer_GetNearbyItems(DoorData[dExitX], DoorData[dExitY], DoorData[dExitZ], STREAMER_TYPE_ACTOR, ActorData, MAX_VIS_ACTORS, MAX_DRAW_DISTANCE, DoorData[dUID]);

	mysql_query_format("DELETE FROM `"SQL_PREF"actors` WHERE actor_vw = '%d'", DoorData[dUID]);

	for (new actor = 0; actor < actor_count; actor++)
	{
		DestroyDynamicActor(ActorData[actor]);
	}
	
	// Wyczyść magazyn drzwi
	new product_next;
	mysql_query_format("DELETE FROM `"SQL_PREF"products` WHERE product_owner = '%d'", DoorData[dUID]);

	foreach(new product_id : Product)
	{
	    if(ProductData[product_id][pUID])
	    {
	        if(ProductData[product_id][pOwner] == DoorData[dUID])
	        {
        		for(new sProductData:e; e < sProductData; ++e)	ProductData[product_id][e] = 0;
				
				Iter_SafeRemove(Product, product_id, product_next);
				product_id = product_next;
	        }
	    }
	}
	
	// Usuń zamówienia do tych drzwi
	mysql_query_format("DELETE FROM `"SQL_PREF"packages` WHERE package_dooruid = '%d'", DoorData[dUID]);

    mysql_query_format("DELETE FROM `"SQL_PREF"doors` WHERE door_uid = '%d'", DoorData[dUID]);
	DestroyDynamicPickup(doorid);
	return 1;
}

public query_OnLoadDoors()
{
	new rows, doorid,
	    DoorData[sDoorInfo];
	
	new Float:door_enter[4], door_entervw, door_enterint,
	    door_pickupid;

	cache_get_row_count(rows);
	for(new row = 0; row != rows; row++)
	{
	    cache_get_value_index_int(row, 0, DoorData[dUID]);
	    cache_get_value_index(row, 1, DoorData[dName], 64);
	    
	    cache_get_value_index_int(row, 2, DoorData[dOwnerType]);
	    cache_get_value_index_int(row, 3, DoorData[dOwner]);

		cache_get_value_index_float(row, 4, door_enter[0]);
		cache_get_value_index_float(row, 5, door_enter[1]);
		cache_get_value_index_float(row, 6, door_enter[2]);
		cache_get_value_index_float(row, 7, DoorData[dEnterA]);
		
		cache_get_value_index_int(row, 8, door_entervw);
		cache_get_value_index_int(row, 9, door_enterint);
		
		cache_get_value_index_float(row, 10, DoorData[dExitX]);
		cache_get_value_index_float(row, 11, DoorData[dExitY]);
		cache_get_value_index_float(row, 12, DoorData[dExitZ]);
		cache_get_value_index_float(row, 13, DoorData[dExitA]);
		
		cache_get_value_index_int(row, 14, DoorData[dExitVW]);
		cache_get_value_index_int(row, 15, DoorData[dExitInt]);
		
		cache_get_value_index_int(row, 16, door_pickupid);
		
		cache_get_value_index_int(row, 17, DoorData[dLocked]);
		cache_get_value_index_int(row, 18, DoorData[dGarage]);
		
		cache_get_value_index_int(row, 19, DoorData[dEnterPay]);
		cache_get_value_index(row, 20, DoorData[dAudioURL], 128);
		
		cache_get_value_index(row, 21, DoorData[dAccess]);
		cache_get_value_index(row, 22, DoorData[dHour]);
		
		doorid = CreateDynamicPickup(door_pickupid, 2, door_enter[0], door_enter[1], door_enter[2], door_entervw, door_enterint);

		if(door_entervw == 0)
		{
			if(DoorData[dOwnerType] == OWNER_GROUP)
			{
			    new group_id = GetGroupID(DoorData[dOwner]),
					group_type = GroupData[group_id][gType];

			    if(GroupTypeInfo[group_type][gTypeMapIcon] != 0)
			    {
					DoorData[dMapIcon] = CreateDynamicMapIcon(door_enter[0], door_enter[1], door_enter[2], GroupTypeInfo[group_type][gTypeMapIcon], 0, (GroupTypeInfo[group_type][gIconStatic]) ? 0 : 9999, door_enterint, -1);
					if(GroupTypeInfo[group_type][gIconStatic])	Streamer_SetIntData(STREAMER_TYPE_MAP_ICON, DoorData[dMapIcon], E_STREAMER_EXTRA_ID, true);

					DoorData[d3DLabel] = CreateDynamic3DTextLabel(" ", COLOR_DO, door_enter[0], door_enter[1], door_enter[2], 10.0, INVALID_PLAYER_ID, INVALID_PLAYER_ID, 1, door_entervw, door_enterint);
				}
			}
		}
		Streamer_SetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	}
	return 1;
}

public ShowPlayerDoorInfo(playerid, doorid)
{
	new DoorData[sDoorInfo], areaid = GetDoorAreaID(doorid);
	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	
	new door_pickupid = Streamer_GetIntData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_MODEL_ID);

    new list_stats[512], string[128];
	format(list_stats, sizeof(list_stats), "PickupID:\t\t%d\n", door_pickupid);

	if(DoorData[dLocked])
	{
		format(list_stats, sizeof(list_stats), "%sDrzwi:\t\t\t{FB5006}Zamknięte{FFFFFF}\n", list_stats);
	}
	else
	{
	    format(list_stats, sizeof(list_stats), "%sDrzwi:\t\t\tOtwarte\n", list_stats);
	}

	if(DoorData[dOwnerType] == OWNER_NONE)
	{
 		format(list_stats, sizeof(list_stats), "%sTyp właściciela:\t\tBrak\n", list_stats);
	}
	if(DoorData[dOwnerType] == OWNER_PLAYER)
	{
		format(list_stats, sizeof(list_stats), "%sTyp właściciela:\t\tGracz\n", list_stats);
		format(list_stats, sizeof(list_stats), "%sUID gracza:\t\t%d\n", list_stats, DoorData[dOwner]);
	}
	if(DoorData[dOwnerType] == OWNER_GROUP)
	{
		format(list_stats, sizeof(list_stats), "%sTyp właściciela:\t\tGrupa\n", list_stats);
		format(list_stats, sizeof(list_stats), "%sUID grupy:\t\t%d\n", list_stats, DoorData[dOwner]);
	}
	
	if(DoorData[dEnterPay])
	{
	    format(list_stats, sizeof(list_stats), "%sKoszt wstępu:\t\t$%d\n", list_stats, DoorData[dEnterPay]);
	}
	
	if(areaid == INVALID_AREA_ID)
	{
		format(list_stats, sizeof(list_stats), "%sMetraż:\t\t\t{FB5006}Nie ustalono!{FFFFFF}\n", list_stats);
	}
	else
	{
		new Float:pointes[8];
		GetDynamicPolygonPoints(areaid, pointes, 8);

		new AreaField, Side[2];
		Side[0] = floatround((pointes[0] > pointes[4]) ? (pointes[0] - pointes[4]) : (pointes[4] - pointes[0]));
  		Side[1] = floatround((pointes[1] > pointes[3]) ? (pointes[1] - pointes[3]) : (pointes[3] - pointes[1]));

		AreaField = Side[0] * Side[1];
		format(list_stats, sizeof(list_stats), "%sMetraż:\t\t\t%dm2\n", list_stats, AreaField);
	}

	if(strlen(DoorData[dAudioURL]))
	{
	    format(list_stats, sizeof(list_stats), "%s \nMuzyka:\n\t\t%s\n", list_stats, DoorData[dAudioURL]);
	}

	format(string, sizeof(string), "%s (UID: %d) » Informacje", DoorData[dName], DoorData[dUID]);
	ShowPlayerDialog(playerid, D_NONE, DIALOG_STYLE_LIST, string, list_stats, "OK", "");
	return 1;
}

public CreatePlayerItem(playerid, item_name[], item_type, item_value1, item_value2)
{
    new itemid = INVALID_ITEM_ID, item_uid, query[512];
    
   	if(item_type == ITEM_PHONE) 		item_value1 = 100000 + random(899999);
	if(item_type == ITEM_INHIBITOR) 	item_value1 = 23;
	if(item_type == ITEM_PAINT) 		item_value1 = 41;
    
    mysql_format(connHandle, query, sizeof(query), "INSERT INTO `"SQL_PREF"items` (item_name, item_value1, item_value2, item_type, item_ownertype, item_owner) VALUES ('%e', '%d', '%d', '%d', '%d', '%d')", item_name, item_value1, item_value2, item_type, PLACE_PLAYER, PlayerCache[playerid][pUID]);
    mysql_query(connHandle, query);

	item_uid = cache_insert_id();
	itemid = LoadPlayerItem(playerid, item_uid);
	return itemid;
}

public DeletePlayerItem(playerid, itemid)
{
	orm_delete(PlayerItemCache[playerid][itemid][iOrm]);
	for(new sPlayerItem:e; e < sPlayerItem; ++e)	PlayerItemCache[playerid][itemid][e] = 0;

	Iter_Remove(PlayerItem[playerid], itemid);
	return 1;
}

public ShowPlayerItemInfo(playerid, item_uid)
{
	new owner_id = GetItemOwner(item_uid);
	if(owner_id == INVALID_PLAYER_ID)
	{
	    return 1;
	}
	new itemid = GetPlayerItemID(owner_id, item_uid),
		list_info[512], title[64],
	    item_type = PlayerItemCache[owner_id][itemid][iType];

	format(list_info, sizeof(list_info), "Identyfikator:\t\t%d\n", PlayerItemCache[owner_id][itemid][iUID]);
    format(list_info, sizeof(list_info), "%sTyp:\t\t\t%s\n\n", list_info, ItemTypeInfo[item_type][iTypeName]);

    if(owner_id != playerid)
    {
    	format(list_info, sizeof(list_info), "%sWłaściciel:\t\t%s (%d)\n\n", list_info, PlayerName(owner_id), PlayerCache[owner_id][pUID]);
	}

	if(PlayerItemCache[owner_id][itemid][iUsed])
	{
	    format(list_info, sizeof(list_info), "%sStatus:\t\t\tW użyciu\n", list_info);
	}
	else
	{
		format(list_info, sizeof(list_info), "%sStatus:\t\t\tNieaktywny\n", list_info);
	}

	format(list_info, sizeof(list_info), "%sWaga:\t\t\t%dg\n\n", list_info, GetPlayerItemWeight(owner_id, itemid));

	format(list_info, sizeof(list_info), "%sWłaściwość 1:\t\t%d\n", list_info, PlayerItemCache[owner_id][itemid][iValue][0]);
	format(list_info, sizeof(list_info), "%sWłaściwość 2:\t\t%d\n\n", list_info, PlayerItemCache[owner_id][itemid][iValue][1]);

	//format(list_info, sizeof(list_info), "%sGrupa:\t\t\t%d\n", list_info, PlayerItemCache[owner_id][itemid][iGroup]);

	format(title, sizeof(title), "Informacje » %s", PlayerItemCache[owner_id][itemid][iName]);
	ShowPlayerDialog(playerid, D_NONE, DIALOG_STYLE_MSGBOX, title, list_info, "OK", "");
	return 1;
}

public ListPlayerItems(playerid)
{
 	new list_items[2048], item_count = Iter_Count(PlayerItem[playerid]), item_weight, item_weight_sum, capacity = PlayerCache[playerid][pStrength] * 2;
	format(list_items, sizeof(list_items), "UID\tNazwa przedmiotu\tWaga\n \t» Funkcja zaznaczania\n \t» Przedmioty w pobliżu\n---\n");
	
	DynamicGui_Init(playerid);

	DynamicGui_AddRow(playerid, D_ITEM_PLAYER_LIST, 0);
	DynamicGui_AddRow(playerid, D_ITEM_PLAYER_LIST, 0);
	DynamicGui_AddRow(playerid, D_ITEM_PLAYER_LIST, 0);
	
	if(item_count > 0)
	{
		foreach(new itemid : PlayerItem[playerid])
		{
		    if(PlayerItemCache[playerid][itemid][iUID])
		    {
		    	item_weight = GetPlayerItemWeight(playerid, itemid);
		    	if(PlayerItemCache[playerid][itemid][iUsed])
		    	{
					format(list_items, sizeof(list_items), "%s\n{FFFFFF}%d\t{FFFFFF}%s\t%dg", list_items, PlayerItemCache[playerid][itemid][iUID], PlayerItemCache[playerid][itemid][iName], item_weight);
				}
				else
				{
	   			 	format(list_items, sizeof(list_items), "%s\n{C0C0C0}%d\t{C0C0C0}%s\t%dg", list_items, PlayerItemCache[playerid][itemid][iUID], PlayerItemCache[playerid][itemid][iName], item_weight);
				}

				item_weight_sum += item_weight;
				DynamicGui_AddRow(playerid, D_ITEM_PLAYER_LIST, itemid);
	  		}
		}
		new title[256];
		
		format(title, sizeof(title), "Twoje przedmioty [ilość: %d | suma wag: %dg/%dg]", item_count, item_weight_sum, capacity);
  		ShowPlayerDialog(playerid, D_ITEM_PLAYER_LIST, DIALOG_STYLE_TABLIST_HEADERS, title, list_items, "Użyj", "Opcje...");
		
		if(item_weight_sum > capacity)	TD_ShowSmallInfo(playerid, 5, "Suma wag przedmiotow osiagnela ~r~maksimum ~w~udzwigu. Zwolnij miejsce w ekwipunku, w innym wypadku ~r~nie bedziesz mogl ~w~nic wiecej podniesc.");
	}
	else
	{
        TD_ShowSmallInfo(playerid, 5, "Nie posiadasz ~r~zadnych ~w~przedmiotow w ekwipunku.");
	}
	return item_count;
}

public ListPlayerCheckedItems(playerid)
{
	new list_items[2048], items_to_check;
	format(list_items, sizeof(list_items), "Zaznaczone przedmioty:\n{C0C0C0} • 1 - Odłóż w pobliżu\n{C0C0C0} • 2 - Włóż do przedmiotu\n{C0C0C0} • 3 - Schowaj do schowka\n{C0C0C0} • 4 - Dodaj do craftingu\n{C0C0C0} • 5 - Połącz ze sobą\n---\n");

	DynamicGui_Init(playerid);

	DynamicGui_AddRow(playerid, D_ITEM_CHECK, 0);
	DynamicGui_AddRow(playerid, D_ITEM_CHECK, 0);
	DynamicGui_AddRow(playerid, D_ITEM_CHECK, 0);
	DynamicGui_AddRow(playerid, D_ITEM_CHECK, 0);
	DynamicGui_AddRow(playerid, D_ITEM_CHECK, 0);
	DynamicGui_AddRow(playerid, D_ITEM_CHECK, 0);
    DynamicGui_AddRow(playerid, D_ITEM_CHECK, 0);

	foreach(new itemid : PlayerItem[playerid])
	{
	    if(PlayerItemCache[playerid][itemid][iUID])
	    {
		    if(!PlayerItemCache[playerid][itemid][iUsed] && PlayerItemCache[playerid][itemid][iType] != ITEM_BAG)
		    {
		        if(PlayerItemCache[playerid][itemid][iChecked])
		        {
		            format(list_items, sizeof(list_items), "%s\n%d\t[X]\t%s", list_items, PlayerItemCache[playerid][itemid][iUID], PlayerItemCache[playerid][itemid][iName]);
		        }
		        else
		        {
		            format(list_items, sizeof(list_items), "%s\n%d\t[ ]\t%s", list_items, PlayerItemCache[playerid][itemid][iUID], PlayerItemCache[playerid][itemid][iName]);
		        }
				items_to_check ++;
				DynamicGui_AddRow(playerid, D_ITEM_CHECK, itemid);
		    }
		}
	}

	if(items_to_check > 0)
	{
		ShowPlayerDialog(playerid, D_ITEM_CHECK, DIALOG_STYLE_LIST, "Przedmioty » Funkcja zaznaczania", list_items, "Zaznacz", "Wróć");
	}
	else
	{
     	CallLocalFunction("ListPlayerItems", "d", playerid);
	    TD_ShowSmallInfo(playerid, 5, "Nie posiadasz ~r~zadnych ~w~przedmiotow mozliwych do zaznaczenia.");
	}
	PlayerCache[playerid][pPuttingBag] = false;
	return 1;
}

public ListPlayerFavoriteItems(playerid)
{
	new list_favorite_items[512] = "Identyfikator\tNazwa przedmiotu", favorite_items_counts;
	DynamicGui_Init(playerid);
	
	foreach(new itemid : PlayerItem[playerid])
	{
	    if(PlayerItemCache[playerid][itemid][iUID])
	    {
	        if(PlayerItemCache[playerid][itemid][iFavorite])
	        {
	     		if(PlayerItemCache[playerid][itemid][iUsed])
	     		{
	             	format(list_favorite_items, sizeof(list_favorite_items), "%s\n{FFFFFF}%d\t{FFFFFF}%s", list_favorite_items, PlayerItemCache[playerid][itemid][iUID], PlayerItemCache[playerid][itemid][iName]);
				}
				else
				{
	   				format(list_favorite_items, sizeof(list_favorite_items), "%s\n{C0C0C0}%d\t{C0C0C0}%s", list_favorite_items, PlayerItemCache[playerid][itemid][iUID], PlayerItemCache[playerid][itemid][iName]);
				}
				DynamicGui_AddRow(playerid, D_ITEM_FAVORITE, itemid);
				favorite_items_counts ++;
			}
	    }
	}

	if(favorite_items_counts > 0)
	{
	    ShowPlayerDialog(playerid, D_ITEM_FAVORITE, DIALOG_STYLE_TABLIST_HEADERS, "Lista ulubionych przedmiotów:", list_favorite_items, "Użyj", "Zamknij");
	}
	else
	{
	    TD_ShowSmallInfo(playerid, 5, "Nie dodales ~r~zadnego ~w~przedmiotu do ulubionych.");
	}
	return 1;
}

public ListPlayerItemsForPlayer(playerid, giveplayer_id)
{
	new list_items[1024] = "UID\tNazwa przedmiotu\tWaga\tWartości", item_count = Iter_Count(PlayerItem[playerid]);
	foreach(new itemid : PlayerItem[playerid])
	{
	    if(PlayerItemCache[playerid][itemid][iUID])
	    {
	        format(list_items, sizeof(list_items), "%s\n%d\t%s\t%dg\t%d/%d", list_items, PlayerItemCache[playerid][itemid][iUID], PlayerItemCache[playerid][itemid][iName], GetPlayerItemWeight(playerid, itemid), PlayerItemCache[playerid][itemid][iValue][0], PlayerItemCache[playerid][itemid][iValue][1]);
	    }
	}

	if(item_count > 0)
	{
	    new title[64];
	    format(title, sizeof(title), "Przedmioty należące do %s (UID: %d)", PlayerName(playerid), PlayerCache[playerid][pUID]);

		ShowPlayerDialog(giveplayer_id, D_NONE, DIALOG_STYLE_TABLIST_HEADERS, title, list_items, "OK", "");
	}
	else
	{
	    TD_ShowSmallInfo(giveplayer_id, 5, "Ten gracz nie posiada ~r~zadnych ~w~przedmiotow.");
	}
	return 1;
}

public ListVehicleItemsForPlayer(vehicleid, playerid)
{
    new	item_uid, item_name[32], list_items[512];
	new rows, Cache:tmp_cache, query[256];

	mysql_format(connHandle, query, sizeof(query), "SELECT `item_uid`, `item_name` FROM `"SQL_PREF"items` WHERE item_ownertype = '%d' AND item_owner = '%d'", PLACE_VEHICLE, CarInfo[vehicleid][cUID]);
	tmp_cache = mysql_query(connHandle, query);

	cache_get_row_count(rows);
   	for(new row = 0; row != rows; row++)
   	{
     	cache_get_value_index_int(row, 0, item_uid);
     	cache_get_value_index(row, 1, item_name, 32);
     	
     	format(list_items, sizeof(list_items), "%s\n%d\t%s", list_items, item_uid, item_name);
	}
  	if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
  	
  	if(strlen(list_items))
  	{
	  	ShowPlayerDialog(playerid, D_NONE, DIALOG_STYLE_LIST, "Przedmioty znajdujące się w pojeździe", list_items, "OK", "");
	}
	else
	{
	    TD_ShowSmallInfo(playerid, 3, "Nie znaleziono ~r~zadnych ~w~przedmiotow w poblizu.");
	}
	return 1;
}

public ListPlayerNearItems(playerid)
{
	new main_query[2048], query[256], item_uid, item_place;
	format(main_query, sizeof(main_query), "SELECT `item_uid`, `item_name` FROM `"SQL_PREF"items` WHERE ");

	if(!IsPlayerInAnyVehicle(playerid))
	{
		new object_id = INVALID_OBJECT_ID,
			Float:PosX, Float:PosY, Float:PosZ,
			virtual_world = GetPlayerVirtualWorld(playerid);
			
        GetPlayerPos(playerid, PosX, PosY, PosZ);
			
		new ObjectData[MAX_VIS_OBJECTS],
			count_objects = Streamer_GetNearbyItems(PosX, PosY, PosZ, STREAMER_TYPE_OBJECT, ObjectData, MAX_VIS_OBJECTS, 3.0, virtual_world);

		for (new object = 0; object < count_objects; object++)
		{
			object_id = ObjectData[object];
			if(GetObjectUID(object_id) > 0)	continue;
			
			item_uid = (GetObjectUID(object_id) * -1);
			format(query, sizeof(query), "item_uid = %d", item_uid);

			if(strlen(main_query) > 64)
			{
				if(strlen(main_query) + strlen(query) < sizeof(main_query))
				{
					strcat(main_query, " OR ", sizeof(main_query));
				}
				else
				{
					strcat(main_query, ";", sizeof(main_query));
					break;
				}
			}
			strcat(main_query, query, sizeof(main_query));
		}

	    if(!item_uid)
	    {
	        TD_ShowSmallInfo(playerid, 5, "Nie znaleziono ~r~zadnych ~w~przedmiotow w poblizu.");
	        return 1;
	    }
	    item_place = PLACE_NONE;
	}
	else
	{
	    // LIST VEHICLE ITEMS
	    new vehid = GetPlayerVehicleID(playerid), veh_uid = CarInfo[vehid][cUID];
	    if(!(PlayerCache[playerid][pAdmin] & A_PERM_CARS))
	    {
		    if(CarInfo[vehid][cOwnerType] == OWNER_PLAYER)
		    {
		        if(CarInfo[vehid][cOwner] != PlayerCache[playerid][pUID])
		        {
		            ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz podnosić przedmiotów z tego pojazdu.");
		            return 1;
		        }
		    }
		}

		format(query, sizeof(query), "item_ownertype = '%d' AND item_owner = '%d'", PLACE_VEHICLE, veh_uid);
		strcat(main_query, query, sizeof(main_query));
		
		item_place = PLACE_VEHICLE;
	}

   	mysql_tquery(connHandle, main_query, "query_OnListPlayerNearItems", "dd", playerid, item_place);
	return 1;
}

public OnPlayerUseItem(playerid, itemid)
{
	if(PlayerCache[playerid][pBW])
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz używać przedmiotów w stanie nieprzytomności.");
	    return 0;
	}
	
	new string[256], item_type = PlayerItemCache[playerid][itemid][iType];
	if(item_type == ITEM_NONE)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Ten przedmiot nie posiada żadnego zastosowania.");
	    return 0;
	}
	
	if(item_type == ITEM_WATCH)
	{
		new hour, minute, second;
		gettime(hour, minute, second);

		format(string, sizeof(string), "~w~Godzina: ~p~%02d:%02d:%02d", hour, minute, second);
		GameTextForPlayer(playerid, string, 5000, 1);

		format(string, sizeof(string), "* %s spogląda na zegarek.", PlayerName(playerid));
		ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);

		ApplyAnimation(playerid, "COP_AMBIENT", "Coplook_watch", 4.1, 0, 0, 0, 0, 0, 1);
	    return 1;
	}
	
	if(item_type == ITEM_FOOD)
	{
		if(PlayerCache[playerid][pHealth] > 20)
   		{
			if(PlayerCache[playerid][pHealth] + PlayerItemCache[playerid][itemid][iValue][0] <= 100)
			{
				crp_SetPlayerHealth(playerid, PlayerCache[playerid][pHealth] + PlayerItemCache[playerid][itemid][iValue][0]);
			}
			else
			{
				crp_SetPlayerHealth(playerid, 100);
			}
		}
		else
		{
	    	TD_ShowSmallInfo(playerid, 5, "W tym stanie ~y~jedzenie ~w~nie pomoze Ci odregenerowac ~r~HP~w~.~n~~n~Udaj sie lepiej do ~g~szpitala ~w~nabyc lek.");
		}
		format(string, sizeof(string), "* %s spożywa \"%s\".", PlayerName(playerid), PlayerItemCache[playerid][itemid][iName]);
		ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);

        ApplyAnimation(playerid, "FOOD", "EAT_Pizza", 4.0, 0, 0, 0, 0, 0, true);
		DeletePlayerItem(playerid, itemid);
	    return 1;
	}
	
	if(item_type == ITEM_CIGGY)
	{
		SetPlayerSpecialAction(playerid, SPECIAL_ACTION_SMOKE_CIGGY);

  		PlayerItemCache[playerid][itemid][iValue][1] --;
  		if(PlayerItemCache[playerid][itemid][iValue][1] <= 0)
		{
            DeletePlayerItem(playerid, itemid);
            return 1;
		}
		orm_update(PlayerItemCache[playerid][itemid][iOrm]);
	    return 1;
	}
	
	if(item_type == ITEM_CUBE)
	{
		new rand = 1 + random(PlayerItemCache[playerid][itemid][iValue][0]);

		format(string, sizeof(string), "* %s wyrzucił %d oczek na %d.", PlayerName(playerid), rand, PlayerItemCache[playerid][itemid][iValue][0]);
		ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
	    return 1;
	}
	
	if(item_type == ITEM_CLOTH)
	{
		if(!PlayerItemCache[playerid][itemid][iValue][0])
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz użyć tego przedmiotu.");
			return 0;
		}
	    if(PlayerItemCache[playerid][itemid][iUsed])
	    {
	        crp_SetPlayerSkin(playerid, PlayerItemCache[playerid][itemid][iValue][0]);
	        return 1;
	    }
	    
	    foreach(new i : PlayerItem[playerid])
	    {
			if(PlayerItemCache[playerid][i][iType] == ITEM_CLOTH && PlayerItemCache[playerid][i][iUsed])
			{
			    PlayerItemCache[playerid][i][iUsed] = false;
			    orm_update(PlayerItemCache[playerid][i][iOrm]);
			    break;
			}
	    }
		PlayerItemCache[playerid][itemid][iUsed] = true;
		orm_update(PlayerItemCache[playerid][itemid][iOrm]);
		
		crp_SetPlayerSkin(playerid, PlayerItemCache[playerid][itemid][iValue][0]);
	    return 1;
	}
	
	if(item_type == ITEM_WEAPON || item_type == ITEM_INHIBITOR || item_type == ITEM_PAINT)
	{
		if(IsPlayerInAnyVehicle(playerid))
	    {
     		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz tego użyć będąc w pojeździe.");
     		return 0;
	    }
		if(PlayerItemCache[playerid][itemid][iValue][0] > 15 && PlayerItemCache[playerid][itemid][iValue][0] < 44 && !PlayerItemCache[playerid][itemid][iValue][1])
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Amunicja w tej broni jest całkowicie zużyta.");
   			return 0;
		}
		if(PlayerCache[playerid][pItemWeapon] != INVALID_ITEM_ID)
		{
		    if(PlayerCache[playerid][pItemWeapon] != itemid)
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Najpierw schowaj obecną broń, aby móc wyjąć drugą.");
		        return 0;
		    }
		}
		if(!strfind(PlayerItemCache[playerid][itemid][iName], "(F)", true))
		{
		    if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby użyć tej broni, musisz być na służbie grupy z odpowiednimi uprawnieniami.");
		        return 0;
		    }
			new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
			if(!(GroupData[group_id][gFlags] & G_FLAG_WEAPONS))
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Grupa, na której służbie jesteś nie posiada do tego uprawnień.");
			    return 0;
			}
		}
		/*
		if(PlayerItemCache[playerid][itemid][iGroup])
		{
			new group_id = GetGroupID(PlayerItemCache[playerid][itemid][iGroup]);
			if(group_id != INVALID_GROUP_ID)
			{
				if(!IsPlayerInGroup(playerid, GroupData[group_id][gUID]))
  				{
  					ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ta broń została oflagowana specjalnie dla grupy!\nAby użyć tej broni, musisz być w grupie %s (UID: %d).", GroupData[group_id][gName], GroupData[group_id][gUID]);
					return 0;
				}
			}
			else
			{
   				ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Ta broń została oflagowana specjalnie dla grupy!\nPrzedmiot zostanie usunięty, ze względu na brak możliwości jego użytkowania (grupa nie istnieje).");
				DeletePlayerItem(playerid, itemid);
				return 0;
			}
		}
		*/
		
		if(!PlayerItemCache[playerid][itemid][iUsed])
		{
		    PlayerCache[playerid][pCheckWeapon] = (gettime() + 5);
		
		    PlayerCache[playerid][pItemWeapon] = itemid;
		    GivePlayerWeapon(playerid, PlayerItemCache[playerid][itemid][iValue][0], PlayerItemCache[playerid][itemid][iValue][1]);
		    
		    PlayerItemCache[playerid][itemid][iUsed] = true;
		    orm_update(PlayerItemCache[playerid][itemid][iOrm]);
		}
		else
		{
		    PlayerCache[playerid][pCheckWeapon] = (gettime() + 5);
		
		    ResetPlayerWeaponsEx(playerid);
		    PlayerCache[playerid][pItemWeapon] = INVALID_ITEM_ID;
		    
			RemovePlayerAttachedObject(playerid, SLOT_WEAPON);
		    
		    PlayerItemCache[playerid][itemid][iUsed] = false;
		    orm_update(PlayerItemCache[playerid][itemid][iOrm]);
		}
	    return 1;
	}
	
	if(item_type == ITEM_AMMO)
	{
	    if(!PlayerItemCache[playerid][itemid][iValue][0])
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten magazynek jest całkowicie pusty.");
	        return 0;
	    }
	    
		DynamicGui_Init(playerid);
	    
	    new list_items[256];
	    foreach(new weapon_itemid : PlayerItem[playerid])
	    {
	        if(PlayerItemCache[playerid][weapon_itemid][iType] == ITEM_WEAPON &&  PlayerItemCache[playerid][weapon_itemid][iValue][0] == PlayerItemCache[playerid][itemid][iValue][0])
	        {
	            format(list_items, sizeof(list_items), "%s\n%d\t%d\t%d\t%s", list_items, PlayerItemCache[playerid][weapon_itemid][iUID], PlayerItemCache[playerid][weapon_itemid][iValue][0], PlayerItemCache[playerid][weapon_itemid][iValue][1], PlayerItemCache[playerid][weapon_itemid][iName]);
				DynamicGui_AddRow(playerid, D_ITEM_RELOAD_WEAPON, weapon_itemid);
			}
		}
	    
	    if(strlen(list_items))
	    {
	        PlayerCache[playerid][pItemArray][ITEM_WEAPON] = itemid;
	        ShowPlayerDialog(playerid, D_ITEM_RELOAD_WEAPON, DIALOG_STYLE_LIST, "Bronie, które możesz przeładować:", list_items, "Przeładuj", "Anuluj");
	    }
	    else
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz broni, do której mógłbyś użyć tej amunicji.");
	    }
	    return 1;
	}
	
	if(item_type == ITEM_PHONE)
	{
	    if(PlayerItemCache[playerid][itemid][iUsed])
	    {
	    	new hour, minute, second;
	    	gettime(hour, minute, second);

	        PlayerCache[playerid][pItemArray][ITEM_PHONE] = itemid;
	        
   			format(string, sizeof(string), "%s [%d] [%02d:%02d:%02d]", PlayerItemCache[playerid][itemid][iName], PlayerItemCache[playerid][itemid][iValue][0], hour, minute, second);
			ShowPlayerDialog(playerid, D_PHONE_OPTIONS, DIALOG_STYLE_LIST, string, "1. Wybierz numer\n2. Napisz SMS'a\n3. Wyślij vCard\n4. Kontakty\n5. Wyłącz telefon", "Wybierz", "Anuluj");
	    }
	    else
	    {
	        if(PlayerCache[playerid][pPhoneNumber])
	        {
	            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Możesz używać jednocześnie tylko jednego telefonu.");
	            return 0;
	        }
	        
	        PlayerItemCache[playerid][itemid][iUsed] = true;
	        orm_update(PlayerItemCache[playerid][itemid][iOrm]);
	        
	        PlayerCache[playerid][pPhoneNumber] = PlayerItemCache[playerid][itemid][iValue][0];
	        TD_ShowSmallInfo(playerid, 3, "Telefon zostal pomyslnie ~g~wlaczony~w~.");
	    }
	    return 1;
	}
	
	if(item_type == ITEM_CANISTER)
	{
 		if(!PlayerItemCache[playerid][itemid][iValue][0])
	    {
	        new object_id = GetClosestObjectType(playerid, OBJECT_FUELING);
			if(object_id == INVALID_OBJECT_ID)
			{
    			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten kanister jest całkowicie pusty.\nNa stacji benzynowej będziesz mógł go napełnić.");
				return 0;
			}
			new bens_type = PlayerItemCache[playerid][itemid][iValue][1],
			    price;
			
			if(bens_type == FUEL_TYPE_BENS) 			price = floatround(5 * 4.5);
			else if(bens_type == FUEL_TYPE_GAS) 		price = floatround(5 * 2.5);
			else if(bens_type == FUEL_TYPE_DIESEL) 		price = floatround(5 * 4.0);
			
			if(price > PlayerCache[playerid][pCash])
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz takiej ilości gotówki.");
			    return 1;
			}
			PlayerItemCache[playerid][itemid][iValue][0] = 5;
			orm_update(PlayerItemCache[playerid][itemid][iOrm]);
			
			crp_GivePlayerMoney(playerid, -price);
			orm_update(PlayerCache[playerid][pOrm]);
			
			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Udało się pomyślnie zapełnić %s (UID: %d).\nObecna ilość paliwa: %dL", PlayerItemCache[playerid][itemid][iName], PlayerItemCache[playerid][itemid][iUID], PlayerItemCache[playerid][itemid][iValue][0]);
	        return 1;
	    }
	    new vehid = GetClosestVehicle(playerid);
	    if(vehid == INVALID_VEHICLE_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znaleziono żadnego pojazdu w pobliżu.");
	        return 0;
	    }
	    new max_fuel = GetVehicleMaxFuel(CarInfo[vehid][cModel]);
	    if(floatround(CarInfo[vehid][cFuel]) >= max_fuel)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten pojazd ma pełny bak paliwa.");
	        return 0;
	    }
	    if(CarInfo[vehid][cFuelType] != PlayerItemCache[playerid][itemid][iValue][1])
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Rodzaj paliwa w kanistrze nie pasuje do tego w pojeździe.");
	        return 0;
	    }
	    if(CarInfo[vehid][cFuel] + PlayerItemCache[playerid][itemid][iValue][0] <= max_fuel)
	    {
     		new item_fuel = PlayerItemCache[playerid][itemid][iValue][0], Float:Refuel = floatround(CarInfo[vehid][cFuel]) + item_fuel;
         	CarInfo[vehid][cFuel] = Refuel;

         	PlayerItemCache[playerid][itemid][iValue][0] = 0;
			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Pojazd %s został pomyślnie zatankowany.\nZatankowano %d litrów paliwa.", GetVehicleName(CarInfo[vehid][cModel]), item_fuel);
	    }
	    else
	    {
     		new needfuel = max_fuel - floatround(CarInfo[vehid][cFuel]), Float:Refuel = floatround(CarInfo[vehid][cFuel]) + needfuel;
       		CarInfo[vehid][cFuel] = Refuel;

			PlayerItemCache[playerid][itemid][iValue][0] = PlayerItemCache[playerid][itemid][iValue][0] - needfuel;
			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Pojazd %s został pomyślnie zatankowany.\nZatankowano %d litrów paliwa.", GetVehicleName(CarInfo[vehid][cModel]), needfuel);
	    }
	    orm_update(PlayerItemCache[playerid][itemid][iOrm]);
	    
		format(string, sizeof(string), "* %s tankuje pojazd %s za pomocą kanistra.", PlayerName(playerid), GetVehicleName(CarInfo[vehid][cModel]));
		ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);

		ApplyAnimation(playerid, "INT_HOUSE", "wash_up", 4.1, 0, 0, 0, 0, 0, 1);
		orm_update(CarInfo[vehid][cOrm]);
	    return 1;
	}
	
	if(item_type == ITEM_MASK)
	{
 		if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
   		{
     		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby użyć tego przedmiotu, musisz być na służbie grupy z odpowiednimi uprawnieniami.");
       		return 0;
	    }
		new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
		if(!(GroupData[group_id][gFlags] & G_FLAG_MASK))
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Grupa, na której służbie jesteś nie posiada do tego uprawnień.");
  			return 0;
		}
		if(!PlayerItemCache[playerid][itemid][iValue][0])
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten przedmiot jest całkowicie zużyty.");
		    return 0;
		}
		if(PlayerCache[playerid][pItemMask] != INVALID_ITEM_ID)
		{
			if(PlayerCache[playerid][pItemMask] != itemid)
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Masz już jakąś maskę w użyciu.");
			    return 0;
			}
		}
 		new name[MAX_PLAYER_NAME];
	    if(!PlayerItemCache[playerid][itemid][iUsed])
	    {
	        PlayerItemCache[playerid][itemid][iUsed] = true;
	        PlayerCache[playerid][pItemMask] = itemid;

	 		format(string, sizeof(string), "* %s zakłada przedmiot %s na twarz.", PlayerName(playerid), PlayerItemCache[playerid][itemid][iName]);
			ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);

			format(name, sizeof(name), "Nieznajomy_%s", CharCode(PlayerCache[playerid][pUID]));
			SetPlayerName(playerid, name);

			format(string, sizeof(string), "%s", PlayerName(playerid));
			UpdateDynamic3DTextLabelText(Text3D:PlayerCache[playerid][pNameTag], PlayerCache[playerid][pNickColor], string);
		}
		else
		{
		    PlayerItemCache[playerid][itemid][iUsed] = false;
      		PlayerCache[playerid][pItemMask] = INVALID_ITEM_ID;

			format(string, sizeof(string), "* %s zdejmuje z twarzy przedmiot %s.", PlayerName(playerid), PlayerItemCache[playerid][itemid][iName]);
			ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);

			SetPlayerName(playerid, PlayerCache[playerid][pCharName]);

			format(string, sizeof(string), "%s (%d)", PlayerName(playerid), playerid);
            UpdateDynamic3DTextLabelText(Text3D:PlayerCache[playerid][pNameTag], PlayerCache[playerid][pNickColor], string);

			PlayerItemCache[playerid][itemid][iValue][0] --;
			if(PlayerItemCache[playerid][itemid][iValue][0] > 0)	orm_update(PlayerItemCache[playerid][itemid][iOrm]);
			else													DeletePlayerItem(playerid, itemid);
		}
	    return 1;
	}
	
	if(item_type == ITEM_HANDCUFFS)
	{
	    pc_cmd_skuj(playerid, "");
	    return 1;
	}
	
	if(item_type == ITEM_MEGAPHONE)
	{
 		pc_cmd_m(playerid, "");
	    return 1;
	}
	
	if(item_type == ITEM_LINE)
	{
	    pc_cmd_oferuj(playerid, "holowanie");
	    return 1;
	}
	
	if(item_type == ITEM_NOTEBOOK)
	{
		if(PlayerItemCache[playerid][itemid][iValue][0] <= 0)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "W tym notesie brakuje karteczek.");
		    return 0;
		}
		
  		PlayerCache[playerid][pItemArray][ITEM_NOTEBOOK] = itemid;
  		ShowPlayerDialog(playerid, D_ITEM_ADD_CHIT, DIALOG_STYLE_INPUT, "Notatnik » Karteczka", "Wpisz treść, która będzie widnieć na karteczce.\nWpisaną treść będzie mógł ujrzeć każdy kto użyje karteczki.", "OK", "Anuluj");
	    return 1;
	}
	
	if(item_type == ITEM_CHIT)
	{
 		new chit_uid, chit_desc[256], chit_writer[24], chit_time[24];
	    new rows, Cache:tmp_cache, query[128];

		mysql_format(connHandle, query, sizeof(query), "SELECT * FROM `"SQL_PREF"chits` WHERE chit_uid = '%d' LIMIT 1", PlayerItemCache[playerid][itemid][iValue][0]);
        tmp_cache = mysql_query(connHandle, query);

        cache_get_row_count(rows);
		if(rows > 0)
		{
		    cache_get_value_index_int(0, 0, chit_uid);
		    cache_get_value_index(0, 1, chit_desc, 128);
		    
		    cache_get_value_index(0, 2, chit_writer, 24);
		    cache_get_value_index(0, 3, chit_time, 24);
		    
		    format(string, sizeof(string), "%s\n\n%s,\n%s", WordWrap(chit_desc, WRAP_AUTO), chit_writer, chit_time);
			ShowPlayerDialog(playerid, D_NONE, DIALOG_STYLE_MSGBOX, PlayerItemCache[playerid][itemid][iName], string, "OK", "");
		}
	    if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
	    return 1;
	}
	
	if(item_type == ITEM_TUNING)
	{
		return 1;
	}
	
	if(item_type == ITEM_CHECKBOOK)
	{
/*
 		if(PlayerCache[playerid][pHours] < 5)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz wypisać czeku mając na koncie poniżej 5h gry.");
	        return 0;
	    }
	    if(PlayerItemCache[playerid][itemid][iValue][0] <= 0)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wszystkie czeki zostały wykorzystane.");
	        return 0;
	    }
	    
     	PlayerCache[playerid][pItemArray][ITEM_CHECKBOOK] = itemid;
    	ShowPlayerDialog(playerid, D_ITEM_WRITE_A_CHECK, DIALOG_STYLE_INPUT, "Wypisz czek", "Wprowadź kwotę jaką chcesz wypisać na czeku.\nKwota jaką wpiszesz, zostanie pobrana z Twojego konta bankowego.", "Wypisz", "Anuluj");
*/
	    return 1;
	}
	
	if(item_type == ITEM_CHECK)
	{
/*
 		if(PlayerCache[playerid][pHours] < 5)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zrealizować czeku mając na koncie poniżej 5h gry.");
	        return 0;
	    }
		new doorid = GetPlayerDoorID(playerid);
		if(doorid == INVALID_DOOR_ID)
		{
      		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby zrealizować czek, musisz znajdować się w banku.");
		    return 0;
		}
		new DoorData[sDoorInfo];
		Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
		
	 	if(DoorData[dOwnerType] != OWNER_GROUP)
	  	{
	   		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby zrealizować czek, musisz znajdować się w banku.");
	   		return 0;
	   	}
	   	new group_id = GetGroupID(DoorData[dOwner]);
	   	if(GroupData[group_id][gType] != G_TYPE_BANK)
	   	{
	   	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby zrealizować czek, musisz znajdować się w banku.");
	   	    return 0;
	   	}
		if(!PlayerCache[playerid][pBankNumber])
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz założonego konta bankowego.");
		    return 0;
		}
		PlayerCache[playerid][pBankCash] += PlayerItemCache[playerid][itemid][iValue][0];
		orm_update(PlayerCache[playerid][pOrm]);

		format(string, sizeof(string), "* %s realizuje czek na $%d.", PlayerName(playerid), PlayerItemCache[playerid][itemid][iValue][0]);
		ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);

		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Czek został pomyślnie zrealizowany.\nNa Twoje konto bankowe przelano $%d.\n\nAktualny stan konta: $%d", PlayerItemCache[playerid][itemid][iValue][0], PlayerCache[playerid][pBankCash]);
        DeletePlayerItem(playerid, itemid);
*/
	    return 1;
	}
	
	if(item_type == ITEM_BAG)
	{
		new query[256];

		mysql_format(connHandle, query, sizeof(query), "SELECT `item_uid`, `item_name` FROM `"SQL_PREF"items` WHERE item_ownertype = '%d' AND item_owner = '%d'", PLACE_BAG, PlayerItemCache[playerid][itemid][iUID]);
		mysql_tquery(connHandle, query, "query_OnListPlayerNearItems", "dd", playerid, PLACE_BAG);

	    PlayerCache[playerid][pItemArray][ITEM_BAG] = itemid;
	    return 1;
	}
	
	if(item_type == ITEM_DRINK)
	{
		if(PlayerItemCache[playerid][itemid][iValue][0] != 20 && PlayerItemCache[playerid][itemid][iValue][0] != 22 && PlayerItemCache[playerid][itemid][iValue][0] != 23)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz użyć tego przedmiotu, prawdopodobnie podane zostały błędne jego wartości.");
			return 0;
		}
		
		SetPlayerSpecialAction(playerid, PlayerItemCache[playerid][itemid][iValue][0]);
        DeletePlayerItem(playerid, itemid);
	    return 1;
	}
	
	if(item_type == ITEM_VEH_ACCESS)
	{
	    pc_cmd_oferuj(playerid, "montaz");
	    return 1;
	}
	
	if(item_type == ITEM_DISC)
	{
	    if(PlayerItemCache[playerid][itemid][iValue][0])
	    {
	        if(GetPlayerState(playerid) == PLAYER_STATE_DRIVER)
	        {
				new vehid = GetPlayerVehicleID(playerid);
				if(!(CarInfo[vehid][cAccess] & VEH_ACCESS_AUDIO))
				{
				    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "W tym pojeździe nie został zamontowany sprzęt audio.");
				    return 0;
				}
				
    			new format_url[128];
    			new rows, Cache:tmp_cache, query[128];
    			
				mysql_format(connHandle, query, sizeof(query), "SELECT `audio_url` FROM `"SQL_PREF"audiourls` WHERE audio_uid = '%d' LIMIT 1", PlayerItemCache[playerid][itemid][iValue][0]);
                tmp_cache = mysql_query(connHandle, query);

                cache_get_row_count(rows);
				if(rows > 0)
				{

				    cache_get_value_index(0, 0, format_url, 128);
				    strmid(CarInfo[vehid][cAudioURL], format_url, 0, strlen(format_url), 64);

				    // Załącz muzę u wszystkich, nie tylko u siebie
				    foreach(new i : Player)
				    {
				        if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
				        {
	           				if(GetPlayerVehicleID(i) == vehid)
	           				{
	           				    if(PlayerCache[i][pItemPlayer] != INVALID_ITEM_ID)
	           				    {
				        			PlayerItemCache[playerid][PlayerCache[i][pItemPlayer]][iUsed] = false;
								}
								
	           				    PlayStreamedAudioForPlayer(i, CarInfo[vehid][cAudioURL]);
							}
						}
					}
				}
				if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);

				format(string, sizeof(string), "* %s umieszcza płytę w radiu.", PlayerName(playerid));
				ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
				
				TD_ShowSmallInfo(playerid, 5, "Plyta ~y~%s ~w~zostala odtworzona pomyslnie.", PlayerItemCache[playerid][itemid][iName]);
	        }
	        else
	        {
	            new list_items[256];
	            PlayerCache[playerid][pItemArray][ITEM_DISC] = itemid;
	            
	            DynamicGui_Init(playerid);
	            
	            foreach(new i : PlayerItem[playerid])
	            {
	                if(PlayerItemCache[playerid][i][iType] == ITEM_PLAYER || PlayerItemCache[playerid][i][iType] == ITEM_BOOMBOX)
	                {
	                    format(list_items, sizeof(list_items), "%s\n%d\t\t%s", list_items, PlayerItemCache[playerid][i][iUID], PlayerItemCache[playerid][i][iName]);
                        DynamicGui_AddRow(playerid, D_DISC_INSERT, i);
					}
	            }
	            
	            if(strlen(list_items))
	            {
	                ShowPlayerDialog(playerid, D_DISC_INSERT, DIALOG_STYLE_LIST, "Dostępne odtwarzacze:", list_items, "Wybierz", "Anuluj");
	            }
	            else
	            {
					TD_ShowSmallInfo(playerid, 3, "Nie posiadasz ~r~zadnych ~w~odtwarzaczy.");
	            }
	        }
	    }
	    else
	    {
	        PlayerCache[playerid][pItemArray][ITEM_DISC] = itemid;
	        ShowPlayerDialog(playerid, D_DISC_RECORD, DIALOG_STYLE_INPUT, "Czysta płyta » Nagrywanie", "To jest czysta płyta, na której możesz nagrać dowolny kawałek.\nWklej w pole tekstowe poniżej link do muzyki, która ma być odtwarzana poprzez urządzenia.\n\nUpewnij się, że link jest poprawny w innym wypadku muzyka może nie być słyszalna.\n\nDługość linku nie może przekroczyć 64 znaków.", "Nagraj", "Anuluj");
	    }
	    return 1;
	}
	
	if(item_type == ITEM_PLAYER)
	{
		if(!PlayerItemCache[playerid][itemid][iValue][0])
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "W tym odtwarzaczu nie ma żadnej płyty.");
		    return 0;
		}
		if(IsPlayerInAnyVehicle(playerid))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz siedzieć w pojeździe.");
		    return 0;
		}
		if(PlayerCache[playerid][pItemPlayer] != INVALID_ITEM_ID)
		{
			if(PlayerCache[playerid][pItemPlayer] != itemid)
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Korzystasz już z jakiegoś odtwarzacza.");
			    return 0;
			}
		}
		if(PlayerItemCache[playerid][itemid][iUsed])
		{
			StopStreamedAudioForPlayer(playerid);
			
			PlayerCache[playerid][pItemPlayer] = INVALID_ITEM_ID;
			PlayerItemCache[playerid][itemid][iUsed] = false;
			
			TD_ShowSmallInfo(playerid, 3, "Odtwarzanie muzyki zostalo ~r~zakonczone~w~.");
		}
		else
		{
			StopStreamedAudioForPlayer(playerid);
			
			PlayerCache[playerid][pItemPlayer] = itemid;
			PlayerItemCache[playerid][itemid][iUsed] = true;

   			new format_url[128],
			   Cache:tmp_cache, query[128];

			mysql_format(connHandle, query, sizeof(query), "SELECT `audio_url` FROM `"SQL_PREF"audiourls` WHERE audio_uid = '%d' LIMIT 1", PlayerItemCache[playerid][itemid][iValue][0]);
            tmp_cache = mysql_query(connHandle, query);

			cache_get_value_index(0, 0, format_url, 128);
			PlayStreamedAudioForPlayer(playerid, format_url);
			
			if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);

			TD_ShowSmallInfo(playerid, 3, "Odtwarzanie muzyki zostalo ~g~rozpoczete~w~.");
		}
	    return 1;
	}
	
	if(item_type == ITEM_CLOTH_ACCESS)
	{
	    if(PlayerItemCache[playerid][itemid][iUsed])
	    {
	        PlayerItemCache[playerid][itemid][iUsed] = false;
	        orm_update(PlayerItemCache[playerid][itemid][iOrm]);
	    
	        RemovePlayerAttachedObject(playerid, SLOT_ACCESS_1);
	        RemovePlayerAttachedObject(playerid, SLOT_ACCESS_2);
	        RemovePlayerAttachedObject(playerid, SLOT_ACCESS_3);
	        
			LoadPlayerAccess(playerid);
	    }
	    else
	    {
	        if(!PlayerItemCache[playerid][itemid][iValue][0] && !PlayerItemCache[playerid][itemid][iValue][1])
	        {
	            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz użyć tego przedmiotu, prawdopodobnie podane zostały błędne jego wartości.");
	            return 0;
	        }
	    
     		PlayerCache[playerid][pItemArray][ITEM_CLOTH_ACCESS] = itemid;
       		ShowPlayerDialog(playerid, D_ACCESS_APPLY, DIALOG_STYLE_MSGBOX, "Akcesorie", "Wybierz poniżej, jak chciałbyś zastosować przedmiot:", "Załóż", "Dopasuj");
		}
	    return 1;
	}
	
	if(item_type == ITEM_PASS)
	{
	    if(PlayerItemCache[playerid][itemid][iUsed])
	    {
			PlayerItemCache[playerid][itemid][iUsed] = false;
			PlayerItemCache[playerid][itemid][iValue][0] = PlayerCache[playerid][pGymTime] / 60;

			orm_update(PlayerItemCache[playerid][itemid][iOrm]);
			
			PlayerCache[playerid][pItemPass]    = INVALID_ITEM_ID;
			PlayerCache[playerid][pGymTime]     = 0;

			new object_id = PlayerCache[playerid][pGymObject];
			if(object_id != INVALID_OBJECT_ID)
			{
				ClearAnimations(playerid, true);
    			PlayerCache[playerid][pStrength] = PlayerCache[playerid][pStrength] + (PlayerCache[playerid][pGymRepeat] / 4);

				PlayerCache[playerid][pGymObject] 	= INVALID_OBJECT_ID;
    			PlayerCache[playerid][pGymRepeat] 	= 0;

				RemovePlayerAttachedObject(playerid, SLOT_TRAIN);
    			TD_ShowSmallInfo(playerid, 3, "Trening zostal ~g~pomyslnie ~w~zakonczony.");
			}
	    }
	    else
	    {
			if(PlayerCache[playerid][pGymTime])
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aktualnie korzystasz już z jakiegoś karnetu.");
			    return 0;
			}
			
			new doorid = GetPlayerDoorID(playerid);
			if(doorid == INVALID_DOOR_ID)
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby skorzystać z karnetu musisz znajdować się w siłowni.");
			    return 0;
			}
			new DoorData[sDoorInfo];
			Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
			
			if(DoorData[dOwnerType] != OWNER_GROUP)
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby skorzystać z karnetu musisz znajdować się w siłowni.");
			    return 0;
			}
			new group_id = GetGroupID(DoorData[dOwner]);
			if(GroupData[group_id][gType] != G_TYPE_GYM || DoorData[dOwner] != PlayerItemCache[playerid][itemid][iValue][1])
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby skorzystać z karnetu musisz znajdować się w siłowni.");
				return 0;
			}
			PlayerItemCache[playerid][itemid][iUsed] = true;

			PlayerCache[playerid][pItemPass] = itemid;
			PlayerCache[playerid][pGymTime] = PlayerItemCache[playerid][itemid][iValue][0] * 60;
			
			TD_ShowSmallInfo(playerid, 3, "Skorzystaj z komendy ~r~/silownia~w~, w poblizu wybranego ~y~obiektu~w~, aby zaczac tening.");
	    }
	    return 1;
	}
	
	if(item_type == ITEM_ROLL)
	{
 		if(!PlayerItemCache[playerid][itemid][iUsed])
	    {
	        if(IsPlayerInAnyVehicle(playerid))
	        {
	            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz użyć tego przedmiotu w pojeździe.");
	            return 0;
	        }
	        if(PlayerCache[playerid][pRoll])
	        {
	            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Masz już obecnie jakieś rolki w użyciu.");
	            return 0;
	        }
	        if(GetPlayerDoorID(playerid) != INVALID_DOOR_ID)
	        {
	            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz jeździć na rolkach wewnątrz budynku.");
	            return 0;
	        }
	        PlayerItemCache[playerid][itemid][iUsed] = true;
	        PlayerCache[playerid][pRoll] = true;
	        
	        TD_ShowSmallInfo(playerid, 3, "Aby rozpoczac jazde na ~b~rolkach~w~, zacznij ~y~sprintowac~w~.");
	    }
	    else
	    {
     		PlayerItemCache[playerid][itemid][iUsed] = false;
	        PlayerCache[playerid][pRoll] = false;

	        ClearAnimations(playerid, true);
	    }
	    orm_update(PlayerItemCache[playerid][itemid][iOrm]);
	    return 1;
	}
	
	if(item_type == ITEM_MEDICINE)
	{
		if(PlayerCache[playerid][pHealth] < 80)
		{
			if(PlayerCache[playerid][pHealth] + PlayerItemCache[playerid][itemid][iValue][0] <= 100)
			{
				new Float:health;

				GetPlayerHealth(playerid, health);
				crp_SetPlayerHealth(playerid, health + PlayerItemCache[playerid][itemid][iValue][0]);
			}
			else
			{
				crp_SetPlayerHealth(playerid, 100);
			}
		}
		else
		{
			TD_ShowSmallInfo(playerid, 5, "Lek nie odregeneruje Ci ~r~paska zdrowia~w~.~n~Udaj sie do ~y~restauracji~w~, by spozyc jedzenie.");
		}
		format(string, sizeof(string), "* %s spożywa \"%s\".", PlayerName(playerid), PlayerItemCache[playerid][itemid][iName]);
		ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);

		DeletePlayerItem(playerid, itemid);
	    return 1;
	}
	
	if(item_type == ITEM_DRUG)
	{
		new drug_type = PlayerItemCache[playerid][itemid][iValue][0];
		if(PlayerCache[playerid][pDrugType] != DRUG_NONE && PlayerCache[playerid][pDrugType] != drug_type)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Jesteś teraz pod wpływem innego narkotyku, użycie następnego grozi śmiercią!");
		    return 0;
		}

		switch(drug_type)
		{
		    case DRUG_MARIHUANA:
		    {
      			new joint_quality = random(4) + 1, joint_itemid = CreatePlayerItem(playerid, "Joint", ITEM_JOINT, 1, joint_quality),
      			    quality_name[32];
      			    
      			switch(joint_quality)
      			{
      			    case 1: quality_name = "Słaba";
      			    case 2: quality_name = "Średnia";
      			    case 3: quality_name = "Dobra";
      			    case 4: quality_name = "Wyśmienita";
      			}
      			
		        ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Wykorzystując przedmiot %s (UID: %d) udało Ci się utworzyć przedmiot %s (UID: %d).\nNowy przedmiot powinien pojawić się w Twoim ekwipunku.\n\nJakość: %s", PlayerItemCache[playerid][itemid][iName], PlayerItemCache[playerid][itemid][iUID], PlayerItemCache[playerid][joint_itemid][iName], PlayerItemCache[playerid][joint_itemid][iUID], quality_name);
		    
		        PlayerItemCache[playerid][itemid][iValue][1] --;
		        if(PlayerItemCache[playerid][itemid][iValue][1] <= 0)
		        {
		            DeletePlayerItem(playerid, itemid);
		        }
		        else
		        {
		            orm_update(PlayerItemCache[playerid][itemid][iOrm]);
		        }
		        
		        ApplyAnimation(playerid, "BUDDY", "buddy_fire", 4.0, 0, 0, 0, 0, 0, true);
		        
	        	format(string, sizeof(string), "* %s wykorzystuje przedmiot %s w celu utworzenia przedmiotu %s.", PlayerName(playerid), PlayerItemCache[playerid][itemid][iName], PlayerItemCache[playerid][joint_itemid][iName]);
				ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
		    }
		    case DRUG_COCAINE:
		    {
		        new object_id = GetClosestObjectType(playerid, OBJECT_STOVE);
				if(object_id == INVALID_OBJECT_ID)
				{
				    new drug_amount = DrugTypeInfo[drug_type][dAmount];
				    
				    PlayerCache[playerid][pDrugType] = DRUG_COCAINE;
				    PlayerCache[playerid][pDrugLevel] += drug_amount;
				    
					if(PlayerCache[playerid][pDrugLevel] < 75)
					{
					    SendClientMessage(playerid, COLOR_DO, "** Czujesz pobudzenie, Twoje serce zaczyna bić coraz mocniej. **");
					    TD_ShowSmallInfo(playerid, 5, "Zazyles ~r~narkotyku~w~, Twoja ~y~sila ~w~zostala czasowo zwiekszona!");
					    
	    				format(string, sizeof(string), "* %s zażywa %s.", PlayerName(playerid), PlayerItemCache[playerid][itemid][iName]);
						ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
					}
					
					PlayerCache[playerid][pDepend] += (0.1 * drug_amount);
					
     				PlayerItemCache[playerid][itemid][iValue][1] --;
			        if(PlayerItemCache[playerid][itemid][iValue][1] <= 0)	DeletePlayerItem(playerid, itemid);
			        else                                                    orm_update(PlayerItemCache[playerid][itemid][iOrm]);
				}
				else
				{
					
				}
		    }
		    case DRUG_HEROIN:
		    {
		        new drug_amount = DrugTypeInfo[drug_type][dAmount];
		        
		    	PlayerCache[playerid][pDrugType] = DRUG_HEROIN;
			    PlayerCache[playerid][pDrugLevel] += drug_amount;
			    
				if(PlayerCache[playerid][pDrugLevel] < 75)
				{
					SendClientMessage(playerid, COLOR_DO, "** Doznajesz lekkich drgawek, straciłeś czucie w dłoniach. **");
    				TD_ShowSmallInfo(playerid, 5, "Zazyles ~r~narkotyku~w~, Twoja ~y~wytrzymalosc ~w~zostala czasowo zwiekszona!");
    				
					format(string, sizeof(string), "* %s zażywa %s.", PlayerName(playerid), PlayerItemCache[playerid][itemid][iName]);
					ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
				}
				
				PlayerCache[playerid][pDepend] += (0.2 * drug_amount);
				
    			PlayerItemCache[playerid][itemid][iValue][1] --;
		        if(PlayerItemCache[playerid][itemid][iValue][1] <= 0)	DeletePlayerItem(playerid, itemid);
		        else                                                    orm_update(PlayerItemCache[playerid][itemid][iOrm]);
		    }
		    case DRUG_AMPHETAMINE:
		    {
		        // DZIALANIE AMFETAMINY (ZWIĘKSZANIE SIŁY + WYTRZYMAŁOŚCI)
		    }
		    case DRUG_CRACK:
		    {
		        new health_amount = DrugTypeInfo[drug_type][dAmount];
   				if(PlayerCache[playerid][pHealth] + health_amount <= 100)
				{
					new Float:health;

					GetPlayerHealth(playerid, health);
					crp_SetPlayerHealth(playerid, health + health_amount);
				}
				else
				{
					crp_SetPlayerHealth(playerid, 100);
				}
				
				format(string, sizeof(string), "* %s zażywa %s.", PlayerName(playerid), PlayerItemCache[playerid][itemid][iName]);
				ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
		    
		        PlayerCache[playerid][pDepend] += (0.1 * health_amount);
		        
		        PlayerItemCache[playerid][itemid][iValue][1] --;
		        if(PlayerItemCache[playerid][itemid][iValue][1] <= 0)	DeletePlayerItem(playerid, itemid);
		        else                                                    orm_update(PlayerItemCache[playerid][itemid][iOrm]);
		    }
		    case DRUG_CONDITIONER:
		    {
		        new drug_amount = DrugTypeInfo[drug_type][dAmount];
		        if(PlayerCache[playerid][pDrugType] == DRUG_CONDITIONER)
		        {
		            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Zażyłeś już jednej odżywki, aby użyć następnej poprzednia musi przestać działać.");
		            return 0;
		        }
		    
		        PlayerCache[playerid][pDrugType] = DRUG_CONDITIONER;
		        PlayerCache[playerid][pDrugValue1] += drug_amount;
		        
          		ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Zażyłeś odżywki wspomagającej wzrost siły.\nPodczas treningu Twoja siła powinna wzrastać trochę szybciej niż zwykle.\n\nJest to czasowe działanie, dlatego zaleca się brać odżywki przed samym treningiem.");

				format(string, sizeof(string), "* %s zażywa %s.", PlayerName(playerid), PlayerItemCache[playerid][itemid][iName]);
				ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
			
   				PlayerItemCache[playerid][itemid][iValue][1] --;
		        if(PlayerItemCache[playerid][itemid][iValue][1] <= 0)	DeletePlayerItem(playerid, itemid);
		        else                                                    orm_update(PlayerItemCache[playerid][itemid][iOrm]);
		    }
		}
		
		if(PlayerCache[playerid][pDrugLevel] >= 75)
		{
			PlayerCache[playerid][pBW] = 10 * 60;

			PlayerCache[playerid][pInteriorID] = GetPlayerInterior(playerid);
			PlayerCache[playerid][pVirtualWorld] = GetPlayerVirtualWorld(playerid);

			GetPlayerPos(playerid, PlayerCache[playerid][pPosX], PlayerCache[playerid][pPosY], PlayerCache[playerid][pPosZ]);

			SetPlayerCameraPos(playerid, PlayerCache[playerid][pPosX] + 3, PlayerCache[playerid][pPosY] + 4, PlayerCache[playerid][pPosZ] + 7);
			SetPlayerCameraLookAt(playerid, PlayerCache[playerid][pPosX], PlayerCache[playerid][pPosY], PlayerCache[playerid][pPosZ], CAMERA_CUT);

			OnPlayerFreeze(playerid, true, 0);
			orm_update(PlayerCache[playerid][pOrm]);

			TD_ShowSmallInfo(playerid, 5, "Przesadziles z ~r~uzywkami~w~, straciles przytomnosc.");

			format(string, sizeof(string), "* %s zażywa %s a następnie upada na ziemie i traci przytomność.", PlayerName(playerid), PlayerItemCache[playerid][itemid][iName]);
			ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
		}
	    return 1;
	}
	
	if(item_type == ITEM_JOINT)
	{
		if(PlayerCache[playerid][pDrugType] != DRUG_NONE && PlayerCache[playerid][pDrugType] != DRUG_MARIHUANA)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Jesteś teraz pod wpływem innego narkotyku, użycie następnego grozi śmiercią!");
		    return 0;
		}
 		PlayerCache[playerid][pDrugType] = DRUG_MARIHUANA;
	    PlayerCache[playerid][pDrugValue1] = 10 * PlayerItemCache[playerid][itemid][iValue][1];
	
	    DeletePlayerItem(playerid, itemid);
	    SetPlayerSpecialAction(playerid, SPECIAL_ACTION_SMOKE_CIGGY);
	    
	    TD_ShowSmallInfo(playerid, 7, "Odpaliles jointa, ~r~wciskaj ~w~rytmicznie klawisz ~y~~k~~PED_FIREWEAPON~~w~, by zazywac narkotyku.~n~~n~Po jakims czasie powinienes ~p~odczuwac ~w~efekty jego zazywania.");
	    return 1;
	}
	
	if(item_type == ITEM_GLOVES)
	{
		if(PlayerCache[playerid][pItemGloves] != INVALID_ITEM_ID && PlayerCache[playerid][pItemGloves] != itemid)
	 	{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Obecnie masz już założone jakieś inne rękawiczki.");
   			return 0;
   		}
	    if(!PlayerItemCache[playerid][itemid][iUsed])
	    {
	        PlayerItemCache[playerid][itemid][iUsed] = true;
	        PlayerCache[playerid][pItemGloves] = itemid;

  			format(string, sizeof(string), "* %s zakłada %s na dłonie.", PlayerName(playerid), PlayerItemCache[playerid][itemid][iName]);
			ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
		}
	    else
	    {
	        PlayerItemCache[playerid][itemid][iUsed] = false;
			PlayerCache[playerid][pItemGloves] = itemid;
			
			PlayerItemCache[playerid][itemid][iValue][0] --;

   			format(string, sizeof(string), "* %s zdejmuje %s z dłoni.", PlayerName(playerid), PlayerItemCache[playerid][itemid][iName]);
			ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
	    }
	    if(PlayerItemCache[playerid][itemid][iValue][0] <= 0)   DeletePlayerItem(playerid, itemid);
	    return 1;
	}
	
	if(item_type == ITEM_CORPSE)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "%s\n\nZabezpieczone zwłoki nie mogą już zostać użyte.\nMożesz je przetransportować w pojeździe, schować w kostnicy lub sporządzić pogrzeb.", PlayerItemCache[playerid][itemid][iName]);
	    return 1;
	}
	
	if(item_type == ITEM_MOLOTOV)
	{
		new doorid = GetPlayerDoorID(playerid);
		if(doorid == INVALID_DOOR_ID)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby móc użyć tego przedmiotu, musisz znajdować się w budynku.");
		    return 0;
		}
		new DoorData[sDoorInfo];
		Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
		
		if(DoorData[dFireData][FIRE_TIME])
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten budynek już płonie!");
		    return 0;
		}
		/*
	   	new firefighter_count, group_id;
	    foreach(new i : Player)
	    {
     		if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
       		{
         		if(PlayerCache[i][pDuty][DUTY_GROUP] != INVALID_GROUP_ID)
           		{
           		    group_id = PlayerCache[i][pDuty][DUTY_GROUP];
             		if(GroupData[group_id][gType] == G_TYPE_FIREDEPT)
               		{
                 		firefighter_count ++;
                   		if(firefighter_count >= 3)
	                    {
							break;
        				}
            		}
          		}
       		}
	    }
	    if(firefighter_count < 3)
	    {
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie mozesz użyć tego przedmiotu teraz.");
   			return 1;
 		}*/
		new Float:PosX, Float:PosY, Float:PosZ,
			virtual_world, interior_id;
			
		Streamer_GetItemPos(STREAMER_TYPE_PICKUP, doorid, PosX, PosY, PosZ);

		virtual_world = Streamer_GetIntData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_WORLD_ID);
		interior_id = Streamer_GetIntData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_INTERIOR_ID);

		DoorData[dFireData][FIRE_OBJECT] = CreateDynamicObject(18690, PosX, PosY, PosZ - 2.0, 0.0, 0.0, 0.0, virtual_world, interior_id, -1, MAX_DRAW_DISTANCE);
		DoorData[dFireData][FIRE_LABEL] = _:CreateDynamic3DTextLabel("Ten budynek stanął w płomieniach!\nSzacowane zniszczenia: 0%", 0x33AA33FF, PosX, PosY, PosZ + 0.3, 15.0);

		foreach(new i : Player)
		{
  			if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
   			{
     			if(GetPlayerDoorID(i) == doorid)
        		{
          			SendClientMessage(i, COLOR_DO, "** W tym budynku z niewiadomych przyczyn wybucha pożar. Wszyscy powinni zacząć się ewakuować. **");
		        }
		    }
		}
		CreateExplosion(PosX, PosY, PosZ, 1, 10.0);
		GetPlayerPos(playerid, PosX, PosY, PosZ);
		
		GetXYInFrontOfPlayer(playerid, PosX, PosY, 8.0);
		CreateExplosion(PosX, PosY, PosZ, 1, 10.0);

		DoorData[dFireData][FIRE_TIME] = 1;
		Streamer_SetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
		
		DeletePlayerItem(playerid, itemid);
	    return 1;
	}
	
	if(item_type == ITEM_BOOMBOX)
	{
	    if(!PlayerItemCache[playerid][itemid][iValue][0])
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "W tym odtwarzaczu nie ma żadnej płyty.");
	        return 0;
	    }
   		if(IsPlayerInAnyVehicle(playerid))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz siedzieć w pojeździe.");
		    return 0;
		}
		if(PlayerCache[playerid][pItemBoombox] != INVALID_ITEM_ID)
		{
			if(PlayerCache[playerid][pItemBoombox] != itemid)
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Korzystasz już z jakiegoś odtwarzacza.");
			    return 0;
			}
		}
	    new areaid = GetPlayerAreaID(playerid);
	    if(areaid == INVALID_AREA_ID)
	    {
     		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby móc użyć tego przedmiotu, musisz znajdować się w strefie.");
       		return 0;
	    }
	    new AreaData[sAreaData];
	    Streamer_GetArrayData(STREAMER_TYPE_AREA, areaid, E_STREAMER_EXTRA_ID, AreaData);
	    
	    if(AreaData[aOwnerType] == OWNER_PLAYER)
	    {
     		if(AreaData[aOwner] != PlayerCache[playerid][pUID])
       		{
         		ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie jesteś właścicielem tej strefy.");
           		return 0;
	        }
	    }
	    if(AreaData[aOwnerType] == OWNER_GROUP)
	    {
     		if(!IsPlayerInGroup(playerid, AreaData[aOwner]))
       		{
         		ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie jesteś właścicielem tej strefy.");
           		return 0;
	        }
	    }
   		if(PlayerItemCache[playerid][itemid][iUsed])
		{
  			areaid = GetPlayerAreaID(playerid);
       		foreach(new i : Player)
			{
				if(i != playerid)
    			{
					if(GetPlayerAreaID(i) == areaid)
					{
                        StopStreamedAudioForPlayer(i);
					}
				}
			}
			strmid(AreaData[aAudioURL], "", 0, 0, 128);
			StopStreamedAudioForPlayer(playerid);

			PlayerCache[playerid][pItemBoombox] = INVALID_ITEM_ID;
			PlayerItemCache[playerid][itemid][iUsed] = false;

			RemovePlayerAttachedObject(playerid, SLOT_BOOMBOX);
			TD_ShowSmallInfo(playerid, 3, "Odtwarzanie muzyki zostalo ~r~zakonczone~w~.");
		}
		else
		{
  			if(strlen(AreaData[aAudioURL]) > 1)
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ktoś obecnie korzysta z boomboxa w tej strefie.");
		        return 0;
		    }
			StopStreamedAudioForPlayer(playerid);

			PlayerCache[playerid][pItemBoombox] = itemid;
			PlayerItemCache[playerid][itemid][iUsed] = true;

   			new format_url[128];
			new rows, Cache:tmp_cache, query[256];

			mysql_format(connHandle, query, sizeof(query), "SELECT `audio_url` FROM `"SQL_PREF"audiourls` WHERE audio_uid = '%d' LIMIT 1", PlayerItemCache[playerid][itemid][iValue][0]);
            tmp_cache = mysql_query(connHandle, query);

    		cache_get_row_count(rows);
			if(rows > 0)
			{
   				cache_get_value_index(0, 0, format_url, 128);
   				
   				foreach(new i : Player)
   				{
   				    if(i != playerid)
   				    {
   				        if(GetPlayerAreaID(i) == areaid)
   				        {
                            PlayStreamedAudio3DForPlayer(i, format_url, PlayerCache[playerid][pPosX], PlayerCache[playerid][pPosY], PlayerCache[playerid][pPosZ]);
   				        }
   				    }
   				}
   				
       			PlayStreamedAudioForPlayer(playerid, format_url);
   				strmid(AreaData[aAudioURL], format_url, 0, strlen(format_url), 128);
			}
			if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
			
			TD_ShowSmallInfo(playerid, 3, "Odtwarzanie muzyki zostalo ~g~rozpoczete~w~.");
			SetPlayerAttachedObject(playerid, SLOT_BOOMBOX, 2226, 5, 0.369999, 0.000000, 0.024000, 0.000000, -100.100021, 36.100002, 0.849999, 0.721000, 0.902000);
		}
	    return 1;
	}
	
	if(item_type == ITEM_FLASHLIGHT)
	{
	    if(PlayerItemCache[playerid][itemid][iUsed])
	    {
	        PlayerCache[playerid][pFlashLight] = false;
	        RemovePlayerAttachedObject(playerid, SLOT_EXTRA);
	        
	        RemovePlayerAttachedObject(playerid, 0);
	        PlayerItemCache[playerid][itemid][iUsed] = false;
	    }
	    else
	    {
	        PlayerCache[playerid][pFlashLight] = true;
	        SetPlayerAttachedObject(playerid, SLOT_EXTRA, 18641, 6, 0.092000, 0.020000, -0.062999, 0.099999, -10.700075, 0.299999);

	        SetPlayerAttachedObject(playerid, 0, 18656, 6, 0.107000, -0.009000, -0.117999, -90.900054, -3.299999, -6.399999, 0.034000, 0.024999, 0.035000);
            PlayerItemCache[playerid][itemid][iUsed] = true;
		}
	    return 1;
	}
	
	if(item_type == ITEM_NEWSPAPER)
	{
		new query[256], Cache:tmp_cache, title[32], text[4096];
		
		format(query, sizeof(query), "SELECT `newspaper_title`, `newspaper_text` FROM `"SQL_PREF"newspapers` WHERE newspaper_uid = '%d' LIMIT 1", PlayerItemCache[playerid][itemid][iValue][0]);
		tmp_cache = mysql_query(connHandle, query);
		
		cache_get_value_index(0, 0, title, 32);
		cache_get_value_index(0, 1, text, 4096);
		
		ShowPlayerDialog(playerid, D_NONE, DIALOG_STYLE_MSGBOX, title, NewsPaperWrap(text), "Zamknij", "");
		if(cache_is_valid(tmp_cache))	cache_delete(tmp_cache);
	    return 1;
	}
	
	if(item_type == ITEM_WOOD)
	{
	    new Float:PosX, Float:PosY, Float:PosZ;
		GetPlayerPos(playerid, PosX, PosY, PosZ);
	
		new ActorData[sActorData], NearActors[MAX_VIS_ACTORS], actorid,
			actor_count = Streamer_GetNearbyItems(PosX, PosY, PosZ, STREAMER_TYPE_ACTOR, NearActors, MAX_VIS_ACTORS, 1000.0, 0);

		for (new actor = 0; actor < actor_count; actor++)
		{
			actorid = NearActors[actor];
			Streamer_GetArrayData(STREAMER_TYPE_ACTOR, actorid, E_STREAMER_EXTRA_ID, ActorData);
			
			if(ActorData[aType] == ACTOR_TRADER)
			{
			    Streamer_GetItemPos(STREAMER_TYPE_ACTOR, actorid, PosX, PosY, PosZ);
			    SetPlayerCheckpoint(playerid, PosX, PosY, PosZ, 2.0);
			
				TD_ShowHint(playerid, HINT_NONE, 10, "Ten przedmiot mozesz ~g~sprzedac ~w~u kupcow. Na mapie ~r~zaznaczono ~w~najblizej znajdujacego sie kupca.~n~~n~Udaj sie do niego i dokonaj ~y~interakcji ~w~za pomoca klawisza ~p~Y");
			    return 1;
			}
		}
		TD_ShowHint(playerid, HINT_NONE, 10, "Ten przedmiot mozesz ~g~sprzedac ~w~u kupcow w miescie.~n~~n~Udaj sie do jednego i dokonaj ~y~interakcji ~w~za pomoca klawisza ~p~Y~w~.");
	    return 1;
	}
	return 1;
}

public OnPlayerDropItem(playerid, itemid)
{
	new string[256];
	if(PlayerItemCache[playerid][itemid][iUsed])
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz odłożyć tego przedmiotu.");
	    return 1;
	}

	if(GetPlayerState(playerid) == PLAYER_STATE_ONFOOT)
	{
	    new Float:PosX, Float:PosY, Float:PosZ, Float:PosA, query[512],
	        virtual_world = GetPlayerVirtualWorld(playerid), interior_id = GetPlayerInterior(playerid);

		GetPlayerPos(playerid, PosX, PosY, PosZ);
		GetPlayerFacingAngle(playerid, PosA);

		format(string, sizeof(string), "* %s odkłada przedmiot na ziemię.", PlayerName(playerid));
		ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);

		ApplyAnimation(playerid, "BOMBER", "BOM_Plant", 4.1, 0, 0, 0, 0, 0, 1);

		mysql_format(connHandle, query, sizeof(query), "UPDATE `"SQL_PREF"items` SET item_ownertype = '%d', item_owner = '0', item_posx = '%f', item_posy = '%f', item_posz = '%f', item_interior = '%d', item_world = '%d' WHERE item_uid = '%d' LIMIT 1", PLACE_NONE, PosX, PosY, PosZ, interior_id, virtual_world, PlayerItemCache[playerid][itemid][iUID]);
		mysql_query(connHandle, query);

		new object_id, item_type = PlayerItemCache[playerid][itemid][iType];
		if(item_type == ITEM_WEAPON || item_type == ITEM_PAINT || item_type == ITEM_INHIBITOR)
		{
		    object_id = CreateDynamicObject(WeaponInfoData[PlayerItemCache[playerid][itemid][iValue][0]][wModel], PosX, PosY, PosZ - 1.0, 80.0, 0.0, -PosA, virtual_world, -1, -1, MAX_DRAW_DISTANCE);
		}
		else if(item_type == ITEM_TUNING)
		{
  			object_id = CreateDynamicObject(PlayerItemCache[playerid][itemid][iValue][0], PosX + random(2), PosY + random(2), PosZ - 0.5, 0.0, 0.0, -PosA, virtual_world, -1, -1, MAX_DRAW_DISTANCE);
		}
		else
		{
		    object_id = CreateDynamicObject(ItemTypeInfo[item_type][iTypeObjModel], PosX, PosY, PosZ - 1.0, ItemTypeInfo[item_type][iTypeObjRotX], ItemTypeInfo[item_type][iTypeObjRotY], -PosA, virtual_world, -1, -1, MAX_DRAW_DISTANCE);
		}
		new objData[sObjectData];
		objData[objUID] = (PlayerItemCache[playerid][itemid][iUID] * -1);
		
		Streamer_SetArrayData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_EXTRA_ID, objData);
		Streamer_UpdateEx(playerid, PosX, PosY, PosZ, virtual_world, interior_id, STREAMER_TYPE_OBJECT);

		// printf("[%d][item] %s (UID: %d, GID: %d) odłożył przedmiot %s (UID: %d) na ziemię (PosX: %.3f, PosY: %.3f, PosZ: %.3f, InteriorID: %d, WorldID: %d).", PlayerRealName(playerid), PlayerCache[playerid][pUID], PlayerCache[playerid][pGID], ItemCache[itemid][iName], ItemCache[itemid][iUID], PosX, PosY, PosZ, interior_id, virtual_world);

		UnloadPlayerItem(playerid, itemid);
		Iter_Remove(PlayerItem[playerid], itemid);
		return 1;
	}

	if(IsPlayerInAnyVehicle(playerid))
	{
	    new	vehid = GetPlayerVehicleID(playerid), veh_uid = CarInfo[vehid][cUID], query[256];

		mysql_format(connHandle, query, sizeof(query), "UPDATE `"SQL_PREF"items` SET item_ownertype = '%d', item_owner = '%d' WHERE item_uid = '%d' LIMIT 1", PLACE_VEHICLE, veh_uid, PlayerItemCache[playerid][itemid][iUID]);
		mysql_query(connHandle, query);

   		format(string, sizeof(string), "* %s odkłada przedmiot w pojeździe.", PlayerName(playerid));
		ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);

		ApplyAnimation(playerid, "BOMBER", "BOM_Plant", 4.1, 0, 0, 0, 0, 0, 1);

		//printf("[item] %s (UID: %d, GID: %d) odłożył przedmiot %s (UID: %d) w pojeździe (UID: %d).", PlayerRealName(playerid), PlayerCache[playerid][pUID], PlayerCache[playerid][pGID], ItemCache[itemid][iName], ItemCache[itemid][iUID], CarInfo[vehid][cUID]);

		UnloadPlayerItem(playerid, itemid);
		Iter_Remove(PlayerItem[playerid], itemid);
	    return 1;
	}
	return 1;
}

public OnPlayerRaiseItems(playerid)
{
	new rows, main_query[2048], query[128], string_lenght, item_uid, items_count, string[128], ObjectData[MAX_VIS_OBJECTS],
		object_id, count_objects, item_place = GetExternalItemCachePlace(playerid), item_owner, weight_sum;

	if(item_place != PLACE_BAG)
	{
	 	if(!(PlayerCache[playerid][pAdmin] & A_PERM_ITEMS) && GetPlayerCapacity(playerid) <= 0)
		{
	 		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Twoja postać nie jest w stanie unieść więcej przedmiotów.");
	 		ClearExternalItemCache(playerid);
	   		return 1;
		}
	}
		
	new Float:PosX, Float:PosY, Float:PosZ,
	    virtual_world = GetPlayerVirtualWorld(playerid);
	    
	GetPlayerPos(playerid, PosX, PosY, PosZ);
		
	switch(item_place)
	{
	    case PLACE_NONE:
		{
			item_owner = 0;
  			format(string, sizeof(string), "* %s podnosi coś z ziemi.", PlayerName(playerid));
		}
	    case PLACE_VEHICLE:
		{
		    if(IsPlayerInAnyVehicle(playerid))
		    {
				item_owner = CarInfo[GetPlayerVehicleID(playerid)][cUID];
				format(string, sizeof(string), "* %s podnosi coś w pojeździe.", PlayerName(playerid));
			}
			else
			{
			    return 1;
			}
		}
		case PLACE_CLOSET:
		{
		    new doorid = PlayerCache[playerid][pMainTable], DoorData[sDoorInfo];
		    Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
		    
			format(string, sizeof(string), "* %s wyjmuje coś ze schowka.", PlayerName(playerid));
		    item_owner = DoorData[dUID];
		}
		case PLACE_BAG:
		{
		    new itemid = PlayerCache[playerid][pItemArray][ITEM_BAG];
			item_owner = PlayerItemCache[playerid][itemid][iUID];
			
			foreach(new i : PlayerItem[playerid])
			{
			    if(i != itemid)
			    {
					weight_sum += GetPlayerItemWeight(playerid, i);
				}
			}
			
			format(string, sizeof(string), "* %s wyjmuje coś z przedmiotu %s.", PlayerName(playerid), PlayerItemCache[playerid][itemid][iName]);
		}
		case PLACE_ACTOR:
		{
		    new actorid = PlayerCache[playerid][pMainTable], ActorData[sActorData],
				Float:actor_pos[3], group_id;
				
		    Streamer_GetArrayData(STREAMER_TYPE_ACTOR, actorid, E_STREAMER_EXTRA_ID, ActorData);
		    Streamer_GetItemPos(STREAMER_TYPE_ACTOR, actorid, actor_pos[0], actor_pos[1], actor_pos[2]);
		    
		    item_owner = ActorData[aUID];
		    
		    // Wyślij informacje do PD
			foreach(new i : Player)
			{
				if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
    			{
					if(PlayerCache[i][pDuty][DUTY_GROUP] != INVALID_GROUP_ID)
					{
						group_id = PlayerCache[i][pDuty][DUTY_GROUP];
 						if(GroupData[group_id][gType] == G_TYPE_POLICE)
      					{
							SendClientMessage(i, COLOR_GREEN, "Centrala: Do wszystkich jednostek, otrzymaliśmy zgłoszenie:");
	       					SendClientFormatMessage(i, COLOR_GREEN, "Zgłaszający: anonim, treść: Ktoś napadł na przechodnia w tych okolicach!");

							TD_ShowSmallInfo(i, 5, "Na mapie zaznaczono ~r~pozycje~w~, w ktorej doszlo do napadu na aktora.");

							SetPlayerCheckpoint(i, actor_pos[0], actor_pos[1], actor_pos[2], 2.0);
							PlayerCache[i][pCheckpoint] = CHECKPOINT_ACTOR;
						}
					}
				}
			}
			new anim_id = GetAnimByCommand(".chowaj");
			if(anim_id != INVALID_ANIM_ID)
			{
				ActorData[aAnim] = AnimCache[anim_id][aUID];

				ClearDynamicActorAnimations(actorid);
				ApplyDynamicActorAnimation(actorid, AnimCache[anim_id][aLib], AnimCache[anim_id][aName], AnimCache[anim_id][aSpeed], AnimCache[anim_id][aOpt1], AnimCache[anim_id][aOpt2], AnimCache[anim_id][aOpt3], AnimCache[anim_id][aOpt4], AnimCache[anim_id][aOpt5]);
			}
			Streamer_SetArrayData(STREAMER_TYPE_ACTOR, actorid, E_STREAMER_EXTRA_ID, ActorData);
			format(string, sizeof(string), "* %s zabiera przedmioty %s.", PlayerName(playerid), ActorData[aName]);
		}
	}

	format(main_query, sizeof(main_query), "UPDATE `"SQL_PREF"items` SET item_ownertype = '%d', item_owner = '%d' WHERE item_ownertype = '%d' AND item_owner ='%d' AND (", PLACE_PLAYER, PlayerCache[playerid][pUID], item_place, item_owner);

    string_lenght = strlen(main_query);
	cache_set_active(external_items_cache[playerid][item_place]);

	cache_get_row_count(rows);
	for(new row = 0; row != rows; row++)
	{
	    cache_get_value_index_int(row, 0, item_uid);

		// Czy zaznaczony
		if(!Iter_Contains(CheckedPlayerItem[playerid], row))
		{
		    continue;
		}

		// Generuj zaytanie
		format(query, sizeof(query), "item_uid = %d", item_uid);
		if(strlen(main_query) > string_lenght)
		{
			if(strlen(main_query) + strlen(query) < sizeof(main_query))
			{
				strcat(main_query, " OR ", sizeof(main_query));
			}
			else
			{
				strcat(main_query, ");", sizeof(main_query));
				mysql_query(connHandle, main_query);
				
				print(main_query);

				strdel(main_query, string_lenght, strlen(main_query));
			}
		}
		strcat(main_query, query, sizeof(main_query));
		print(main_query);

		// Usuń obiekt przedmiotu
		if(item_place == PLACE_NONE)
		{
			count_objects = Streamer_GetNearbyItems(PosX, PosY, PosZ, STREAMER_TYPE_OBJECT, ObjectData, MAX_VIS_OBJECTS, 3.0, virtual_world);
			for (new object = 0; object < count_objects; object++)
			{
				object_id = ObjectData[object];
				if(GetObjectUID(object_id) == (item_uid * -1))
				{
				    DestroyDynamicObject(object_id);
				    break;
				}
			}
		}
		items_count ++;
	}
	
	cache_unset_active();
	if(cache_is_valid(external_items_cache[playerid][item_place]))	cache_delete(external_items_cache[playerid][item_place]);

	if(items_count > 0)
	{
	    strcat(main_query, ")", sizeof(main_query));
	    mysql_query(connHandle, main_query);

	    UnloadPlayerItems(playerid);
	    LoadPlayerItems(playerid);

	    // Generuj wagę torby
	    if(item_place == PLACE_BAG)
	    {
	        new itemid = INVALID_ITEM_ID;
			foreach(new i : PlayerItem[playerid])
			{
			    if(PlayerItemCache[playerid][i][iUID] == item_owner)
			    {
			        itemid = i;
					continue;
				}
				weight_sum -= GetPlayerItemWeight(playerid, i);
			}

			PlayerItemCache[playerid][itemid][iValue][0] = (PlayerItemCache[playerid][itemid][iValue][0] + weight_sum);
			orm_update(PlayerItemCache[playerid][itemid][iOrm]);
	    }

		ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
		//TD_ShowHint(playerid, HINT_NEW_ITEM, 15, "W Twoim ~y~ekwipunku ~w~pojawil sie nowy przedmiot. Skorzystaj z komendy ~p~/p~w~, by zobaczyc liste przedmiotow, ktore posiadasz przy sobie.~n~~n~P"); // TODO
	}
	return 1;
}

public LoadPlayerItems(playerid)
{
	new query[512], Cache:tmp_cache;
	
	mysql_format(connHandle, query, sizeof(query), "SELECT `item_uid`, `item_name`, `item_value1`, `item_value2`, `item_type`, `item_favorite`, `item_ownertype`, `item_owner`, `item_group`, `item_used` FROM `"SQL_PREF"items` WHERE `item_ownertype` = '%d' AND `item_owner` = '%d' LIMIT %d", PLACE_PLAYER, PlayerCache[playerid][pUID], MAX_ITEM_CACHE);
	tmp_cache = mysql_query(connHandle, query);

	new rows, itemid, ORM:orm_id;
	cache_get_row_count(rows);
	
	if(rows > 0)
	{
		for(new row = 0; row != rows; row++)
		{
			itemid = Iter_Free(PlayerItem[playerid]);
			orm_id = PlayerItemCache[playerid][itemid][iOrm] = orm_create(""SQL_PREF"items", connHandle);

			orm_addvar_int(orm_id, PlayerItemCache[playerid][itemid][iUID], "item_uid");
			orm_addvar_string(orm_id, PlayerItemCache[playerid][itemid][iName], 32, "item_name");

			orm_addvar_int(orm_id, PlayerItemCache[playerid][itemid][iValue][0], "item_value1");
			orm_addvar_int(orm_id, PlayerItemCache[playerid][itemid][iValue][1], "item_value2");

			orm_addvar_int(orm_id, PlayerItemCache[playerid][itemid][iPlace], "item_ownertype");
			orm_addvar_int(orm_id, PlayerItemCache[playerid][itemid][iOwner], "item_owner");

			orm_addvar_int(orm_id, PlayerItemCache[playerid][itemid][iType], "item_type");
			orm_addvar_int(orm_id, PlayerItemCache[playerid][itemid][iFavorite], "item_favorite");
			
			orm_addvar_int(orm_id, PlayerItemCache[playerid][itemid][iGroup], "item_group");
			orm_addvar_int(orm_id, PlayerItemCache[playerid][itemid][iUsed], "item_used");
			
			orm_setkey(orm_id, "item_uid");
			orm_apply_cache(orm_id, row);
			
			// Przeładowanie przedmiotwó - przypisz ineksy używanych
			switch(PlayerItemCache[playerid][itemid][iType])
			{
			    case ITEM_PHONE:
			    {
			        if(PlayerItemCache[playerid][itemid][iUsed])	PlayerCache[playerid][pPhoneNumber] = PlayerItemCache[playerid][itemid][iValue][0];
			    }
				case ITEM_WEAPON, ITEM_INHIBITOR, ITEM_PAINT:
				{
                    if(PlayerItemCache[playerid][itemid][iUsed])	PlayerCache[playerid][pItemWeapon] = itemid;
				}
				case ITEM_MASK:
				{
				    if(PlayerItemCache[playerid][itemid][iUsed])	PlayerCache[playerid][pItemMask] = itemid;
				}
				case ITEM_GLOVES:
				{
				    if(PlayerItemCache[playerid][itemid][iUsed])	PlayerCache[playerid][pItemGloves] = itemid;
				}
				case ITEM_PASS:
				{
				    if(PlayerItemCache[playerid][itemid][iUsed])	PlayerCache[playerid][pItemPass] = itemid;
				}
				case ITEM_PLAYER:
				{
				    if(PlayerItemCache[playerid][itemid][iUsed])	PlayerCache[playerid][pItemPlayer] = itemid;
				}
				case ITEM_BOOMBOX:
				{
				    if(PlayerItemCache[playerid][itemid][iUsed])	PlayerCache[playerid][pItemBoombox] = itemid;
				}
			}
			Iter_Add(PlayerItem[playerid], itemid);
		}
	}
	if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
	return 1;
}


public UnloadPlayerItems(playerid)
{
	if(PlayerCache[playerid][pItemWeapon] != INVALID_ITEM_ID)	PlayerCache[playerid][pCheckWeapon] = (gettime() + 10);
	
	foreach(new itemid : PlayerItem[playerid])
	{
	    orm_destroy(PlayerItemCache[playerid][itemid][iOrm]);
	    for(new sPlayerItem:e; e < sPlayerItem; ++e)	PlayerItemCache[playerid][itemid][e] = 0;
	}
	Iter_Clear(PlayerItem[playerid]);
	return 1;
}

public LoadPlayerItem(playerid, item_uid)
{
	new query[512], Cache:tmp_cache, rows, ORM:orm_id, itemid = INVALID_ITEM_ID;

	mysql_format(connHandle, query, sizeof(query), "SELECT `item_uid`, `item_name`, `item_value1`, `item_value2`, `item_type`, `item_favorite`, `item_ownertype`, `item_owner`, `item_group`, `item_used` FROM `"SQL_PREF"items` WHERE `item_uid` = '%d' LIMIT 1", item_uid);
	tmp_cache = mysql_query(connHandle, query);
	
	cache_get_row_count(rows);
	if(rows > 0)
	{
	 	itemid = Iter_Free(PlayerItem[playerid]),
	 	orm_id = PlayerItemCache[playerid][itemid][iOrm] = orm_create(""SQL_PREF"items", connHandle);

		orm_addvar_int(orm_id, PlayerItemCache[playerid][itemid][iUID], "item_uid");
		orm_addvar_string(orm_id, PlayerItemCache[playerid][itemid][iName], 32, "item_name");

		orm_addvar_int(orm_id, PlayerItemCache[playerid][itemid][iValue][0], "item_value1");
		orm_addvar_int(orm_id, PlayerItemCache[playerid][itemid][iValue][1], "item_value2");

		orm_addvar_int(orm_id, PlayerItemCache[playerid][itemid][iPlace], "item_ownertype");
		orm_addvar_int(orm_id, PlayerItemCache[playerid][itemid][iOwner], "item_owner");

		orm_addvar_int(orm_id, PlayerItemCache[playerid][itemid][iType], "item_type");
		orm_addvar_int(orm_id, PlayerItemCache[playerid][itemid][iFavorite], "item_favorite");

		orm_addvar_int(orm_id, PlayerItemCache[playerid][itemid][iGroup], "item_group");
		orm_addvar_int(orm_id, PlayerItemCache[playerid][itemid][iUsed], "item_used");

		orm_setkey(orm_id, "item_uid");
		orm_apply_cache(orm_id, 0);

		Iter_Add(PlayerItem[playerid], itemid);
	}
	if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
	return itemid;
}

public UnloadPlayerItem(playerid, itemid)
{
	orm_destroy(PlayerItemCache[playerid][itemid][iOrm]);
	for(new sPlayerItem:e; e < sPlayerItem; ++e)	PlayerItemCache[playerid][itemid][e] = 0;

	Iter_Remove(PlayerItem[playerid], itemid);
	return 1;
}

public query_OnListPlayerNearItems(playerid, item_place)
{
	new list_items[1024], item_uid, item_name[32], rows, action_string[12];
	
	switch(item_place)
	{
 		case PLACE_NONE, PLACE_VEHICLE:
 		{
		 	action_string = "Podnieś";
		}
   		case PLACE_CLOSET, PLACE_BAG:   action_string = "Wyjmij";
	    case PLACE_ACTOR:               action_string = "Ukradnij";
	}
	format(list_items, sizeof(list_items), "Identyfikator\t*\tNazwa przedmiotu\n» %s\t0\tprzedmioty/ów\n» Zaznacz wszystkie\n---\n", action_string);

	ClearExternalItemCache(playerid);
	Iter_Clear(CheckedPlayerItem[playerid]);
	
	DynamicGui_Init(playerid);

	DynamicGui_AddRow(playerid, D_ITEM_RAISE, 0);
	DynamicGui_AddRow(playerid, D_ITEM_RAISE, 0);
	DynamicGui_AddRow(playerid, D_ITEM_RAISE, 0);

    cache_get_row_count(rows);
	for(new row = 0; row != rows; row++)
	{
		cache_get_value_index_int(row, 0, item_uid);
		cache_get_value_index(row, 1, item_name, 32);

		if(Iter_Contains(CheckedPlayerItem[playerid], row))
		{
			format(list_items, sizeof(list_items), "%s\n%d\t[X]\t%s", list_items, item_uid, item_name);
		}
		else
		{
			format(list_items, sizeof(list_items), "%s\n%d\t[ ]\t%s", list_items, item_uid, item_name);
		}
		DynamicGui_AddRow(playerid, D_ITEM_RAISE, row);
	}
	
	if(!item_uid)
	{
	    TD_ShowSmallInfo(playerid, 5, "Nie znaleziono ~r~zadnych ~w~przedmiotow.");
	    return 1;
	}

	external_items_cache[playerid][item_place] = cache_save();
	ShowPlayerDialog(playerid, D_ITEM_RAISE, DIALOG_STYLE_TABLIST_HEADERS, "Lista przedmiotów:", list_items, "Wybierz", "Anuluj");

	TD_ShowHint(playerid, HINT_ITEMS_NEAR, 15, "Niemal kazdy przedmiot moze zostac ~y~podniesiony~w~, o ile znajduje sie w poblizu Ciebie.~n~~n~Uwazaj jednak na ~r~udzwig ~w~Twojej postaci, ktory jest zalezny od jej ~y~sily~w~.~n~~n~Jezeli udzwig zostanie przekroczony, ~r~nie bedziesz ~w~mogl nic wiecej dodac do swojego ekwipunku. Dlatego warto korzystac z roznego rodzaju ~p~schowkow ~w~(w pojezdzie, lub domu).");
	return 1;
}



public CreateArea(Float:AreaMinX, Float:AreaMinY, Float:AreaMaxX, Float:AreaMaxY, area_world, Float:AreaMinZ, Float:AreaMaxZ)
{
	new area_uid, query[128];
	mysql_query_format("INSERT INTO `"SQL_PREF"areas` (area_point1, area_point2, area_vw) VALUES ('%f|%f|%f', '%f|%f|%f', '%d')", AreaMinX, AreaMinY, AreaMinZ, AreaMaxX, AreaMaxY, AreaMaxZ, area_world);
	
	area_uid = cache_insert_id();
	
	mysql_format(connHandle, query, sizeof(query), "SELECT * FROM `"SQL_PREF"areas` WHERE area_uid = '%d' LIMIT 1", area_uid);
	mysql_tquery(connHandle, query, "query_OnLoadAreas", "");
	
	return area_uid;
}

public DeleteArea(areaid)
{
	new area_uid = GetAreaUID(areaid);
	mysql_query_format("DELETE FROM `"SQL_PREF"areas` WHERE area_uid = '%d' LIMIT 1", area_uid);

	DestroyDynamicArea(areaid);
	return 1;
}

public query_OnLoadAreas()
{
	new AreaData[sAreaData], area_id, area_world, rows,
	    Float:point1[3], Float:point2[3], str[2][128], Float:pointes[8];

	cache_get_row_count(rows);
	for(new row = 0; row != rows; row++)
	{
	    cache_get_value_index_int(row, 0, AreaData[aUID]);
	    
	    cache_get_value_index_int(row, 3, AreaData[aOwnerType]);
	    cache_get_value_index_int(row, 4, AreaData[aOwner]);
	    
	    cache_get_value_index_int(row, 6, area_world);
	    
		cache_get_value_index(row, 8, str[0]);
		sscanf(str[0], "p<|>a<f>[3]", point1);

		cache_get_value_index(row, 9, str[1]);
		sscanf(str[1], "p<|>a<f>[3]", point2);
		
		cache_get_value_index_int(row, 10, AreaData[aFlags]);
		cache_get_value_index(row, 11, AreaData[aAudioURL], 128);

		pointes[0] = point1[0];
		pointes[1] = point1[1];
		pointes[2] = point1[0];
		pointes[3] = point2[1];
		pointes[4] = point2[0];
		pointes[5] = point2[1];
		pointes[6] = point2[0];
		pointes[7] = point1[1];

		area_id = CreateDynamicPolygon(pointes, (point1[2] == 0.0) ? -FLOAT_INFINITY : point1[2], (point2[2] == 0.0) ? FLOAT_INFINITY : point2[2], 8, area_world);

		// Serwis
		if(AreaData[aFlags] & A_FLAG_SERVICE || AreaData[aFlags] & A_FLAG_CORNER || AreaData[aFlags] & A_FLAG_LUMBERJACK || AreaData[aFlags] & A_FLAG_MISSION)
		{
			AreaData[aExtraID] = GangZoneCreate(pointes[0], pointes[1], pointes[4], pointes[3]);
		}
		else
		{
		    AreaData[aExtraID] = 0;
		}

		Streamer_SetArrayData(STREAMER_TYPE_AREA, area_id, E_STREAMER_EXTRA_ID, AreaData);
	}
	
	printf("CountDynamicAreas: %d", Streamer_GetUpperBound(STREAMER_TYPE_AREA));
	return 1;
}

public SaveArea(areaid)
{
	new AreaData[sAreaData];
	Streamer_GetArrayData(STREAMER_TYPE_AREA, areaid, E_STREAMER_EXTRA_ID, AreaData);
	
	mysql_query_format("UPDATE `"SQL_PREF"areas` SET area_ownertype = '%d', area_owner = '%d', area_flags = '%d', area_audio = '%s' WHERE area_uid = '%d' LIMIT 1", AreaData[aOwnerType], AreaData[aOwner], AreaData[aFlags], AreaData[aAudioURL], AreaData[aUID]);
	return 1;
}

public CreateDoorProduct(doorid, ProductName[], ProductType, ProductValue1, ProductValue2, ProductPrice, ProductCount)
{
	new DoorData[sDoorInfo];
	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	
    if(DoorData[dOwnerType] != OWNER_GROUP)	return 1;
    
	// Sumuj produkt z innymi
	foreach(new product : Product)
	{
	    if(ProductData[product][pUID])
	    {
	        if(ProductData[product][pOwner] == DoorData[dOwner])
	        {
	            if(ProductData[product][pType] == ProductType && ProductData[product][pValue1] == ProductValue1 && ProductData[product][pValue2] == ProductValue2)
	            {
	                if(!strcmp(ProductData[product][pName], ProductName, true))
	                {
	                    ProductData[product][pCount] += ProductCount;
						orm_update(ProductData[product][pOrm]);
	                    return 1;
	                }
	            }
	        }
	    }
	}
	new query[512], Cache:tmp_cache, product_uid;
	
	mysql_format(connHandle, query, sizeof(query), "SELECT `product_uid` FROM `"SQL_PREF"products` WHERE product_type = '%d' AND product_name = '%s' AND product_value1 = '%d' AND product_value2 = '%d' AND product_owner = '%d' AND product_count = 0 LIMIT 1", ProductType, ProductName, ProductValue1, ProductValue2, DoorData[dOwner]);
	tmp_cache = mysql_query(connHandle, query);
	
	cache_get_value_index_int(0, 0, product_uid);
    if(cache_is_valid(tmp_cache))	cache_delete(tmp_cache);
    
	if(product_uid != 0)
	{
	    mysql_format(connHandle, query, sizeof(query), "UPDATE `"SQL_PREF"products` SET product_count = product_count + %d WHERE product_uid = '%d' LIMIT 1", ProductCount, product_uid);
		mysql_query(connHandle, query);
	}
	else
	{
		mysql_format(connHandle, query, sizeof(query), "INSERT INTO `"SQL_PREF"products` (product_name, product_type, product_value1, product_value2, product_price, product_count, product_owner, product_max_price) VALUES ('%s', '%d', '%d', '%d', '%d', '%d', '%d', '%d')", ProductName, ProductType, ProductValue1, ProductValue2, ProductPrice, ProductCount, DoorData[dOwner], (ProductPrice + floatround(ProductPrice * 1.5)));
		mysql_query(connHandle, query);
		
		product_uid = cache_insert_id();
	}

	mysql_format(connHandle, query, sizeof(query), "SELECT * FROM `"SQL_PREF"products` WHERE product_uid = '%d' LIMIT 1", product_uid);
	mysql_tquery(connHandle, query, "query_OnLoadProducts", "");
	
	return 1;
}

public query_OnLoadProducts()
{
	new rows, product_id, ORM:orm_id;

	cache_get_row_count(rows);
	for(new row = 0; row != rows; row++)
	{
		product_id = Iter_Free(Product);
		orm_id = ProductData[product_id][pOrm] = orm_create(""SQL_PREF"products", connHandle);
		
		orm_addvar_int(orm_id, ProductData[product_id][pUID], "product_uid");
		
		orm_addvar_string(orm_id, ProductData[product_id][pName], 32, "product_name");
		orm_addvar_int(orm_id, ProductData[product_id][pType], "product_type");
		
		orm_addvar_int(orm_id, ProductData[product_id][pOwner], "product_owner");
		orm_addvar_int(orm_id, ProductData[product_id][pPrice], "product_price");
		
		orm_addvar_int(orm_id, ProductData[product_id][pValue1], "product_value1");
		orm_addvar_int(orm_id, ProductData[product_id][pValue2], "product_value2");
		
		orm_addvar_int(orm_id, ProductData[product_id][pCount], "product_count");
		orm_addvar_int(orm_id, ProductData[product_id][pMaxPrice], "product_price");
		
		orm_setkey(orm_id, "product_uid");
		orm_apply_cache(orm_id, row);
		
		Iter_Add(Product, product_id);
	}
	return 1;
}

public DeleteProduct(product_id)
{
	ProductData[product_id][pCount] = 0;
	orm_update(ProductData[product_id][pOrm]);
	
	orm_destroy(ProductData[product_id][pOrm]);
	Iter_Remove(Product, product_id);
	return 1;
}

public ListGroupProductsForPlayer(group_id, playerid, list_type)
{
	new list_products[1024], query[256],
        product_uid, product_name[32], product_price, product_count;

    new rows, Cache:tmp_cache;
    
 	mysql_format(connHandle, query, sizeof(query), "SELECT `product_uid`, `product_name`, `product_price`, `product_count` FROM `"SQL_PREF"products` WHERE product_owner = '%d' AND product_count > 0 AND product_price > 0", GroupData[group_id][gUID]);
	tmp_cache = mysql_query(connHandle, query);
	
	if(list_type == PRODUCT_LIST_PRICE)	format(list_products, sizeof(list_products), "Nazwa produktu\tCena\n");
	else								format(list_products, sizeof(list_products), "Nazwa produktu\tCena\tIlość\n");
	
	DynamicGui_Init(playerid);

	cache_get_row_count(rows);
	for(new row = 0; row != rows; row++)
	{
		cache_get_value_index_int(row, 0, product_uid);
		
		cache_get_value_index(row, 1, product_name, 32);
		
		cache_get_value_index_int(row, 2, product_price);
		cache_get_value_index_int(row, 3, product_count);
		
		if(list_type == PRODUCT_LIST_PRICE)	format(list_products, sizeof(list_products), "%s\n%s\t$%d", list_products, product_name, product_price);
		else								format(list_products, sizeof(list_products), "%s\n%s\t$%d\tx%d", list_products, product_name, product_price, product_count);

		DynamicGui_AddRow(playerid, product_price, product_uid);
	}
	if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
	
	if(strlen(list_products))
	{
	    switch(list_type)
	    {
	        case PRODUCT_LIST_NONE:
	        {
	            ShowPlayerDialog(playerid, D_NONE, DIALOG_STYLE_TABLIST_HEADERS, "Produkty w magazynie:", list_products, "OK", "");
	        }
	        case PRODUCT_LIST_OFFER:
	        {
	            ShowPlayerDialog(playerid, D_PRODUCT_OFFER, DIALOG_STYLE_TABLIST_HEADERS, "Oferuj produkt z magazynu:", list_products, "Oferuj", "Anuluj");
	        }
	        case PRODUCT_LIST_BUY:
	        {
	            ShowPlayerDialog(playerid, D_PRODUCT_BUY, DIALOG_STYLE_TABLIST_HEADERS, "Zakup produkt:", list_products, "Zakup", "Anuluj");
	        }
	        case PRODUCT_LIST_OPTIONS:
	        {
	            ShowPlayerDialog(playerid, D_PRODUCT_SELECT, DIALOG_STYLE_TABLIST_HEADERS, "Zarządzaj produktem:", list_products, "Wybierz", "Anuluj");
	        }
	        case PRODUCT_LIST_PRICE:
	        {
	            ShowPlayerDialog(playerid, D_NONE, DIALOG_STYLE_TABLIST_HEADERS, "Cennik:", list_products, "OK", "");
	        }
	    }
	}
	else
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znaleziono żadnych produktów w magazynie.");
	}
	return 1;
}

public AddGroupTransactionLog(transaction_owner, group_id, transaction_type, price, transaction_value, transaction_extraid)
{
	new query[512];
	mysql_format(connHandle, query, sizeof(query), "INSERT INTO `"SQL_PREF"group_transactions` VALUES ('', '%d', '%d', '%d', '%d', '%d', '%d', '%d')", PlayerCache[transaction_owner][pUID], transaction_type, GroupData[group_id][gUID], price, transaction_value, transaction_extraid, gettime());
	mysql_query(connHandle, query);
	
	return 1;
}

public crp_AddObject(ModelID, Float:PosX, Float:PosY, Float:PosZ, Float:RotX, Float:RotY, Float:RotZ, InteriorID, VirtualWorld)
{
	new object_id, object_uid, objData[sObjectData];
	mysql_query_format("INSERT INTO `"SQL_PREF"objects` (`object_model`, `object_posx`, `object_posy`, `object_posz`, `object_rotx`, `object_roty`, `object_rotz`, `object_world`, `object_interior`) VALUES ('%d', '%f', '%f', '%f', '%f', '%f', '%f', '%d', '%d')", ModelID, PosX, PosY, PosZ, RotX, RotY, RotZ, VirtualWorld, InteriorID);

	object_uid = cache_insert_id();
	object_id = CreateDynamicObject(ModelID, PosX, PosY, PosZ, RotX, RotY, RotZ, VirtualWorld, InteriorID, -1, MAX_DRAW_DISTANCE, MAX_DRAW_DISTANCE);

	objData[objUID] = object_uid;
	Streamer_SetArrayData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_EXTRA_ID, objData);
	return object_id;
}

public SaveObjectPos(object_id)
{
	new object_uid = GetObjectUID(object_id),
	    Float:PosX, Float:PosY, Float:PosZ,
	    Float:RotX, Float:RotY, Float:RotZ;
	    
	GetDynamicObjectPos(object_id, PosX, PosY, PosZ);
	GetDynamicObjectRot(object_id, RotX, RotY, RotZ);
	
	mysql_query_format("UPDATE `"SQL_PREF"objects` SET object_posx = '%f', object_posy = '%f', object_posz = '%f', object_rotx = '%f', object_roty = '%f', object_rotz = '%f' WHERE object_uid = '%d' LIMIT 1", PosX, PosY, PosZ, RotX, RotY, RotZ, object_uid);
	return 1;
}

public DeleteObject(object_id)
{
	new object_uid = GetObjectUID(object_id);
	
	mysql_query_format("DELETE FROM `"SQL_PREF"objects` WHERE object_uid = '%d' LIMIT 1", object_uid);
	mysql_query_format("DELETE FROM `"SQL_PREF"materials` WHERE material_owner = '%d'", object_uid);
	
	DestroyDynamicObject(object_id);
	return object_uid;
}

public query_OnLoadObjects()
{
	new objData[sObjectData], rows, last_uid,
	    object_id, object_uid, object_model, object_world, object_interior, Float:object_pos[3], Float:object_rot[3], object_material[256];

	cache_get_row_count(rows);
	for(new row = 0; row != rows; row++)
	{
	    cache_get_value_index_int(row, 0, object_uid);
	    if(object_uid != last_uid)
	    {
		    objData[objUID] = object_uid;

		    cache_get_value_index_int(row, 5, object_model);

		    cache_get_value_index_int(row, 6, object_world);
		    cache_get_value_index_int(row, 7, object_interior);

		    cache_get_value_index_float(row, 8, object_pos[0]);
		    cache_get_value_index_float(row, 9, object_pos[1]);
		    cache_get_value_index_float(row, 10, object_pos[2]);

		    cache_get_value_index_float(row, 11, object_rot[0]);
		    cache_get_value_index_float(row, 12, object_rot[1]);
		    cache_get_value_index_float(row, 13, object_rot[2]);

		    cache_get_value_index_float(row, 14, objData[objGateX]);
		    cache_get_value_index_float(row, 15, objData[objGateY]);
		    cache_get_value_index_float(row, 16, objData[objGateZ]);

		    cache_get_value_index_float(row, 17, objData[objGateRX]);
		    cache_get_value_index_float(row, 18, objData[objGateRY]);
		    cache_get_value_index_float(row, 19, objData[objGateRZ]);

		    cache_get_value_index_int(row, 20, objData[objGate]);

			object_id = CreateDynamicObject(object_model, object_pos[0], object_pos[1], object_pos[2], object_rot[0], object_rot[1], object_rot[2], object_world, object_interior, -1, MAX_DRAW_DISTANCE, MAX_DRAW_DISTANCE);
			Streamer_SetArrayData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_EXTRA_ID, objData);
			
			if(object_world == 0)
			{
			    // Obiekty w świecie 0 widoczne z mniejszej odległości o połowę od zdefiniowanej
				Streamer_SetFloatData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_DRAW_DISTANCE, MAX_DRAW_DISTANCE / 2);
				Streamer_SetFloatData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_STREAM_DISTANCE, MAX_DRAW_DISTANCE / 2);
			
				// Centrum (dwukrotna odległość widzenia i obiekt statyczny)
			    if(object_model >= -2017 && object_model <= -2001 || object_model == -2020 || object_model == -2021 || object_model == -2089 || object_model == -2090 || object_model == -2099)
			    {
			        Streamer_SetIntData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_WORLD_ID, -1);
			        Streamer_SetIntData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_INTERIOR_ID, -1);
			    	
   					Streamer_SetFloatData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_DRAW_DISTANCE, MAX_DRAW_DISTANCE * 2);
					Streamer_SetFloatData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_STREAM_DISTANCE, MAX_DRAW_DISTANCE * 2);

					Streamer_ToggleItemStatic(STREAMER_TYPE_OBJECT, object_id, true);
				}
				
				if(object_model == OBJECT_CORNER_GREEN)
				{
				    Streamer_SetIntData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_MODEL_ID, object_model + random(1));
				}
			}
			
			// Priorytet pierwszych 10 obiektów (podłogi)
			if(object_world != 0 && row <= 10)	Streamer_SetIntData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_PRIORITY, true);
			last_uid = object_uid;
		}
		cache_get_value_index(row, 25, object_material, 256);

		if(strlen(object_material) > 5)
		{
		    new material_type, index, material_rest[256];
		    sscanf(object_material, "p<^>dp<:>ds[128]", material_type, index, material_rest);
		
 			// Materials
			new color1, color2, modelid, txdname[32], texturename[64],
			    matsize, fontsize, bold, alignment, fonttype[12], text[256];
			    
		    if(material_type == 0)
		    {
      			sscanf(material_rest, "p<:>dds[32]s[64]", color1, modelid, txdname, texturename);
        		SetDynamicObjectMaterial(object_id, index, modelid, txdname, texturename, color1);
	        }

			if(material_type == 1)
			{
 				sscanf(material_rest, "p<:>dddxxds[12]s[128]", matsize, fontsize, bold, color1, color2, alignment, fonttype, text);

   				format(text, sizeof(text), "%s", WordWrap(text, WRAP_MANUAL));
     			SetDynamicObjectMaterialText(object_id, index, text, matsize, fonttype, fontsize, bold, color1, color2, alignment);
			}
			print(object_material);
		}
		object_material = "";
	}
	return 1;
}

public Add3DTextLabel(LabelDesc[256], LabelColor, Float:LabelPosX, Float:LabelPosY, Float:LabelPosZ, Float:LabelDrawDistance, LabelWorld, LabelInteriorID)
{
	new query[512], label_uid;

	mysql_format(connHandle, query, sizeof(query), "INSERT INTO `"SQL_PREF"3dlabels` (`label_desc`, `label_color`, `label_posx`, `label_posy`, `label_posz`, `label_drawdist`, `label_world`, `label_interior`) VALUES ('%e', '%d', '%f', '%f', '%f', '%f', '%d', '%d')", LabelDesc, LabelColor, LabelPosX, LabelPosY, LabelPosZ, LabelDrawDistance, LabelWorld, LabelInteriorID);
	mysql_query(connHandle, query);
	
	label_uid = cache_insert_id();
	
	mysql_format(connHandle, query, sizeof(query), "SELECT * FROM `"SQL_PREF"3dlabels` WHERE label_uid = '%d' LIMIT 1", label_uid);
	mysql_tquery(connHandle, query, "query_OnLoad3DTextLabels", "");

	return label_uid;
}

public query_OnLoad3DTextLabels()
{
	new rows, label_uid, Text3D:label_id, col[20],
	    label_desc[256], label_color, Float:label_pos[3], Float:label_draw, label_world, label_interior;
	
	cache_get_row_count(rows);
	for(new row = 0; row != rows; row++)
	{
	    cache_get_value_index_int(row, 0, label_uid);
	    cache_get_value_index(row, 3, label_desc, 256);

		cache_get_value_index(row, 4, col, 20);
		sscanf(col, "x", label_color);
		
		cache_get_value_index_float(row, 5, label_pos[0]);
		cache_get_value_index_float(row, 6, label_pos[1]);
		cache_get_value_index_float(row, 7, label_pos[2]);
		
		cache_get_value_index_float(row, 8, label_draw);
		
		cache_get_value_index_int(row, 9, label_world);
		cache_get_value_index_int(row, 10, label_interior);
		
		label_id = CreateDynamic3DTextLabel(WordWrap(label_desc, WRAP_MANUAL), label_color, label_pos[0], label_pos[1], label_pos[2], label_draw, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 1, label_world, label_interior, -1, 100.0);
		Streamer_SetIntData(STREAMER_TYPE_3D_TEXT_LABEL, label_id, E_STREAMER_EXTRA_ID, label_uid);
	}
	return 1;
}

public crp_Delete3DTextLabel(label_id)
{
	new label_uid = GetLabelUID(label_id);
	mysql_query_format("DELETE FROM `"SQL_PREF"3dlabels` WHERE label_uid = '%d' LIMIT 1", label_uid);

	DestroyDynamic3DTextLabel(Text3D:label_id);
	return 1;
}

public Save3DTextLabel(label_id)
{
	new label_uid = GetLabelUID(label_id),
	    Float:PosX, Float:PosY, Float:PosZ;

	Streamer_GetFloatData(STREAMER_TYPE_3D_TEXT_LABEL, label_id, E_STREAMER_X, PosX);
	Streamer_GetFloatData(STREAMER_TYPE_3D_TEXT_LABEL, label_id, E_STREAMER_Y, PosY);
	Streamer_GetFloatData(STREAMER_TYPE_3D_TEXT_LABEL, label_id, E_STREAMER_Z, PosZ);

	mysql_query_format("UPDATE `"SQL_PREF"3dlabels` SET label_posx = '%f', label_posy = '%f', label_posz = '%f' WHERE label_uid = '%d' LIMIT 1", PosX, PosY, PosZ, label_uid);
	return 1;
}

public LoadPlayerAccess(playerid)
{
	new access_model, access_bone, slot_index,
 		Float:access_posx, Float:access_posy, Float:access_posz,
  		Float:access_rotx, Float:access_roty, Float:access_rotz,
   		Float:access_scalex, Float:access_scaley, Float:access_scalez;

	new rows, Cache:tmp_cache, query[512];
	
	mysql_format(connHandle, query, sizeof(query), "SELECT `attach_model`, `attach_bone`, `attach_x`, `attach_y`, `attach_z`, `attach_rx`, `attach_ry`, `attach_rz`, `attach_sx`, `attach_sy`, `attach_sz` FROM `"SQL_PREF"items`, `"SQL_PREF"attached_objects` WHERE (item_ownertype = '%d' AND item_owner = '%d' AND item_type = '%d' AND item_used = '1') AND (attach_uid = item_value1 OR attach_uid = item_value2)", PLACE_PLAYER, PlayerCache[playerid][pUID], ITEM_CLOTH_ACCESS);
	tmp_cache = mysql_query(connHandle, query);

	cache_get_row_count(rows);
	for(new row = 0; row != rows; row++)
	{
	    slot_index = GetPlayerFreeSlotAccess(playerid);
	    
	    cache_get_value_index_int(row, 0, access_model);
	    cache_get_value_index_int(row, 1, access_bone);

		cache_get_value_index_float(row, 2, access_posx);
		cache_get_value_index_float(row, 3, access_posy);
		cache_get_value_index_float(row, 4, access_posz);

		cache_get_value_index_float(row, 5, access_rotx);
		cache_get_value_index_float(row, 6, access_roty);
		cache_get_value_index_float(row, 7, access_rotz);

		cache_get_value_index_float(row, 8, access_scalex);
		cache_get_value_index_float(row, 9, access_scaley);
		cache_get_value_index_float(row, 10, access_scalez);
	    
		SetPlayerAttachedObject(playerid, slot_index, access_model, access_bone, access_posx, access_posy, access_posz, access_rotx, access_roty, access_rotz, access_scalex, access_scaley, access_scalez);
 	}
	if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
	return 1;
}

public LoadAllAccess()
{
	new access_id,
		query[256], rows, Cache:tmp_cache;
	
	mysql_format(connHandle, query, sizeof(query), "SELECT * FROM `"SQL_PREF"attached_objects` WHERE attach_owner = '%d' AND access_price > 0 LIMIT %d", OWNER_NONE, MAX_ACCESS);
	tmp_cache = mysql_query(connHandle, query);
	
	cache_get_row_count(rows);
	for(new row = 0; row != rows; row++)
	{
 		cache_get_value_index_int(row, 0, AccessData[access_id][aUID]);
	    cache_get_value_index_int(row, 2, AccessData[access_id][aModel]);

		cache_get_value_index_int(row, 3, AccessData[access_id][aBone]);
		
		cache_get_value_index_float(row, 4, AccessData[access_id][aPosX]);
		cache_get_value_index_float(row, 5, AccessData[access_id][aPosY]);
		cache_get_value_index_float(row, 6, AccessData[access_id][aPosZ]);
		
		cache_get_value_index_float(row, 7, AccessData[access_id][aRotX]);
		cache_get_value_index_float(row, 8, AccessData[access_id][aRotY]);
		cache_get_value_index_float(row, 9, AccessData[access_id][aRotZ]);
		
		cache_get_value_index_float(row, 10, AccessData[access_id][aScaleX]);
		cache_get_value_index_float(row, 11, AccessData[access_id][aScaleY]);
		cache_get_value_index_float(row, 12, AccessData[access_id][aScaleZ]);
		
		cache_get_value_index(row, 13, AccessData[access_id][aName], 32);
		cache_get_value_index_int(row, 14, AccessData[access_id][aPrice]);
		
		Iter_Add(Access, access_id);
		access_id ++;
	}
	if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
	
	printf("[load] Proces wczytywania akcesoriów został zakończony (count: %d).", Iter_Count(Access));
	return 1;
}

public LoadAllSkins()
{
	new query[256], Cache:tmp_cache, rows, skin_id;
	
	mysql_format(connHandle, query, sizeof(query), "SELECT `skin_id`, `skin_name`, `skin_price` FROM `"SQL_PREF"game_skins` WHERE skin_group = '0' AND skin_extraid = '0' LIMIT %d", MAX_SKINS);
	tmp_cache = mysql_query(connHandle, query);
	
	print("[load] Rozpoczynam proces wczytywania skinów...");
	
	cache_get_row_count(rows);
	for(new row = 0; row != rows; row++)
	{
	    cache_get_value_index_int(row, 0, SkinData[skin_id][sModel]);
	    cache_get_value_index(row, 1, SkinData[skin_id][sName], 32);
	    
	    cache_get_value_index_int(row, 2, SkinData[skin_id][sPrice]);
	    
	    Iter_Add(Skin, skin_id);
	    skin_id ++;
	}
	if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
	
	printf("[load] Proces wczytywania skinów został zakończony (count: %d).", Iter_Count(Skin));
	return 1;
}

public LoadAllAnims()
{
	new anim_id;
	new rows, Cache:tmp_cache = mysql_query(connHandle, "SELECT * FROM `"SQL_PREF"anim` ORDER BY `anim_command` ASC");

	print("[load] Rozpoczynam proces wczytywania animacji...");

	cache_get_row_count(rows);
	for(new row = 0; row != rows; row++)
	{
	    cache_get_value_index_int(row, 0, AnimCache[anim_id][aUID]);
	    
	    cache_get_value_index(row, 1, AnimCache[anim_id][aCommand], 12);
	    cache_get_value_index(row, 2, AnimCache[anim_id][aLib], 16);
	    
	    cache_get_value_index(row, 3, AnimCache[anim_id][aName], 24);
	    
	    cache_get_value_index_float(row, 4, AnimCache[anim_id][aSpeed]);
	    
	    cache_get_value_index_int(row, 5, AnimCache[anim_id][aOpt1]);
	    cache_get_value_index_int(row, 6, AnimCache[anim_id][aOpt2]);
	    cache_get_value_index_int(row, 7, AnimCache[anim_id][aOpt3]);
	    cache_get_value_index_int(row, 8, AnimCache[anim_id][aOpt4]);
	    cache_get_value_index_int(row, 9, AnimCache[anim_id][aOpt5]);
	    
	    cache_get_value_index_int(row, 10, AnimCache[anim_id][aAction]);

		Iter_Add(Anim, anim_id);
  		anim_id ++;
	}
	if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);

	printf("[load] Proces wczytywania animacji został zakończony (count: %d).", Iter_Count(Anim));
	return 1;
}

public OnPlayerSendOffer(playerid, customerid, OfferName[], OfferType, OfferValue1, OfferValue2, OfferPrice)
{
	if(OfferPrice < 0)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzona została błędna kwota.");
	    return 1;
	}
	
	new offer_desc[256];
	if(playerid >= 0)
	{
		if(OfferData[customerid][oOffererID] != INVALID_PLAYER_ID)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ktoś temu graczu składa aktualnie ofertę.");
		    return 1;
		}

		if(GetCustomerID(playerid) != INVALID_PLAYER_ID)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz składać kilku ofert jednocześnie.");
		    return 1;
		}
		
		/*
		switch(OfferType)
		{
		    case OFFER_ITEM, OFFER_VEHICLE, OFFER_DOOR, OFFER_TOWING, OFFER_PAINT, OFFER_MONTAGE, OFFER_BUSINESS, OFFER_REGISTER, OFFER_PASS, OFFER_SALON:
		    {
	   			if(PlayerCache[customerid][pHours] < 2)
				{
				    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz tego zaoferować temu graczowi, dopóki ten nie przegra 2h.");
				    return 1;
				}
				if(PlayerCache[playerid][pHours] < 2)
				{
				    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz nic oferować, dopóki nie przegrasz więcej niż 2h w grze.");
				    return 1;
				}
		    }
		}
		*/
		
		SendClientMessage(playerid, COLOR_INFO, "Oferta została wysłana. Odczekaj chwilę, by przekonać się, czy gracz zaakceptuje Twoją ofertę.");
        printf("[offe] %s (UID: %d, GID: %d) wysłał ofertę dla %s (UID: %d, GID: %d). Typ oferty: %s, nazwa: %s, wartości: %d/%d, cena: $%d", PlayerRealName(playerid), PlayerCache[playerid][pUID], PlayerCache[playerid][pGID], PlayerRealName(customerid), PlayerCache[customerid][pUID], PlayerCache[customerid][pGID], OfferTypeInfo[OfferType][oTypeName], OfferName, OfferValue1, OfferValue2, OfferPrice);

        format(offer_desc, sizeof(offer_desc), "~y~~h~Oferta od %s ~>~ %s~n~~n~~b~~h~~h~Nazwa: ~w~%s~n~~g~~h~Koszt: ~w~$%d", PlayerName(playerid), OfferTypeInfo[OfferType][oTypeName], OfferName, OfferPrice);
	}
	else
	{
		// Oferta od aktora
		new actorid = (playerid * -1), ActorData[sActorData];
		Streamer_GetArrayData(STREAMER_TYPE_ACTOR, actorid, E_STREAMER_EXTRA_ID, ActorData);
		
		format(offer_desc, sizeof(offer_desc), "~y~~h~Oferta od %s (aktor) ~>~ %s~n~~n~~b~~h~~h~Nazwa: ~w~%s~n~~g~~h~Koszt: ~w~$%d", ActorData[aName], OfferTypeInfo[OfferType][oTypeName], OfferName, OfferPrice);
	}
	new pay_type = PAY_TYPE_NONE;
	
	switch(OfferType)
	{
		case OFFER_REFUEL, OFFER_REPAIR, OFFER_MONTAGE, OFFER_REGISTER, OFFER_SALON, OFFER_TAX:
		{
			if(PlayerCache[customerid][pDuty][DUTY_GROUP] != INVALID_GROUP_ID)
			{
			    new group_id = PlayerCache[customerid][pDuty][DUTY_GROUP];
			    if(HavePlayerGroupPerm(customerid, GroupData[group_id][gUID], G_PERM_CAPITAL))
			    {
	   				if(OfferType != OFFER_SALON && OfferType != OFFER_TAX)
	   				{
						new veh_uid = OfferValue1, vehid = GetVehicleID(veh_uid);
						if(CarInfo[vehid][cOwnerType] == OWNER_GROUP && CarInfo[vehid][cOwner] == GroupData[group_id][gUID])
						{
		    				pay_type = PAY_TYPE_CAPITAL;
							TD_ShowSmallInfo(customerid, 0, "~r~Uwaga!~n~~w~Za ta usluge zaplacisz za pomoca kapitalu grupy ~y~%s (UID: %d)~w~. Jesli nie chcesz tego robic - ~r~dezaktywuj ~w~sluzbe grupy.", GroupData[group_id][gName], GroupData[group_id][gUID]);
						}
					}
					else
					{
		   				pay_type = PAY_TYPE_CAPITAL;
		   				TD_ShowSmallInfo(customerid, 0, "~r~Uwaga!~n~~w~Za ta usluge zaplacisz za pomoca kapitalu grupy ~y~%s (UID: %d)~w~. Jesli nie chcesz tego robic - ~r~dezaktywuj ~w~sluzbe grupy.", GroupData[group_id][gName], GroupData[group_id][gUID]);
					}
				}
			}
		}
		case OFFER_PASSAGE: pay_type = PAY_TYPE_CASH;
	}
	
	OfferData[customerid][oOffererID] = playerid;
	OfferData[customerid][oType] = OfferType;
	
	strmid(OfferData[customerid][oName], OfferName, 0, strlen(OfferName), 32);
	
	OfferData[customerid][oValue1] = OfferValue1;
	OfferData[customerid][oValue2] = OfferValue2;
	
	OfferData[customerid][oPrice] = OfferPrice;
	OfferData[customerid][oPayType] = pay_type;

	PlayerTextDrawSetString(customerid, TextDrawOfferDesc[customerid], offer_desc);

	TextDrawShowForPlayer(customerid, TextDrawOfferAccept);
	TextDrawShowForPlayer(customerid, TextDrawOfferReject);

	TextDrawShowForPlayer(customerid, TextDrawOfferBack);
	PlayerTextDrawShow(customerid, TextDrawOfferDesc[customerid]);

	SelectTextDraw(customerid, COLOR_GREEN);
	return 1;
}

public OnPlayerAcceptOffer(playerid, offererid)
{
	if(OfferData[playerid][oPayType] == PAY_TYPE_CASH)
	{
 		if(OfferData[playerid][oPrice] > PlayerCache[playerid][pCash])
   		{
     		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz takiej ilości gotówki.");
       		OnPlayerRejectOffer(playerid, offererid);
	        return 1;
	    }
	}

	if(OfferData[playerid][oPayType] == PAY_TYPE_CARD)
	{
  		if(OfferData[playerid][oPrice] > PlayerCache[playerid][pBankCash])
  		{
 	 		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz takiej sumy pieniężnej w banku.");
  			OnPlayerRejectOffer(playerid, offererid);
  			return 1;
		}
	}
	
	if(OfferData[playerid][oPayType] == PAY_TYPE_CAPITAL)
	{
		if(PlayerCache[playerid][pDuty][DUTY_GROUP] != INVALID_GROUP_ID)
		{
		    new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
			if(OfferData[playerid][oPrice] > GroupData[group_id][gCapital])
			{
 				ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Grupa %s (UID: %d) nie posiada takiej sumy na koncie kapitału.", GroupData[group_id][gName], GroupData[group_id][gUID]);
  				OnPlayerRejectOffer(playerid, offererid);
			    return 1;
			}
		}
		else
		{
		    OnPlayerRejectOffer(playerid, offererid);
		    return 1;
		}
	}

	new string[256],
		offer_type = OfferData[playerid][oType], offer_price = OfferData[playerid][oPrice];

	if(offererid >= 0)
	{
		if(offer_type == OFFER_ITEM)
		{
			if(!(PlayerCache[playerid][pAdmin] & A_PERM_ITEMS) && GetPlayerCapacity(playerid) <= 0)
			{
	  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Twoja postać nie jest w stanie unieść więcej przedmiotów.");
	  			OnPlayerRejectOffer(playerid, offererid);
		    	return 1;
			}

			new item_uid = OfferData[playerid][oValue1], itemid = GetPlayerItemID(offererid, item_uid);
			if(itemid == INVALID_ITEM_ID)
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz nie posiada tego przedmiotu w swoim ewkipunku.");
			    OnPlayerRejectOffer(playerid, offererid);
			    return 1;
			}

			if(offer_price > 0)
			{
				if(OfferData[playerid][oPayType] == PAY_TYPE_CASH)
				{
				    crp_GivePlayerMoney(playerid, -offer_price);
				    crp_GivePlayerMoney(offererid, offer_price);
				}
				else
				{
				    PlayerCache[playerid][pBankCash] -= offer_price;
				    PlayerCache[offererid][pBankCash] += offer_price;
				}
			}
			mysql_query_format("UPDATE `"SQL_PREF"items` SET item_ownertype = '%d', item_owner = '%d' WHERE item_uid = '%d' LIMIT 1", PLACE_PLAYER, PlayerCache[playerid][pUID], item_uid);

			UnloadPlayerItem(offererid, itemid);
			itemid = LoadPlayerItem(playerid, item_uid);

			format(string, sizeof(string), "* %s podaje przedmiot %s.", PlayerName(offererid), PlayerName(playerid));
			ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);

			printf("[item] %s (UID: %d, GID: %d) podał przedmiot %s (UID: %d) dla %s (UID: %d, GID: %d).", PlayerRealName(offererid), PlayerCache[offererid][pUID], PlayerCache[offererid][pGID], PlayerItemCache[playerid][itemid][iName], PlayerItemCache[playerid][itemid][iUID], PlayerRealName(playerid), PlayerCache[playerid][pUID], PlayerCache[playerid][pGID]);
		}

		if(offer_type == OFFER_VEHICLE)
		{
	 		if(offer_price > 0)
	   		{
	     		if(OfferData[playerid][oPayType] == PAY_TYPE_CASH)
	       		{
	         		crp_GivePlayerMoney(playerid, -offer_price);
	           		crp_GivePlayerMoney(offererid, offer_price);
		        }
		        else
				{
	   				PlayerCache[playerid][pBankCash] -= offer_price;
	       			PlayerCache[offererid][pBankCash] += offer_price;
	   			}
	   		}

			new vehid = OfferData[playerid][oValue1];

			CarInfo[vehid][cOwnerType] = OWNER_PLAYER;
			CarInfo[vehid][cOwner] = PlayerCache[playerid][pUID];

			orm_update(CarInfo[vehid][cOrm]);
			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Pojazd %s (UID: %d) kupiony.\nUżyj komendy /pomoc aby poznać szczegóły dotyczące pojazdów.", GetVehicleName(CarInfo[vehid][cModel]), CarInfo[vehid][cUID]);
		}

		if(offer_type == OFFER_PRODUCT)
		{
			if(!(PlayerCache[playerid][pAdmin] & A_PERM_ITEMS) && GetPlayerCapacity(playerid) <= 0)
			{
	  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Twoja postać nie jest w stanie unieść więcej przedmiotów.");
	  			OnPlayerRejectOffer(playerid, offererid);
		    	return 1;
			}

			new product_id = GetProductID(OfferData[playerid][oValue1]);
			if(product_id == INVALID_PRODUCT_ID)
			{
	  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Tego produktu nie ma już w magazynie.");
	  			OnPlayerRejectOffer(playerid, offererid);
		    	return 1;
			}

		    if(offer_price > 0)
		    {
	   			new group_cash = floatround(0.90 * offer_price),
					playercash = floatround(0.10 * offer_price);

				if(OfferData[playerid][oPayType] == PAY_TYPE_CASH)
		        {
				    crp_GivePlayerMoney(playerid, -offer_price);
					crp_GivePlayerMoney(offererid, playercash);
				}
				else
				{
				    PlayerCache[playerid][pBankCash] -= offer_price;
				    PlayerCache[offererid][pBankCash] += playercash;
				}

				if(PlayerCache[offererid][pDuty][DUTY_GROUP] != INVALID_GROUP_ID)
				{
					new group_id = PlayerCache[offererid][pDuty][DUTY_GROUP];
					
					GroupData[group_id][gCash] += group_cash;
					orm_update(GroupData[group_id][gOrm]);
					
     				AddGroupTransactionLog(offererid, group_id, TRANSACTION_OFFER, group_cash, offer_type, ProductData[product_id][pUID]);
					ShowPlayerInfoDialog(offererid, D_TYPE_INFO, "Otrzymałeś premię w wysokości $%d!\n\nNa konto grupy dodano: $%d", playercash, group_cash);
				}
				else
				{
					new group_id = GetGroupID(ProductData[product_id][pOwner]);

					GroupData[group_id][gCash] += group_cash;
					orm_update(GroupData[group_id][gOrm]);

                    AddGroupTransactionLog(offererid, group_id, TRANSACTION_OFFER, group_cash, offer_type, ProductData[product_id][pUID]);
					ShowPlayerInfoDialog(offererid, D_TYPE_INFO, "Sprzedałeś produkt %s za cenę $%d. Otrzymałeś premię w wysokości $%d!", OfferData[playerid][oName], offer_price, playercash);
				}
			}
	   		ProductData[product_id][pCount] --;
	   		ProductData[product_id][pPrice] = offer_price;

	     	new itemid = CreatePlayerItem(playerid, ProductData[product_id][pName], ProductData[product_id][pType], ProductData[product_id][pValue1], ProductData[product_id][pValue2]);
			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Zakupiłeś produkt %s.\nKoszt: $%d\n\nPrzedmiot (UID: %d) pojawił się w Twoim ekwipunku.\nSkorzystaj z komendy /p, by wyświetlić listę posiadanych przedmiotów.", ProductData[product_id][pName], offer_price, PlayerItemCache[playerid][itemid][iUID]);

			PlayerItemCache[playerid][itemid][iGroup] = ProductData[product_id][pOwner];
			orm_update(PlayerItemCache[playerid][itemid][iOrm]);

			if(ProductData[product_id][pCount] <= 0)	DeleteProduct(product_id);
			else 										orm_update(ProductData[product_id][pOrm]);

			format(string, sizeof(string), "* %s podaje przedmiot %s.", PlayerName(offererid), PlayerName(playerid));
			ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
		}

		if(offer_type == OFFER_VCARD)
		{
	 		mysql_query_format("INSERT INTO `"SQL_PREF"contacts` (contact_number, contact_name, contact_owner) VALUES ('%d', '%s', '%d')", OfferData[playerid][oValue1], PlayerRealName(offererid), PlayerCache[playerid][pPhoneNumber]);

			format(string, sizeof(string), "* %s wyjmuje telefon i wysyła wizytówkę %s.", PlayerName(offererid), PlayerName(playerid));
			ProxDetector(10.0, offererid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);

			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Nowy kontakt został dodany do listy.\nUżyj /tel, by sprawdzić listę kontaktów.");
		}

		if(offer_type == OFFER_DOOR)
		{
		    if(offer_price > 0)
		    {
				if(OfferData[playerid][oPayType] == PAY_TYPE_CASH)
		        {
				    crp_GivePlayerMoney(playerid, -offer_price);
					crp_GivePlayerMoney(offererid, offer_price);
				}
				else
				{
				    PlayerCache[playerid][pBankCash] -= offer_price;
				    PlayerCache[offererid][pBankCash] += offer_price;
				}
			}

		    new doorid = OfferData[playerid][oValue1];

		    new DoorData[sDoorInfo];
			Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);

		    DoorData[dOwnerType] = OWNER_PLAYER;
		    DoorData[dOwner] = PlayerCache[playerid][pUID];

		    Streamer_SetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);

		    SaveDoor(doorid);
		    ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Gratulacje, zakupiłeś nową nieruchomość %s (UID: %d).\nNieruchomością możesz zarządzać poprzez komendę /drzwi.", DoorData[dName], DoorData[dUID]);
		}

		if(offer_type == OFFER_TOWING)
		{
		    if(offer_type > 0)
		    {
				if(OfferData[playerid][oPayType] == PAY_TYPE_CASH)
		  		{
		    		crp_GivePlayerMoney(playerid, -offer_price);
					crp_GivePlayerMoney(offererid, offer_price);
				}
				else
				{
		  			PlayerCache[playerid][pBankCash] -= offer_price;
			    	PlayerCache[offererid][pBankCash] += offer_price;
				}
			}

			new towed_vehid = OfferData[playerid][oValue1], vehid = OfferData[playerid][oValue2];
			AttachTrailerToVehicle(vehid, towed_vehid);

			ShowPlayerInfoDialog(offererid, D_TYPE_SUCCESS, "Pojazd zostal pomyślnie podczepiony.\nAby go odczepić wciśnij klawisz \"N\".");
		}

		if(offer_type == OFFER_PASSAGE)
		{
			PlayerCache[offererid][pTaxiPassenger] = playerid;

			PlayerCache[playerid][pTaxiVeh] = OfferData[playerid][oValue1];
			PlayerCache[playerid][pTaxiPrice] = offer_price;

			ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Od teraz skrypt naliczy każde przejechane 100 metrów.\nSkrypt automatycznie zabierze Ci pieniądze po opuszczeniu pojazdu.");
		}

		if(offer_type == OFFER_REFUEL)
		{
			new veh_uid = OfferData[playerid][oValue1], vehid = GetVehicleID(veh_uid), fuel_value = OfferData[playerid][oValue2];
			if(vehid == INVALID_VEHICLE_ID)
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Pojazd (UID: %d) prawdopodobnie nie jest zespawnowany.", veh_uid);
			    OnPlayerRejectOffer(playerid, offererid);
			    return 1;
			}
			
		    if(offer_price > 0)
		    {
	  			new group_cash = floatround(0.60 * offer_price),
					playercash = floatround(0.40 * offer_price);

				if(OfferData[playerid][oPayType] == PAY_TYPE_CASH)
		        {
				    crp_GivePlayerMoney(playerid, -offer_price);
					crp_GivePlayerMoney(offererid, playercash);
				}
				else if(OfferData[playerid][oPayType] == PAY_TYPE_CAPITAL)
				{
					new capital_group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
					
					GroupData[capital_group_id][gCapital] -= offer_price;
					PlayerCache[offererid][pBankCash] += playercash;
					
					AddGroupTransactionLog(playerid, capital_group_id, TRANSACTION_SERVICE, -offer_price, offer_type, veh_uid);
				}
				else
				{
				    PlayerCache[playerid][pBankCash] -= offer_price;
				    PlayerCache[offererid][pBankCash] += playercash;
				}

				if(PlayerCache[offererid][pDuty][DUTY_GROUP] != INVALID_GROUP_ID)
				{
				    new group_id = PlayerCache[offererid][pDuty][DUTY_GROUP];
				    if(GroupData[group_id][gType] == G_TYPE_GASSTATION)
				    {
				        GroupData[group_id][gCash] += group_cash;
				        orm_update(GroupData[group_id][gOrm]);
				        
       					AddGroupTransactionLog(offererid, group_id, TRANSACTION_OFFER, group_cash, offer_type, 0);
						ShowPlayerInfoDialog(offererid, D_TYPE_INFO, "Otrzymałeś premię w wysokości $%d!\n\nNa konto grupy dodano: $%d", playercash, group_cash);
				    }
				}
		    }

			CarInfo[vehid][cFuel] = floatadd(CarInfo[vehid][cFuel], fuel_value);
			orm_update(CarInfo[vehid][cOrm]);

			SendClientFormatMessage(playerid, COLOR_LIGHTBLUE, "Zapłaciłeś $%d za %d litrów paliwa.", offer_price, fuel_value);
			ApplyAnimation(offererid, "INT_HOUSE", "wash_up",4.1, 0, 0, 0, 0, 0, 1);

			format(string, sizeof(string), "* %s wkłada wąż do baku.", PlayerName(offererid));
			ProxDetector(10.0, offererid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);

			format(string, sizeof(string), "* Pojazd %s został pomyślnie zatankowany (( %s ))", GetVehicleName(CarInfo[vehid][cModel]), PlayerName(offererid));
	  		ProxDetector(10.0, offererid, string, COLOR_DO, COLOR_DO, COLOR_DO, COLOR_DO, COLOR_DO);
		}

		if(offer_type == OFFER_REPAIR)
		{
			new veh_uid = OfferData[playerid][oValue1], vehid = GetVehicleID(veh_uid);
			if(vehid == INVALID_VEHICLE_ID)
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Pojazd (UID: %d) prawdopodobnie nie jest zespawnowany.", veh_uid);
			    OnPlayerRejectOffer(playerid, offererid);
			    return 1;
			}
			if(offer_price)
		    {
	  			new group_cash = floatround(0.80 * offer_price),
					playercash = floatround(0.20 * offer_price);

				if(OfferData[playerid][oPayType] == PAY_TYPE_CASH)
		        {
				    crp_GivePlayerMoney(playerid, -offer_price);
					crp_GivePlayerMoney(offererid, playercash);
				}
				else if(OfferData[playerid][oPayType] == PAY_TYPE_CAPITAL)
				{
					new capital_group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];

					GroupData[capital_group_id][gCapital] -= offer_price;
					PlayerCache[offererid][pBankCash] += playercash;
					
					AddGroupTransactionLog(playerid, capital_group_id, TRANSACTION_SERVICE, -offer_price, offer_type, veh_uid);
				}
				else
				{
				    PlayerCache[playerid][pBankCash] -= offer_price;
				    PlayerCache[offererid][pBankCash] += playercash;
				}
				
				if(PlayerCache[offererid][pDuty][DUTY_GROUP] != INVALID_GROUP_ID)
				{
				    new group_id = PlayerCache[offererid][pDuty][DUTY_GROUP];
				    if(GroupData[group_id][gType] == G_TYPE_WORKSHOP || GroupData[group_id][gType] == G_TYPE_GASSTATION)
			    	{
				        GroupData[group_id][gCash] += group_cash;
				        orm_update(GroupData[group_id][gOrm]);
				        
				        AddGroupTransactionLog(offererid, group_id, TRANSACTION_OFFER, group_cash, offer_type, 0);
	       				ShowPlayerInfoDialog(offererid, D_TYPE_INFO, "Otrzymałeś premię w wysokości $%d!\n\nNa konto grupy dodano: $%d", playercash, group_cash);
				    }
				}
			}
			new Text3D:label_id;

			PlayerCache[offererid][pRepairVeh] = vehid;
			PlayerCache[offererid][pRepairTime] = 180;

			label_id = CreateDynamic3DTextLabel("Naprawianie w toku...\n -- (0%) --", COLOR_LIGHTBLUE, 0.0, 0.0, 0.0, 20.0, INVALID_PLAYER_ID, vehid, 0, -1, -1, -1, 20.0);

			Streamer_SetFloatData(STREAMER_TYPE_3D_TEXT_LABEL, label_id, E_STREAMER_ATTACH_OFFSET_Z, 1.0);
			PlayerCache[offererid][pRepairTag] = label_id;
		}

		if(offer_type == OFFER_PAINT)
		{
			new color1 = OfferData[playerid][oValue1],
			    color2 = OfferData[playerid][oValue2],
			    vehid = GetPlayerVehicleID(playerid), Text3D:label_id;

			if(vehid == INVALID_VEHICLE_ID)
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz siedzieć w pojeździe, który chcesz przelakierować.");
			    OnPlayerRejectOffer(playerid, offererid);
			    return 1;
			}
			
			if(offer_price)
		    {
	  			new group_cash = floatround(0.80 * offer_price),
					playercash = floatround(0.20 * offer_price);

				if(OfferData[playerid][oPayType] == PAY_TYPE_CASH)
		        {
				    crp_GivePlayerMoney(playerid, -offer_price);
					crp_GivePlayerMoney(offererid, playercash);
				}
				else
				{
				    PlayerCache[playerid][pBankCash] -= offer_price;
				    PlayerCache[offererid][pBankCash] += playercash;
				}

				if(PlayerCache[offererid][pDuty][DUTY_GROUP] != INVALID_GROUP_ID)
				{
				    new group_id = PlayerCache[offererid][pDuty][DUTY_GROUP];
				    if(GroupData[group_id][gType] == G_TYPE_WORKSHOP || GroupData[group_id][gType] == G_TYPE_GASSTATION)
			    	{
				        GroupData[group_id][gCash] += group_cash;
				        orm_update(GroupData[group_id][gOrm]);

				        AddGroupTransactionLog(offererid, group_id, TRANSACTION_OFFER, group_cash, offer_type, 0);
	       				ShowPlayerInfoDialog(offererid, D_TYPE_INFO, "Otrzymałeś premię w wysokości $%d!\n\nNa konto grupy dodano: $%d", playercash, group_cash);
				    }
				}
			}

		    PlayerCache[offererid][pSprayVeh] = vehid;
		    PlayerCache[offererid][pSprayTime] = 1800;

		    PlayerCache[offererid][pSprayColor][0] = color1;
		    PlayerCache[offererid][pSprayColor][1] = color2;

		    PlayerCache[offererid][pSprayType] = SPRAY_TYPE_COLORS;
		    ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Zaakceptowałeś usługę lakierowania pojazdu.\nTeraz odczekaj chwilę aż mechanik skończy lakierować pojazd.");

			label_id = CreateDynamic3DTextLabel("Lakierowanie w toku...\n -- (0%) --", COLOR_LIGHTBLUE, 0.0, 0.0, 0.0, 20.0, INVALID_PLAYER_ID, vehid, 0, -1, -1, -1, 20.0);
			Streamer_SetFloatData(STREAMER_TYPE_3D_TEXT_LABEL, label_id, E_STREAMER_ATTACH_OFFSET_Z, 1.0);

			PlayerCache[offererid][pSprayTag] = label_id;
			ShowPlayerInfoDialog(offererid, D_TYPE_INFO, "Gracz zaakceptował Twoją ofertę.\n\nMożesz teraz zacząć malować pojazd,\nużyj do tego lakieru a następnie psikaj w jego stronę.");
		}

		if(offer_type == OFFER_PAINTJOB)
		{
			new paintjob_id = OfferData[playerid][oValue1],
				vehid = GetPlayerVehicleID(playerid), Text3D:label_id;

			if(vehid == INVALID_VEHICLE_ID)
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz siedzieć w pojeździe, który chcesz przelakierować.");
			    OnPlayerRejectOffer(playerid, offererid);
			    return 1;
			}
			
			if(offer_price)
		    {
				if(OfferData[playerid][oPayType] == PAY_TYPE_CASH)
		        {
				    crp_GivePlayerMoney(playerid, -offer_price);
					crp_GivePlayerMoney(offererid, offer_price);
				}
				else
				{
				    PlayerCache[playerid][pBankCash] -= offer_price;
				    PlayerCache[offererid][pBankCash] += offer_price;
				}
			}

	  		PlayerCache[offererid][pSprayVeh] = vehid;
		    PlayerCache[offererid][pSprayTime] = 30000;

		    PlayerCache[offererid][pSprayColor][0] = paintjob_id;
		    PlayerCache[offererid][pSprayColor][1] = 0;

		    PlayerCache[offererid][pSprayType] = SPRAY_TYPE_PAINTJOB;
		    ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Zaakceptowałeś usługę lakierowania pojazdu.\nTeraz odczekaj chwilę aż oferujący skończy lakierować pojazd.");

			label_id = CreateDynamic3DTextLabel("Lakierowanie pojazdu w toku...\n -- (0%) --.", COLOR_LIGHTBLUE, 0.0, 0.0, 0.0, 20.0, INVALID_PLAYER_ID, vehid, 0, -1, -1, -1, 20.0);
			Streamer_SetFloatData(STREAMER_TYPE_3D_TEXT_LABEL, label_id, E_STREAMER_ATTACH_OFFSET_Z, 1.0);

			PlayerCache[offererid][pSprayTag] = label_id;
			ShowPlayerInfoDialog(offererid, D_TYPE_INFO, "Gracz zaakceptował Twoją ofertę.\n\nMożesz teraz zacząć malować pojazd,\nużyj do tego lakieru a następnie psikaj w jego stronę.");
		}

		if(offer_type == OFFER_MONTAGE)
		{
			new veh_uid = OfferData[playerid][oValue1],
				item_uid = OfferData[playerid][oValue2], vehid = GetVehicleID(veh_uid), itemid = GetPlayerItemID(offererid, item_uid);

			if(vehid == INVALID_VEHICLE_ID)
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Pojazd (UID: %d) prawdopodobnie nie jest zespawnowany.", veh_uid);
			    OnPlayerRejectOffer(playerid, offererid);
			    return 1;
			}

			if(itemid == INVALID_ITEM_ID)
			{
			   ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz nie posiada tego przedmiotu w swoim ewkipunku.");
			   OnPlayerRejectOffer(playerid, offererid);
			   return 1;
			}
		
			if(offer_price)
		    {
	  			new group_cash = floatround(0.80 * offer_price),
					playercash = floatround(0.20 * offer_price);

				if(OfferData[playerid][oPayType] == PAY_TYPE_CASH)
		        {
				    crp_GivePlayerMoney(playerid, -offer_price);
					crp_GivePlayerMoney(offererid, playercash);
				}
				else
				{
				    PlayerCache[playerid][pBankCash] -= offer_price;
				    PlayerCache[offererid][pBankCash] += playercash;
				}

				if(PlayerCache[offererid][pDuty][DUTY_GROUP] != INVALID_GROUP_ID)
				{
				    new group_id = PlayerCache[offererid][pDuty][DUTY_GROUP];
				    if(GroupData[group_id][gType] == G_TYPE_WORKSHOP || GroupData[group_id][gType] == G_TYPE_GASSTATION)
			    	{
				        GroupData[group_id][gCash] += group_cash;
				        orm_update(GroupData[group_id][gOrm]);

				        AddGroupTransactionLog(offererid, group_id, TRANSACTION_OFFER, group_cash, offer_type, 0);
	       				ShowPlayerInfoDialog(offererid, D_TYPE_INFO, "Otrzymałeś premię w wysokości $%d!\n\nNa konto grupy dodano: $%d", playercash, group_cash);
				    }
				}
			}


			PlayerItemCache[offererid][itemid][iUsed] = true;

			PlayerCache[offererid][pMontageVeh] = vehid;
			PlayerCache[offererid][pMontageItem] = itemid;

		    PlayerCache[offererid][pMontageTime] = 120;
		}

		if(offer_type == OFFER_MANDATE)
		{
			if(offer_price)
		    {
	   			new group_cash = floatround(0.90 * offer_price),
					playercash = floatround(0.10 * offer_price);

				if(OfferData[playerid][oPayType] == PAY_TYPE_CASH)
		        {
				    crp_GivePlayerMoney(playerid, -offer_price);
					crp_GivePlayerMoney(offererid, playercash);
				}
				else
				{
				    PlayerCache[playerid][pBankCash] -= offer_price;
				    PlayerCache[offererid][pBankCash] += playercash;
				}
				new group_id = PlayerCache[offererid][pDuty][DUTY_GROUP];
				
				GroupData[group_id][gCash] += group_cash;
				orm_update(GroupData[group_id][gOrm]);
				
				AddGroupTransactionLog(offererid, group_id, TRANSACTION_OFFER, group_cash, offer_type, 0);
				ShowPlayerInfoDialog(offererid, D_TYPE_INFO, "Otrzymałeś premię w wysokości $%d!\n\nNa konto grupy dodano: $%d", playercash, group_cash);
			}
			new mandate_reason[128], add_pdp = OfferData[playerid][oValue1];

			mysql_escape_string(OfferData[playerid][oName], mandate_reason);
			mysql_query_format("INSERT INTO `"SQL_PREF"directory` VALUES ('', '%d', '%d', '%s', '%d', NOW())", PlayerCache[playerid][pUID], PlayerCache[offererid][pUID], mandate_reason, add_pdp);

	        PlayerCache[playerid][pPDP] += add_pdp;
		}

		if(offer_type == OFFER_UNBLOCK)
		{
	   		if(offer_price)
		    {
	   			new group_cash = floatround(0.90 * offer_price),
					playercash = floatround(0.10 * offer_price);

				if(OfferData[playerid][oPayType] == PAY_TYPE_CASH)
		        {
				    crp_GivePlayerMoney(playerid, -offer_price);
					crp_GivePlayerMoney(offererid, playercash);
				}
				else
				{
				    PlayerCache[playerid][pBankCash] -= offer_price;
				    PlayerCache[offererid][pBankCash] += playercash;
				}
				new group_id = PlayerCache[offererid][pDuty][DUTY_GROUP];
				
				GroupData[group_id][gCash] += group_cash;
				orm_update(GroupData[group_id][gOrm]);
				
				AddGroupTransactionLog(offererid, group_id, TRANSACTION_OFFER, group_cash, offer_type, 0);
				ShowPlayerInfoDialog(offererid, D_TYPE_INFO, "Otrzymałeś premię w wysokości $%d!\n\nNa konto grupy dodano: $%d", playercash, group_cash);
			}
			new vehid = OfferData[playerid][oValue1];

			CarInfo[vehid][cBlockWheel] = 0;
			orm_update(CarInfo[vehid][cOrm]);

			ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Blokada została zdjęta z koła %s (UID: %d).", GetVehicleName(CarInfo[vehid][cModel]), CarInfo[vehid][cUID]);
		}

		if(offer_type == OFFER_DOCUMENT)
		{
			if(offer_price)
		    {
	   			new group_cash = floatround(0.90 * offer_price),
					playercash = floatround(0.10 * offer_price);

				if(OfferData[playerid][oPayType] == PAY_TYPE_CASH)
		        {
				    crp_GivePlayerMoney(playerid, -offer_price);
					crp_GivePlayerMoney(offererid, playercash);
				}
				else
				{
				    PlayerCache[playerid][pBankCash] -= offer_price;
				    PlayerCache[offererid][pBankCash] += playercash;
				}
				new group_id = PlayerCache[offererid][pDuty][DUTY_GROUP];
				
				GroupData[group_id][gCash] += group_cash;
				orm_update(GroupData[group_id][gOrm]);
				
				AddGroupTransactionLog(offererid, group_id, TRANSACTION_OFFER, group_cash, offer_type, 0);
				ShowPlayerInfoDialog(offererid, D_TYPE_INFO, "Otrzymałeś premię w wysokości $%d!\n\nNa konto grupy dodano: $%d", playercash, group_cash);
			}
			PlayerCache[playerid][pDocuments] += OfferData[playerid][oValue1];
			ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Zakupiłeś nowy dokument.\nUżyj komendy /pokaz, aby zarządzać dokumentami.");
		}

		if(offer_type == OFFER_BUSINESS)
		{
			new group_slot = GetPlayerFreeGroupSlot(playerid);
			if(group_slot == INVALID_SLOT_ID)
			{
			    ShowPlayerInfoDialog(offererid, D_TYPE_ERROR, "Ten gracz nie posiada żadnego wolnego slotu dla grupy.");
				ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz żadnego wolnego slotu dla grupy.");

				OnPlayerRejectOffer(playerid, offererid);
				return 1;
			}

			if(offer_price)
		    {
	   			new group_cash = floatround(0.99 * offer_price),
					playercash = floatround(0.01 * offer_price);

				if(OfferData[playerid][oPayType] == PAY_TYPE_CASH)
		        {
				    crp_GivePlayerMoney(playerid, -offer_price);
					crp_GivePlayerMoney(offererid, playercash);
				}
				else
				{
				    PlayerCache[playerid][pBankCash] -= offer_price;
				    PlayerCache[offererid][pBankCash] += playercash;
				}
				new group_id = PlayerCache[offererid][pDuty][DUTY_GROUP];
				
				GroupData[group_id][gCash] += group_cash;
				orm_update(GroupData[group_id][gOrm]);
				
				AddGroupTransactionLog(offererid, group_id, TRANSACTION_OFFER, group_cash, offer_type, 0);
				ShowPlayerInfoDialog(offererid, D_TYPE_INFO, "Otrzymałeś premię w wysokości $%d!\n\nNa konto grupy dodano: $%d", playercash, group_cash);
			}

			new group_type = OfferData[playerid][oValue1],
				group_id = CreateGroup(OfferData[playerid][oName], group_type);

			PlayerGroup[playerid][group_slot][gpUID] = GroupData[group_id][gUID];
			PlayerGroup[playerid][group_slot][gpID] = group_id;

			PlayerGroup[playerid][group_slot][gpPerm] = G_PERM_MAX;
			mysql_query_format("INSERT INTO `"SQL_PREF"char_groups` (`char_uid`, `group_belongs`, `group_perm`, `char_joined`) VALUES ('%d', '%d', '%d', '%d')", PlayerCache[playerid][pUID], GroupData[group_id][gUID], G_PERM_MAX, gettime());

			ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Gratulacje! Od teraz jesteś właścicielem nowego biznesu.\n\nNazwa biznesu: %s\nTyp: %s\nIdentyfikator (UID): %d\n\nSkorzystaj z komendy /g, by poznać szczegóły.", GroupData[group_id][gName], GroupTypeInfo[GroupData[group_id][gType]][gTypeName], GroupData[group_id][gUID]);
		}

		if(offer_type == OFFER_REGISTER)
		{
			if(offer_price)
		    {
	   			new group_cash = floatround(0.90 * offer_price),
					playercash = floatround(0.10 * offer_price);

				if(OfferData[playerid][oPayType] == PAY_TYPE_CASH)
		        {
				    crp_GivePlayerMoney(playerid, -offer_price);
					crp_GivePlayerMoney(offererid, playercash);
				}
				else
				{
				    PlayerCache[playerid][pBankCash] -= offer_price;
				    PlayerCache[offererid][pBankCash] += playercash;
				}
				new group_id = PlayerCache[offererid][pDuty][DUTY_GROUP];
				
				GroupData[group_id][gCash] += group_cash;
				orm_update(GroupData[group_id][gOrm]);
				
				AddGroupTransactionLog(offererid, group_id, TRANSACTION_OFFER, group_cash, offer_type, 0);
				ShowPlayerInfoDialog(offererid, D_TYPE_INFO, "Otrzymałeś premię w wysokości $%d!\n\nNa konto grupy dodano: $%d", playercash, group_cash);
			}

			new vehid = OfferData[playerid][oValue1];
	        format(string, sizeof(string), "LS%d", CarInfo[vehid][cUID]);

	        strmid(CarInfo[vehid][cRegister], string, 0, strlen(string), 12);
			orm_update(CarInfo[vehid][cOrm]);

		    SetVehicleNumberPlate(vehid, string);
			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Pojazd został pomyślnie zarejestrowany.\nTablice rejestracyjne zmieniły się automatycznie.");
		}

		if(offer_type == OFFER_HEAL)
		{
			if(offer_price)
		    {
	   			new group_cash = floatround(0.90 * offer_price),
					playercash = floatround(0.10 * offer_price);

				if(OfferData[playerid][oPayType] == PAY_TYPE_CASH)
		        {
				    crp_GivePlayerMoney(playerid, -offer_price);
					crp_GivePlayerMoney(offererid, playercash);
				}
				else
				{
				    PlayerCache[playerid][pBankCash] -= offer_price;
				    PlayerCache[offererid][pBankCash] += playercash;
				}
				new group_id = PlayerCache[offererid][pDuty][DUTY_GROUP];
				
				GroupData[group_id][gCash] += group_cash;
				orm_update(GroupData[group_id][gOrm]);
				
				AddGroupTransactionLog(offererid, group_id, TRANSACTION_OFFER, group_cash, offer_type, 0);
				ShowPlayerInfoDialog(offererid, D_TYPE_INFO, "Otrzymałeś premię w wysokości $%d!\n\nNa konto grupy dodano: $%d\nPunkty aktywności: +%d", playercash, group_cash);
			}
			PlayerCache[offererid][pHealing] = playerid;

			ShowPlayerInfoDialog(offererid, D_TYPE_INFO, "Postanowiłeś uleczyć gracza %s.\nProces leczenia potrwa chwile, nie oddalaj się od pacjenta.", PlayerName(playerid));
			ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Gracz %s postanowił Cię uleczyć.\nProces leczenia potrwa chwile, nie oddalaj się od medyka.", PlayerName(offererid));
		}

		if(offer_type == OFFER_PASS)
		{
			if(!(PlayerCache[playerid][pAdmin] & A_PERM_ITEMS) && GetPlayerCapacity(playerid) <= 0)
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Twoja postać nie jest w stanie unieść więcej przedmiotów.");
				OnPlayerRejectOffer(playerid, offererid);
				return 1;
			}
			if(offer_price)
		    {
	   			new group_cash = floatround(0.40 * offer_price),
					playercash = floatround(0.10 * offer_price);

				if(OfferData[playerid][oPayType] == PAY_TYPE_CASH)
		        {
				    crp_GivePlayerMoney(playerid, -offer_price);
					crp_GivePlayerMoney(offererid, playercash);
				}
				else
				{
				    PlayerCache[playerid][pBankCash] -= offer_price;
				    PlayerCache[offererid][pBankCash] += playercash;
				}
				new group_id = PlayerCache[offererid][pDuty][DUTY_GROUP];
				
				GroupData[group_id][gCash] += group_cash;
				orm_update(GroupData[group_id][gOrm]);
				
				AddGroupTransactionLog(offererid, group_id, TRANSACTION_OFFER, group_cash, offer_type, 0);
				ShowPlayerInfoDialog(offererid, D_TYPE_INFO, "Otrzymałeś premię w wysokości $%d!\n\nNa konto grupy dodano: $%d", playercash, group_cash);
			}
			new pass_time = OfferData[playerid][oValue1], group_uid = OfferData[playerid][oValue2];
	        CreatePlayerItem(playerid, OfferData[playerid][oName], ITEM_PASS, pass_time, group_uid);

	        ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Otrzymałeś karnet na siłownię.\nSkorzystaj z komendy /p, aby użyć przedmiotu.\n\nPo użyciu karnetu będziesz mógł korzystać\nz obiektów sportowych w budynku tej firmy.");
		}

		if(offer_type == OFFER_WELCOME)
		{
		    if(!PlayerToPlayer(5.0, playerid, offererid))
		    {
	  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
	  			OnPlayerRejectOffer(playerid, offererid);
		        return 1;
		    }

			new welcome_type = OfferData[playerid][oValue1],
			    Float:PosX, Float:PosY, Float:PosZ, Float:PosA;

			GetPlayerPos(offererid, PosX, PosY, PosZ);

			if(welcome_type <= 6)	GetXYInFrontOfPlayer(offererid, PosX, PosY, 1.0);
			else					GetXYInFrontOfPlayer(offererid, PosX, PosY, 0.5);

			GetPlayerFacingAngle(offererid, PosA);

			SetPlayerPos(playerid, PosX, PosY, PosZ);
			SetPlayerFacingAngle(playerid, (floatabs(PosA) - 180.0));

			switch(welcome_type)
			{
			    case 1:
			    {
	  				ApplyAnimation(offererid, "GANGS", "hndshkfa", 4.1, 0, 0, 0, 0, 0, 1);
					ApplyAnimation(playerid, "GANGS", "hndshkfa", 4.1, 0, 0, 0, 0, 0, 1);
			    }
			    case 2:
			    {
	  				ApplyAnimation(offererid, "GANGS", "hndshkba", 4.1, 0, 0, 0, 0, 0, 1);
					ApplyAnimation(playerid, "GANGS", "hndshkba", 4.1, 0, 0, 0, 0, 0, 1);
			    }
			    case 3:
			    {
			    	ApplyAnimation(offererid, "GANGS", "hndshkaa", 4.1, 0, 0, 0, 0, 0, 1);
					ApplyAnimation(playerid, "GANGS", "hndshkaa", 4.1, 0, 0, 0, 0, 0, 1);
			    }
			    case 4:
			    {
	  				ApplyAnimation(offererid, "GANGS", "hndshkda", 4.1, 0, 0, 0, 0, 0, 1);
					ApplyAnimation(playerid, "GANGS", "hndshkda", 4.1, 0, 0, 0, 0, 0, 1);
			    }
			    case 5:
			    {
	  				ApplyAnimation(offererid, "GANGS", "hndshkca", 4.1, 0, 0, 0, 0, 0, 1);
					ApplyAnimation(playerid, "GANGS", "hndshkca", 4.1, 0, 0, 0, 0, 0, 1);
			    }
			    case 6:
			    {
	  				ApplyAnimation(offererid, "GANGS", "hndshkcb", 4.1, 0, 0, 0, 0, 0, 1);
					ApplyAnimation(playerid, "GANGS", "hndshkcb", 4.1, 0, 0, 0, 0, 0, 1);
			    }
			    case 7:
			    {
	  				ApplyAnimation(offererid, "GANGS", "prtial_hndshk_biz_01", 4.1, 0, 0, 0, 0, 0, 1);
					ApplyAnimation(playerid, "GANGS", "prtial_hndshk_biz_01", 4.1, 0, 0, 0, 0, 0, 1);
			    }
			    case 8:
			    {
					ApplyAnimation(offererid, "KISSING", "Playa_Kiss_01", 4.1, 0, 0, 0, 0, 0, 1);
					ApplyAnimation(playerid, "KISSING", "Playa_Kiss_01", 4.1, 0, 0, 0, 0, 0, 1);
				}
				case 9:
				{
					ApplyAnimation(offererid, "KISSING", "Playa_Kiss_02", 4.1, 0, 0, 0, 0, 0, 1);
					ApplyAnimation(playerid, "KISSING", "Playa_Kiss_02", 4.1, 0, 0, 0, 0, 0, 1);
				}
				case 10:
				{
					ApplyAnimation(offererid, "KISSING", "Playa_Kiss_03", 4.1, 0, 0, 0, 0, 0, 1);
					ApplyAnimation(playerid, "KISSING", "Playa_Kiss_03", 4.1, 0, 0, 0, 0, 0, 1);
				}
			}
		}

		if(offer_type == OFFER_ADVERTISE)
		{
		    if(offer_price)
		    {
		        new group_cash = floatround(0.90 * offer_price),
		            playercash = floatround(0.10 * offer_price);

				if(OfferData[playerid][oPayType] == PAY_TYPE_CASH)
		        {
				    crp_GivePlayerMoney(playerid, -offer_price);
					crp_GivePlayerMoney(offererid, playercash);
				}
				else
				{
				    PlayerCache[playerid][pBankCash] -= offer_price;
				    PlayerCache[offererid][pBankCash] += playercash;
				}
				new group_id = PlayerCache[offererid][pDuty][DUTY_GROUP];
				
				GroupData[group_id][gCash] += group_cash;
				orm_update(GroupData[group_id][gOrm]);
				
				AddGroupTransactionLog(offererid, group_id, TRANSACTION_OFFER, group_cash, offer_type, 0);
				ShowPlayerInfoDialog(offererid, D_TYPE_INFO, "Otrzymałeś premię w wysokości $%d!\n\nNa konto grupy dodano: $%d", playercash, group_cash);
		    }
		}

		if(offer_type == OFFER_SALON)
		{
		    new veh_ownertype = OWNER_PLAYER, veh_owner = PlayerCache[playerid][pUID],
		        capital_group_id = INVALID_GROUP_ID;
		    
		    if(offer_price)
		    {
	  			new group_cash = floatround(0.09 * offer_price),
					playercash = floatround(0.001 * offer_price);

				if(OfferData[playerid][oPayType] == PAY_TYPE_CASH)
		        {
				    crp_GivePlayerMoney(playerid, -offer_price);
					crp_GivePlayerMoney(offererid, playercash);
				}
				else if(OfferData[playerid][oPayType] == PAY_TYPE_CAPITAL)
				{
					capital_group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
					GroupData[capital_group_id][gCapital] -= offer_price;
					
					PlayerCache[offererid][pBankCash] += playercash;
					
					veh_ownertype = OWNER_GROUP;
					veh_owner = GroupData[capital_group_id][gUID];
				}
				else
				{
				    PlayerCache[playerid][pBankCash] -= offer_price;
				    PlayerCache[offererid][pBankCash] += playercash;
				}
				
				new group_id = PlayerCache[offererid][pDuty][DUTY_GROUP];
				
				GroupData[group_id][gCash] += group_cash;
				orm_update(GroupData[group_id][gOrm]);
				
				ShowPlayerInfoDialog(offererid, D_TYPE_INFO, "Otrzymałeś premię w wysokości $%d!\n\nNa konto grupy dodano: $%d", playercash, group_cash);
		    }
		    new veh_model = OfferData[playerid][oValue1], vehid, spawn_point = random(sizeof(SalonSpawnPos)), color = random(36);
		    vehid = CreateStaticVehicle(veh_model, SalonSpawnPos[spawn_point][0], SalonSpawnPos[spawn_point][1], SalonSpawnPos[spawn_point][2], SalonSpawnPos[spawn_point][3], color, color, 3600);

	  		SetPlayerCheckpoint(playerid, SalonSpawnPos[spawn_point][0], SalonSpawnPos[spawn_point][1], SalonSpawnPos[spawn_point][2], 5.0);
	    	PlayerCache[playerid][pCheckpoint] = CHECKPOINT_VEHICLE;

			CarInfo[vehid][cOwnerType] = veh_ownertype;
			CarInfo[vehid][cOwner] = veh_owner;

			orm_update(CarInfo[vehid][cOrm]);
	  		ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Gratulacje! Zakupiłeś nowy pojazd.\nUdaj się w wyznaczone miejsce na mapie, by odebrać swój pojazd.\n\nZapoznaj się również z komendą /pojazd.");

            if(capital_group_id != INVALID_GROUP_ID)	AddGroupTransactionLog(playerid, capital_group_id, TRANSACTION_SERVICE, -offer_price, offer_type, CarInfo[vehid][cUID]);
		}

		if(offer_type == OFFER_TAX)
		{
	 		if(offer_price)
		    {
	  			new group_cash = floatround(0.90 * offer_price),
					playercash = floatround(0.10 * offer_price);

				if(OfferData[playerid][oPayType] == PAY_TYPE_CASH)
		        {
				    crp_GivePlayerMoney(playerid, -offer_price);
					crp_GivePlayerMoney(offererid, playercash);
				}
				else if(OfferData[playerid][oPayType] == PAY_TYPE_CAPITAL)
				{
					new capital_group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];

					GroupData[capital_group_id][gCapital] -= offer_price;
					PlayerCache[offererid][pBankCash] += playercash;
				}
				else
				{
				    PlayerCache[playerid][pBankCash] -= offer_price;
				    PlayerCache[offererid][pBankCash] += playercash;
				}
				new group_id = PlayerCache[offererid][pDuty][DUTY_GROUP];
				
				GroupData[group_id][gCash] += group_cash;
				orm_update(GroupData[group_id][gOrm]);
				
				AddGroupTransactionLog(offererid, group_id, TRANSACTION_OFFER, group_cash, offer_type, 0);
				ShowPlayerInfoDialog(offererid, D_TYPE_INFO, "Otrzymałeś premię w wysokości $%d!\n\nNa konto grupy dodano: $%d", playercash, group_cash);
		    }

		    new group_id = OfferData[playerid][oValue1];

		    GroupData[group_id][gLastTax] = gettime();
		    orm_update(GroupData[group_id][gOrm]);

		    ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Podatek za firmę %s (UID: %d) został pomyślnie spłacony.", GroupData[group_id][gName], GroupData[group_id][gUID]);
		}

		if(offer_type == OFFER_KEYS)
		{
			if(!(PlayerCache[playerid][pAdmin] & A_PERM_ITEMS) && GetPlayerCapacity(playerid) <= 0)
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Twoja postać nie jest w stanie unieść więcej przedmiotów.");
			    OnPlayerRejectOffer(playerid, offererid);
   				return 1;
			}
			if(offer_price)
		    {
	  			new group_cash = floatround(0.90 * offer_price),
					playercash = floatround(0.10 * offer_price);

				if(OfferData[playerid][oPayType] == PAY_TYPE_CASH)
		        {
				    crp_GivePlayerMoney(playerid, -offer_price);
					crp_GivePlayerMoney(offererid, playercash);
				}
				else
				{
	   				PlayerCache[playerid][pBankCash] -= offer_price;
				    PlayerCache[offererid][pBankCash] += playercash;
				}
				new group_id = PlayerCache[offererid][pDuty][DUTY_GROUP];
				
				GroupData[group_id][gCash] += group_cash;
				orm_update(GroupData[group_id][gOrm]);
				
				AddGroupTransactionLog(offererid, group_id, TRANSACTION_OFFER, group_cash, offer_type, 0);
				ShowPlayerInfoDialog(offererid, D_TYPE_INFO, "Otrzymałeś premię w wysokości $%d!\n\nNa konto grupy dodano: $%d", playercash, group_cash);
		    }
			new vehid = OfferData[playerid][oValue1];

			format(string, sizeof(string), "Kluczyki do %s", GetVehicleName(CarInfo[vehid][cModel]));
			CreatePlayerItem(playerid, string, ITEM_KEYS, CarInfo[vehid][cUID], 0);

			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Kluczyki do pojazdu %s (UID: %d) zostały pomyślnie wyrobione.\nPrzedmiot pojawił się w Twoim ekwipunku.", GetVehicleName(CarInfo[vehid][cModel]), CarInfo[vehid][cUID]);
		}

		if(offer_type == OFFER_STYLE)
		{
			if(offer_price)
		    {
	  			new group_cash = floatround(0.90 * offer_price),
					playercash = floatround(0.10 * offer_price);

				if(OfferData[playerid][oPayType] == PAY_TYPE_CASH)
		        {
				    crp_GivePlayerMoney(playerid, -offer_price);
					crp_GivePlayerMoney(offererid, playercash);
				}
				else
				{
	   				PlayerCache[playerid][pBankCash] -= offer_price;
				    PlayerCache[offererid][pBankCash] += playercash;
				}
				new group_id = PlayerCache[offererid][pDuty][DUTY_GROUP];
				
				GroupData[group_id][gCash] += group_cash;
				orm_update(GroupData[group_id][gOrm]);
				
				AddGroupTransactionLog(offererid, group_id, TRANSACTION_OFFER, group_cash, offer_type, 0);
				ShowPlayerInfoDialog(offererid, D_TYPE_INFO, "Otrzymałeś premię w wysokości $%d!\n\nNa konto grupy dodano: $%d", playercash, group_cash);
		    }

			new style = OfferData[playerid][oValue1];
			GivePlayerAchievement(playerid, ACHIEVE_STYLE);

			PlayerCache[playerid][pFightStyle] = style + 4;
			SetPlayerFightingStyle(playerid, PlayerCache[playerid][pFightStyle]);

			orm_update(PlayerCache[playerid][pOrm]);
			ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Gratulacje! Twoja postać poznała nową sztukę walki.\nOd teraz podczas walk posługiwać się będzie tylko i wyłącznie nim.\n\nNauczono się nowego stylu: %s", FightStyleData[style][0]);
		}

		if(offer_type == OFFER_LESSON)
		{
			if(offer_price)
		    {
	   			new group_cash = floatround(0.90 * offer_price),
					playercash = floatround(0.10 * offer_price);

				if(OfferData[playerid][oPayType] == PAY_TYPE_CASH)
		        {
				    crp_GivePlayerMoney(playerid, -offer_price);
					crp_GivePlayerMoney(offererid, playercash);
				}
				else
				{
				    PlayerCache[playerid][pBankCash] -= offer_price;
				    PlayerCache[offererid][pBankCash] += playercash;
				}
				new group_id = PlayerCache[offererid][pDuty][DUTY_GROUP];
				
				GroupData[group_id][gCash] += group_cash;
				orm_update(GroupData[group_id][gOrm]);
				
				AddGroupTransactionLog(offererid, group_id, TRANSACTION_OFFER, group_cash, offer_type, 0);
				ShowPlayerInfoDialog(offererid, D_TYPE_INFO, "Otrzymałeś premię w wysokości $%d!\n\nNa konto grupy dodano: $%d", playercash, group_cash);
			}
			new lesson_time = OfferData[playerid][oValue1],
				group_id = OfferData[playerid][oValue2];

			PlayerCache[playerid][pLesson]      = group_id;
			PlayerCache[playerid][pLessonTime] 	= lesson_time * 60;
		}
		
		TD_ShowSmallInfo(playerid, 5, "Oferta od %s zostala ~g~zaakceptowana~w~.", PlayerName(offererid));
		TD_ShowSmallInfo(offererid, 5, "%s ~g~zaakceptowal ~w~Twoja oferte.", PlayerName(playerid));
		
		orm_update(PlayerCache[playerid][pOrm]);
		orm_update(PlayerCache[offererid][pOrm]);

		printf("[offe] %s (UID: %d, GID: %d) zaakceptował ofertę gracza %s (UID: %d, GID: %d). Typ oferty: %s, nazwa: %s, wartości: %d/%d, cena: $%d.", PlayerRealName(playerid), PlayerCache[playerid][pUID], PlayerCache[playerid][pGID], PlayerName(offererid), PlayerCache[offererid][pUID], PlayerCache[offererid][pGID], OfferTypeInfo[OfferData[playerid][oType]][oTypeName], OfferData[playerid][oName], OfferData[playerid][oValue1], OfferData[playerid][oValue2], OfferData[playerid][oPrice]);
	}
	else
	{
	    // Oferta od aktora
	    new actorid = (offererid * -1), ActorData[sActorData];
		Streamer_GetArrayData(STREAMER_TYPE_ACTOR, actorid, E_STREAMER_EXTRA_ID, ActorData);
			
		if(offer_type == OFFER_REPAIR)
		{
		    new veh_uid = OfferData[playerid][oValue1], vehid = GetVehicleID(veh_uid);
			if(vehid == INVALID_VEHICLE_ID)
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Pojazd (UID: %d) prawdopodobnie nie jest zespawnowany.", veh_uid);
			    OnPlayerRejectOffer(playerid, offererid);
			    return 1;
			}
			
			new repair_type = OfferData[playerid][oValue2];
			if(repair_type == 0)
			{
			    // Całkowita naprawa
				strmid(CarInfo[vehid][cVisual], "0 0 0 0", 0, 32);
	  		    CarInfo[vehid][cHealth] = 1000;

				RepairVehicle(vehid);
	    		SetVehicleHealth(vehid, 1000);
			}

			if(repair_type == 1)
			{
			    // Wizualna naprawa
			    strmid(CarInfo[vehid][cVisual], "0 0 0 0", 0, 32);
			    UpdateVehicleDamageStatus(vehid, 0, 0, 0, 0);
			}

			if(repair_type == 2)
			{
			    // Techniczna naprawa
	  		    CarInfo[vehid][cHealth] = 1000;
	    		SetVehicleHealth(vehid, 1000);
			}
			
			if(OfferData[playerid][oPayType] == PAY_TYPE_CASH)
   			{
		    	crp_GivePlayerMoney(playerid, -offer_price);
			}
			else if(OfferData[playerid][oPayType] == PAY_TYPE_CAPITAL)
			{
				new capital_group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
				GroupData[capital_group_id][gCapital] -= offer_price;
			}
			else
			{
   				PlayerCache[playerid][pBankCash] -= offer_price;
			}

			orm_update(CarInfo[vehid][cOrm]);
			SendClientFormatMessage(playerid, COLOR_FADE1, "%s mówi: Proszę bardzo, robota wykonana.", ActorData[aName]);
		}
		
		if(offer_type == OFFER_DOCUMENT)
		{
		    if(PlayerCache[playerid][pDocuments] & OfferData[playerid][oValue1])
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Posiadasz już ten dokument.");
		        OnPlayerRejectOffer(playerid, offererid);
		        return 1;
		    }
		    
			if(OfferData[playerid][oPayType] == PAY_TYPE_CASH)
   			{
		    	crp_GivePlayerMoney(playerid, -offer_price);
			}
			else
			{
   				PlayerCache[playerid][pBankCash] -= offer_price;
			}
		    
			PlayerCache[playerid][pDocuments] += OfferData[playerid][oValue1];
			ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Zakupiłeś nowy dokument.\nUżyj komendy /pokaz, aby zarządzać dokumentami.");
			
			if((PlayerCache[playerid][pDocuments] & DOC_PROOF) && (PlayerCache[playerid][pDocuments] & DOC_DRIVER))	TD_ShowHint(playerid, HINT_DOCUMENT, 15, "~y~Gratulacje! ~w~Wlasnie wszedles w posiadanie ~p~dokumentow ~w~niezbednych do gry. Mozesz teraz przystapic do zarabiania ~g~pieniedzy~w~, by dorobic sie swoich pierwszych czterech kolek, lub mieszkania.~n~~n~Ponownie wejdz w ~r~interakcje ~w~z aktorem (pamietasz klawisz?) i zapytaj go o dostepne ~y~prace dorywcze~w~.");
		}
		
		if(offer_type == OFFER_PRODUCT)
		{
		
		}
		
		if(offer_type == OFFER_REGISTER)
		{
			new veh_uid = OfferData[playerid][oValue1], vehid = GetVehicleID(veh_uid);
			if(vehid == INVALID_VEHICLE_ID)
			{
   				ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Pojazd (UID: %d) prawdopodobnie nie jest zespawnowany.", veh_uid);
		        OnPlayerRejectOffer(playerid, offererid);
			    return 1;
			}
			
			if(OfferData[playerid][oPayType] == PAY_TYPE_CASH)
   			{
		    	crp_GivePlayerMoney(playerid, -offer_price);
			}
			else if(OfferData[playerid][oPayType] == PAY_TYPE_CAPITAL)
			{
				new capital_group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
				GroupData[capital_group_id][gCapital] -= offer_price;
				
				AddGroupTransactionLog(playerid, capital_group_id, TRANSACTION_SERVICE, -offer_price, offer_type, veh_uid);
			}
			else
			{
   				PlayerCache[playerid][pBankCash] -= offer_price;
			}
			
	        format(string, sizeof(string), "LS%d", CarInfo[vehid][cUID]);

	        strmid(CarInfo[vehid][cRegister], string, 0, strlen(string), 12);
			orm_update(CarInfo[vehid][cOrm]);

		    SetVehicleNumberPlate(vehid, string);
			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Pojazd został pomyślnie zarejestrowany.\nTablice rejestracyjne zmieniły się automatycznie.");
		}
		
		if(offer_type == OFFER_SALON)
		{
  			new veh_ownertype = OWNER_PLAYER, veh_owner = PlayerCache[playerid][pUID],
  			    capital_group_id = INVALID_GROUP_ID;

		    if(offer_price)
		    {
				if(OfferData[playerid][oPayType] == PAY_TYPE_CASH)
		        {
				    crp_GivePlayerMoney(playerid, -offer_price);
				}
				else if(OfferData[playerid][oPayType] == PAY_TYPE_CAPITAL)
				{
					capital_group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
					GroupData[capital_group_id][gCapital] -= offer_price;

					veh_ownertype = OWNER_GROUP;
					veh_owner = GroupData[capital_group_id][gUID];
				}
				else
				{
				    PlayerCache[playerid][pBankCash] -= offer_price;
				}
		    }
		    new veh_model = OfferData[playerid][oValue1], vehid, spawn_point = random(sizeof(SalonSpawnPos)), color = random(36);
		    vehid = CreateStaticVehicle(veh_model, SalonSpawnPos[spawn_point][0], SalonSpawnPos[spawn_point][1], SalonSpawnPos[spawn_point][2], SalonSpawnPos[spawn_point][3], color, color, 3600);

	  		SetPlayerCheckpoint(playerid, SalonSpawnPos[spawn_point][0], SalonSpawnPos[spawn_point][1], SalonSpawnPos[spawn_point][2], 5.0);
	    	PlayerCache[playerid][pCheckpoint] = CHECKPOINT_VEHICLE;

			CarInfo[vehid][cOwnerType] = veh_ownertype;
			CarInfo[vehid][cOwner] = veh_owner;

			orm_update(CarInfo[vehid][cOrm]);
	  		ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Gratulacje! Zakupiłeś nowy pojazd.\nUdaj się w wyznaczone miejsce na mapie, by odebrać swój pojazd.\n\nZapoznaj się również z komendą /pojazd.");

            if(capital_group_id != INVALID_GROUP_ID)	AddGroupTransactionLog(playerid, capital_group_id, TRANSACTION_SERVICE, -offer_price, offer_type, CarInfo[vehid][cUID]);
		}
		
		TD_ShowSmallInfo(playerid, 5, "Oferta od %s (aktor) zostala ~g~zaakceptowana~w~.", ActorData[aName]);
	}
	
	TextDrawHideForPlayer(playerid, TextDrawOfferAccept);
	TextDrawHideForPlayer(playerid, TextDrawOfferReject);
	
	TextDrawHideForPlayer(playerid, TextDrawOfferBack);
	PlayerTextDrawHide(playerid, TextDrawOfferDesc[playerid]);
	
	CancelSelectTextDraw(playerid);
	
	OfferData[playerid][oOffererID]		= INVALID_PLAYER_ID;
	OfferData[playerid][oType]  		= 0;

	OfferData[playerid][oValue1] 		= 0;
	OfferData[playerid][oValue2] 		= 0;

	OfferData[playerid][oPrice] 		= 0;
	OfferData[playerid][oPayType] 		= PAY_TYPE_NONE;
	return 1;
}

public OnPlayerRejectOffer(playerid, offererid)
{
	if(offererid >= 0)
	{
		TD_ShowSmallInfo(playerid, 5, "Oferta od %s zostala ~r~odrzucona~w~.", PlayerName(offererid));
		TD_ShowSmallInfo(offererid, 5, "%s ~r~odrzucil ~w~Twoja oferte.", PlayerName(playerid));

		printf("[offe] %s (UID: %d, GID: %d) odrzucił ofertę gracza %s (UID: %d, GID: %d). Typ oferty: %s, nazwa: %s, wartości: %d/%d, cena: $%d.", PlayerRealName(playerid), PlayerCache[playerid][pUID], PlayerCache[playerid][pGID], PlayerName(offererid), PlayerCache[offererid][pUID], PlayerCache[offererid][pGID], OfferTypeInfo[OfferData[playerid][oType]][oTypeName], OfferData[playerid][oName], OfferData[playerid][oValue1], OfferData[playerid][oValue2], OfferData[playerid][oPrice]);
	}
	else
	{
	    // Oferta od aktora
	    new actorid = (offererid * -1), ActorData[sActorData];
	    Streamer_GetArrayData(STREAMER_TYPE_ACTOR, actorid, E_STREAMER_EXTRA_ID, ActorData);
	    
	    TD_ShowSmallInfo(playerid, 5, "Oferta od %s (aktor) zostala ~r~odrzucona~w~.", ActorData[aName]);
	}
	TextDrawHideForPlayer(playerid, TextDrawOfferAccept);
	TextDrawHideForPlayer(playerid, TextDrawOfferReject);

	TextDrawHideForPlayer(playerid, TextDrawOfferBack);
	PlayerTextDrawHide(playerid, TextDrawOfferDesc[playerid]);
	
	CancelSelectTextDraw(playerid);

	OfferData[playerid][oOffererID]		= INVALID_PLAYER_ID;
	OfferData[playerid][oType]  		= 0;
	
	OfferData[playerid][oValue1] 		= 0;
	OfferData[playerid][oValue2] 		= 0;

	OfferData[playerid][oPrice] 		= 0;
	OfferData[playerid][oPayType] 		= PAY_TYPE_NONE;
	return 1;
}

public OnPlayerEnterDoor(playerid, doorid)
{
	new DoorData[sDoorInfo],
		freeze_time = 3;
		
	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	
   	if(DoorData[dLocked])
    {
    	GameTextForPlayer(playerid, "~n~~n~~n~~n~~n~~r~Drzwi sa zamkniete", 4000, 3);
     	return 1;
    }
    if(PlayerCache[playerid][pCash] < DoorData[dEnterPay])
    {
    	GameTextForPlayer(playerid, "~n~~n~~n~~n~~n~~r~Brak gotowki na wstep", 4000, 3);
    	return 1;
    }
    if(!DoorData[dExitX])
    {
    	GameTextForPlayer(playerid, "~n~~n~~n~~n~~n~~w~Wnetrze jest w trakcie ~p~~h~remontu", 4000, 3);
     	return 1;
    }
   	if(PlayerCache[playerid][pRoll])
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz wejść do budynku mając rolki na nogach.");
	    return 1;
	}
	if(DoorData[dFireData][FIRE_TIME] > 0)
	{
	    if(!IsPlayerInGroupType(playerid, G_TYPE_FIREDEPT))
		{
	    	ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Ten budynek płonie!\n\nZadzwoń po służby porządkowe, w przeciwnym wypadku\nbudynek ulegnie całkowitemu zniszczeniu!");
	    	return 1;
		}
		CreateExplosion(DoorData[dExitX], DoorData[dExitY], DoorData[dExitZ], 9, 5.0);
		TD_ShowHint(playerid, HINT_NONE, 10, "Wszedles do ~r~palacego ~w~sie budynku. Uzywaj ~y~gasnicy ~w~by gasic pozar.~n~~n~Plomienie beda sie co chwile ~r~pojawiac~w~. Wypatruj ich i ~y~ugaszaj ~w~pozar bys nie splonal!");
	}
	if(PlayerCache[playerid][pFreeze] > 0)
	{
	    return 1;
	}
	if(DoorData[dExitVW] != 0 && !DoorData[dObjectsLoaded] && DoorData[dExitVW] != Streamer_GetIntData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_WORLD_ID))
	{
 		new query[512];
		mysql_format(connHandle, query, sizeof(query), "SELECT "SQL_PREF"objects.*, "SQL_PREF"materials.material_texture FROM "SQL_PREF"objects LEFT JOIN "SQL_PREF"materials on "SQL_PREF"objects.object_uid = "SQL_PREF"materials.material_owner WHERE "SQL_PREF"objects.object_world = '%d' ORDER BY "SQL_PREF"objects.object_uid ASC", DoorData[dExitVW]);
 		mysql_tquery(connHandle, query, "query_OnLoadObjects", "");

	    DoorData[dObjectsLoaded] = true;
		Streamer_SetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	    
	    freeze_time = 5;
	}
   	if(strlen(DoorData[dAudioURL]))
	{
	    if(PlayerCache[playerid][pItemPlayer] != INVALID_ITEM_ID)
	    {
	        new itemid = PlayerCache[playerid][pItemPlayer];
	        PlayerItemCache[playerid][itemid][iUsed] = false;
	    }
	    PlayStreamedAudioForPlayer(playerid, DoorData[dAudioURL]);
	}
	OnPlayerFreeze(playerid, true, freeze_time);
	Streamer_UpdateEx(playerid, DoorData[dExitX], DoorData[dExitY], DoorData[dExitZ], DoorData[dExitVW], DoorData[dExitInt], STREAMER_TYPE_OBJECT);

	if(!IsPlayerInAnyVehicle(playerid))
	{
	    crp_SetPlayerPos(playerid, DoorData[dExitX], DoorData[dExitY], DoorData[dExitZ]);
	    SetPlayerFacingAngle(playerid, DoorData[dExitA]);

		SetPlayerInterior(playerid, DoorData[dExitInt]);
		SetPlayerVirtualWorld(playerid, DoorData[dExitVW]);
	}
	else
	{
	    new vehid = GetPlayerVehicleID(playerid), seatid = GetPlayerVehicleSeat(playerid);

		PlayerCache[playerid][pPosX] = DoorData[dExitX];
		PlayerCache[playerid][pPosY] = DoorData[dExitY];
		PlayerCache[playerid][pPosZ] = DoorData[dExitZ];
		
		foreach(new i : Player)
		{
		    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
		    {
	  			if(GetPlayerVehicleID(i) == vehid)
	    		{
					SetPlayerVirtualWorld(i, DoorData[dExitVW]);
					SetPlayerInterior(i, DoorData[dExitInt]);
				}
			}
		}
		
		SetVehicleVirtualWorld(vehid, DoorData[dExitVW]);
		SetVehiclePos(vehid, PlayerCache[playerid][pPosX], PlayerCache[playerid][pPosY], PlayerCache[playerid][pPosZ]);

		SetVehicleZAngle(vehid, DoorData[dExitA]);
		LinkVehicleToInterior(vehid, DoorData[dExitInt]);
		
		PutPlayerInVehicle(playerid, vehid, seatid);
	}
	CancelEdit(playerid);

	TD_HideDoor(playerid);
	ResetPlayerCamera(playerid);
	
	if(DoorData[dHour] != 0)	SetPlayerTime(playerid, DoorData[dHour], 0);

	// Zabierz graczowi kasę za wstęp i przelej ją na konto właściciela
 	if(DoorData[dEnterPay])
    {
        if(PlayerCache[playerid][pHours] > 5)
        {
			crp_GivePlayerMoney(playerid, -DoorData[dEnterPay]);
			orm_update(PlayerCache[playerid][pOrm]);
			
	        if(DoorData[dOwnerType] == OWNER_PLAYER)
	        {
				new owner_id = GetPlayerID(DoorData[dOwner]);
				if(owner_id != INVALID_PLAYER_ID && PlayerCache[owner_id][pLogged] && PlayerCache[owner_id][pSpawned])
				{
					PlayerCache[owner_id][pBankCash] += DoorData[dEnterPay];
					orm_update(PlayerCache[owner_id][pOrm]);
				}
				else
				{
				    mysql_query_format("UPDATE `"SQL_PREF"characters` SET char_bankcash = char_bankcash + %d WHERE char_uid = '%d' LIMIT 1", DoorData[dEnterPay], DoorData[dOwner]);
				}
	        }
	        if(DoorData[dOwnerType] == OWNER_GROUP)
	        {
	            new group_id = GetGroupID(DoorData[dOwner]);
	            
	            GroupData[group_id][gCash] += DoorData[dEnterPay];
	            orm_update(GroupData[group_id][gOrm]);
	        }
		}
    }
    
    // Podatek & samouczek
    if(DoorData[dOwnerType] == OWNER_GROUP)
    {
		if(IsPlayerInGroup(playerid, DoorData[dOwner]))
		{
			new group_id = GetPlayerGroupID(playerid, DoorData[dOwner]);
			if(GroupData[group_id][gFlags] & G_FLAG_TAX)
			{
			    if(GroupData[group_id][gLastTax] + (7 * 86000) <= gettime())
			    {
			    /*
					new year, month, day, hour, minute, second;
					TimestampToDate(GroupData[group_id][gLastTax] + (15 * 86000), year, month, day, hour, minute, second, 1);

			        ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Uwaga! Firma ta nie wywiązała się z obowiązku spłaty podatku.\nZaleca się jak najprędzej spłacić dług, w przeciwnym wypadku firma zostanie usunięta!\n\nPodatek zapłacić można w Urzędzie Miasta, udaj się tam i poproś urzędnika o ofertę.\nAktywność firmy wygasa: %02d/%02d/%d %02d:%02d", day, month, year, hour, minute);
				*/
				}
			}
			/*
			// Ograniczona slużba
			if(GroupData[group_id][gFlags] & G_FLAG_DUTY)
			{
			    if(PlayerCache[playerid][pDuty][DUTY_GROUP] == group_id)
				{
				    if(PlayerCache[playerid][pSession][SESSION_NONE] != 0)
				    {
						PlayerCache[playerid][pSession][SESSION_GROUP] += (gettime() - PlayerCache[playerid][pSession][SESSION_NONE]);
						PlayerCache[playerid][pSession][SESSION_NONE] = 0;
				    }
				}
			}
			*/

			// Przemycony towar
			if(MissionData[playerid][mUID] != 0)
			{
			    if(MissionData[playerid][mType] == MISSION_SMUGGLE && MissionData[playerid][mLevel] == 3)
			    {
			        if(MissionData[playerid][mLeader] && MissionData[playerid][mGroup] == group_id)
			        {
						GroupData[group_id][gCash] += MissionData[playerid][mAward];
						orm_update(GroupData[group_id][gOrm]);

						switch(random(1))
						{
		    				case 0:
						    {
						        new weapon_id = 22 + random(10);
          						CreateDoorProduct(doorid, "Bron z przemytu", ITEM_WEAPON, weapon_id, (GetWeaponType(weapon_id) == WEAPON_TYPE_LIGHT) ? random(70) : random(300), 1, MissionData[playerid][mMembers]);
						    }
						    case 1:
						    {
			       				new drug_type = random(5);
		        				CreateDoorProduct(doorid, DrugTypeInfo[drug_type][dName], ITEM_DRUG, drug_type, 1, 1, MissionData[playerid][mMembers] * 20);
						    }
						}
			            foreach(new i : MissionPlayer[playerid])
			            {
			                TD_ShowHint(i, HINT_NONE, 15, "Zadanie zostalo ~g~pomyslnie ~w~wykonane! Na konto grupy ~y~%s (UID: %d) ~w~zostalo dodane ~g~$%d~w~.~n~~n~W magazynie grupy pojawil sie takze ~b~losowy ~w~towar (~p~/g magazyn~w~), ktory mozecie wykorzystac do gry.", GroupData[group_id][gName], GroupData[group_id][gUID], MissionData[playerid][mAward]);
						}
						DeleteMission(MissionData[playerid][mUID]);
						
						// Jeśli ktoś chciał przerwać zadanie
						new mission_uid;
						foreach(new i : Player)
						{
						    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
						    {
						        if(MissionData[i][mUID] != 0 && MissionData[i][mType] == MISSION_CHASE)
						        {
						            if(MissionData[i][mVictim] == PlayerCache[playerid][pUID])
						            {
						                mission_uid = MissionData[i][mUID];
										TD_ShowHint(i, HINT_NONE, 10, "~r~Lider ~w~grupy przemytniczej dotarl do swojej ~y~siedziby~w~. Zadanie ~r~nie zostalo ~w~wykonane prawidlowo.");
						            }
						        }
						    }
						}
						DeleteMission(mission_uid);
			        }
			    }
			}
			
		}
		
		new group_id = GetGroupID(DoorData[dOwner]);
		switch(GroupData[group_id][gType])
		{
		    case G_TYPE_GOV:
		    {
		        TD_ShowHint(playerid, HINT_GOV, 15, "Wszedles do ~y~Ratusza~w~, udaj sie do okienka i patrzac na stojacego tam aktora wcisnij klawisz ~r~Y~w~.~n~~n~Ten klawisz odpowiada za ~y~interakcje ~w~z otoczeniem i jest bardzo obszernie rozbudowany, jednak dowiesz sie o nim wiecej w dalszym etapie gry.~n~~n~Wyrob sobie ~y~identyfikator ~w~(dowod osobisty) i ~y~licencje ~w~(prawo jazdy), te z pewnoscia przydadza Ci sie do gry. :)");
		    }
		    case G_TYPE_BANK:
		    {
		        TD_ShowHint(playerid, HINT_BANK, 15, "Wlasnie wszedles do ~y~banku~w~! Uzyj komendy ~p~/bank~w~, by zalozyc swoje konto bankowe i moc placic za uslugi za pomoca ~y~karty kredytowej~w~.~n~~n~Bedziesz mogl rowniez trzymac tutaj swoje oszczednosci, a nawet dokonywac ~y~przelewow ~w~(pod warunkiem ze znasz numer konta innego gracza).~n~~n~Sprawdz swoj ~y~stan konta ~w~po zalozeniu - wydaje sie, ze cos tam jest.");
		    }
		    case G_TYPE_24/7:
		    {
		        TD_ShowHint(playerid, HINT_24/7, 15, "W sklepach 24/7 jest cos takiego jak ~y~samoobsluga~w~. Za lada stoi aktor, ktory zaoferuje Ci ~b~przedmiot~w~, ktorym bedziesz mogl pozniej zarzadzac.~n~~n~Odegraj akcje zakupow a nastepnie podejdz do aktora (lub wpisz ~p~/kup~w~) i dokonaj z nim ~y~interakcji ~w~przytrzymujac klawisz ~y~Y~w~.~n~~n~Warto zaopatrzyc sie w podstawowe rzeczy takie jak ~b~telefon~w~, lub ~b~papierosy~w~.");
		    }
		    case G_TYPE_HOTEL:
		    {
		        TD_ShowHint(playerid, HINT_HOTEL, 15, "W hotelu mieszka wielu ludzi, na poczatku zanim dorobisz sie swoich ~y~wlasnych ~w~czterech katow musisz byc skazany na takie zakwaterowanie.~n~~n~Dzieki hotelom bedziesz przy ~y~kazdym wejsciu ~w~do gry pojawial sie w swoim wlasnym pokoju.~n~~n~Oczwiscie kazdy hotel pobiera symboliczna oplate (~p~/hotel koszt~w~) od Ciebie przy rozdaniu wyplat.~n~~n~Komenda ~p~/hotel zamelduj ~w~przydzieli Ci swoj ~g~unikalny ~w~pokoj.");
		    }
		}
	}
	
	printf("[door] %s (UID: %d, GID: %d) wszedł przez drzwi %s (UID: %d). Koszt: $%d", PlayerRealName(playerid), PlayerCache[playerid][pUID], PlayerCache[playerid][pGID], DoorData[dName], DoorData[dUID], DoorData[dEnterPay]);
	return 1;
}

public OnPlayerExitDoor(playerid, doorid)
{
	new DoorData[sDoorInfo];
	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	
	new Float:door_enter[3], door_entervw, door_enterint;
	Streamer_GetItemPos(STREAMER_TYPE_PICKUP, doorid, door_enter[0], door_enter[1], door_enter[2]);
	
	door_entervw = Streamer_GetIntData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_WORLD_ID);
	door_enterint = Streamer_GetIntData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_INTERIOR_ID);
	
	if(DoorData[dLocked])
 	{
  		GameTextForPlayer(playerid, "~n~~n~~n~~n~~n~~r~Drzwi sa zamkniete.", 4000, 3);
  		return 1;
 	}
	if(PlayerCache[playerid][pFreeze] > 0)
	{
	    return 1;
	}
 	if(strlen(DoorData[dAudioURL]))
 	{
  		if(PlayerCache[playerid][pItemPlayer] != INVALID_ITEM_ID)
	    {
	        new itemid = PlayerCache[playerid][pItemPlayer];
	        PlayerItemCache[playerid][itemid][iUsed] = false;
	    }
		StopStreamedAudioForPlayer(playerid);
	}
	
	if(PlayerCache[playerid][pItemPass] != INVALID_ITEM_ID)
	{
	    new itemid = PlayerCache[playerid][pItemPass];
	    
		PlayerItemCache[playerid][itemid][iUsed] = false;
		PlayerItemCache[playerid][itemid][iValue][0] = PlayerCache[playerid][pGymTime] / 60;

		orm_update(PlayerItemCache[playerid][itemid][iOrm]);

		PlayerCache[playerid][pItemPass]    = INVALID_ITEM_ID;
		PlayerCache[playerid][pGymTime]     = 0;
	}
	
	/*
	// Ograniczona służba
	if(PlayerCache[playerid][pDuty][DUTY_GROUP] != INVALID_GROUP_ID)
	{
	    if(door_entervw != GetPlayerVirtualWorld(playerid))
	    {
		    new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
		    if(GroupData[group_id][gFlags] & G_FLAG_DUTY)
		    {
		        PlayerCache[playerid][pSession][SESSION_NONE] = gettime();
		        TD_ShowSmallInfo(playerid, 5, "Grupa na ktorej sluzbie jestes ma ~r~ograniczona sluzbe~w~, ktora liczy sie tylko wewnatrz ~y~budynku ~w~lub ~y~strefie~w~.");
		    }
		}
	}
	*/
	
	OnPlayerFreeze(playerid, true, 3);
	Streamer_UpdateEx(playerid, door_enter[0], door_enter[1], door_enter[2], door_entervw, door_enterint, STREAMER_TYPE_OBJECT);

  	if(!IsPlayerInAnyVehicle(playerid))
  	{
		crp_SetPlayerPos(playerid, door_enter[0], door_enter[1], door_enter[2]);
	  	SetPlayerFacingAngle(playerid, DoorData[dEnterA]);

		SetPlayerInterior(playerid, door_enterint);
	 	SetPlayerVirtualWorld(playerid, door_entervw);
	}
	else
	{
	    new vehid = GetPlayerVehicleID(playerid), seatid = GetPlayerVehicleSeat(playerid);

		PlayerCache[playerid][pPosX] = door_enter[0];
		PlayerCache[playerid][pPosY] = door_enter[1];
		PlayerCache[playerid][pPosZ] = door_enter[2];
		
		foreach(new i : Player)
		{
			if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
			{
	  			if(GetPlayerVehicleID(i) == vehid)
		    	{
					SetPlayerVirtualWorld(i, door_entervw);
					SetPlayerInterior(i, door_enterint);
				}
			}
		}

		SetVehicleVirtualWorld(vehid, door_entervw);
		SetVehiclePos(vehid, PlayerCache[playerid][pPosX], PlayerCache[playerid][pPosY], PlayerCache[playerid][pPosZ]);

		SetVehicleZAngle(vehid, DoorData[dEnterA]);
		LinkVehicleToInterior(vehid, door_enterint);
		
		PutPlayerInVehicle(playerid, vehid, seatid);
	}
	CancelEdit(playerid);
    
	ResetPlayerCamera(playerid);
	SetPlayerTime(playerid, WorldTime, 0);
	
	printf("[door] %s (UID: %d, GID: %d) wyszedł przez drzwi %s (UID: %d).", PlayerRealName(playerid), PlayerCache[playerid][pUID], PlayerCache[playerid][pGID], DoorData[dName], DoorData[dUID]);
	return 1;
}

public OnPlayerEnterDynamicArea(playerid, areaid)
{
	new AreaData[sAreaData];
	Streamer_GetArrayData(STREAMER_TYPE_AREA, areaid, E_STREAMER_EXTRA_ID, AreaData);
	
	/*
	if(AreaData[aOwnerType] == OWNER_GROUP)
	{
	    if(PlayerCache[playerid][pDuty][DUTY_GROUP] != INVALID_GROUP_ID)
	    {
	        new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
			if(GroupData[group_id][gFlags] & G_FLAG_DUTY)
			{
			    if(GroupData[group_id][gUID] == AreaData[aOwner])
				{
				    if(PlayerCache[playerid][pSession][SESSION_NONE] != 0)
				    {
						PlayerCache[playerid][pSession][SESSION_GROUP] += (gettime() - PlayerCache[playerid][pSession][SESSION_NONE]);
						PlayerCache[playerid][pSession][SESSION_NONE] = 0;
				    }
				}
			}
		}
	}
	*/
	if(AreaData[aFlags] & A_FLAG_LUMBERJACK)
	{
	    if(WorkInfo[playerid][wID] == JOB_LUMBERJACK)
	    {
	        SetPlayerAttachedObject(playerid, SLOT_EXTRA, 341, 6);
			TD_ShowHint(playerid, HINT_NONE, 15, "Praca drwala~n~~n~Podejdz do pobliskiego ~r~drzewa~w~, a nastepnie uzyj klawisza ~y~LPM~w~, by scinac drzewo i zbierac z nich drewno.~n~~n~Sciete drewno magazynowac bedziesz w swoim ~b~ekwipunku~w~, ktore mozesz pozniej ~g~sprzedac ~w~w tartaku.");

			WorkInfo[playerid][wValue][0] = areaid;
			
			new objData[sObjectData],
				Float:PosX, Float:PosY, Float:PosZ, virtual_world = GetPlayerVirtualWorld(playerid);

			GetPlayerPos(playerid, PosX, PosY, PosZ);

			new ObjectData[MAX_VIS_OBJECTS], object_id = INVALID_OBJECT_ID,
				count_objects = Streamer_GetNearbyItems(PosX, PosY, PosZ, STREAMER_TYPE_OBJECT, ObjectData, MAX_VIS_OBJECTS, 100.0, 9999);

			for (new object = 0; object < count_objects; object++)
			{
   				object_id = ObjectData[object];
				if(GetObjectModel(object_id) == OBJECT_TREE)
				{
					Streamer_GetArrayData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_EXTRA_ID, objData);
					if(objData[objExtraID] != 0 && gettime() - objData[objExtraID] > 3600)
					{
						Streamer_SetIntData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_WORLD_ID, virtual_world);
						Streamer_SetFloatData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_R_Y, 0.0);
					}
				}
			}
			new	Float:objX, Float:objY, Float:objZ;
			object_id = GetClosestObjectType(playerid, OBJECT_TREE, 30.0);
			
			if(object_id != INVALID_OBJECT_ID)
			{
				GetDynamicObjectPos(object_id, objX, objY, objZ);
				SetPlayerCheckpoint(playerid, objX, objY, objZ, 2.0);
			}
			Streamer_Update(playerid, STREAMER_TYPE_OBJECT);
		}
	}
	
 	if(AreaData[aFlags] & A_FLAG_MISSION)
    {
        if(MissionData[playerid][mUID] != 0 && MissionData[playerid][mVictim] == AreaData[aUID])
        {
	    	new mission_uid = MissionData[playerid][mUID], mission_type = MissionData[playerid][mType],
	     		mission_leader = GetMissionLeader(mission_uid);

			if(MissionData[playerid][mDate] + MissionData[playerid][mTime] < gettime())
			{
				foreach(new i : MissionPlayer[mission_leader])
				{
					TD_ShowHint(i, HINT_NONE, 15, "Czas wykonania zadania zostal ~r~przekroczony~w~. Niestety ~r~nie udalo ~w~sie go prawidlowo wykonac.");

					DisablePlayerCheckpoint(i);
					PlayerCache[i][pCheckpoint] = CHECKPOINT_NONE;
				}
				DeleteMission(mission_uid);
			    return 1;
			}

			if(MissionData[playerid][mMembers] > 0)
			{
				new count_members;
			    foreach(new i : MissionPlayer[mission_leader])
			    {
       				if(IsPlayerInDynamicArea(i, areaid))
			        {
						count_members ++;
      				}
		    	}
			    if(count_members < MissionData[playerid][mMembers])
			    {
					TD_ShowSmallInfo(playerid, 5, "Zaczekaj, az wszyscy ~y~czlonkowie ~w~zadania pojawia sie na ~r~miejscu~w~.");
     				return 1;
		    	}
			}
	  		if(mission_type == MISSION_SMUGGLE)
	    	{
				// Przyjazd na miejsce
	   			if(MissionData[playerid][mLevel] == 0)
	      		{
					if(!IsPlayerInAnyVehicle(playerid) || GetPlayerState(playerid) != PLAYER_STATE_DRIVER)
					{
	    				TD_ShowSmallInfo(playerid, 5, "Musicie w to miejsce wjechac ~r~pojazdem ~w~dostawczym.");
					    return 1;
					}
					new vehid = GetPlayerVehicleID(playerid);
					if(!IsVehicleVan(vehid))
					{
	    				TD_ShowSmallInfo(playerid, 5, "Ten pojazd ~r~nie jest ~w~pojazdem dostawczym (np. Rumpo).");
					    return 1;
					}
					new object_id, crates = 0,
						Float:PosX, Float:PosY, Float:PosZ, virtual_world = GetPlayerVirtualWorld(playerid);

					GetPlayerPos(playerid, PosX, PosY, PosZ);

					new ObjectData[MAX_VIS_OBJECTS],
						count_objects = Streamer_GetNearbyItems(PosX, PosY, PosZ, STREAMER_TYPE_OBJECT, ObjectData, MAX_VIS_OBJECTS, 200.0, virtual_world);

					for (new object = 0; object < count_objects; object++)
					{
						object_id = ObjectData[object];
						if(GetObjectModel(object_id) == OBJECT_SMUGGLE_CRATE)
						{
							GetDynamicObjectPos(object_id, PosX, PosY, PosZ);
		 					foreach(new i : MissionPlayer[mission_leader])
							{
			    				SetPlayerMapIcon(i, crates, PosX, PosY, PosZ, 56, 0);
			    				if(!Streamer_IsInArrayData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_PLAYER_ID, i))	Streamer_AppendArrayData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_PLAYER_ID, i);

                                Streamer_Update(i, STREAMER_TYPE_OBJECT);
							}
							crates ++;
						}
					}

					foreach(new i : MissionPlayer[mission_leader])
					{
	    				MissionData[i][mLevel] = 1;

						MissionData[i][mPoints] = 0;
						MissionData[i][mNeedPoints] = crates;

						MissionData[i][mValue][0] = vehid;
		    			MissionData[i][mValue][1] = gettime();

		    			TD_ShowHint(i, HINT_NONE, 0, "Musicie teraz zapakowac ~y~towar ~w~na busa. Na minimapie pokazano miejsca, w ktorych znajduja sie ~r~skrzynki~w~.~n~~n~Podejdz do skrzynki i wcisnij klawisz ~y~Y~w~, by ja podniesc.~n~~n~Zapakowane towary: %d~n~Pozostalo: %d", MissionData[i][mPoints], MissionData[i][mNeedPoints]);
					}
					return 1;
				}
    		}
		}
    }
    
	if(strlen(AreaData[aAudioURL]) > 1)
	{
	    if(PlayerCache[playerid][pItemPlayer] != INVALID_ITEM_ID)	return 1;
	    PlayStreamedAudioForPlayer(playerid, AreaData[aAudioURL]);
	}
	return 1;
}

public OnPlayerLeaveDynamicArea(playerid, areaid)
{
	new AreaData[sAreaData], area_world = Streamer_GetIntData(STREAMER_TYPE_AREA, areaid, E_STREAMER_WORLD_ID);
    Streamer_GetArrayData(STREAMER_TYPE_AREA, areaid, E_STREAMER_EXTRA_ID, AreaData);
    
    // Nie bierz pod uwagę metrażu w budynkach
    if(area_world == 0)
    {
		if(PlayerCache[playerid][pItemBoombox] != INVALID_ITEM_ID)
		{
			new itemid = PlayerCache[playerid][pItemBoombox];
			foreach(new i : Player)
			{
				if(i != playerid)
	   			{
					if(GetPlayerAreaID(i) == areaid)
					{
						StopStreamedAudioForPlayer(i);
					}
				}
			}
			strmid(AreaData[aAudioURL], "", 0, 0, 128);
			StopStreamedAudioForPlayer(playerid);

			PlayerCache[playerid][pItemBoombox] = INVALID_ITEM_ID;
			PlayerItemCache[playerid][itemid][iUsed] = false;

			RemovePlayerAttachedObject(playerid, SLOT_BOOMBOX);
			TD_ShowSmallInfo(playerid, 3, "Odtwarzanie muzyki zostalo ~r~zakonczone~w~.");
		}
		if(strlen(AreaData[aAudioURL]) > 1)
		{
	 		if(PlayerCache[playerid][pItemPlayer] != INVALID_ITEM_ID)	return 1;
			StopStreamedAudioForPlayer(playerid);
		}
		
		if(AreaData[aFlags] & A_FLAG_LUMBERJACK)
		{
		    if(WorkInfo[playerid][wID] == JOB_LUMBERJACK)
		    {
		        RemovePlayerAttachedObject(playerid, SLOT_EXTRA);
		        WorkInfo[playerid][wValue][0] = 0;
		    }
		}
		
		/*
		// Ograniczona służba
		if(AreaData[aOwnerType] == OWNER_GROUP)
		{
			if(PlayerCache[playerid][pDuty][DUTY_GROUP] != INVALID_GROUP_ID)
			{
	  			new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
	  			if(GroupData[group_id][gUID] == AreaData[aOwner])
	  			{
		  			if(GroupData[group_id][gFlags] & G_FLAG_DUTY)
		  			{
		       			PlayerCache[playerid][pSession][SESSION_NONE] = gettime();
		       			TD_ShowSmallInfo(playerid, 5, "Grupa na ktorej sluzbie jestes ma ~r~ograniczona sluzbe~w~, ktora liczy sie tylko wewnatrz ~y~budynku ~w~lub ~y~strefie~w~.");
		  			}
				}
			}
		}
		*/
	}
	else
	{
	    if(GetPlayerVirtualWorld(playerid) != area_world || PlayerCache[playerid][pCreatingArea])    return 1;
	    
	    new doorid = GetDoorID(area_world), DoorData[sDoorInfo];
	    Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	    
		crp_SetPlayerPos(playerid, DoorData[dExitX], DoorData[dExitY], DoorData[dExitZ]);
		TD_ShowSmallInfo(playerid, 3, "Wyszedles poza ustalony metraz drzwi. Zostales przywrocony do prawidlowej pozycji.");
	}
	return 1;
}

public GivePlayerAchievement(playerid, achieve_type)
{
	if((PlayerCache[playerid][pAchievements] & achieve_type))
	{
	    return 1;
	}
	
	new achieve_id = GetAchieveIndex(achieve_type), string[256];
	format(string, sizeof(string), "Zdobyles osiagniecie: ~n~~y~%s", AchieveInfo[achieve_id][aName]);

	if(AchieveInfo[achieve_id][aPoints] < 0)    format(string, sizeof(string), "%s~n~~n~~w~Punkty: ~r~~h~(%d) mPoints", string, AchieveInfo[achieve_id][aPoints]);
	else                                        format(string, sizeof(string), "%s~n~~n~~w~Punkty: ~b~~h~(+%d) mPoints", string, AchieveInfo[achieve_id][aPoints]);

	PlayerTextDrawSetString(playerid, PlayerText:TextDrawAchieve[playerid], string);
	PlayerTextDrawShow(playerid, PlayerText:TextDrawAchieve[playerid]);
	
	PlayerCache[playerid][pPoints] 			+= AchieveInfo[achieve_id][aPoints];
	PlayerCache[playerid][pAchievements] 	+= achieve_type;
	
	PlayerCache[playerid][pAchieveTextTime] = (gettime() + 10);
	SetPlayerScore(playerid, PlayerCache[playerid][pPoints]);
	
	//Audio_Play(playerid, AUDIO_ACHIEVE);
	mysql_query_format("UPDATE `core_members`, `"SQL_PREF"characters` SET member_game_points = '%d', char_achievements = '%d' WHERE char_uid = '%d' AND member_id = '%d'", PlayerCache[playerid][pPoints], PlayerCache[playerid][pAchievements], PlayerCache[playerid][pUID], PlayerCache[playerid][pGID]);
	mysql_query_format("INSERT INTO `"SQL_PREF"char_achievements` (achiev_score, achiev_bit, achiev_owner, achiev_date) VALUES ('%d', '%d', '%d', '%d')", AchieveInfo[achieve_id][aPoints], achieve_type, PlayerCache[playerid][pUID], gettime());
	return 1;
}

public ShowPlayerDirectoryForPlayer(playerid, giveplayer_id)
{
	new string[128], list_directory[512];
	
	new rows, Cache:tmp_cache, query[256];
	
	mysql_format(connHandle, query, sizeof(query), "SELECT `directory_uid`, `directory_reason`, `directory_date` FROM `"SQL_PREF"directory` WHERE directory_owner = '%d' ORDER BY `directory_date` DESC", PlayerCache[playerid][pUID]);
	tmp_cache = mysql_query(connHandle, query);
	
	new directory_uid, dir_count,
		directory_reason[64], directory_date[24];
		
    format(list_directory, sizeof(list_directory), "Dodaj nowy wpis...\n-----");
    
    DynamicGui_Init(playerid);
    
    DynamicGui_AddBlankRow(playerid);
    DynamicGui_AddBlankRow(playerid);
    
	cache_get_row_count(rows);
	for(new row = 0; row != rows; row++)
	{
	    cache_get_value_index_int(row, 0, directory_uid);
	    
		cache_get_value_index(row, 1, directory_reason, 64);
		cache_get_value_index(row, 2, directory_date, 24);
	    
	    strdel(directory_reason, 24, strlen(directory_reason));
	    format(list_directory, sizeof(list_directory), "%s\n%d\t%s\t\t%s...", list_directory, directory_uid, directory_date, directory_reason);
	    
	    dir_count ++;
	    DynamicGui_AddRow(playerid, D_DIRECTORY_LIST, directory_uid);
	}
	if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
	if(!dir_count)	format(list_directory, sizeof(list_directory), "%s\n{FF3D3D}#\t\tNie znaleziono żadnych wpisów w kartotece", list_directory);
	
 	format(string, sizeof(string), "Kartoteka - %s. Punkty Karne: %d (DNA: %s)", PlayerRealName(playerid), PlayerCache[playerid][pPDP], CharCode(PlayerCache[playerid][pUID]));
 	ShowPlayerDialog(giveplayer_id, D_DIRECTORY_LIST, DIALOG_STYLE_LIST, string, list_directory, "Szczegóły", "Anuluj");
	return 1;
}

public GivePlayerPunish(playerid, giverid, punish_type, punish_reason[], punish_time, punish_extraid)
{
	new string[256], player_name[24], giver_name[24],
	    kick = false, punish_date = gettime(), punish_end;
	    
	if(giverid == INVALID_PLAYER_ID)    strmid(giver_name, "System", 0, 6, 24);
	else                                strmid(giver_name, PlayerName(giverid), 0, strlen(PlayerName(giverid)), 24);
	
	if(playerid == INVALID_PLAYER_ID)   strmid(player_name, "Niezalogowany", 0, 6, 24);
	else                                strmid(player_name, PlayerRealName(playerid), 0, strlen(PlayerRealName(playerid)), 24);
	
	switch(punish_type)
	{
	    case PUNISH_WARN:
	    {
			TextDrawSetString(Text:TextDrawPunishTitle, "Warn");
	    }
	    case PUNISH_KICK:
    	{
	        TextDrawSetString(Text:TextDrawPunishTitle, "Kick");
	        
	        kick = true;
	    }
	    case PUNISH_BAN:
    	{
			new IP[16];
			GetPlayerIp(playerid, IP, sizeof(IP));
	        mysql_query_format("INSERT INTO `"SQL_PREF"bans` (ban_owner, ban_ip, ban_reason) VALUES ('%d', '%s', '%s')", PlayerCache[playerid][pGID], IP, punish_reason);
	    
	        format(string, sizeof(string), "Ban (%d dni)", punish_time);
	        TextDrawSetString(Text:TextDrawPunishTitle, string);
	        
	        punish_end = punish_date + (punish_time * 86400);
            PlayerCache[playerid][pBlock] += (PlayerCache[playerid][pBlock] & BLOCK_CHAR) ? 0 : BLOCK_CHAR;
            
            orm_update(PlayerCache[playerid][pOrm]);
            kick = true;
		}
	    case PUNISH_BLOCK:
	    {
	        switch(punish_extraid)
	        {
	            case BLOCK_CHAR:
	            {
	                TextDrawSetString(Text:TextDrawPunishTitle, "Blokada postaci");
	                kick = true;
	            }
	            case BLOCK_VEH:
	            {
	                format(string, sizeof(string), "Blokada prowadzenia pojazdow (%d dni)", punish_time);
	                TextDrawSetString(Text:TextDrawPunishTitle, string);
	                
	                punish_end = punish_date + (punish_time * 86400);
	            }
	            case BLOCK_RUN:
	            {
             		format(string, sizeof(string), "Blokada biegania i bicia (%d dni)", punish_time);
	                TextDrawSetString(Text:TextDrawPunishTitle, string);
	                
	                punish_end = punish_date + (punish_time * 86400);
	            }
	            case BLOCK_OOC:
	            {
     				format(string, sizeof(string), "Blokada czatu OOC (%d dni)", punish_time);
	                TextDrawSetString(Text:TextDrawPunishTitle, string);
	                
	                punish_end = punish_date + (punish_time * 86400);
	            }
	        }
	        
	        PlayerCache[playerid][pBlock] += punish_extraid;
	        orm_update(PlayerCache[playerid][pOrm]);
	    }
	    case PUNISH_AJ:
	    {
	        GivePlayerAchievement(playerid, ACHIEVE_AJ);
	        crp_SetPlayerPos(playerid, PosInfo[ADMIN_JAIL_POS][sPosX], PosInfo[ADMIN_JAIL_POS][sPosY], PosInfo[ADMIN_JAIL_POS][sPosZ]);
	        
	        SetPlayerInterior(playerid, 0);
	        SetPlayerVirtualWorld(playerid, playerid + 1000);
	    
	        // Zmknij pojazd i zgaś silnik
	        if(GetPlayerState(playerid) == PLAYER_STATE_DRIVER)
	        {
	            new vehid = GetPlayerVehicleID(playerid);
				CarInfo[vehid][cLocked] = true;
	  			SetVehicleLock(vehid, CarInfo[vehid][cLocked]);

				ChangeVehicleEngineStatus(vehid, false);
				orm_update(CarInfo[vehid][cOrm]);
			}
	        
	        PlayerCache[playerid][pAJ] = punish_time * 60;
			TextDrawSetString(Text:TextDrawPunishTitle, "AdminJail");
	    }
	}
	escape_pl(punish_reason);
    AddPlayerPunishLog(playerid, giverid, punish_type, punish_extraid, punish_reason, punish_date, punish_end);
	
	format(string, sizeof(string), "Nadawca: %s~n~Odbiorca: %s~n~~n~Powod:~n~%s", giver_name, player_name, punish_reason);
	TextDrawSetString(Text:TextDrawPunishDesc, string);

	TextDrawShowForAll(Text:TextDrawPunishTitle);
	TextDrawShowForAll(Text:TextDrawPunishDesc);
	
 	SendClientMessage(playerid, COLOR_RED, "Jeżeli kara została nadana niesłusznie - możesz apelować na naszym forum.");
  	SendClientMessage(playerid, COLOR_RED, "Wszystkie nadane kary są logowane i znaleźć je możesz w swoim profilu na stronie.");
   	SendClientMessage(playerid, COLOR_RED, "Adres naszej strony: "WEB_URL". Pamiętaj, by nie załatwiać takich spraw w grze!");
	
	if(kick) defer OnKickPlayer(playerid);
	PunishTime = 15;
	return 1;
}

public AddPlayerPunishLog(playerid, punish_giver, punish_type, punish_extraid, punish_reason[], punish_date, punish_end)
{
	new player_uid = PlayerCache[playerid][pUID], giver_uid;
	if(punish_giver == INVALID_PLAYER_ID) 	giver_uid = -1;
	else                            		giver_uid = PlayerCache[punish_giver][pUID];
	
	mysql_query_format("INSERT INTO `"SQL_PREF"penalties` (penalty_owner, penalty_giver, penalty_type, penalty_extraid, penalty_reason, penalty_date, penalty_end) VALUES ('%d', '%d', '%d', '%d', '%s', '%d', '%d')", player_uid, giver_uid, punish_type, punish_extraid, punish_reason, punish_date, punish_end);
	return 1;
}

public LoadPlayerBans(playerid)
{
	new IP[16], ban_reason[128];
	GetPlayerIp(playerid, IP, sizeof(IP));
	
	new rows, Cache:tmp_cache, query[256];

	mysql_format(connHandle, query, sizeof(query), "SELECT `ban_reason` FROM `"SQL_PREF"bans` WHERE (ban_owner = '%d' OR ban_ip = '%s') AND ban_filter != '%d' LIMIT 1", PlayerCache[playerid][pGID], IP, PlayerCache[playerid][pGID]);
	tmp_cache = mysql_query(connHandle, query);

    cache_get_row_count(rows);
   	if(rows > 0)
   	{
   	    cache_get_value_index(0, 0, ban_reason, 128);
   	   	ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Zostałeś zbanowany, powód: %s\nMożesz złożyć apelacje na forum: "WEB_URL".", ban_reason);

		PlayerCache[playerid][pBanned] = true;
		defer OnKickPlayer(playerid);
   	}
    if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
	return 1;
}

public crp_CreateActor(actor_name[32], modelid, Float:aX, Float:aY, Float:aZ, Float:aR, aVW, aInterior)
{
	new query[512];
	mysql_format(connHandle, query, sizeof(query), "INSERT INTO `"SQL_PREF"actors` (actor_name, actor_skin, actor_x, actor_y, actor_z, actor_r, actor_vw, actor_interior) VALUES ('%e', '%d', '%f', '%f', '%f', '%f', '%d', '%d')", actor_name, modelid, aX, aY, aZ, aR, aVW, aInterior);
	mysql_query(connHandle, query);
	
	new actor_uid = cache_insert_id(),
		rows, Cache:tmp_cache, ActorData[sActorData], actor_id,
		Float:actor_pos[4], actor_vw, actor_interior;
		
	mysql_format(connHandle, query, sizeof(query), "SELECT * FROM `"SQL_PREF"actors` WHERE actor_uid = '%d' LIMIT 1", actor_uid);
	tmp_cache = mysql_query(connHandle, query);

	cache_get_row_count(rows);
	if(rows > 0)
	{
	    cache_get_value_index_int(0, 0, ActorData[aUID]);

	    cache_get_value_index(0, 1, ActorData[aName], 32);
	    cache_get_value_index_int(0, 2, modelid);

		cache_get_value_index_float(0, 3, actor_pos[0]);
		cache_get_value_index_float(0, 4, actor_pos[1]);
		cache_get_value_index_float(0, 5, actor_pos[2]);
		cache_get_value_index_float(0, 6, actor_pos[3]);

		cache_get_value_index_int(0, 7, ActorData[aType]);
		cache_get_value_index_int(0, 8, ActorData[aAnim]);

		cache_get_value_index_int(0, 10, actor_vw);
		cache_get_value_index_int(0, 11, actor_interior);

		cache_get_value_index(0, 12, ActorData[aText], 128);

		if(ActorData[aType] == ACTOR_CORPSE)
		{
			ActorData[aLabel] = CreateDynamic3DTextLabel(ActorData[aName], COLOR_RED, actor_pos[0], actor_pos[1], actor_pos[2] - 0.5, 20.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 0, actor_vw, actor_interior);
		}

		if(ActorData[aType] == ACTOR_VICTIM)
		{
		    ActorData[aLabel] = CreateDynamic3DTextLabel("(!!!)", COLOR_RED, actor_pos[0], actor_pos[1], actor_pos[2] + 1.5, 20.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 0, actor_vw, actor_interior);
		}

		if(ActorData[aType] == ACTOR_SPECIAL)
		{
		    ActorData[aLabel] = CreateDynamic3DTextLabel("(???)", COLOR_WHITE, actor_pos[0], actor_pos[1], actor_pos[2] + 1.5, 20.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 0, actor_vw, actor_interior);
		}

		actor_id = CreateDynamicActor(modelid, actor_pos[0], actor_pos[1], actor_pos[2], actor_pos[3], true, 100.0, actor_vw, actor_interior);
		Streamer_SetArrayData(STREAMER_TYPE_ACTOR, actor_id, E_STREAMER_EXTRA_ID, ActorData);
	}
	
	if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
	return actor_id;
}

public query_OnLoadActors()
{
	new rows, ActorData[sActorData], actor_id,
		modelid, Float:actor_pos[4], actor_vw, actor_interior;

	cache_get_row_count(rows);
	for(new row = 0; row != rows; row++)
	{
	    cache_get_value_index_int(row, 0, ActorData[aUID]);

	    cache_get_value_index(row, 1, ActorData[aName], 32);
	    cache_get_value_index_int(row, 2, modelid);

		cache_get_value_index_float(row, 3, actor_pos[0]);
		cache_get_value_index_float(row, 4, actor_pos[1]);
		cache_get_value_index_float(row, 5, actor_pos[2]);
		cache_get_value_index_float(row, 6, actor_pos[3]);

		cache_get_value_index_int(row, 7, ActorData[aType]);
		cache_get_value_index_int(row, 8, ActorData[aAnim]);

		cache_get_value_index_int(row, 10, actor_vw);
		cache_get_value_index_int(row, 11, actor_interior);

		cache_get_value_index(row, 12, ActorData[aText], 128);

		if(ActorData[aType] == ACTOR_CORPSE)
		{
			ActorData[aLabel] = CreateDynamic3DTextLabel(ActorData[aName], COLOR_RED, actor_pos[0], actor_pos[1], actor_pos[2] - 0.5, 20.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 0, actor_vw, actor_interior);
		}

		if(ActorData[aType] == ACTOR_VICTIM)
		{
		    ActorData[aLabel] = CreateDynamic3DTextLabel("(!!!)", COLOR_RED, actor_pos[0], actor_pos[1], actor_pos[2] + 1.5, 20.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 0, actor_vw, actor_interior);
		}

		if(ActorData[aType] == ACTOR_SPECIAL)
		{
		    ActorData[aLabel] = CreateDynamic3DTextLabel("(???)", COLOR_WHITE, actor_pos[0], actor_pos[1], actor_pos[2] + 1.5, 20.0, INVALID_PLAYER_ID, INVALID_VEHICLE_ID, 0, actor_vw, actor_interior);
		}

		actor_id = CreateDynamicActor(modelid, actor_pos[0], actor_pos[1], actor_pos[2], actor_pos[3], true, 100.0, actor_vw, actor_interior);
		Streamer_SetArrayData(STREAMER_TYPE_ACTOR, actor_id, E_STREAMER_EXTRA_ID, ActorData);
	}
	return 1;
}

public DeleteActor(actorid)
{
	new actor_uid = GetActorUID(actorid), ActorData[sActorData];
	Streamer_GetArrayData(STREAMER_TYPE_ACTOR, actorid, E_STREAMER_EXTRA_ID, ActorData);
	
	if(ActorData[aLabel])   DestroyDynamic3DTextLabel(ActorData[aLabel]);
	
	mysql_query_format("DELETE FROM `"SQL_PREF"actors` WHERE actor_uid = '%d' LIMIT 1", actor_uid);
	DestroyDynamicActor(actorid);
	return 1;
}

public SaveActor(actorid)
{
	new actor_uid = GetActorUID(actorid), ActorData[sActorData],
	    Float:PosX, Float:PosY, Float:PosZ, Float:PosA, actor_text[128];

	Streamer_GetFloatData(STREAMER_TYPE_ACTOR, actorid, E_STREAMER_X, PosX);
	Streamer_GetFloatData(STREAMER_TYPE_ACTOR, actorid, E_STREAMER_Y, PosY);
	Streamer_GetFloatData(STREAMER_TYPE_ACTOR, actorid, E_STREAMER_Z, PosZ);
	
	GetDynamicActorFacingAngle(actorid, PosA);
	Streamer_GetArrayData(STREAMER_TYPE_ACTOR, actorid, E_STREAMER_EXTRA_ID, ActorData);
	
	mysql_escape_string(ActorData[aText], actor_text, 128);
	mysql_query_format("UPDATE `"SQL_PREF"actors` SET actor_x = '%f', actor_y = '%f', actor_z = '%f', actor_r = '%f', actor_anim = '%d', actor_type = '%d', actor_text = '%s' WHERE actor_uid = '%d' LIMIT 1", PosX, PosY, PosZ, PosA, ActorData[aAnim], ActorData[aType], actor_text, actor_uid);
	return 1;
}

public OnPlayerInteractActor(playerid, actorid)
{
	if(PlayerCache[playerid][pLastActor] && (PlayerCache[playerid][pLastActor] + 5) > gettime())
	{
	    // Odczekaj chwilę, przed chwilą była interakcja
		return 1;
	}

	new ActorData[sActorData], DoorData[sDoorInfo], AreaData[sAreaData], group_id = INVALID_GROUP_ID,
		string[512], doorid = GetPlayerDoorID(playerid), areaid = GetPlayerAreaID(playerid);
		
	Streamer_GetArrayData(STREAMER_TYPE_ACTOR, actorid, E_STREAMER_EXTRA_ID, ActorData);
	new actor_type = ActorData[aType];
	
	if(doorid != INVALID_DOOR_ID)
	{
	    Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
		if(DoorData[dOwnerType] == OWNER_GROUP)	group_id = GetGroupID(DoorData[dOwner]);
	}
	
	if(areaid != INVALID_AREA_ID)
	{
	    Streamer_GetArrayData(STREAMER_TYPE_AREA, areaid, E_STREAMER_EXTRA_ID, AreaData);
	    if(AreaData[aOwnerType] == OWNER_GROUP) group_id = GetGroupID(AreaData[aOwner]);
	}
	
	// Formatuj tekst aktora
	new pos, editingString[256];
	if(strlen(ActorData[aText]) > 0)
	{
 	   	memcpy(editingString, ActorData[aText], 0, 128 * 4);
 	   	
	    pos = strfind(editingString, "[player]", true);
	    if(pos != -1)
	    {
	        strdel(editingString, pos, pos + 8);
	        strins(editingString, PlayerName(playerid), pos);

	        pos = strfind(editingString, PlayerName(playerid), true, pos + strlen(PlayerName(playerid)));
	    }
		    
	    pos = strfind(editingString, "[door]", true);
	    if(pos != -1)
	    {
			if(doorid != INVALID_DOOR_ID)
			{
        		strdel(editingString, pos, pos + 6);
        		strins(editingString, DoorData[dName], pos);

				pos = strfind(editingString, DoorData[dName], true, pos + strlen(DoorData[dName]));
		    }
		}
		
  		pos = strfind(editingString, "[group]", true);
	    if(pos != -1)
	    {
			if(group_id != INVALID_GROUP_ID)
			{
	 			strdel(editingString, pos, pos + 7);
	  			strins(editingString, GroupData[group_id][gName], pos);

				pos = strfind(editingString, GroupData[group_id][gName], true, pos + strlen(GroupData[group_id][gName]));
			}
		}
		
		pos = strfind(editingString, "[actor]", true);
	    if(pos != -1)
	    {
			strdel(editingString, pos, pos + 7);
  			strins(editingString, ActorData[aName], pos);

			pos = strfind(editingString, ActorData[aName], true, pos + strlen(ActorData[aName]));
		}
	}
	
	PlayerCache[playerid][pLastActor] = gettime();

	// Nieokreślony
	if(actor_type == ACTOR_NONE)
	{
	
	}
	
	// Pracownik
	if(actor_type == ACTOR_WORKER)
	{
	    if(group_id == INVALID_GROUP_ID)    return 1;
	    new group_type = GroupData[group_id][gType];
	    
	    if(group_type == G_TYPE_MEDICAL)
	    {
			// Leczenie
	    }
	    
	    if(group_type == G_TYPE_NEWS)
	    {
	        if(WorkInfo[playerid][wID] == JOB_NEWSPAPER)
	        {
	            if(WorkInfo[playerid][wValue][0] != 0)
	            {
	                TD_ShowSmallInfo(playerid, 3, "Pozostalo Ci ~y~%d gazet(y) ~w~do rozwiezienia.", WorkInfo[playerid][wValue][0]);
	                return 1;
	            }
	            WorkInfo[playerid][wValue][0] = 20;
	            TD_ShowSmallInfo(playerid, 5, "Odebrales ~y~20 sztuk ~w~gazet. Rozwiez je do ~r~zaznaczonych ~w~na mapie miejsc.");

                new Float:PosX, Float:PosY, Float:PosZ;
				Streamer_GetItemPos(STREAMER_TYPE_PICKUP, doorid, PosX, PosY, PosZ);
                
				new random_doorid = GetNearRandomDoorID(PosX, PosY, PosZ, OWNER_PLAYER);
					
				WorkInfo[playerid][wExtraID] = random_doorid;
				Streamer_GetItemPos(STREAMER_TYPE_PICKUP, random_doorid, PosX, PosY, PosZ);
				
				SetPlayerCheckpoint(playerid, PosX, PosY, PosZ, 2.0);
				PlayerCache[playerid][pCheckpoint] = CHECKPOINT_NEWSPAPER;
	        }
	    }
	    
	    if(group_type == G_TYPE_24/7)
	    {
			ListGroupProductsForPlayer(group_id, playerid, PRODUCT_LIST_BUY);
			PlayerCache[playerid][pMainTable] = group_id;
	    }
	    
	    if(group_type == G_TYPE_BAR)
	    {
  			new count_workers = 0;
			foreach(new i : Player)
			{
				if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
				{
				    if(IsPlayerInGroup(i, GroupData[group_id][gUID]))
				    {
            			TD_ShowHint(i, HINT_NONE, 5, "Ktos pragnie ~y~skorzystac ~w~z uslug grupy ~p~%s~w~.", GroupData[group_id][gName]);
						count_workers ++;
				    }
				}
			}
			if(count_workers > 0)
			{
			    SendClientFormatMessage(playerid, COLOR_FADE1, "%s mówi: Przykro mi, ja już mam wolne.", ActorData[aName]);
			    return 1;
			}
			ListGroupProductsForPlayer(group_id, playerid, PRODUCT_LIST_BUY);
			PlayerCache[playerid][pMainTable] = group_id;
	    }
	    
	    if(group_type == G_TYPE_CARDEALER)
	    {
			ShowPlayerDialog(playerid, D_SALON_CATEGORY, DIALOG_STYLE_TABLIST_HEADERS, "Salon samochodowy", "Kategoria\tCeny\nTrzydrzwiowe\tod $1800\nPięciodrzwiowe\tod $1500\nCiężarowe\tod $4000\nLatające\tod $60000\nŁodzie\tod $4000\nSportowe\tod $15000\nJednoślady\tod $300\nPremium\tod $7500", "Wybierz", "Anuluj");
			PlayerCache[playerid][pMainTable] = actorid;
		}
	    
	    if(group_type == G_TYPE_WORKSHOP)
	    {
			// Naprawianie najbliższego pojazdu
			new count_workers = 0;
			foreach(new i : Player)
			{
				if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
				{
				    if(IsPlayerInGroup(i, GroupData[group_id][gUID]))
				    {
            			TD_ShowHint(i, HINT_NONE, 5, "Ktos pragnie ~y~skorzystac ~w~z uslug grupy ~p~%s~w~.", GroupData[group_id][gName]);
						count_workers ++;
				    }
				}
			}
			if(count_workers > 0)
			{
			    SendClientFormatMessage(playerid, COLOR_FADE1, "%s mówi: Przykro mi, ja już mam wolne.", ActorData[aName]);
			    return 1;
			}
			
			new vehid = GetClosestVehicle(playerid);
			if(vehid == INVALID_VEHICLE_ID)
			{
				TD_ShowSmallInfo(playerid, 3, "Ten aktor moze ~y~naprawic ~w~Twoj pojazd. Przyjedz nim i stan obok niego wykonujac ~g~interakcje ~w~z aktorem.");
			    return 1;
			}
			new title[64], veh_visual[4],
				repair_price = 2000 - floatround(CarInfo[vehid][cHealth], floatround_ceil), visual_price = 0;
			
			sscanf(CarInfo[vehid][cVisual], "a<d>[4]", veh_visual);
			
			for (new i = 0; i < 4; i++)
			{
			    if(veh_visual[i] > 0)
			    {
					visual_price += 45;
			    }
			}
			
			DynamicGui_Init(playerid);
			
			DynamicGui_AddRow(playerid, CarInfo[vehid][cUID], repair_price + visual_price);
			DynamicGui_AddRow(playerid, CarInfo[vehid][cUID], visual_price);
			DynamicGui_AddRow(playerid, CarInfo[vehid][cUID], repair_price);
			
			format(title, sizeof(title), "Wybierz usługę dla pojazdu %s (%d):", GetVehicleName(CarInfo[vehid][cModel]), CarInfo[vehid][cUID]);
			format(string, sizeof(string), "*\tUsługa\n1\tCałkowita naprawa\n2\tWygląd wizualny\n3\tNaprawa techniczna");

			TD_ShowHint(playerid, HINT_NONE, 5, "Naprawiajac pojazd u ~y~innego gracza ~w~(pracownika warsztatu lub mechanika) otrzymasz bardziej ~g~korzystna ~w~oferte.");
			
			ShowPlayerDialog(playerid, D_ACTOR_WORKSHOP, DIALOG_STYLE_TABLIST_HEADERS, title, string, "Wybierz", "Anuluj");
			PlayerCache[playerid][pMainTable] = actorid;
	    }
	    
	    if(group_type == G_TYPE_GASSTATION)
	    {
	        // Tankowanie najbliższego pojazdu
	    }
	    
	    if(group_type == G_TYPE_GYM)
	    {
	        // Oferta karnetu siłowni
	    }
	    
	    if(group_type == G_TYPE_GOV)
	    {
	        // Dokumenty, prace dorwycze, dotacje, zakładanie biznesu etc.
	        ShowPlayerDialog(playerid, D_ACTOR_GOV, DIALOG_STYLE_TABLIST_HEADERS, "Skorzystaj z usługi:", "*\tUsługa\tCena\n1\tWyrób identyfikator (dowód)\t$80\n2\tLicencja prowadzenia pojazdów\t$350\n3\tZapytaj o pracę dorywczą\t-\n4\tRejestracja ostatnio używanego pojazdu\t$150", "Wybierz", "Anuluj");
			PlayerCache[playerid][pMainTable] = actorid;
	    }
	}
	
	// Ofiara
	if(actor_type == ACTOR_VICTIM)
	{
 		// Został napadnięty
	    if(ActorData[aExtraID] != 0)
	    {
			if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten aktor został napadnięty!\nAby dokonać interakcji, musisz być na służbie grupy.");
			    return 1;
			}
			new group_duty = PlayerCache[playerid][pDuty][DUTY_GROUP];
			if(GroupData[group_duty][gType] != G_TYPE_POLICE)
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten aktor został napadnięty!\nNie posiadasz odpowiedniego doświadczenia, by móc przesłuchać aktora.");
			    return 1;
			}
	    }
	    if(GetPlayerTargetDynamicActor(playerid) != actorid)
	    {
	        return 1;
	    }
	    new query[512];
	    ActorData[aExtraID] = (PlayerCache[playerid][pItemMask] == INVALID_ITEM_ID)	? PlayerCache[playerid][pUID] : -1;

		if(ActorData[aExtraID])
		{
		    format(string, sizeof(string), "Nie widziałem jego twarzy, miał maskę i celował do mnie z broni!");
		}
		else
		{
		    format(string, sizeof(string), "Dokładnie widziałem jego twarz... {C2A2DA}* opisuje rysopis %s *", PlayerRealName(playerid));
		}
		strmid(ActorData[aText], string, 0, strlen(string));
	    ApplyDynamicActorAnimation(actorid, "ROB_BANK", "SHP_HandsUp_Scr", 4, 0, 1, 1, 1, 1);
	    
	    mysql_format(connHandle, query, sizeof(query), "INSERT INTO `"SQL_PREF"items` (item_name, item_type, item_value1, item_value2, item_ownertype, item_owner) SELECT item_name, item_type, item_value1, item_value2, item_ownertype, %d FROM `"SQL_PREF"items` WHERE item_ownertype = %d AND item_owner = 0", ActorData[aUID], PLACE_ACTOR);
		mysql_query(connHandle, query);

		mysql_format(connHandle, query, sizeof(query), "SELECT `item_uid`, `item_name` FROM `"SQL_PREF"items` WHERE item_ownertype = %d AND item_owner = %d ORDER BY RAND() LIMIT %d", PLACE_ACTOR, ActorData[aUID], 5 + random(5));
		mysql_tquery(connHandle, query, "query_OnListPlayerNearItems", "dd", playerid, PLACE_ACTOR);
		
		Streamer_SetArrayData(STREAMER_TYPE_ACTOR, actorid, E_STREAMER_EXTRA_ID, ActorData);
		PlayerCache[playerid][pMainTable] = actorid;
	}
	
	// Zwłoki
	if(actor_type == ACTOR_CORPSE)
	{
		if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby dokonać interakcji, musisz być na służbie grupy.");
		    return 1;
		}
		group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
		if(GroupData[group_id][gType] != G_TYPE_POLICE && GroupData[group_id][gType] != G_TYPE_MEDICAL && GroupData[group_id][gType] != G_TYPE_FBI)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz odpowiedniego doświadczenia, by móc zidentyfikować zwłoki.");
		    return 1;
		}
		new corpse_actor = GetActorUID(actorid),
		    corpse_death, corpse_owner, corpse_killer, corpse_weapon, corpse_body, corpse_date;

		new rows, Cache:tmp_cache, query[512];

		mysql_format(connHandle, query, sizeof(query), "SELECT `corpse_death`, `corpse_owner`, `corpse_killer`, `corpse_weapon`, `corpse_body`, `corpse_date` FROM `"SQL_PREF"corpses` WHERE corpse_actor = '%d' LIMIT 1", corpse_actor);
        tmp_cache = mysql_query(connHandle, query);

        cache_get_row_count(rows);
		if(rows > 0)
		{
		    cache_get_value_index_int(0, 0, corpse_death);
		    cache_get_value_index_int(0, 1, corpse_owner);
		    cache_get_value_index_int(0, 2, corpse_killer);
		    cache_get_value_index_int(0, 3, corpse_weapon);
		    cache_get_value_index_int(0, 4, corpse_body);

		    cache_get_value_index_int(0, 5, corpse_date);
		}
		if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);

		switch(GroupData[group_id][gType])
		{
		    case G_TYPE_POLICE, G_TYPE_FBI:
		    {
		        if(corpse_killer)
		        {
					ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Zbierając dowody z ciała oraz jego otoczenia jesteś w stanie wyjąć DNA zabójcy: %s.", CharCode(corpse_killer));
				}
				else
				{
				    ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Zabójcy udało się idealnie zatrzeć dowody zbrodni.");
				}
		    }
		    case G_TYPE_MEDICAL, G_TYPE_FIREDEPT:
		    {
		        if(strfind(ActorData[aName], "(niezidentyfikowane)", true) != -1)
		        {
  				    new item_name[32];
  				    
					format(item_name, sizeof(item_name), "Zwloki (DNA: %s)", CharCode(corpse_owner));
					UpdateDynamic3DTextLabelText(ActorData[aLabel], COLOR_RED, item_name);

					strmid(ActorData[aName], item_name, 0, strlen(item_name), 32);
					SaveActor(actorid);

					ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Jako medyk, byłeś w stanie zidentyfikować zwłoki.\nZwłoki zostały pomyślnie zidentyfikowane (DNA: %s).", CharCode(corpse_owner));
		        }
		        else
				{
  					new corpse_desc[512], list_body_part[256],
  					    year, month, day, hour, minute, second;

		 			for(new bp_id = 0; bp_id < sizeof(BodyPartInfo); bp_id++)
					{
		    			if(BodyPartInfo[bp_id][bpType] & corpse_body)
		    			{
		        			format(list_body_part, sizeof(list_body_part), "%s, %s", list_body_part, BodyPartInfo[bp_id][bpName]);
						}
					}

					if(strlen(list_body_part))
					{
		    			strdel(list_body_part, 0, 2);
					}
					else
					{
		    			format(list_body_part, sizeof(list_body_part), "brak");
					}

					TimestampToDate(corpse_date, year, month, day, hour, minute, second, 1);
					format(corpse_desc, sizeof(corpse_desc), "Dokładna data zgonu %02d/%02d/%d %02d:%02d.\nPrzyczyna śmierci: %s\nWidoczne obrażenia: %s", day, month, year, hour, minute, DeathTypeData[corpse_death][0], list_body_part);

					if(corpse_weapon)
					{
						new weapon_id;

						mysql_format(connHandle, query, sizeof(query), "SELECT `item_value1` FROM `"SQL_PREF"items` WHERE item_uid = '%d' LIMIT 1", corpse_weapon);
                        tmp_cache = mysql_query(connHandle, query);

						cache_get_value_index_int(0, 0, weapon_id);
						if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);

  						new weapon_type = GetWeaponType(weapon_id), weapon_name[24];
		    			GetWeaponName(weapon_id, weapon_name, 24);

						switch(weapon_type)
						{
							case WEAPON_TYPE_LIGHT:
					        {
								format(corpse_desc, sizeof(corpse_desc), "%s\n\nWidać wyraźnie, że ciało zostało zranione za pomocą broni lekkiej.\nBadając łuski znajdujące się przy ciele martwego, poznajesz broń zabójcy.", corpse_desc);
							}
					        case WEAPON_TYPE_MELEE:
					        {
					            format(corpse_desc, sizeof(corpse_desc), "%s\n\nWidać wyraźnie, że ciało zostało zranione za pomocą broni białej.\nSądząc po ogólnych obrażeniach, możesz poznać szczegóły narzędzia zbrodni.", corpse_desc);
					        }
					        case WEAPON_TYPE_HEAVY:
					        {
					            format(corpse_desc, sizeof(corpse_desc), "%s\n\nOfiara musiała zostać raniona za pomocą broni ciężkiej.\nBadając łuski znajdujące się przy ciele martwego, poznajesz broń zabójcy.", corpse_desc);
		  			        }
						}

						format(corpse_desc, sizeof(corpse_desc), "%s\n\nModel: %d\nNazwa: %s\nNr. identyfikacyjny: %d", corpse_desc, weapon_id, weapon_name, corpse_weapon);
					}
					else
					{
						format(corpse_desc, sizeof(corpse_desc), "%s\n\nObrażenia nie wskazują na żaden przyrząd oraz broń.", corpse_desc);
					}
					
					strcat(corpse_desc, "\n---\n1. Zabezpiecz zwłoki (zapakuj w folie)");
					ShowPlayerDialog(playerid, D_ACTOR_CORPSE, DIALOG_STYLE_LIST, "Badanie zwłok", corpse_desc, "Wybierz", "Zamknij");

					PlayerCache[playerid][pMainTable] = actorid;
				}
		    }
		}
	}
	
	if(actor_type == ACTOR_TRADER)
	{
	    ShowPlayerDialog(playerid, D_ACTOR_TRADER, DIALOG_STYLE_LIST, "Wybierz rodzaj przemiotu sprzedaży:", "1\tDrewno\n2\tRyby\n3\tBiżuteria", "Wybierz", "Zamknij");
	    PlayerCache[playerid][pMainTable] = actorid;
	}
	
 	if(strlen(editingString) > 0)	SendClientFormatMessage(playerid, COLOR_FADE1, "%s mówi: %s", ActorData[aName], editingString);
	return 1;
}


public ProxDetector(Float:radi, playerid, string[], col1, col2, col3, col4, col5)
{
	new	Float:PosX, Float:PosY, Float:PosZ,
		WorldID, WorldID2;

	WorldID = GetPlayerVirtualWorld(playerid);
	GetPlayerPos(playerid, PosX, PosY, PosZ);

	if(strfind(string, "(radio)", true) == -1)	SendClientMessage(playerid, col1, string);

	if(IsPlayerInAnyVehicle(playerid) && col1 == COLOR_FADE1)
	{
	    new vehid = GetPlayerVehicleID(playerid);
	    if(CarInfo[vehid][cGlass])
	    {
	   		foreach(new i : Player)
			{
				if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
				{
				    if(i != playerid)
				    {
				        if(GetPlayerVehicleID(i) == vehid)
				        {
				            SendClientMessage(i, col1, string);
				        }
					}
				}
			}
	    }
	    else
	    {
	        goto normal_chat;
	    }
	}
	else
	{
	    normal_chat:
	    
		foreach(new i : Player)
		{
			if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
			{
			    if(i != playerid)
			    {
					WorldID2 = GetPlayerVirtualWorld(i);
					
					if(PlayerCache[i][pBW] && col1 != COLOR_PURPLE && col1 != COLOR_DO ||
					WorldID != WorldID2 ||
					col1 == COLOR_GREY && !PlayerCache[i][pOOC] ||
					IsPlayerInAnyVehicle(i) && CarInfo[GetPlayerVehicleID(i)][cGlass] && col1 == COLOR_FADE1) continue;

					if(IsPlayerInRangeOfPoint(i, radi/16, PosX, PosY, PosZ))
					{
						SendClientMessage(i, col1, string);
					}
					else if(IsPlayerInRangeOfPoint(i, radi/8, PosX, PosY, PosZ))
					{
						SendClientMessage(i, col2, string);
					}
					else if(IsPlayerInRangeOfPoint(i, radi/4, PosX, PosY, PosZ))
					{
						SendClientMessage(i, col3, string);
					}
					else if(IsPlayerInRangeOfPoint(i, radi/2, PosX, PosY, PosZ))
					{
						SendClientMessage(i, col4, string);
					}
					else if(IsPlayerInRangeOfPoint(i, radi, PosX, PosY, PosZ))
					{
						SendClientMessage(i, col5, string);
					}
				}
			}
		}
	}
	return 1;
}

public UpdatePlayerStatus(playerid)
{
	new player_status = PlayerCache[playerid][pStatus],
		name_string[32], status_string[256];
	
	if(PlayerCache[playerid][pItemMask] == INVALID_ITEM_ID)	format(name_string, sizeof(name_string), "%s (%d)", PlayerName(playerid), playerid);
	else													format(name_string, sizeof(name_string), "%s", PlayerName(playerid));
	
    for(new status_id = 0; status_id < sizeof(StatusInfo); status_id++)
	{
	    if(StatusInfo[status_id][sType] & player_status)
	    {
	        if(StatusInfo[status_id][sType] & STATUS_TYPE_AFK)
	        {
	            new hour, minute;
	            gettime(hour, minute);
	            
	        	format(status_string, sizeof(status_string), "%s, %s %02d:%02d", status_string, StatusInfo[status_id][sName], hour, minute);
			}
			else
			{
  				format(status_string, sizeof(status_string), "%s, %s", status_string, StatusInfo[status_id][sName]);
			}
	    }
	}
	
	if(strlen(status_string))
	{
		strdel(status_string, 0, 2);
		format(status_string, sizeof(status_string), "%s\n(%s)", name_string, status_string);
	}
	else
	{
	    format(status_string, sizeof(status_string), "%s", name_string);
	}
	
	if(PlayerCache[playerid][pDuty][DUTY_GROUP] != INVALID_GROUP_ID)
	{
 		new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
   		if(GroupData[group_id][gFlags] & G_FLAG_DUTY)
    	{
			format(status_string, sizeof(status_string), "%s\n[%s]", status_string, GroupData[group_id][gTag]);
		}
	}
	
	new player_color = Streamer_GetIntData(STREAMER_TYPE_3D_TEXT_LABEL, Text3D:PlayerCache[playerid][pNameTag], E_STREAMER_COLOR);
	UpdateDynamic3DTextLabelText(Text3D:PlayerCache[playerid][pNameTag], player_color, status_string);
	return 1;
}

public CreatePlayerCorpse(playerid, killer_uid, weapon_uid)
{
	new	Float:PosX, Float:PosY, Float:PosZ, Float:PosA, InteriorID, VirtualWorldID,
	    date = gettime(), corpse_death = PlayerCache[playerid][pDeathType], corpse_name[32];

	GetPlayerPos(playerid, PosX, PosY, PosZ);
	GetPlayerFacingAngle(playerid, PosA);

	InteriorID = GetPlayerInterior(playerid);
	VirtualWorldID = GetPlayerVirtualWorld(playerid);

	if(PlayerCache[playerid][pDocuments])	format(corpse_name, sizeof(corpse_name), "Zwloki %s", PlayerRealName(playerid));
	else                                    corpse_name = "Zwloki (niezidentyfikowane)";
	
	new actorid = crp_CreateActor(corpse_name, PlayerCache[playerid][pSkin], PosX, PosY, PosZ, PosA, VirtualWorldID, InteriorID);
	
	new ActorData[sActorData];
	Streamer_GetArrayData(STREAMER_TYPE_ACTOR, actorid, E_STREAMER_EXTRA_ID, ActorData);
	
	mysql_query_format("INSERT INTO `"SQL_PREF"corpses` (corpse_owner, corpse_killer, corpse_death, corpse_weapon, corpse_body, corpse_actor, corpse_date) VALUES ('%d', '%d', '%d', '%d', '%d', '%d', '%d')", PlayerCache[playerid][pUID], killer_uid, corpse_death, weapon_uid, PlayerCache[playerid][pDeathBody], ActorData[aUID], date);

	ActorData[aType] = ACTOR_CORPSE;
	ActorData[aLabel] = CreateDynamic3DTextLabel(corpse_name, COLOR_RED, PosX, PosY, PosZ - 0.5, 20.0);
	
	new anim_id = GetAnimByCommand(".padnij");
	if(anim_id != INVALID_ANIM_ID)
	{
		ActorData[aAnim] = AnimCache[anim_id][aUID];

		ClearDynamicActorAnimations(actorid);
		ApplyDynamicActorAnimation(actorid, AnimCache[anim_id][aLib], AnimCache[anim_id][aName], AnimCache[anim_id][aSpeed], AnimCache[anim_id][aOpt1], AnimCache[anim_id][aOpt2], AnimCache[anim_id][aOpt3], AnimCache[anim_id][aOpt4], AnimCache[anim_id][aOpt5]);
	}
	
	Streamer_SetArrayData(STREAMER_TYPE_ACTOR, actorid, E_STREAMER_EXTRA_ID, ActorData);
	SaveActor(actorid);
	return 1;
}

public OnPlayerRequestDownload(playerid, type, crc)
{
	new fullurl[256+1], dlfilename[64+1], foundfilename = 0,
	    string[256];

	if(!IsPlayerConnected(playerid)) return 0;

	if(type == DOWNLOAD_REQUEST_TEXTURE_FILE)
	{
		format(string, sizeof(string), "Pobieranie plikow w toku.~n~Pamietaj by nie minimalizowac gry do czasu ukonczenia pobierania~n~~n~Aktualny plik: ~y~txd %d", crc);
		foundfilename = FindTextureFileNameFromCRC(crc,dlfilename,64);
	}
	else if(type == DOWNLOAD_REQUEST_MODEL_FILE)
	{
		format(string, sizeof(string), "Pobieranie plikow w toku.~n~Pamietaj by nie minimalizowac gry do czasu ukonczenia pobierania~n~~n~Aktualny plik: ~y~dff %d", crc);
	    foundfilename = FindModelFileNameFromCRC(crc,dlfilename,64);
	}

	if(foundfilename)
	{
	    TD_ShowSmallInfo(playerid, 0, string);
	
	    format(fullurl,256,"%s/%s", models_url, dlfilename);
	    RedirectDownload(playerid, fullurl);
	}
	return 1;
}

public OnPlayerFinishedDownloading(playerid, virtualworld)
{
    foreach(new i : Player)
	{
	    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	    {
	        if(PlayerCache[i][pSpectate] == playerid)
	        {
         		SetPlayerVirtualWorld(i, virtualworld);
	            //SetPlayerInterior(i, GetPlayerInterior(playerid));
	            
	            switch(GetPlayerState(playerid))
	            {
      		    	case 0, 1, 7, 8:
				    {
						PlayerSpectatePlayer(i, playerid);
					}
	    			case 2, 3:
	    			{
						PlayerSpectateVehicle(i , GetPlayerVehicleID(playerid));
					}
		   			case 9:
				    {
				        SetPlayerSpawn(i);
				    }
	            }
	        }
	    }
	}
	
	SetPlayerVirtualWorld(playerid, virtualworld);
	
	if(PlayerCache[playerid][pLogged])  return 1;
	TD_HideSmallInfo(playerid);

	mysql_query_format("SELECT `member_id`, `members_pass_hash` FROM `core_members` WHERE name = '%s' LIMIT 1", PlayerName(playerid));
	
	new rows, string[256];
	cache_get_row_count(rows);
	if(rows > 0)
	{
	    // Znalazło konto globalne
	    cache_get_value_index_int(0, 0, PlayerCache[playerid][pGID]);
	    cache_get_value_index(0, 1, PlayerCache[playerid][pPassword], 256);

	    format(string, sizeof(string), "Wprowadź poniżej hasło do konta %s (GID: %d).\n\nJeśli konto nie należy do Ciebie, oznacza to, że takie konto\njuż istnieje i nie możesz stworzyć nowego o tej nazwie.\nJeśli chcesz założyć nowe konto, wyjdź z gry i wprowadź inny nick w okno SAMP.", PlayerName(playerid), PlayerCache[playerid][pGID]);
	    ShowPlayerDialog(playerid, D_LOGIN, DIALOG_STYLE_PASSWORD, "Logowanie", string, "Dalej", "Wyjdź");
	}
	else
	{
	    // Nie znalazło, chcesz stworzyć?
	    format(string, sizeof(string), "Konto %s nie zostało znalezione w naszej bazie danych...\nJednak to nic straconego! Możesz je założyć właśnie teraz.\n\nWprowadź poniżej hasło dla swojego konta, którego będziesz używał do logowania.", PlayerName(playerid));
	    ShowPlayerDialog(playerid, D_REGISTER, DIALOG_STYLE_PASSWORD, "Rejestracja", string, "Rejestruj", "Wyjdź");
	}
	
	

	return 1;
}

public OnDynamicActorStreamIn(actorid, forplayerid)
{
	new ActorData[sActorData];
	Streamer_GetArrayData(STREAMER_TYPE_ACTOR, actorid, E_STREAMER_EXTRA_ID, ActorData);
	
	if(ActorData[aAnim] == 0)   return 1;
	
	new anim_id = GetAnimID(ActorData[aAnim]);
	if(anim_id == INVALID_ANIM_ID)  return 1;
	
	ClearDynamicActorAnimations(actorid);
	if(AnimCache[anim_id][aAction] == 0)	ApplyDynamicActorAnimation(actorid, AnimCache[anim_id][aLib], AnimCache[anim_id][aName], AnimCache[anim_id][aSpeed], AnimCache[anim_id][aOpt1], AnimCache[anim_id][aOpt2], AnimCache[anim_id][aOpt3], AnimCache[anim_id][aOpt4], AnimCache[anim_id][aOpt5]);
	return 1;
}

/* Komendy */
cmd:test(playerid, params[])
{
/*
	new slot, Float:rotx, Float:roty, Float:rotz, Float:zoom;
	sscanf(params, "dffff", slot, rotx, roty, rotz, zoom);

    TextDrawSetPreviewRot(GII_Option[slot], rotx, roty, rotz, zoom);
*/





	/*
	new type, Float:handling;
	if(sscanf(params, "df", type, handling))
	{
	    new Float:hand;
	    ShowTipForPlayer(playerid, "/test [typ świateł] [handling]");
	    
    	if(IsPlayerInAnyVehicle(playerid))
		{
	    	new vehid = GetPlayerVehicleID(playerid);
	    	GetVehicleHandlingFloat(vehid, HANDL_TR_FENGINEACCELERATION, hand);

	    	ShowTipForPlayer(playerid, "VELOCITY: %f", hand);
		}
	    return 1;
	}
	
	if(IsPlayerInAnyVehicle(playerid))
	{
	    new vehid = GetPlayerVehicleID(playerid);
	    SetVehicleHandlingFloat(vehid, HANDL_TR_FENGINEACCELERATION, handling);
	    
	    TD_ShowSmallInfo(playerid, 5, "Ustawiono handling na %f", handling);
	}
	*/
	return 1;
}

cmd:qs(playerid, params[])
{
	if(PlayerCache[playerid][pBusTravel] != INVALID_OBJECT_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz tego teraz zrobić.");
	    return 1;
	}
	new string[128],
	    Float:PosX, Float:PosY, Float:PosZ;
	    
    format(string, sizeof(string), "(( %s - /qs ))", PlayerRealName(playerid));
    GetPlayerPos(playerid, PosX, PosY, PosZ);

	PlayerCache[playerid][pPosX] = PosX;
	PlayerCache[playerid][pPosY] = PosY;
	PlayerCache[playerid][pPosZ] = PosZ;

	PlayerCache[playerid][pVirtualWorld] = GetPlayerVirtualWorld(playerid);
	PlayerCache[playerid][pInteriorID] = GetPlayerInterior(playerid);
	
	new Text3D:reason_label = CreateDynamic3DTextLabel(string, 0xB4B5B766, PosX, PosY, PosZ + 0.3, 15.0);
	defer OnDestroyReasonLabel[15000](_:reason_label);

	PlayerCache[playerid][pCrash] = gettime();
	orm_update(PlayerCache[playerid][pOrm]);

	defer OnKickPlayer(playerid);
	return 1;
}

cmd:stats(playerid, params[])
{
	new giveplayer_id;
	if(sscanf(params, "u", giveplayer_id))
	{
	    ShowPlayerStatsForPlayer(playerid, playerid);
	    return 1;
	}
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_BASIC))
	{
	    ShowPlayerStatsForPlayer(playerid, playerid);
	    return 1;
	}
	if(giveplayer_id == INVALID_PLAYER_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	    return 1;
	}
	if(!PlayerCache[giveplayer_id][pLogged])
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    return 1;
	}
	ShowPlayerStatsForPlayer(giveplayer_id, playerid);
	return 1;
}
alias:stats("staty");

cmd:pomoc(playerid, params[])
{
	new list_help[256];
	strcat(list_help, "» Wprowadzenie\n", sizeof(list_help));
	strcat(list_help, "» Komendy podstawowe\n", sizeof(list_help));
	
	strcat(list_help, "» Pojazd\n", sizeof(list_help));
	strcat(list_help, "» Ekwipunek\n", sizeof(list_help));
	
	strcat(list_help, "» Praca dorywcza\n", sizeof(list_help));
	strcat(list_help, "» Animacje\n", sizeof(list_help));
	
	strcat(list_help, "» Dostępne oferty\n", sizeof(list_help));
	
	if(IsPlayerInAnyGroup(playerid))	strcat(list_help, "» Grupy\n", sizeof(list_help));
	if(PlayerCache[playerid][pAdmin])	strcat(list_help, "» Administracja\n", sizeof(list_help));
	
	PlayerCache[playerid][pMainTable] = 0;
	ShowPlayerDialog(playerid, D_HELP_MAIN, DIALOG_STYLE_LIST, "Pomoc główna", list_help, "Wybierz", "Anuluj");
	return 1;
}
alias:pomoc("help");

cmd:ag(playerid, params[])
{
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_GROUPS))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz zarządzać grupami.");
 		return 1;
	}
	new type[32], varchar[64], string[256];
	if(sscanf(params, "s[32]S()[64]", type, varchar))
	{
	    ShowTipForPlayer(playerid, "/ag [stworz, lider, lista, nazwa, usun, info, typ, wypros, zapros]");
	    return 1;
	}
	if(!strcmp(type, "stworz", true) || !strcmp(type, "create", true))
	{
	    new group_type, group_name[32];
	    if(sscanf(varchar, "k<group_type>s[32]", group_type, group_name))
	    {
	        ShowTipForPlayer(playerid, "/ag stworz [Typ grupy] [Nazwa grupy]");
	        return 1;
	    }
	    if(group_type == INVALID_GROUP_TYPE)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędny typ grupy.");
	        return 1;
	    }
	    new group_uid = CreateGroup(group_name, group_type);
		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Pomyślnie utworzono grupę %s (UID: %d).\n\nTyp grupy: %s", group_name, group_uid, GroupTypeInfo[group_type][gTypeName]);
		return 1;
	}
	if(!strcmp(type, "lider", true) || !strcmp(type, "leader", true))
	{
	    new group_uid, giveplayer_id;
	    if(sscanf(varchar, "du", group_uid, giveplayer_id))
	    {
			ShowTipForPlayer(playerid, "/ag lider [UID grupy] [ID gracza]");
	        return 1;
	    }
	    new group_id = GetGroupID(group_uid);
	    if(group_id == INVALID_GROUP_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID grupy.");
	        return 1;
	    }
    	if(giveplayer_id == INVALID_PLAYER_ID)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
		   	return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(IsPlayerInGroup(giveplayer_id, GroupData[group_id][gUID]) || (GroupData[group_id][gOwner] && IsPlayerInGroup(giveplayer_id, GroupData[group_id][gOwner])))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz należy już do tej grupy lub jej podgrupy.");
		    return 1;
		}
		new group_slot = GetPlayerFreeGroupSlot(giveplayer_id);
		if(group_slot == INVALID_SLOT_ID)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz nie posiada żadnego wolnego slotu dla grupy.");
		    return 1;
		}
		PlayerGroup[giveplayer_id][group_slot][gpUID] = GroupData[group_id][gUID];
		PlayerGroup[giveplayer_id][group_slot][gpID] = group_id;

		PlayerGroup[giveplayer_id][group_slot][gpPerm] = G_PERM_MAX;
		mysql_query_format("INSERT INTO `"SQL_PREF"char_groups` (`char_uid`, `group_belongs`, `group_perm`, `char_joined`) VALUES ('%d', '%d', '%d', '%d')", PlayerCache[giveplayer_id][pUID], GroupData[group_id][gUID], G_PERM_MAX, gettime());

		ShowPlayerInfoDialog(giveplayer_id, D_TYPE_INFO, "Administrator %s przypisał Ci lidera grupy %s (UID: %d).\nSkorzystaj z komendy /pomoc, by zapoznać się z komendami lidera.", PlayerName(playerid), GroupData[group_id][gName], GroupData[group_id][gUID]);
		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Gracz %s (ID: %d, UID: %d) otrzymał lidera grupy %s (UID: %d).", PlayerName(giveplayer_id), giveplayer_id, PlayerCache[giveplayer_id][pUID], GroupData[group_id][gName], GroupData[group_id][gUID]);
		return 1;
	}
	if(!strcmp(type, "nazwa", true) || !strcmp(type, "name", true))
	{
	    new group_uid, group_name[32];
	    if(sscanf(varchar, "ds[32]", group_uid, group_name))
	    {
	        ShowTipForPlayer(playerid, "/ag nazwa [UID grupy] [Nowa nazwa]");
	        return 1;
	    }
	    new group_id = GetGroupID(group_uid);
	    if(group_id == INVALID_GROUP_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID grupy.");
	        return 1;
	    }
	    strmid(GroupData[group_id][gName], group_name, 0, strlen(group_name), 32);
		orm_update(GroupData[group_id][gOrm]);
		
	    ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Nazwa grupy (UID: %d) została zmieniona pomyślnie.\nNowa nazwa: %s", GroupData[group_id][gUID], group_name);
		return 1;
	}
	if(!strcmp(type, "usun", true) || !strcmp(type, "delete", true))
	{
	    new group_uid;
	    if(sscanf(varchar, "d", group_uid))
	    {
	        ShowTipForPlayer(playerid, "/ag usun [UID grupy]");
	        return 1;
	    }
	    new group_id = GetGroupID(group_uid);
	    if(group_id == INVALID_GROUP_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID grupy.");
	        return 1;
	    }
	    printf("[admin][grou] %s (UID: %d, GID: %d) usunął grupę %s (UID: %d).", PlayerRealName(playerid), PlayerCache[playerid][pUID], PlayerCache[playerid][pGID], GroupData[group_id][gName], GroupData[group_id][gUID]);
	    
	    DeleteGroup(group_id);
		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Grupa została pomyślnie usunięta z bazy danych.");
	    return 1;
	}
	if(!strcmp(type, "info", true))
	{
	    new group_uid;
	    if(sscanf(varchar, "d", group_uid))
	    {
	        ShowTipForPlayer(playerid, "/ag info [UID grupy]");
	        return 1;
	    }
	    new group_id = GetGroupID(group_uid);
	    if(group_id == INVALID_GROUP_ID)
	    {
            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID grupy.");
	        return 1;
	    }
	    ShowPlayerGroupInfo(playerid, group_id);
	    return 1;
	}
	if(!strcmp(type, "typ", true))
	{
 		new group_uid;
	    if(sscanf(varchar, "d", group_uid))
	    {
	        ShowTipForPlayer(playerid, "/ag typ [UID grupy]");
	        return 1;
	    }
	    new group_id = GetGroupID(group_uid);
	    if(group_id == INVALID_GROUP_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID grupy.");
	        return 1;
	    }
	    PlayerCache[playerid][pMainTable] = group_id;

		new list_group_type[512];
		for (new i = 0; i < sizeof(GroupTypeInfo); i++)
		{
		    format(list_group_type, sizeof(list_group_type), "%s\n%d\t%s", list_group_type, i + 1, GroupTypeInfo[i][gTypeName]);
		}

		format(string, sizeof(string), "%s (UID: %d) » Zmiana typu", GroupData[group_id][gName], GroupData[group_id][gUID]);
		ShowPlayerDialog(playerid, D_GROUP_TYPE, DIALOG_STYLE_LIST, string, list_group_type, "Wybierz", "Anuluj");
	    return 1;
	}
	if(!strcmp(type, "wypros", true) || !strcmp(type, "uninvite", true))
	{
		new giveplayer_id, group_uid;
		if(sscanf(varchar, "ud", giveplayer_id, group_uid))
		{
		    ShowTipForPlayer(playerid, "/ag wypros [ID gracza] [UID grupy]");
		    return 1;
		}
 		if(giveplayer_id == INVALID_PLAYER_ID)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
   			return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
  		new group_id = GetPlayerGroupID(giveplayer_id, group_uid);
	    if(group_id == INVALID_GROUP_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz nie jest członkiem tej grupy, lub grupa nie istnieje.");
	        return 1;
	    }
		new group_slot = GetPlayerGroupSlot(giveplayer_id, GroupData[group_id][gUID]);

		if(PlayerCache[giveplayer_id][pDuty][DUTY_GROUP] == group_id)
		{
		    UpdatePlayerSession(giveplayer_id, SESSION_GROUP, GroupData[group_id][gUID]);

		    PlayerCache[giveplayer_id][pDuty][DUTY_GROUP] = INVALID_GROUP_ID;
		    PlayerCache[giveplayer_id][pSession][SESSION_GROUP] = 0;
		}

  		PlayerGroup[giveplayer_id][group_slot][gpUID] = 0;
    	PlayerGroup[giveplayer_id][group_slot][gpID] = 0;

		PlayerGroup[giveplayer_id][group_slot][gpPerm] = 0;
  		strmid(PlayerGroup[giveplayer_id][group_slot][gpTitle], "Brak", 0, 4, 32);

		PlayerGroup[giveplayer_id][group_slot][gpPayment] = 0;
		mysql_query_format("DELETE FROM `"SQL_PREF"char_groups` WHERE char_uid = '%d' AND group_belongs = '%d'", PlayerCache[giveplayer_id][pUID], GroupData[group_id][gUID]);

		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Wyprosiłeś gracza %s z grupy %s (UID: %d).", PlayerName(giveplayer_id), GroupData[group_id][gName], GroupData[group_id][gUID]);
		ShowPlayerInfoDialog(giveplayer_id, D_TYPE_INFO, "Administrator %s wyprosił Cię z grupy %s (UID: %d).", PlayerName(playerid), GroupData[group_id][gName], GroupData[group_id][gUID]);
	    return 1;
	}
	if(!strcmp(type, "zapros", true) || !strcmp(type, "invite", true))
	{
		new giveplayer_id, group_uid;
		if(sscanf(varchar, "ud", giveplayer_id, group_uid))
		{
		    ShowTipForPlayer(playerid, "/ag zapros [ID gracza] [UID grupy]");
		    return 1;
		}
 		if(giveplayer_id == INVALID_PLAYER_ID)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
   			return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		new group_id = GetPlayerGroupID(giveplayer_id, group_uid);
	    if(group_id != INVALID_GROUP_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz należy już do tej grupy, lub grupa nie istnieje.");
	        return 1;
	    }
		new group_slot = GetPlayerFreeGroupSlot(giveplayer_id);
		if(group_slot == INVALID_SLOT_ID)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz nie posiada żadnego wolnego slotu dla grupy.");
		    return 1;
		}
		PlayerGroup[giveplayer_id][group_slot][gpUID] = GroupData[group_id][gUID];
		PlayerGroup[giveplayer_id][group_slot][gpID] = group_id;

	    mysql_query_format("INSERT INTO `"SQL_PREF"char_groups` (`char_uid`, `group_belongs`, `char_joined`) VALUES ('%d', '%d', '%d')", PlayerCache[giveplayer_id][pUID], GroupData[group_id][gUID], gettime());

		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Zaprosiłeś gracza %s do grupy %s (UID: %d).", PlayerName(giveplayer_id), GroupData[group_id][gName], GroupData[group_id][gUID]);
		ShowPlayerInfoDialog(giveplayer_id, D_TYPE_INFO, "Administrator %s zaprosił Cię do grupy %s (UID: %d).", PlayerName(playerid), GroupData[group_id][gName], GroupData[group_id][gUID]);
	    return 1;
	}
	return 1;
}

cmd:g(playerid, params[])
{
	new group_slot = INVALID_SLOT_ID, type[32], varchar[64];
	//if(is_null(params))	SendClientMessage(playerid, COLOR_GREY, "Jeżeli jesteś na służbie jednej z grup, nie musisz podawać jej slotu - skrypt automatycznie go wyszuka.");

	if(sscanf(params, "ds[32]S()[64]", group_slot, type, varchar))
	{
		if(IsPlayerInAnyGroup(playerid))
		{
   			ShowPlayerGroupOptions(playerid);
   			ShowTipForPlayer(playerid, "/g {slot (1-%d)} [info, online, duty, przebierz, zapros, wypros, wplac, wyplac, pojazdy, respawn, magazyn]", MAX_GROUP_SLOTS);
		}
		else
		{
		    TD_ShowSmallInfo(playerid, 3, "Nie jestes czlonkiem ~r~zadnej ~w~grupy.");
		}
		return 1;
	}
	group_slot -= 1;
	if(group_slot < 0 || group_slot >= MAX_GROUP_SLOTS)
	{
	    GameTextForPlayer(playerid, "~r~Nieprawidlowy slot grupy.", 3000, 3);
	    return 1;
	}
	if(!PlayerGroup[playerid][group_slot][gpUID])
	{
	    GameTextForPlayer(playerid, "~r~Nieprawidlowy slot grupy.", 3000, 3);
	    return 1;
	}
	if(!strcmp(type, "info", true))
	{
	    new group_id = PlayerGroup[playerid][group_slot][gpID];
	    ShowPlayerGroupInfo(playerid, group_id);
	    return 1;
	}
	if(!strcmp(type, "online", true))
	{
  		new list_workers[1024];
    	foreach(new i : Player)
	    {
	        if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	        {
       			if(IsPlayerInGroup(i, PlayerGroup[playerid][group_slot][gpUID]))
				{
				    if(PlayerCache[i][pDuty][DUTY_GROUP] == PlayerGroup[playerid][group_slot][gpID])
				    {
						format(list_workers, sizeof(list_workers), "%s\n%d\t\t{008000}%s{FFFFFF}", list_workers, i, PlayerName(i));
					}
					else
					{
					    format(list_workers, sizeof(list_workers), "%s\n%d\t\t%s", list_workers, i, PlayerName(i));
					}
				}
        	}
	    }
	    
		ShowPlayerDialog(playerid, D_PLAYER_LIST, DIALOG_STYLE_LIST, "Członkowie online:", list_workers, "PW", "Zamknij");
		return 1;
	}
	if(!strcmp(type, "zadania", true) || !strcmp(type, "quest", true))
	{
	    new group_id = PlayerGroup[playerid][group_slot][gpID];
	    if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz być na służbie grupy, by móc wybrać zadanie.");
	        return 1;
	    }
	    
		new query[256], title[128], list_missions[1024],
			Cache:tmp_cache, rows;
			
		new mission_uid, mission_type, mission_members, mission_award, mission_date, mission_limit, mission_time, mission_hours, mission_minutes;
		format(list_missions, sizeof(list_missions), "Typ zadania\tIlość osób\tNagroda\tCzas wykonania");
			
		mysql_format(connHandle, query, sizeof(query), "SELECT `mission_uid`, `mission_type`, `mission_members`, `mission_award`, `mission_date`, `mission_limit`, `mission_time` FROM `"SQL_PREF"group_missions` WHERE mission_owner = '%d' AND mission_extraid = 0 OR mission_owner = 0 AND mission_extraid = '%d'", GroupData[group_id][gType], GroupData[group_id][gUID]);
	    tmp_cache = mysql_query(connHandle, query);
	    
	    DynamicGui_Init(playerid);
	    
	    cache_get_row_count(rows);
		for(new row = 0; row < rows; row++)
		{
		    cache_get_value_index_int(row, 0, mission_uid);
		    cache_get_value_index_int(row, 1, mission_type);
		    cache_get_value_index_int(row, 2, mission_members);
		    cache_get_value_index_int(row, 3, mission_award);
		    cache_get_value_index_int(row, 4, mission_date);
            cache_get_value_index_int(row, 5, mission_limit);
            cache_get_value_index_int(row, 6, mission_time);
            
    		mission_hours = floatround(mission_time / 3600, floatround_floor),
			mission_minutes = floatround(mission_time / 60, floatround_floor) % 60;
		
		    mission_type -= 1;
			if(mission_date + mission_limit < gettime())
			{
				format(list_missions, sizeof(list_missions), "%s\n%s\tx%d\t$%d\t%dh %dm", list_missions, MissionTypeInfo[mission_type][mName], mission_members, mission_award, mission_hours, mission_minutes);
                DynamicGui_AddRow(playerid, D_NONE, mission_uid);
			}
		}
		DynamicGui_SetDialogValue(playerid, group_id);
		if(cache_is_valid(tmp_cache))	cache_delete(tmp_cache);
		
		if(rows > 0)
		{
			format(title, sizeof(title), "Zadania dla grupy %s (UID: %d)", GroupData[group_id][gName], GroupData[group_id][gUID]);
			ShowPlayerDialog(playerid, D_MISSION_DESC, DIALOG_STYLE_TABLIST_HEADERS, title, list_missions, "Szczegóły", "Zamknij");
		}
		else
		{
		    TD_ShowSmallInfo(playerid, 3, "Grupa ~r~nie posiada ~w~zadnych aktywnych zadan do wykonania.");
		}
	    return 1;
	}
	if(!strcmp(type, "sluzba", true) || !strcmp(type, "duty", true))
	{
		if(GetCustomerID(playerid) != INVALID_PLAYER_ID)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz skorzystać ze służby zaraz po wysłaniu oferty.");
		    return 1;
		}
		new group_id = PlayerGroup[playerid][group_slot][gpID];
		/*
	    
		if(GroupData[group_id][gFlags] & G_FLAG_DUTY)
  		{
			new doorid = GetPlayerDoorID(playerid);
			if(doorid != INVALID_DOOR_ID)
			{
				new DoorData[sDoorInfo];
				Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);

				if(DoorData[dOwnerType] != OWNER_GROUP)
				{
					ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ta grupa ma ograniczoną służbę, możesz być na służbie tylko w budynku, lub strefie należącej do grupy.");
					return 1;
				}

				if(DoorData[dOwner] != GroupData[group_id][gUID])
				{
					ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ta grupa ma ograniczoną służbę, możesz być na służbie tylko w budynku, lub strefie należącej do grupy.");
					return 1;
				}
			}
			else
			{
				new areaid = GetPlayerAreaID(playerid);
				if(areaid == INVALID_AREA_ID)
				{
					ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ta grupa ma ograniczoną służbę, możesz być na służbie tylko w budynku, lub strefie należącej do grupy.");
					return 1;
				}
				new AreaData[sAreaData];
				Streamer_GetArrayData(STREAMER_TYPE_AREA, areaid, E_STREAMER_EXTRA_ID, AreaData);

				if(AreaData[aOwnerType] != OWNER_GROUP)
				{
					ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ta grupa ma ograniczoną służbę, możesz być na służbie tylko w budynku, lub strefie należącej do grupy.");
					return 1;
				}

				if(AreaData[aOwner] != GroupData[group_id][gUID])
				{
					ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ta grupa ma ograniczoną służbę, możesz być na służbie tylko w budynku, lub strefie należącej do grupy.");
					return 1;
				}
			}
		}
		*/
	    if(PlayerCache[playerid][pDuty][DUTY_GROUP] != INVALID_GROUP_ID)
		{
	        if(PlayerCache[playerid][pDuty][DUTY_GROUP] == group_id)
	        {
        		new	duty_hours = floatround((gettime() - PlayerCache[playerid][pSession][SESSION_GROUP]) / 3600, floatround_floor),
					duty_minutes = floatround((gettime() - PlayerCache[playerid][pSession][SESSION_GROUP]) / 60, floatround_floor) % 60;
	        
	            UpdatePlayerSession(playerid, SESSION_GROUP, GroupData[group_id][gUID]);
	            
	            PlayerCache[playerid][pDuty][DUTY_GROUP] = INVALID_GROUP_ID;
	            PlayerCache[playerid][pSession][SESSION_GROUP] = 0;

	            PlayerCache[playerid][pNickColor] = (COLOR_NICK & ~0xFF) | clamp(0x88, 0x00, 0xFF);
	            Streamer_SetIntData(STREAMER_TYPE_3D_TEXT_LABEL, Text3D:PlayerCache[playerid][pNameTag], E_STREAMER_COLOR, PlayerCache[playerid][pNickColor]);
	            
				PlayerTextDrawHide(playerid, TextDrawDuty[playerid]);
	            SendClientFormatMessage(playerid, GroupData[group_id][gColor], "» Zszedłeś ze służby grupy %s (UID: %d). Czas trwania sesji: %dh %dm.", GroupData[group_id][gName], GroupData[group_id][gUID], duty_hours, duty_minutes);
	            return 1;
	        }
	        else
			{
	            UpdatePlayerSession(playerid, SESSION_GROUP, GroupData[group_id][gUID]);
	        }
	    }
	    
	    PlayerCache[playerid][pDuty][DUTY_GROUP] = group_id;
	    PlayerCache[playerid][pSession][SESSION_GROUP] = gettime();
	    
	    new group_color = (GroupData[group_id][gColor] & 0xFFFFFF00) + 136,
			start_hour, start_minute;
			
		gettime(start_hour, start_minute);
        if(GroupData[group_id][gFlags] & G_FLAG_COLOR)
        {
            if(GroupData[group_id][gColor] != -1)
            {
			    PlayerCache[playerid][pNickColor] = group_color;
			    Streamer_SetIntData(STREAMER_TYPE_3D_TEXT_LABEL, Text3D:PlayerCache[playerid][pNameTag], E_STREAMER_COLOR, PlayerCache[playerid][pNickColor]);
			}
		}
		TD_ShowLargeInfo(playerid, 10, "Sluzba: ~b~~h~grupa               ~y~%s (UID: %d)~n~~n~~w~Rozpoczeto: ~g~~h~%02d:%02d          ~w~Tytul: ~r~~h~%s~n~~n~~y~%s", GroupData[group_id][gName], GroupData[group_id][gUID], start_hour, start_minute, PlayerGroup[playerid][group_slot][gpTitle], GroupData[group_id][gAdvertise]);
	    SendClientFormatMessage(playerid, GroupData[group_id][gColor], "» Wszedłeś na służbę grupy %s (UID: %d). Aby zejść ze służby wpisz /g %d duty.", GroupData[group_id][gName], GroupData[group_id][gUID], group_slot + 1);

		PlayerTextDrawSetString(playerid, TextDrawDuty[playerid], GroupData[group_id][gTag]);
		PlayerTextDrawBackgroundColor(playerid, TextDrawDuty[playerid], group_color);

		PlayerTextDrawShow(playerid, TextDrawDuty[playerid]);
		return 1;
	}
	if(!strcmp(type, "przebierz", true))
	{
		if(PlayerGroup[playerid][group_slot][gpSkin])
		{
		    SetPlayerSkinEx(playerid, PlayerGroup[playerid][group_slot][gpSkin]);
		}
		else
		{
		    TD_ShowSmallInfo(playerid, 3, "Nie posiadasz ~r~tego ~w~ubrania.");
		}
		return 1;
	}
	if(!strcmp(type, "zapros", true) || !strcmp(type, "invite", true))
	{
	    if(!(PlayerGroup[playerid][group_slot][gpPerm] & G_PERM_LEADER))
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie posiadasz uprawnień lidera grupy.");
			return 1;
	    }
	    new giveplayer_id;
	    if(sscanf(varchar, "u", giveplayer_id))
	    {
	        ShowTipForPlayer(playerid, "/g {slot (1-%d)} zapros [ID gracza]", MAX_GROUP_SLOTS);
	        return 1;
	    }
	    if(giveplayer_id == INVALID_PLAYER_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	        return 1;
	    }
	    if(!PlayerCache[giveplayer_id][pLogged])
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	        return 1;
	    }
	    if(giveplayer_id == playerid)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zatrudnić siebie.");
	        return 1;
	    }
	    new group_id = PlayerGroup[playerid][group_slot][gpID];
	    if(IsPlayerInGroup(giveplayer_id, GroupData[group_id][gUID]))
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz należy już do tej grupy.");
	        return 1;
	    }
		new giveplayer_group_slot = GetPlayerFreeGroupSlot(giveplayer_id);
		if(giveplayer_group_slot == INVALID_SLOT_ID)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz nie posiada żadnego wolnego slotu dla grupy.");
		    return 1;
		}
		PlayerGroup[giveplayer_id][giveplayer_group_slot][gpUID] = GroupData[group_id][gUID];
		PlayerGroup[giveplayer_id][giveplayer_group_slot][gpID] = group_id;
		
	    mysql_query_format("INSERT INTO `"SQL_PREF"char_groups` (`char_uid`, `group_belongs`, `char_joined`) VALUES ('%d', '%d', '%d')", PlayerCache[giveplayer_id][pUID], GroupData[group_id][gUID], gettime());
		
		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Zaprosiłeś gracza %s do grupy %s (UID: %d).\nPamiętaj, by ustawić mu odpowiednie uprawnienia w panelu grupy.", PlayerName(giveplayer_id), GroupData[group_id][gName], GroupData[group_id][gUID]);
		SendClientFormatMessage(giveplayer_id, GroupData[group_id][gColor], "Gracz %s zaprosił Cię do grupy %s (UID: %d).", PlayerName(playerid), GroupData[group_id][gName], GroupData[group_id][gUID]);

		printf("[grou] %s (UID: %d, GID: %d) zaprosił %s (UID: %d, GID: %d) do grupy %s (UID: %d).", PlayerRealName(playerid), PlayerCache[playerid][pUID], PlayerCache[playerid][pGID], PlayerRealName(giveplayer_id), PlayerCache[giveplayer_id][pUID], PlayerCache[giveplayer_id][pGID], GroupData[group_id][gName], GroupData[group_id][gUID]);
		return 1;
	}
	if(!strcmp(type, "wypros", true) || !strcmp(type, "uninvite", true))
	{
		if(!(PlayerGroup[playerid][group_slot][gpPerm] & G_PERM_LEADER))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie posiadasz uprawnień lidera grupy.");
	    	return 1;
		}
		new giveplayer_id;
		if(sscanf(varchar, "u", giveplayer_id))
		{
			ShowTipForPlayer(playerid, "/g {slot (1-%d)} wypros [ID gracza]", MAX_GROUP_SLOTS);
		    return 1;
		}
		if(giveplayer_id == INVALID_PLAYER_ID)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
   			return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(giveplayer_id == playerid)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz wyprosić siebie.");
		    return 1;
		}
		new group_id = PlayerGroup[playerid][group_slot][gpID];
		if(!IsPlayerInGroup(giveplayer_id, GroupData[group_id][gUID]))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz nie jest członkiem tej grupy.");
		    return 1;
		}
		new giveplayer_group_slot = GetPlayerGroupSlot(giveplayer_id, GroupData[group_id][gUID]);
		
		if(PlayerCache[giveplayer_id][pDuty][DUTY_GROUP] == group_id)
		{
		    UpdatePlayerSession(giveplayer_id, SESSION_GROUP, GroupData[group_id][gUID]);
		    
		    PlayerCache[giveplayer_id][pDuty][DUTY_GROUP] = INVALID_GROUP_ID;
		    PlayerCache[giveplayer_id][pSession][SESSION_GROUP] = 0;
		}

  		PlayerGroup[giveplayer_id][giveplayer_group_slot][gpUID] = 0;
    	PlayerGroup[giveplayer_id][giveplayer_group_slot][gpID] = 0;

		PlayerGroup[giveplayer_id][giveplayer_group_slot][gpPerm] = 0;
  		strmid(PlayerGroup[giveplayer_id][giveplayer_group_slot][gpTitle], "Brak", 0, 4, 32);

		PlayerGroup[giveplayer_id][giveplayer_group_slot][gpPayment] = 0;
		mysql_query_format("DELETE FROM `"SQL_PREF"char_groups` WHERE char_uid = '%d' AND group_belongs = '%d'", PlayerCache[giveplayer_id][pUID], GroupData[group_id][gUID]);

		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Wyprosiłeś gracza %s z grupy %s (UID: %d).", PlayerName(giveplayer_id), GroupData[group_id][gName], GroupData[group_id][gUID]);
		SendClientFormatMessage(giveplayer_id, GroupData[group_id][gColor], "Gracz %s wyprosił Cię z grupy %s (UID: %d).", PlayerName(playerid), GroupData[group_id][gName], GroupData[group_id][gUID]);

        printf("[grou] %s (UID: %d, GID: %d) wyprosił %s (UID: %d, GID: %d) z grupy %s (UID: %d).", PlayerRealName(playerid), PlayerCache[playerid][pUID], PlayerCache[playerid][pGID], PlayerRealName(giveplayer_id), PlayerCache[giveplayer_id][pUID], PlayerCache[giveplayer_id][pGID], GroupData[group_id][gName], GroupData[group_id][gUID]);
		return 1;
	}
	if(!strcmp(type, "wyplac", true))
	{
		if(!(PlayerGroup[playerid][group_slot][gpPerm] & G_PERM_LEADER))
		{
	    	ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz odpowiednich uprawnień, aby użyć tej komendy.");
	    	return 1;
		}
	   	new price;
	   	if(sscanf(varchar, "d", price))
	   	{
	   	    ShowTipForPlayer(playerid, "/g [slot (1-%d)] wyplac [Kwota]", MAX_GROUP_SLOTS);
	   	    return 1;
	   	}
		new doorid = GetPlayerDoorID(playerid);
		if(doorid == INVALID_DOOR_ID)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znajdujesz się w banku.");
		    return 1;
		}
  		new DoorData[sDoorInfo];
  		Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
  		
	 	if(DoorData[dOwnerType] != OWNER_GROUP)
	  	{
	   		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znajdujesz się w banku.");
	   		return 1;
	   	}
	   	new at_group_id = GetGroupID(DoorData[dOwner]);
	   	if(GroupData[at_group_id][gType] != G_TYPE_BANK)
	   	{
	   	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znajdujesz się w banku.");
	   	    return 1;
	   	}
	   	if(price <= 0)
	   	{
	   	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłową kwotę.");
	   	    return 1;
	   	}
	   	new group_id = PlayerGroup[playerid][group_slot][gpID];
	   	if(price > GroupData[group_id][gCash])
	   	{
	   	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz takiej ilości gotówki na koncie biznesu.");
	   	    return 1;
	   	}
	   	if(PlayerCache[playerid][pHours] < 5)
	   	{
	   	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz wypłacać pieniędzy dopóki nie przegrasz 5h.");
	   	    return 1;
	   	}
	   	crp_GivePlayerMoney(playerid, price);
	   	orm_update(PlayerCache[playerid][pOrm]);

	   	GroupData[group_id][gCash] -= price;
	   	orm_update(GroupData[group_id][gOrm]);

        AddGroupTransactionLog(playerid, group_id, TRANSACTION_WITHDRAW, -price, 0, 0);
		ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Wypłaciłeś pieniądze z konta grupy.\n\nZ konta grupy zostało wypłacone: $%d\nPozostałe środki na koncie: $%d", price, GroupData[group_id][gCash]);

		printf("[cash] %s (UID: %d, GID: %d) wypłacił $%d z konta grupy %s (UID: %d). Na koncie pozostało: $%d", PlayerRealName(playerid), PlayerCache[playerid][pUID], PlayerCache[playerid][pGID], price, GroupData[group_id][gName], GroupData[group_id][gUID], GroupData[group_id][gCash]);
		return 1;
	}
	if(!strcmp(type, "wplac", true))
	{
		if(!(PlayerGroup[playerid][group_slot][gpPerm] & G_PERM_LEADER))
		{
	    	ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz odpowiednich uprawnień, aby użyć tej komendy.");
	    	return 1;
		}
	   	new price;
	   	if(sscanf(varchar, "d", price))
	   	{
	   	    ShowTipForPlayer(playerid, "/g [slot (1-%d)] wplac [Kwota]", MAX_GROUP_SLOTS);
	   	    ShowTipForPlayer(playerid, "Uwaga! Pieniądze zostaną automatycznie wpłacone na kapitał grupy - oznacza to, że nie będziesz mógł ich odzyskać!");
	   	    return 1;
	   	}
		new doorid = GetPlayerDoorID(playerid);
		if(doorid == INVALID_DOOR_ID)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znajdujesz się w banku.");
		    return 1;
		}
  		new DoorData[sDoorInfo];
    	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
    	
	 	if(DoorData[dOwnerType] != OWNER_GROUP)
	  	{
	   		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znajdujesz się w banku.");
	   		return 1;
	   	}
	   	new at_group_id = GetGroupID(DoorData[dOwner]);
	   	if(GroupData[at_group_id][gType] != G_TYPE_BANK)
	   	{
	   	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znajdujesz się w banku.");
	   	    return 1;
	   	}
	   	if(price <= 0)
	   	{
	   	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłową kwotę.");
	   	    return 1;
	   	}
	   	if(price > PlayerCache[playerid][pCash])
	   	{
	   	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłową kwotę.");
	   	    return 1;
	   	}
	   	new group_id = PlayerGroup[playerid][group_slot][gpID];

		crp_GivePlayerMoney(playerid, -price);
	   	orm_update(PlayerCache[playerid][pOrm]);

	   	GroupData[group_id][gCapital] += price;
	    orm_update(GroupData[group_id][gOrm]);
	    
		AddGroupTransactionLog(playerid, group_id, TRANSACTION_DEPOSIT, price, 0, 0);
	   	ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Wpłaciłeś pieniądze na konto grupy.\n\nNa konto grupy zostało wpłacone: $%d\nKapitał grupy wynosi: $%d", price, GroupData[group_id][gCapital]);

        printf("[cash] %s (UID: %d, GID: %d) wpłacił $%d na konto grupy %s (UID: %d). Nowy stan konta: $%d", PlayerRealName(playerid), PlayerCache[playerid][pUID], PlayerCache[playerid][pGID], price, GroupData[group_id][gName], GroupData[group_id][gUID], GroupData[group_id][gCapital]);
		return 1;
	}
	if(!strcmp(type, "pojazdy", true) || !strcmp(type, "v", true))
	{
		if(!(PlayerGroup[playerid][group_slot][gpPerm] & G_PERM_CARS))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie posiadasz uprawnień prowadzenia pojazdów.");
	    	return 1;
		}
		
		DynamicGui_Init(playerid);
		
	    new list_vehicles[1024];
	    foreach(new vehid : Vehicles)
	    {
     		if(CarInfo[vehid][cOwnerType] == OWNER_GROUP && CarInfo[vehid][cOwner] == PlayerGroup[playerid][group_slot][gpUID])
     		{
				format(list_vehicles, sizeof(list_vehicles), "%s\n%d\t\t%s", list_vehicles, CarInfo[vehid][cUID], GetVehicleName(CarInfo[vehid][cModel]));
				DynamicGui_AddRow(playerid, D_TARGET_VEH, vehid);
			}
	    }
	    if(strlen(list_vehicles))
	    {
	    	ShowPlayerDialog(playerid, D_TARGET_VEH, DIALOG_STYLE_LIST, "Pojazdy należące do grupy:", list_vehicles, "Namierz", "Anuluj");
		}
		else
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znaleziono żadnych pojazdów przypisanych pod grupę.");
		}
		return 1;
	}
	if(!strcmp(type, "respawn", true) || !strcmp(type, "res", true))
	{
	    if(!(PlayerGroup[playerid][group_slot][gpPerm] & G_PERM_LEADER))
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz odpowiednich uprawnień, aby użyć tej komendy.");
	        return 1;
	    }
     	foreach(new vehid : Vehicles)
      	{
       		if(CarInfo[vehid][cOwnerType] == OWNER_GROUP && CarInfo[vehid][cOwner] == PlayerGroup[playerid][group_slot][gpUID])
         	{
          		if(!IsAnyPlayerInVehicle(vehid))
          		{
					SetVehicleToRespawn(vehid);
     			}
			}
		}
		ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Wszystkie nieużywane pojazdy grupowe zostały przywrócone na miejsce spawnu.");
		return 1;
	}
	if(!strcmp(type, "magazyn", true))
	{
		new doorid = GetPlayerDoorID(playerid);
		if(doorid == INVALID_DOOR_ID)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znajdujesz się w budynku należącym do grupy.");
		    return 1;
		}
  		new DoorData[sDoorInfo];
  		Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
  		
		if(DoorData[dOwnerType] != OWNER_GROUP)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znajdujesz się w budynku należącym do grupy.");
			return 1;
		}
		new group_id = PlayerGroup[playerid][group_slot][gpID];
		if(DoorData[dOwner] != GroupData[group_id][gUID])
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Ten budynek nie należy do tej grupy.");
		    return 1;
		}
  		ListGroupProductsForPlayer(group_id, playerid, PRODUCT_LIST_NONE);
	    return 1;
	}
	if(!strcmp(type, "czat", true))
	{
		if(!(PlayerGroup[playerid][group_slot][gpPerm] & G_PERM_LEADER))
		{
	    	ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz skorzystać z tej komendy.");
	    	return 1;
		}

		new group_id = PlayerGroup[playerid][group_slot][gpID];
		if(GroupData[group_id][gToggleChat])
		{
		    GroupData[group_id][gToggleChat] = false;
			SendClientFormatMessage(playerid, GroupData[group_id][gColor], "Czat OOC grupy %s (UID: %d) został włączony.", GroupData[group_id][gName], GroupData[group_id][gUID]);
		}
		else
		{
  			GroupData[group_id][gToggleChat] = true;
			SendClientFormatMessage(playerid, GroupData[group_id][gColor], "Czat OOC grupy %s (UID: %d) został wyłączony.", GroupData[group_id][gName], GroupData[group_id][gUID]);
		}
	    return 1;
	}
	return 1;
}

cmd:apojazd(playerid, params[])
{
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_CARS))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz zarządzać pojazdami.");
	    return 1;
	}
	new type[32], varchar[32];
	if(sscanf(params, "s[32]S()[32]", type, varchar))
	{
	    ShowTipForPlayer(playerid, "/apojazd [stworz, usun, model, kolor1, kolor2, paliwo, hp, zaparkuj, zamknij, info]");
		ShowTipForPlayer(playerid, "/apojazd [res, przebieg, visual, spawn, unspawn, resall, goto, gethere, id, przypisz]");
		return 1;
	}
	if(!strcmp(type, "stworz", true) || !strcmp(type, "create", true))
	{
	    new modelid, color1, color2;
	    if(sscanf(varchar, "k<vehicle_model>dd", modelid, color1, color2))
	    {
	        ShowTipForPlayer(playerid, "/apojazd stworz [Model] [Kolor1] [Kolor2]");
	        return 1;
	    }
	    if(modelid < 400 || modelid > 611)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Model pojazdu nie może być mniejszy niż 400 oraz większy od 611.");
	        return 1;
	    }
     	if(color1 < 0 || color1 > 255 || color2 < 0 || color2 > 255)
      	{
      	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "ID koloru nie może być mniejsze niż 0 a także większe od 255.");
         	return 1;
       	}
        new Float:PosX, Float:PosY, Float:PosZ, vehid;
        
        GetPlayerPos(playerid, PosX, PosY, PosZ);
        vehid = CreateStaticVehicle(modelid, PosX + 2, PosY, PosZ, 0.0, color1, color2, 3600);

		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Pojazd został stworzony pomyślnie (UID: %d).", CarInfo[vehid][cUID]);
		return 1;
	}
	if(!strcmp(type, "usun", true) || !strcmp(type, "del", true))
	{
	    new veh_uid;
 		if(sscanf(varchar, "d", veh_uid))
	    {
	        ShowTipForPlayer(playerid, "/apojazd usun [UID pojazdu]");
	        return 1;
	    }
	    new vehid = GetVehicleID(veh_uid);
	    if(vehid == INVALID_VEHICLE_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID pojazdu.");
			return 1;
		}
      	DeleteVehicle(vehid);
		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Pojazd został pomyślnie usunięty z bazy danych.");
		return 1;
	}
	if(!strcmp(type, "model", true))
	{
	    new veh_uid, modelid;
	    if(sscanf(varchar, "dk<vehicle_model>", veh_uid, modelid))
	    {
	        ShowTipForPlayer(playerid, "/apojazd model [UID pojazdu] [Model]");
	        return 1;
	    }
	    new vehid = GetVehicleID(veh_uid);
	    if(vehid == INVALID_VEHICLE_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID pojazdu.");
			return 1;
		}
	    if(modelid < 400 || modelid > 611)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Model pojazdu nie może być mniejszy niż 400 oraz większy od 611.");
	        return 1;
	    }
     	new Float:VehPosX, Float:VehPosY, Float:VehPosZ, Float:VehPosA;
     	
      	GetVehiclePos(vehid, VehPosX, VehPosY, VehPosZ);
       	GetVehicleZAngle(vehid, VehPosA);

		CarInfo[vehid][cModel] = modelid;
		CarInfo[vehid][cFuel] = GetVehicleMaxFuel(modelid);
		
  		orm_update(CarInfo[vehid][cOrm]);
		orm_destroy(CarInfo[vehid][cOrm]);

		DestroyVehicle(vehid);
		Iter_Remove(Vehicles, vehid);
		
		LoadVehicle(veh_uid);
		
		SetVehiclePos(vehid, VehPosX, VehPosY, VehPosZ);
		SetVehicleZAngle(vehid, VehPosA);
		
		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Model pojazdu został zmieniony pomyślnie. Nowy model: %d (%s)", modelid, GetVehicleName(modelid));
		return 1;
	}
	if(!strcmp(type, "kolor1", true) || !strcmp(type, "color1", true))
	{
	    new veh_uid, color1;
	    if(sscanf(varchar, "dd", veh_uid, color1))
	    {
	        ShowTipForPlayer(playerid, "/apojazd kolor1 [UID pojazdu] [Kolor 1]");
	        return 1;
	    }
	    new vehid = GetVehicleID(veh_uid);
	    if(vehid == INVALID_VEHICLE_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID pojazdu.");
			return 1;
		}
    	if(color1 < 0 || color1 > 255)
      	{
       		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "ID koloru nie może być mniejsze niż 0 a także większe od 255.");
         	return 1;
       	}
		CarInfo[vehid][cColor1] = color1;
		ChangeVehicleColor(vehid, CarInfo[vehid][cColor1], CarInfo[vehid][cColor2]);

		orm_update(CarInfo[vehid][cOrm]);
		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Kolor pojazdu został pomyślnie zmieniony. Nowy kolor: %d", color1);
		return 1;
	}
	if(!strcmp(type, "kolor2", true))
	{
	    new veh_uid, color2;
	    if(sscanf(varchar, "dd", veh_uid, color2))
	    {
	        ShowTipForPlayer(playerid, "/apojazd kolor2 [UID pojazdu] [Kolor 2]");
	        return 1;
	    }
	    new vehid = GetVehicleID(veh_uid);
	    if(vehid == INVALID_VEHICLE_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID pojazdu.");
			return 1;
		}
    	if(color2 < 0 || color2 > 255)
      	{
       		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "ID koloru nie może być mniejsze niż 0 a także większe od 255.");
         	return 1;
       	}
		CarInfo[vehid][cColor2] = color2;
		ChangeVehicleColor(vehid, CarInfo[vehid][cColor1], CarInfo[vehid][cColor2]);

		orm_update(CarInfo[vehid][cOrm]);
		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Kolor pojazdu został pomyślnie zmieniony. Nowy kolor: %d", color2);
		return 1;
	}
	if(!strcmp(type, "paliwo", true))
	{
	    new veh_uid, Float: new_fuel;
	    if(sscanf(varchar, "df", veh_uid, new_fuel))
	    {
	        ShowTipForPlayer(playerid, "/apojazd paliwo [UID pojazdu] [Ilość litrów]");
	        return 1;
	    }
	    new vehid = GetVehicleID(veh_uid);
	    if(vehid == INVALID_VEHICLE_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID pojazdu.");
			return 1;
		}
	    if(new_fuel > GetVehicleMaxFuel(CarInfo[vehid][cModel]))
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz ustalić więcej paliwa niż umieści bak.\nPojemność baku w tym pojeździe wynosi: %d litry/ów.", GetVehicleMaxFuel(CarInfo[vehid][cModel]));
	        return 1;
	    }
		CarInfo[vehid][cFuel] = new_fuel;
		orm_update(CarInfo[vehid][cOrm]);
		
		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Zmieniono stan paliwa w pojeździe %s.\nIlość paliwa: %.0fL", GetVehicleName(CarInfo[vehid][cModel]), CarInfo[vehid][cFuel]);
		return 1;
	}
	if(!strcmp(type, "hp", true) || !strcmp(type, "health", true))
	{
	    new veh_uid, Float:health;
 		if(sscanf(varchar, "df", veh_uid, health))
	    {
	        ShowTipForPlayer(playerid, "/apojazd hp [UID pojazdu] [HP]");
	        return 1;
	    }
	    new vehid = GetVehicleID(veh_uid);
	    if(vehid == INVALID_VEHICLE_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID pojazdu.");
			return 1;
		}
	    if(health < 350 || health > 1000)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "HP pojazdu nie może być mniejsze niż 350 oraz większe od 1000.");
	        return 1;
	    }
     	CarInfo[vehid][cHealth] = health;
     	
      	SetVehicleHealth(vehid, health);
       	orm_update(CarInfo[vehid][cOrm]);
       	
       	ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Stan techniczny pojazdu został zmieniony pomyślnie.\nHP pojazdu wynosi teraz: %.0f HP.", CarInfo[vehid][cHealth]);
		return 1;
	}
	if(!strcmp(type, "fix", true))
	{
 		new veh_uid;
 		if(sscanf(varchar, "d", veh_uid))
	    {
	        ShowTipForPlayer(playerid, "/apojazd fix [UID pojazdu]");
	        return 1;
	    }
	    new vehid = GetVehicleID(veh_uid);
	    if(vehid == INVALID_VEHICLE_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID pojazdu.");
			return 1;
		}
 		CarInfo[vehid][cHealth] = 1000.0;
      	SetVehicleHealth(vehid, 1000.0);
      	
		UpdateVehicleDamageStatus(vehid, 0, 0, 0, 0);
		strmid(CarInfo[vehid][cVisual], "0 0 0 0", 0, 32);
		
       	orm_update(CarInfo[vehid][cOrm]);
       	ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Pojazd %s (UID: %d) został całkowicie naprawiony.", GetVehicleModel(CarInfo[vehid][cModel]), veh_uid);
	    return 1;
	}
	if(!strcmp(type, "zaparkuj", true))
	{
	    new veh_uid;
		if(sscanf(varchar, "d", veh_uid))
		{
		    ShowTipForPlayer(playerid, "/apojazd zaparkuj [UID pojazdu]");
		    return 1;
		}
	    new vehid = GetVehicleID(veh_uid);
	    if(vehid == INVALID_VEHICLE_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID pojazdu.");
			return 1;
		}
		CarInfo[vehid][cWorldID] = GetPlayerVirtualWorld(playerid);
		CarInfo[vehid][cInteriorID] = GetPlayerInterior(playerid);

		GetVehiclePos(vehid, CarInfo[vehid][cPosX], CarInfo[vehid][cPosY], CarInfo[vehid][cPosZ]);
		GetVehicleZAngle(vehid, CarInfo[vehid][cPosA]);

		DestroyVehicle(vehid);
		Iter_Remove(Vehicles, vehid);

		orm_update(CarInfo[vehid][cOrm], "LoadVehicle", "d", veh_uid);
		orm_destroy(CarInfo[vehid][cOrm]);
		
		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Pojazd został zaparkowany w miejscu, na którym właśnie stoi.");
		return 1;
	}
	if(!strcmp(type, "zamknij", true) || !strcmp(type, "z", true) || !strcmp(type, "lock", true))
	{
 		new veh_uid;
		if(sscanf(varchar, "d", veh_uid))
		{
		    ShowTipForPlayer(playerid, "/apojazd zamknij [UID pojazdu]");
		    return 1;
		}
	    new vehid = GetVehicleID(veh_uid);
	    if(vehid == INVALID_VEHICLE_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID pojazdu.");
			return 1;
		}
	    if(CarInfo[vehid][cLocked])
	    {
  			CarInfo[vehid][cLocked] = false;
			SetVehicleLock(vehid, false);
			
			ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Pojazd %s (UID: %d) został otwarty.", GetVehicleName(CarInfo[vehid][cModel]), CarInfo[vehid][cUID]);
	    }
	    else
	    {
  			CarInfo[vehid][cLocked] = true;
			SetVehicleLock(vehid, true);
			
			ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Pojazd %s (UID: %d) został zamknięty.", GetVehicleName(CarInfo[vehid][cModel]), CarInfo[vehid][cUID]);
	    }
	    orm_update(CarInfo[vehid][cOrm]);
	    return 1;
	}
	if(!strcmp(type, "info", true))
	{
	    new veh_uid;
	    if(sscanf(varchar, "d", veh_uid))
	    {
	        ShowTipForPlayer(playerid, "/apojazd info [UID pojazdu]");
	        return 1;
	    }
	    new vehid = GetVehicleID(veh_uid);
	    if(vehid == INVALID_VEHICLE_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID pojazdu.");
			return 1;
		}
	    ShowPlayerVehicleInfo(playerid, vehid);
	    return 1;
	}
	if(!strcmp(type, "res", true))
	{
	    new veh_uid;
	    if(sscanf(varchar, "d", veh_uid))
	    {
	        ShowTipForPlayer(playerid, "/apojazd res [UID pojazdu]");
	        return 1;
	    }
	    new vehid = GetVehicleID(veh_uid);
	    if(vehid == INVALID_VEHICLE_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID pojazdu.");
			return 1;
		}
     	SetVehicleToRespawn(vehid);
      	ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Pojazd został przywrócony na miejsce spawnu.");
		return 1;
	}
	if(!strcmp(type, "przebieg", true) || !strcmp(type, "mileage", true))
	{
	    new veh_uid, Float:mileage;
	    if(sscanf(varchar, "df", veh_uid, mileage))
	    {
	        ShowTipForPlayer(playerid, "/apojazd przebieg [UID pojazdu] [Przebieg]");
	        return 1;
	    }
	    new vehid = GetVehicleID(veh_uid);
	    if(vehid == INVALID_VEHICLE_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID pojazdu.");
			return 1;
		}
	    CarInfo[vehid][cMileage] = mileage;
	    orm_update(CarInfo[vehid][cOrm]);

		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Przebieg pojazdu %s (UID: %d) został pomyślnie ustalony.\nNowy przebieg pojazdu: %.0f km", GetVehicleName(CarInfo[vehid][cModel]), CarInfo[vehid][cUID], CarInfo[vehid][cMileage]);
		return 1;
	}
	if(!strcmp(type, "visual", true))
	{
	    new veh_uid;
	    if(sscanf(varchar, "d", veh_uid))
		{
		    ShowTipForPlayer(playerid, "/apojazd visual [UID pojazdu]");
	        return 1;
	    }
	    new vehid = GetVehicleID(veh_uid);
	    if(vehid == INVALID_VEHICLE_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID pojazdu.");
			return 1;
		}
		UpdateVehicleDamageStatus(vehid, 0, 0, 0, 0);
		strmid(CarInfo[vehid][cVisual], "0 0 0 0", 0, 32);

		orm_update(CarInfo[vehid][cOrm]);
	    return 1;
	}
	if(!strcmp(type, "spawn", true))
	{
	    new veh_uid;
	    if(sscanf(varchar, "d", veh_uid))
	    {
	        ShowTipForPlayer(playerid, "/apojazd spawn [UID pojazdu]");
	        return 1;
	    }
		new vehid = GetVehicleID(veh_uid);
		if(vehid != INVALID_VEHICLE_ID)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten pojazd jest już zespawnowany (UID: %d).", veh_uid);
		    return 1;
		}
		vehid = LoadVehicle(veh_uid);
		
		if(vehid == INVALID_VEHICLE_ID)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znaleziono w bazie danych pojazdu o takim UID.");
		    return 1;
		}
		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Pojazd %s (UID: %d) został zespawnowany pomyślnie.", GetVehicleName(CarInfo[vehid][cModel]), CarInfo[vehid][cUID]);
		return 1;
	}
	if(!strcmp(type, "unspawn", true))
	{
 		new veh_uid;
	    if(sscanf(varchar, "d", veh_uid))
	    {
	        ShowTipForPlayer(playerid, "/apojazd unspawn [UID pojazdu]");
	        return 1;
	    }
	    new vehid = GetVehicleID(veh_uid);
	    if(vehid == INVALID_VEHICLE_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID pojazdu.");
			return 1;
		}
		orm_update(CarInfo[vehid][cOrm]);
		orm_destroy(CarInfo[vehid][cOrm]);
		
		DestroyVehicle(vehid);
		Iter_Remove(Vehicles, vehid);

		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Pojazd %s (UID: %d) został odspawnowany pomyślnie.", GetVehicleName(CarInfo[vehid][cModel]), CarInfo[vehid][cUID]);
		return 1;
	}
	if(!strcmp(type, "resall", true))
	{
		foreach(new vehid : Vehicles)
		{
			if(!IsAnyPlayerInVehicle(vehid))
		    {
		        SetVehicleToRespawn(vehid);
		    }
		}
		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Wszystkie nieużywane pojazdy zostały przywrócone na miejsce spawnu.");
		return 1;
	}
	if(!strcmp(type, "goto", true) || !strcmp(type, "to", true))
	{
 		new veh_uid;
	    if(sscanf(varchar, "d", veh_uid))
	    {
	        ShowTipForPlayer(playerid, "/apojazd goto [UID pojazdu]");
	        return 1;
	    }
	    new vehid = GetVehicleID(veh_uid);
	    if(vehid == INVALID_VEHICLE_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID pojazdu.");
			return 1;
		}
		new driverid = GetVehicleDriver(vehid);
		if(driverid != INVALID_VEHICLE_ID)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Tym pojazdem w chwili obecnej kieruje %s (ID: %d).", PlayerName(driverid), driverid);
		    return 1;
		}
	    if(GetPlayerState(playerid) == PLAYER_STATE_DRIVER || GetPlayerState(playerid) == PLAYER_STATE_PASSENGER)
		{
			RemovePlayerFromVehicle(playerid);
		}
		PlayerCache[playerid][pLastVeh] = vehid;

		SetPlayerVirtualWorld(playerid, CarInfo[vehid][cWorldID]);
		SetPlayerInterior(playerid, CarInfo[vehid][cInteriorID]);

		PutPlayerInVehicle(playerid, vehid, 0);
		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Przeteleportowałeś się do pojazdu %s (UID: %d).", GetVehicleName(CarInfo[vehid][cModel]), CarInfo[vehid][cUID]);
		return 1;
	}
	if(!strcmp(type, "gethere", true) || !strcmp(type, "tm", true))
	{
		new veh_uid;
	    if(sscanf(varchar, "d", veh_uid))
	    {
	        ShowTipForPlayer(playerid, "/apojazd gethere [UID pojazdu]");
	        return 1;
	    }
	    new vehid = GetVehicleID(veh_uid);
	    if(vehid == INVALID_VEHICLE_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID pojazdu.");
			return 1;
		}
		new Float:PosX, Float:PosY, Float:PosZ,
		    interior_id = GetPlayerInterior(playerid), world_id = GetPlayerVirtualWorld(playerid);
		    
		GetPlayerPos(playerid, PosX, PosY, PosZ);
		SetVehiclePos(vehid, PosX + 3.0, PosY, PosZ);
		
		LinkVehicleToInterior(vehid, interior_id);
		SetVehicleVirtualWorld(vehid, world_id);
	    return 1;
	}
	if(!strcmp(type, "id", true) || !strcmp(type, "sampid", true))
	{
	    new samp_id;
	    if(sscanf(varchar, "d", samp_id))
	    {
		    new vehid = GetClosestVehicle(playerid);
	   		if(vehid == INVALID_VEHICLE_ID)
			{
				ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znaleziono żadnego pojazdu w pobliżu.");
	   			return 1;
			}
			ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Najbliżej znajdujący się pojazd to \"%s\" (UID: %d).", GetVehicleName(CarInfo[vehid][cModel]), CarInfo[vehid][cUID]);
			return 1;
		}
		
		if(Iter_Contains(Vehicles, samp_id))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Pojazd (SAMPID: %d) to \"%s\" (UID: %d).", samp_id, GetVehicleName(CarInfo[samp_id][cModel]), CarInfo[samp_id][cUID]);
		}
		else
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Błędne SAMPID pojazdu.");
		}
		return 1;
	}
	if(!strcmp(type, "przypisz", true) || !strcmp(type, "assign", true))
	{
		new veh_uid, owner_type[24], varchar2[24];
		if(sscanf(varchar, "ds[24]S()[24]", veh_uid, owner_type, varchar2))
		{
		    ShowTipForPlayer(playerid, "/apojazd przypisz [UID pojazdu] [Typ (gracz, grupa, praca)]");
		    return 1;
		}
	    new vehid = GetVehicleID(veh_uid);
	    if(vehid == INVALID_VEHICLE_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID pojazdu.");
			return 1;
		}
	    if(!strcmp(owner_type, "gracz", true) || !strcmp(owner_type, "player", true))
	    {
	        new giveplayer_id;
			if(sscanf(varchar2, "u", giveplayer_id))
			{
			    ShowTipForPlayer(playerid, "/apojazd przypisz %d gracz [ID gracza]", veh_uid);
			    return 1;
			}
			if(giveplayer_id == INVALID_PLAYER_ID)
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
			    return 1;
			}
			if(!PlayerCache[giveplayer_id][pLogged])
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
			    return 1;
			}
			CarInfo[vehid][cOwnerType] = OWNER_PLAYER;
			CarInfo[vehid][cOwner] = PlayerCache[giveplayer_id][pUID];

			orm_update(CarInfo[vehid][cOrm]);
			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Pojazd %s (UID: %d) został przypisany pomyślnie.\n\nTyp właściciela: gracz\nWłaściciel: %s (ID: %d, UID: %d).", GetVehicleName(CarInfo[vehid][cModel]), CarInfo[vehid][cUID], PlayerName(giveplayer_id), giveplayer_id, PlayerCache[giveplayer_id][pUID]);
			return 1;
		}
		if(!strcmp(owner_type, "grupa", true) || !strcmp(owner_type, "group", true))
		{
		    new group_uid;
		    if(sscanf(varchar2, "d", group_uid))
		    {
		        ShowTipForPlayer(playerid, "/apojazd przypisz %d grupa [UID grupy]", veh_uid);
		        return 1;
		    }
		    new group_id = GetGroupID(group_uid);
 	    	if(group_id == INVALID_GROUP_ID)
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID grupy.");
		        return 1;
		    }
			CarInfo[vehid][cOwnerType] = OWNER_GROUP;
			CarInfo[vehid][cOwner] = GroupData[group_id][gUID];

			orm_update(CarInfo[vehid][cOrm]);
			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Pojazd %s (UID: %d) został przypisany pomyślnie.\n\nTyp właściciela: grupa\nWłaściciel: %s (UID: %d)", GetVehicleName(CarInfo[vehid][cModel]), CarInfo[vehid][cUID], GroupData[group_id][gName], GroupData[group_id][gUID]);
			return 1;
		}
		if(!strcmp(owner_type, "praca", true) || !strcmp(owner_type, "work", true))
		{
		    new work_id;
		    if(sscanf(varchar2, "d", work_id))
		    {
		        ShowTipForPlayer(playerid, "/apojazd przypisz %d praca [ID pracy dorywczej]", veh_uid);
				for(new i = 0; i < sizeof(WorkTypeName); i++)	ShowTipForPlayer(playerid, "%d - %s", i + 1, WorkTypeName[i]);
				return 1;
		    }
			work_id -= 1;
			
			if(work_id <= 0 || work_id >= sizeof(WorkTypeName))
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne ID pracy dorywczej.");
			    return 1;
			}
			new ORM:orm_id = CarInfo[vehid][cOrm];
			
			CarInfo[vehid][cOwnerType] = OWNER_WORK;
			CarInfo[vehid][cOwner] = work_id;
			
			DestroyVehicle(vehid);
			Iter_Remove(Vehicles, vehid);

			orm_update(orm_id, "LoadVehicle", "d", veh_uid);
			orm_destroy(orm_id);
			
			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Pojazd %s (UID: %d) został przypisany pomyślnie.\n\nTyp właściciela: praca\nWłaściciel: %s (ID: %d).", GetVehicleName(CarInfo[vehid][cModel]), CarInfo[vehid][cUID], WorkTypeName[work_id], work_id + 1);
		    return 1;
		}
	    return 1;
	}
	return 1;
}
alias:apojazd("av");

cmd:pojazd(playerid, params[])
{
	new type[32], varchar[128];
	if(sscanf(params, "s[32]S()[128]", type, varchar))
	{
	    new vehid = GetClosestVehicle(playerid);
	    if(vehid == INVALID_VEHICLE_ID)
	    {
	 		new veh_uid, veh_model, list_vehicles[256], list;
	 		
			new rows, Cache:tmp_cache, query[256];
			
			mysql_format(connHandle, query, sizeof(query), "SELECT `vehicle_uid`, `vehicle_model` FROM `"SQL_PREF"vehicles` WHERE vehicle_ownertype = '%d' AND vehicle_owner = '%d'", OWNER_PLAYER, PlayerCache[playerid][pUID]);
			tmp_cache = mysql_query(connHandle, query);

			DynamicGui_Init(playerid);

			cache_get_row_count(rows);
			for(new row = 0; row != rows; row++)
			{
			    list ++;
				
				cache_get_value_index_int(row, 0, veh_uid);
				cache_get_value_index_int(row, 1, veh_model);
				
				format(list_vehicles, sizeof(list_vehicles), "%s\n%d\t\t%s", list_vehicles, veh_uid, GetVehicleName(veh_model));
				DynamicGui_AddRow(playerid, D_SPAWN_VEH, veh_uid);
			}
			if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
			
			if(strlen(list_vehicles))
			{
			    if(list >= 5) 	GivePlayerAchievement(playerid, ACHIEVE_COLLECTOR);
   				GivePlayerAchievement(playerid, ACHIEVE_FIRST_VEH);
			    
			    ShowPlayerDialog(playerid, D_SPAWN_VEH, DIALOG_STYLE_LIST, "Pojazdy należące do Ciebie:", list_vehicles, "(Un)spawn", "Zamknij");
			}
			else
			{
			    TD_ShowSmallInfo(playerid, 3, "Nie posiadasz ~r~zadnych ~w~pojazdow.", 3000, 3);
			    TD_ShowHint(playerid, HINT_CARDEALER, 15, "Twoja postac moze posiadac niezliczona ilosc ~y~pojazdow~w~. To wszystko zalezy od Ciebie i zawartosci Twojego ~g~portfela~w~.~n~~n~Musisz jednak wiedziec gdzie taki pojazd zakupic. Dlatego na mapie sa widoczne ~w~wszystkie ~y~salony samochodowe~w~ (ikonka samochodu), gdzie bedziesz mogl nabyc swoje pierwsze cztery kolka.");
			}
			
			ShowTipForPlayer(playerid, "/pojazd [namierz, zaparkuj, tuning, przypisz, zamknij, info, opis]");
		}
		else
		{
		    if(!(PlayerCache[playerid][pAdmin] & A_PERM_CARS))
		    {
			    if(CarInfo[vehid][cOwnerType] == OWNER_NONE || CarInfo[vehid][cOwnerType] == OWNER_WORK)
			    {
			        ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie jesteś właścicielem tego pojazdu.");
			        return 1;
			    }
		   		if(CarInfo[vehid][cOwnerType] == OWNER_PLAYER && CarInfo[vehid][cOwner] != PlayerCache[playerid][pUID])
				{
				    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie jesteś właścicielem tego pojazdu.");
					return 1;
				}
				if(CarInfo[vehid][cOwnerType] == OWNER_GROUP)
				{
				    if(!HavePlayerGroupPerm(playerid, CarInfo[vehid][cOwner], G_PERM_CARS))
				    {
				        ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie posiadasz uprawnień prowadzenia pojazdów, w grupie do której przypisany jest pojazd.");
				        return 1;
				    }
				}
			}
   			new list_manage[128];
   			if(GetVehicleBonnetStatus(vehid) == 1)	strcat(list_manage, "1 - Zamknij maskę\n");
			else									strcat(list_manage, "1 - Uchyl maskę\n");

			if(GetVehicleBootStatus(vehid) == 1)	strcat(list_manage, "2 - Zamknij bagażnik\n");
			else									strcat(list_manage, "2 - Otwórz bagażnik\n");

			if(GetVehicleLightsStatus(vehid) == 1)	strcat(list_manage, "3 - Wyłącz światła\n");
			else									strcat(list_manage, "3 - Włącz światła\n");
			
			if(CarInfo[vehid][cGlass])              strcat(list_manage, "4 - Otwórz szybę\n");
			else                                    strcat(list_manage, "4 - Zamknij szybę\n");

			if(IsPlayerInVehicle(playerid, vehid))
			{
				strcat(list_manage, "5 - Opcje CB radio\n");
				strcat(list_manage, "6 - Własna rejestracja");
			}
			
			DynamicGui_SetDialogValue(playerid, vehid);
 			ShowPlayerDialog(playerid, D_MANAGE_VEH, DIALOG_STYLE_LIST, "Zarządzanie pojazdem", list_manage, "Wybierz", "Anuluj");
		}
	    return 1;
	}
	if(!strcmp(type, "namierz", true) || !strcmp(type, "target", true))
	{
		if(PlayerCache[playerid][pCheckpoint] == CHECKPOINT_VEHICLE)
		{
		    DisablePlayerCheckpoint(playerid);
		    PlayerCache[playerid][pCheckpoint] = CHECKPOINT_NONE;

			TD_ShowSmallInfo(playerid, 3, "Namierzanie zostalo ~r~anulowane~w~.");
			return 1;
		}
		
		new list_vehicles[256];
		DynamicGui_Init(playerid);
		
  		foreach(new vehid : Vehicles)
		{
		    if(CarInfo[vehid][cOwnerType] == OWNER_PLAYER && CarInfo[vehid][cOwner] == PlayerCache[playerid][pUID])
		    {
		        format(list_vehicles, sizeof(list_vehicles), "%s\n%d\t\t%s", list_vehicles, CarInfo[vehid][cUID], GetVehicleName(CarInfo[vehid][cModel]));
				DynamicGui_AddRow(playerid, D_TARGET_VEH, vehid);
			}
		}
		if(strlen(list_vehicles))
		{
		    ShowPlayerDialog(playerid, D_TARGET_VEH, DIALOG_STYLE_LIST, "Pojazdy zespawnowane:", list_vehicles, "Namierz", "Anuluj");
		}
		else
		{
		    TD_ShowSmallInfo(playerid, 3, "Zaden z Twoich pojazdow ~r~nie jest ~w~zespawnowany.");
		}
	    return 1;
	}
	if(!strcmp(type, "zaparkuj", true))
	{
		if(GetPlayerState(playerid) != PLAYER_STATE_DRIVER)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz siedzieć w pojeździe jako kierowca, aby zaparkować pojazd.");
	        return 1;
	    }
	    new vehid = GetPlayerVehicleID(playerid);
	    if(!(PlayerCache[playerid][pAdmin] & A_PERM_CARS))
	    {
	   		if(CarInfo[vehid][cOwnerType] == OWNER_PLAYER && CarInfo[vehid][cOwner] != PlayerCache[playerid][pUID])
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie jesteś właścicielem tego pojazdu.");
				return 1;
			}
			if(CarInfo[vehid][cOwnerType] == OWNER_GROUP)
			{
			    if(!HavePlayerGroupPerm(playerid, CarInfo[vehid][cOwner], G_PERM_LEADER))
			    {
	                ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie posiadasz lidera grupy, do której przypisany jest pojazd.");
			        return 1;
			    }
			}
			if(CarInfo[vehid][cOwnerType] == OWNER_WORK)
			{
   				ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie jesteś właścicielem tego pojazdu.");
				return 1;
			}
			if(!IsVehiclePlaceFree(vehid))
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "To miejsce parkingowe jest już zajęte.");
			    return 1;
			}
			new areaid = GetPlayerAreaID(playerid);
			if(areaid != INVALID_AREA_ID)
			{
			    new AreaData[sAreaData];
				Streamer_GetArrayData(STREAMER_TYPE_AREA, areaid, E_STREAMER_EXTRA_ID, AreaData);
				
				if(AreaData[aFlags] & A_FLAG_PARKING)
				{
				    if(AreaData[aOwnerType] == OWNER_NONE)
				    {
					    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "W tej strefie parking jest ograniczony. Tylko właściciel strefy może tu zaparkować.");
					    return 1;
					}
					if(AreaData[aOwnerType] == OWNER_PLAYER && AreaData[aOwner] != PlayerCache[playerid][pUID])
					{
     					ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "W tej strefie parking jest ograniczony. Tylko właściciel strefy może tu zaparkować.");
     					return 1;
					}
					if(AreaData[aOwnerType] == OWNER_GROUP)
					{
					    if(!HavePlayerGroupPerm(playerid, AreaData[aOwner], G_PERM_LEADER))
					    {
					        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "W tej strefie parking jest ograniczony. Tylko właściciel strefy może tu zaparkować.");
					        return 1;
						}
					}
				}
			}
		}
  		new veh_uid = CarInfo[vehid][cUID], ORM:orm_id = CarInfo[vehid][cOrm],
		  	seatid = GetPlayerVehicleSeat(playerid);

		CarInfo[vehid][cWorldID] = GetPlayerVirtualWorld(playerid);
		CarInfo[vehid][cInteriorID] = GetPlayerInterior(playerid);

		GetVehiclePos(vehid, CarInfo[vehid][cPosX], CarInfo[vehid][cPosY], CarInfo[vehid][cPosZ]);
		GetVehicleZAngle(vehid, CarInfo[vehid][cPosA]);
		
		DestroyVehicle(vehid);
		Iter_Remove(Vehicles, vehid);
		
		orm_update(orm_id, "LoadVehicle", "d", veh_uid);
		orm_destroy(orm_id);
		
		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Pojazd został zaparkowany pomyślnie.");
	    return 1;
	}
	if(!strcmp(type, "tuning", true))
	{
 		if(!IsPlayerInAnyVehicle(playerid))
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz siedzieć w pojeździe, aby móc użyć tej komendy.");
	        return 1;
	    }
	    new vehid = GetPlayerVehicleID(playerid);
	    if(!(PlayerCache[playerid][pAdmin] & A_PERM_CARS))
	    {
  			if(CarInfo[vehid][cOwnerType] == OWNER_NONE || CarInfo[vehid][cOwnerType] == OWNER_WORK)
			{
   				ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie jesteś właścicielem tego pojazdu.");
				return 1;
			}
	   		if(CarInfo[vehid][cOwnerType] == OWNER_PLAYER && CarInfo[vehid][cOwner] != PlayerCache[playerid][pUID])
			{
				ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie jesteś właścicielem tego pojazdu.");
				return 1;
			}
			if(CarInfo[vehid][cOwnerType] == OWNER_GROUP)
			{
			    if(!HavePlayerGroupPerm(playerid, CarInfo[vehid][cOwner], G_PERM_CARS))
			    {
			        ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie posiadasz uprawnień prowadzenia pojazdów, w grupie do której przypisany jest pojazd.");
			        return 1;
			    }
			}
		}
		new list_tuning_items[512],
		    item_uid, item_value1, item_name[32];

		new rows, Cache:tmp_cache, query[256];
		
		mysql_format(connHandle, query, sizeof(query), "SELECT `item_uid`, `item_value1`, `item_name` FROM `"SQL_PREF"items` WHERE item_vehuid = '%d'", CarInfo[vehid][cUID]);
		tmp_cache = mysql_query(connHandle, query);

		DynamicGui_Init(playerid);

		cache_get_row_count(rows);
		for(new row = 0; row != rows; row++)
		{
		    cache_get_value_index_int(row, 0, item_uid);
		    
		    cache_get_value_index_int(row, 1, item_value1);
		    cache_get_value_index(row, 2, item_name, 32);
		    
		    format(list_tuning_items, sizeof(list_tuning_items), "%s\n%d\t%d\t%s", list_tuning_items, item_uid, item_value1, item_name);
			DynamicGui_AddRow(playerid, item_uid, item_value1);

		}
        if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
		if(strlen(list_tuning_items))
		{
		    ShowPlayerDialog(playerid, D_TUNING_UNMOUNT, DIALOG_STYLE_LIST, "Zamontowane części:", list_tuning_items, "Odmontuj", "Zamknij");
		}
		else
		{
		    TD_ShowSmallInfo(playerid, 3, "Nie znaleziono ~r~zadnych ~w~zamontowanych czesci.");
		}
	    return 1;
	}
	if(!strcmp(type, "zamknij", true) || !strcmp(type, "z", true) || !strcmp(type, "lock", true))
	{
		new vehid = GetClosestVehicle(playerid);
		if(vehid == INVALID_VEHICLE_ID)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znaleziono żadnego pojazdu w pobliżu.");
		    return 1;
		}
  		if(!(PlayerCache[playerid][pAdmin] & A_PERM_CARS))
    	{
	 		if(CarInfo[vehid][cOwnerType] == OWNER_NONE)
	  		{
	      		ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie posiadasz kluczyków do tego pojazdu.");
	      		return 1;
	  		}
			if(CarInfo[vehid][cOwnerType] == OWNER_PLAYER)
			{
	   			if(CarInfo[vehid][cOwner] != PlayerCache[playerid][pUID] && !HavePlayerItemType(playerid, ITEM_KEYS, CarInfo[vehid][cUID]))
	   			{
					ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie posiadasz kluczyków do tego pojazdu.");
					return 1;
				}
			}
			if(CarInfo[vehid][cOwnerType] == OWNER_GROUP)
			{
	   			if(!HavePlayerGroupPerm(playerid, CarInfo[vehid][cOwner], G_PERM_CARS))
	   			{
	       			ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie posiadasz kluczyków do tego pojazdu.");
					return 1;
		    	}
			}
			if(CarInfo[vehid][cOwnerType] == OWNER_WORK)
			{
			    if(WorkInfo[playerid][wID] != CarInfo[vehid][cOwner])
			    {
			        ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie posiadasz kluczyków do tego pojazdu.");
			        return 1;
			    }

			    if(CarInfo[vehid][cOwner] == JOB_COURIER && PlayerCache[playerid][pPackage] == INVALID_PACKAGE_ID)
			    {
			        ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Musisz wybrać paczkę z listy, by móc poruszać się tym pojazdem (/paczka).");
			        return 1;
			    }

			    if(CarInfo[vehid][cOwner] == JOB_NEWSPAPER && WorkInfo[playerid][wValue][0] <= 0)
			    {
			        ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Musisz posiadać przy sobie gazety, by skorzystać z tego pojazdu.");
			        return 1;
			    }
			}
		}
  		new Float:VehPosX, Float:VehPosY, Float:VehPosZ;
  		GetVehiclePos(vehid, VehPosX, VehPosY, VehPosZ);

		if(CarInfo[vehid][cLocked])
		{
		    GameTextForPlayer(playerid, "~w~Pojazd ~g~otwarty", 4000, 6);
			CarInfo[vehid][cLocked] = false;
		}
		else
		{
		    GameTextForPlayer(playerid, "~w~Pojazd ~r~zamkniety", 4000, 6);
			CarInfo[vehid][cLocked] = true;
		}
		
		// Jeśli ma alarm
  		if(CarInfo[vehid][cAccess] & VEH_ACCESS_ALARM)
    	{
  			ApplyAnimation(playerid, "HEIST9", "Use_SwipeCard", 4.1, 0, 0, 0, 0, 0, 1);

			// Audio alarmu
			new audio_handle;
			foreach(new i : Player)
		 	{
				if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
				{
	   				if(IsPlayerInRangeOfPoint(i, 10.0, VehPosX, VehPosY, VehPosZ))
				    {
				        Play3DAudioForPlayer(i, AUDIO_ALARM, VehPosX, VehPosY, VehPosZ, 10.0);
					}
				}
    		}
    	}
	    else
	    {
			ApplyAnimation(playerid,"INT_HOUSE", "wash_up", 4.1, 0, 0, 0, 0, 0, 1);
			PlayerPlaySound(playerid, 1145, 0.0, 0.0, 0.0);
		}
		
		SetVehicleLock(vehid, CarInfo[vehid][cLocked]);
		orm_update(CarInfo[vehid][cOrm]);
	    return 1;
	}
	if(!strcmp(type, "info", true))
	{
	    if(!IsPlayerInAnyVehicle(playerid))
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz siedzieć w pojeździe, by sprawdzić jego informacje.");
	        return 1;
	    }
	    new vehid = GetPlayerVehicleID(playerid);
    	if(!(PlayerCache[playerid][pAdmin] & A_PERM_CARS))
	    {
  			if(CarInfo[vehid][cOwnerType] == OWNER_NONE || CarInfo[vehid][cOwnerType] == OWNER_WORK)
			{
   				ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie jesteś właścicielem tego pojazdu.");
				return 1;
			}
	   		if(CarInfo[vehid][cOwnerType] == OWNER_PLAYER && CarInfo[vehid][cOwner] != PlayerCache[playerid][pUID])
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie jesteś właścicielem tego pojazdu.");
				return 1;
			}
			if(CarInfo[vehid][cOwnerType] == OWNER_GROUP)
			{
			    if(!HavePlayerGroupPerm(playerid, CarInfo[vehid][cOwner], G_PERM_CARS))
			    {
			        ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie posiadasz uprawnień prowadzenia pojazdów, w grupie do której przypisany jest pojazd.");
			        return 1;
			    }
			}
		}
		ShowPlayerVehicleInfo(playerid, vehid);
	    return 1;
	}
	if(!strcmp(type, "przypisz", true))
	{
		if(!IsPlayerInAnyVehicle(playerid))
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz siedzieć w pojeździe, aby móc użyć tej komendy.");
	        return 1;
	    }
	    new vehid = GetPlayerVehicleID(playerid);
	    if(!(PlayerCache[playerid][pAdmin] & A_PERM_CARS))
	    {
		    if(CarInfo[vehid][cOwnerType] == OWNER_NONE || CarInfo[vehid][cOwnerType] == OWNER_WORK)
		    {
	         	ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie jesteś właścicielem tego pojazdu.");
		        return 1;
		    }
	   		if(CarInfo[vehid][cOwnerType] == OWNER_PLAYER && CarInfo[vehid][cOwner] != PlayerCache[playerid][pUID])
			{
	            ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie jesteś właścicielem tego pojazdu.");
				return 1;
			}
			if(CarInfo[vehid][cOwnerType] == OWNER_GROUP)
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten pojazd jest już przypisany pod grupę.");
			    return 1;
			}
		}
  		new list_groups[256], group_id;
  		DynamicGui_Init(playerid);
  		
		for (new group_slot = 0; group_slot < MAX_GROUP_SLOTS; group_slot++)
		{
			if(PlayerGroup[playerid][group_slot][gpUID])
  			{
  				group_id = PlayerGroup[playerid][group_slot][gpID];
				format(list_groups, sizeof(list_groups), "%s\n%d\t%s (%d)", list_groups, group_slot + 1, GroupData[group_id][gName], GroupData[group_id][gUID]);

				DynamicGui_AddRow(playerid, D_ASSIGN_VEH, group_slot);
			}
		}
		ShowPlayerDialog(playerid, D_ASSIGN_VEH, DIALOG_STYLE_LIST, "SLOT      NAZWA GRUPY", list_groups, "Wybierz", "Anuluj");
	    return 1;
	}
	if(!strcmp(type, "opis", true))
	{
		if(!IsPlayerInAnyVehicle(playerid))
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz siedzieć w pojeździe, aby móc użyć tej komendy.");
	        return 1;
	    }
		new vehid = GetPlayerVehicleID(playerid);
  		if(!(PlayerCache[playerid][pAdmin] & A_PERM_CARS))
    	{
  			if(CarInfo[vehid][cOwnerType] == OWNER_NONE || CarInfo[vehid][cOwnerType] == OWNER_WORK)
			{
   				ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie jesteś właścicielem tego pojazdu.");
				return 1;
			}
			if(CarInfo[vehid][cOwnerType] == OWNER_PLAYER && CarInfo[vehid][cOwner] != PlayerCache[playerid][pUID])
			{
				ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie jesteś właścicielem tego pojazdu.");
				return 1;
			}
			if(CarInfo[vehid][cOwnerType] == OWNER_GROUP)
			{
			    if(!HavePlayerGroupPerm(playerid, CarInfo[vehid][cOwner], G_PERM_CARS))
			    {
	                ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie posiadasz uprawnień prowadzenia pojazdów, w grupie do której przypisany jest pojazd.");
			        return 1;
			    }
			}
		}
		new desc[256];
		if(sscanf(varchar, "s[256]", desc))
		{
		    ShowTipForPlayer(playerid, "/v opis [Treść opisu] | Aby usunąć opis, użyj komendy /v opis usun.");
			return 1;
		}
		if(!strcmp(desc, "usun", true))
		{
	 		UpdateDynamic3DTextLabelText(Text3D:PlayerCache[playerid][vDescTag], COLOR_DESC, " ");
			TD_ShowSmallInfo(playerid, 3, "Opis pojazdu zostal ~g~pomyslnie ~w~usuniety.");
		    return 1;
		}
		for (new i = 0; i < MAX_PLAYERS; i++)
		{
			if(Streamer_GetIntData(STREAMER_TYPE_3D_TEXT_LABEL, Text3D:PlayerCache[i][vDescTag], E_STREAMER_ATTACHED_VEHICLE) == vehid)
  			{
  				UpdateDynamic3DTextLabelText(Text3D:PlayerCache[i][vDescTag], COLOR_DESC, " ");
				Streamer_SetIntData(STREAMER_TYPE_3D_TEXT_LABEL, Text3D:PlayerCache[i][vDescTag], E_STREAMER_ATTACHED_PLAYER, i);
			}
		}
		format(desc, sizeof(desc), "%s", WordWrap(desc, WRAP_AUTO));
		
		UpdateDynamic3DTextLabelText(Text3D:PlayerCache[playerid][vDescTag], COLOR_DO, desc);
		ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Ustalono nowy opis pojazdu:\n\n%s", desc);

		Streamer_SetIntData(STREAMER_TYPE_3D_TEXT_LABEL, Text3D:PlayerCache[playerid][vDescTag], E_STREAMER_ATTACHED_VEHICLE, vehid);
  		Streamer_SetFloatData(STREAMER_TYPE_3D_TEXT_LABEL, Text3D:PlayerCache[playerid][vDescTag], E_STREAMER_Z, 0.3);
		return 1;
	}
	return 1;
}
alias:pojazd("v");

cmd:silnik(playerid, params[])
{
	if(GetPlayerState(playerid) != PLAYER_STATE_DRIVER)
	{
		return 1;
	}
	new vehid = GetPlayerVehicleID(playerid);
	if(IsVehicleBike(vehid))
 	{
  		return 1;
 	}
 	if(!(PlayerCache[playerid][pAdmin] & A_PERM_CARS))
 	{
	  	if(CarInfo[vehid][cOwnerType] == OWNER_NONE)
	   	{
	   	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie posiadasz kluczyków do tego pojazdu.");
	     	return 1;
	   	}
		if(CarInfo[vehid][cOwnerType] == OWNER_PLAYER)
		{
		    if(CarInfo[vehid][cOwner] != PlayerCache[playerid][pUID] && !HavePlayerItemType(playerid, ITEM_KEYS, CarInfo[vehid][cUID]))
		    {
	 			ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie posiadasz kluczyków do tego pojazdu.");
				return 1;
			}
		}
		if(CarInfo[vehid][cOwnerType] == OWNER_GROUP)
		{
			if(!HavePlayerGroupPerm(playerid, CarInfo[vehid][cOwner], G_PERM_CARS))
			{
	       		ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie posiadasz kluczyków do tego pojazdu.");
	       		return 1;
	       	}
		}
		if(CarInfo[vehid][cOwnerType] == OWNER_WORK)
		{
		    if(WorkInfo[playerid][wID] != CarInfo[vehid][cOwner])
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie posiadasz kluczyków do tego pojazdu.");
		        return 1;
		    }
		    
		    if(CarInfo[vehid][cOwner] == JOB_COURIER && PlayerCache[playerid][pPackage] == INVALID_PACKAGE_ID)
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Musisz wybrać paczkę z listy, by móc poruszać się tym pojazdem (/paczka).");
		        return 1;
		    }
		    
		    if(CarInfo[vehid][cOwner] == JOB_NEWSPAPER && WorkInfo[playerid][wValue][0] <= 0)
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Musisz posiadać przy sobie gazety, by skorzystać z tego pojazdu.");
		        return 1;
		    }
		}
	}
	if(CarInfo[vehid][cHealth] < 360)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Silnik w tym pojeździe jest całkowicie zniszczony.");
   		return 1;
	}
    if(GetVehicleEngineStatus(vehid) == 1)
    {
    	ChangeVehicleEngineStatus(vehid, false);
     	TD_ShowSmallInfo(playerid, 0, "Aby uruchomic silnik, wcisnij ~y~~k~~VEHICLE_FIREWEAPON_ALT~~w~ + ~y~~k~~SNEAK_ABOUT~~w~.~n~Klawisz ~y~~k~~VEHICLE_FIREWEAPON~ ~w~kontroluje swiatla w pojezdzie.");

		printf("[cars] %s (UID: %d, GID: %d) zgasił silnik pojazdu %s (UID: %d).", PlayerRealName(playerid), PlayerCache[playerid][pUID], PlayerCache[playerid][pGID], GetVehicleName(CarInfo[vehid][cModel]), CarInfo[vehid][cUID]);
	}
	else
	{
	    new started_time = 3000 - floatround(CarInfo[vehid][cHealth]);
	
 		GameTextForPlayer(playerid, "~n~~n~~n~~n~~n~~n~~n~~g~Trwa uruchamianie silnika...", 3000, 3);
 		defer OnVehicleEngineStarted[started_time](vehid);
	}
	return 1;
}

cmd:pasy(playerid, params[])
{
	if(!IsPlayerInAnyVehicle(playerid))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w pojeździe, by móc zapiąć pasy.");
	    return 1;
	}
	if(PlayerCache[playerid][pBelts])
	{
		PlayerPlaySound(playerid, 1145, 0.0, 0.0, 0.0);
		GameTextForPlayer(playerid, "~w~pasy ~g~odpiete", 3000, 6);

		PlayerCache[playerid][pBelts] = false;
	}
	else
	{
		PlayerPlaySound(playerid, 1145, 0.0, 0.0, 0.0);
		GameTextForPlayer(playerid, "~w~pasy ~r~zapiete", 3000, 6);

		PlayerCache[playerid][pBelts] = true;
	}
	return 1;
}

cmd:adrzwi(playerid, params[])
{
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_DOORS))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz zarządzać drzwiami.");
	    return 1;
	}
	new type[32], varchar[64];
	if(sscanf(params, "s[32]S()[64]", type, varchar))
	{
	    ShowTipForPlayer(playerid, "/adrzwi [stworz, usun, nazwa, pickup, goto, przypisz, interior, zamknij]");
	    ShowTipForPlayer(playerid, "/adrzwi [wejscie, wyjscie, entervw, exitvw, lista, info, id, przeladuj, metraz]");
		return 1;
	}
	if(!strcmp(type, "stworz", true) || !strcmp(type, "create", true))
	{
 		new door_name[32];
	    if(sscanf(varchar, "s[32]", door_name))
	    {
	        ShowTipForPlayer(playerid, "/adrzwi stworz [Nazwa drzwi]");
	        return 1;
	    }
	    if(GetPlayerState(playerid) != PLAYER_STATE_ONFOOT)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby stworzyć drzwi, musisz być w pozycji stojącej.");
	        return 1;
	    }
   		new Float:EnterX, Float:EnterY, Float:EnterZ, Float:EnterA, InteriorID, VirtualWorld;

		GetPlayerPos(playerid, EnterX, EnterY, EnterZ);
		GetPlayerFacingAngle(playerid, EnterA);

		InteriorID = GetPlayerInterior(playerid);
		VirtualWorld = GetPlayerVirtualWorld(playerid);

		new door_uid = CreateDoor(EnterX, EnterY, EnterZ, EnterA, InteriorID, VirtualWorld, door_name);
		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Drzwi zostały stworzone pomyślnie %s (UID: %d).", door_name, door_uid);
		return 1;
	}
	if(!strcmp(type, "usun", true) || !strcmp(type, "delete", true))
	{
	    new door_uid;
	    if(sscanf(varchar, "d", door_uid))
	    {
	        ShowTipForPlayer(playerid, "/adrzwi usun [UID drzwi]");
	        return 1;
	    }
	    new doorid = GetDoorID(door_uid);
	    if(doorid == INVALID_DOOR_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID drzwi.");
			return 1;
	    }
	    
	    DeleteDoor(doorid);
		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Drzwi zostały pomyślnie usunięte z bazy danych.");
		return 1;
	}
	if(!strcmp(type, "nazwa", true) || !strcmp(type, "name", true))
	{
	    new door_uid, door_name[32];
	    if(sscanf(varchar, "ds[32]", door_uid, door_name))
	    {
	        ShowTipForPlayer(playerid, "/adrzwi nazwa [UID drzwi] [Nowa nazwa]");
	        return 1;
	    }
	    new doorid = GetDoorID(door_uid);
	    if(doorid == INVALID_DOOR_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID drzwi.");
			return 1;
	    }
		new DoorData[sDoorInfo];
		Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);

        strmid(DoorData[dName], door_name, 0, strlen(door_name), 32);
        Streamer_SetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);

		SaveDoor(doorid);
		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Nazwa drzwi (UID: %d) została pomyślnie zmieniona.\nNowa nazwa: %s", DoorData[dUID], door_name);
		return 1;
	}
	if(!strcmp(type, "pickup", true))
	{
	    new door_uid, pickupid;
	    if(sscanf(varchar, "dd", door_uid, pickupid))
	    {
	        ShowTipForPlayer(playerid, "/adrzwi pickup [UID drzwi] [Pickup ID]");
	        return 1;
	    }
	    new doorid = GetDoorID(door_uid);
	    if(doorid == INVALID_DOOR_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID drzwi.");
			return 1;
	    }
	    new DoorData[sDoorInfo];
	    Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	    
   		Streamer_SetIntData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_MODEL_ID, pickupid);

		SaveDoor(doorid);
		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Model pickupa dla drzwi %s (UID: %d) został pomyślnie zmieniony.", DoorData[dName], door_uid);
		return 1;
	}
	if(!strcmp(type, "goto", true) || !strcmp(type, "to", true))
	{
	    new door_uid;
	    if(sscanf(varchar, "d", door_uid))
	    {
	        ShowTipForPlayer(playerid, "/adrzwi goto [UID drzwi]");
	        return 1;
	    }
	    new doorid = GetDoorID(door_uid);
	    if(doorid == INVALID_DOOR_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID drzwi.");
			return 1;
	    }
		new Float:door_pos[3], door_enterint, door_entervw;
		Streamer_GetItemPos(STREAMER_TYPE_PICKUP, doorid, door_pos[0], door_pos[1], door_pos[2]);
		
		door_enterint = Streamer_GetIntData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_INTERIOR_ID);
		door_entervw = Streamer_GetIntData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_WORLD_ID);
	    
	    crp_SetPlayerPos(playerid, door_pos[0], door_pos[1], door_pos[2]);
	    SetPlayerInterior(playerid, door_enterint);

	    SetPlayerVirtualWorld(playerid, door_entervw);
		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Zostałeś przeteleportowany do drzwi %s (UID: %d).", DoorName(doorid), GetDoorUID(doorid));
		return 1;
	}
	if(!strcmp(type, "przypisz", true) || !strcmp(type, "assign", true))
	{
		new door_uid, owner_type[24], varchar2[24];
		if(sscanf(varchar, "ds[24]S()[24]", door_uid, owner_type, varchar2))
		{
		    ShowTipForPlayer(playerid, "/adrzwi przypisz [UID drzwi] [Typ (gracz, grupa)]");
		    return 1;
		}
		new doorid = GetDoorID(door_uid);
	    if(doorid == INVALID_DOOR_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID drzwi.");
			return 1;
	    }
	    
	    new DoorData[sDoorInfo];
	    Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	    
	    if(!strcmp(owner_type, "gracz", true) || !strcmp(owner_type, "player", true))
	    {
	        new giveplayer_id;
			if(sscanf(varchar2, "u", giveplayer_id))
			{
			    ShowTipForPlayer(playerid, "/adrzwi przypisz %d gracz [ID gracza]", door_uid);
			    return 1;
			}
			if(giveplayer_id == INVALID_PLAYER_ID)
			{
				ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
			    return 1;
			}
			if(!PlayerCache[playerid][pLogged])
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
			    return 1;
			}
			DoorData[dOwnerType] = OWNER_PLAYER;
			DoorData[dOwner] = PlayerCache[giveplayer_id][pUID];
			
			Streamer_SetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);

			SaveDoor(doorid);
			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Drzwi %s (UID: %d) zostały przypisane pomyślnie.\n\nTyp właściciela: gracz\nWłaściciel: %s (ID: %d, UID: %d)", DoorData[dName], DoorData[dUID], PlayerName(giveplayer_id), giveplayer_id, PlayerCache[giveplayer_id][pUID]);
			return 1;
		}
		if(!strcmp(owner_type, "grupa", true) || !strcmp(owner_type, "group", true))
		{
			new group_uid;
			if(sscanf(varchar2, "d", group_uid))
			{
			    ShowTipForPlayer(playerid, "/adrzwi przypisz %d grupa [UID grupy]", door_uid);
			    return 1;
			}
			new group_id = GetGroupID(group_uid);
  			if(group_id == INVALID_GROUP_ID)
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID grupy.");
		        return 1;
			}
		    DoorData[dOwnerType] = OWNER_GROUP;
		    DoorData[dOwner] = GroupData[group_id][gUID];
		    
		    Streamer_SetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);

		    SaveDoor(doorid);
   			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Drzwi %s (UID: %d) zostały przypisane pomyślnie.\n\nTyp właściciela: grupa\nWłaściciel: %s (UID: %d)", DoorData[dName], DoorData[dUID], GroupData[group_id][gName], GroupData[group_id][gUID]);
			return 1;
		}
	    return 1;
	}
	if(!strcmp(type, "interior", true))
	{
		new interiorid;
		if(sscanf(varchar, "d", interiorid))
		{
		    new list_interiors[3064];
		    for (new int = 0; int < sizeof(InteriorInfo); int++)
		    {
		        format(list_interiors, sizeof(list_interiors), "%s\n%d\t%s", list_interiors, int, InteriorInfo[int][INTERIOR_NAME]);
		    }
		    ShowPlayerDialog(playerid, D_DOOR_INTERIOR, DIALOG_STYLE_LIST, "Dostępne interiory:", list_interiors, "Wybierz", "Anuluj");
		    return 1;
		}
		if(interiorid > 145 || interiorid < 0)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Błędne ID interioru, nie może wynieść więcej niż 145 ani mniej niż 0.");
		    return 1;
		}
	 	SetPlayerPos(playerid, InteriorInfo[interiorid][INTERIOR_X], InteriorInfo[interiorid][INTERIOR_Y], InteriorInfo[interiorid][INTERIOR_Z]);
	 	SetPlayerInterior(playerid, InteriorInfo[interiorid][INTERIOR_ID]);

	 	SetPlayerFacingAngle(playerid, InteriorInfo[interiorid][INTERIOR_A]);
	 	ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Zostałeś pomyślnie przeteleportowany do interioru %s (InteriorID: %d).", InteriorInfo[interiorid][INTERIOR_NAME], InteriorInfo[interiorid][INTERIOR_ID]);
	    return 1;
	}
	if(!strcmp(type, "zamknij", true) || !strcmp(type, "lock", true))
	{
	    new door_uid;
		if(sscanf(varchar, "d", door_uid))
		{
		    ShowTipForPlayer(playerid, "/adrzwi zamknij [UID drzwi]");
		    return 1;
		}
		new doorid = GetDoorID(door_uid);
  		if(doorid == INVALID_DOOR_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID drzwi.");
			return 1;
	    }
	    new DoorData[sDoorInfo];
	    Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	    
	    if(DoorData[dLocked])
	    {
	        DoorData[dLocked] = false;
	        ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Drzwi %s (UID: %d) zostały otwarte.", DoorData[dName], DoorData[dUID]);
	    }
	    else
	    {
	        DoorData[dLocked] = true;
	        ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Drzwi %s (UID: %d) zostały zamknięte.", DoorData[dName], DoorData[dUID]);
	    }
	    Streamer_SetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	    SaveDoor(doorid);
 		return 1;
	}
	if(!strcmp(type, "wejscie", true) || !strcmp(type, "enter", true))
	{
	    new door_uid;
	    if(sscanf(varchar, "d", door_uid))
	    {
	        ShowTipForPlayer(playerid, "/adrzwi wejscie [UID drzwi]");
	        return 1;
	    }
	    new doorid = GetDoorID(door_uid);
	    if(doorid == INVALID_DOOR_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID drzwi.");
			return 1;
	    }
	    new Float:PosX, Float:PosY, Float:PosZ, Float:PosA;
	    
	    GetPlayerPos(playerid, PosX, PosY, PosZ);
	    GetPlayerFacingAngle(playerid, PosA);
	    
	    Streamer_SetItemPos(STREAMER_TYPE_PICKUP, doorid, PosX, PosY, PosZ);
	    Streamer_SetIntData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_INTERIOR_ID, GetPlayerInterior(playerid));
	    
	    new DoorData[sDoorInfo];
	    Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	    
	    if(DoorData[dMapIcon])	Streamer_SetItemPos(STREAMER_TYPE_MAP_ICON, DoorData[dMapIcon], PosX, PosY, PosZ);
	    
	    DoorData[dEnterA] = PosA;
	    Streamer_SetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	    
		SaveDoor(doorid);
		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Pozycja wejścia dla drzwi %s (UID: %d) została ustalona.", DoorName(doorid), door_uid);
		return 1;
	}
	if(!strcmp(type, "wyjscie", true) || !strcmp(type, "exit", true))
	{
	    new door_uid;
	    if(sscanf(varchar, "d", door_uid))
	    {
	        ShowTipForPlayer(playerid, "/adrzwi wyjscie [UID drzwi]");
	        return 1;
	    }
	    new doorid = GetDoorID(door_uid);
	    if(doorid == INVALID_DOOR_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID drzwi.");
			return 1;
	    }
	    new DoorData[sDoorInfo];
	    Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	    
		GetPlayerPos(playerid, DoorData[dExitX], DoorData[dExitY], DoorData[dExitZ]);
		GetPlayerFacingAngle(playerid, DoorData[dExitA]);
		
		DoorData[dExitInt] = GetPlayerInterior(playerid);
		
		Streamer_SetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	    SaveDoor(doorid);
	    
		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Pozycja wyjścia dla drzwi %s (UID: %d) została ustalona.", DoorData[dName], DoorData[dUID]);
		return 1;
	}
	if(!strcmp(type, "entervw", true))
	{
	    new door_uid, entervw;
	    if(sscanf(varchar, "dd", door_uid, entervw))
	    {
	        ShowTipForPlayer(playerid, "/adrzwi entervw [UID drzwi] [VirtualWorld]");
	        return 1;
	    }
	    new doorid = GetDoorID(door_uid);
	    if(doorid == INVALID_DOOR_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID drzwi.");
			return 1;
	    }
	    Streamer_SetIntData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_WORLD_ID, entervw);
		SaveDoor(doorid);

	    ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "VirtualWorld wejścia dla drzwi %s (UID: %d) został ustalony (VW: %d).", DoorName(doorid), GetDoorUID(doorid), entervw);
		return 1;
	}
	if(!strcmp(type, "exitvw", true))
	{
	    new door_uid, exitvw;
	    if(sscanf(varchar, "dd", door_uid, exitvw))
	    {
	        ShowTipForPlayer(playerid, "/adrzwi exitvw [UID drzwi] [VirtualWorld]");
	        return 1;
	    }
	    new doorid = GetDoorID(door_uid);
	    if(doorid == INVALID_DOOR_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID drzwi.");
			return 1;
	    }
	    new DoorData[sDoorInfo];
	    Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	    
	    DoorData[dExitVW] = exitvw;
		Streamer_SetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
		
		SaveDoor(doorid);
	    ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "VirtualWorld wyjścia dla drzwi %s (UID: %d) został ustalony (VW: %d).", DoorName(doorid), DoorData[dUID], exitvw);
		return 1;
	}
	if(!strcmp(type, "info", true))
	{
	    new door_uid;
	    if(sscanf(varchar, "d", door_uid))
	    {
	        ShowTipForPlayer(playerid, "/adrzwi info [UID drzwi]");
	        return 1;
	    }
	    new doorid = GetDoorID(door_uid);
	    if(doorid == INVALID_DOOR_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID drzwi.");
			return 1;
	    }
	    ShowPlayerDoorInfo(playerid, doorid);
		return 1;
	}
	if(!strcmp(type, "id", true) || !strcmp(type, "sampid", true))
	{
		new doorid = GetClosestDoor(playerid);
		if(doorid == INVALID_DOOR_ID)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znaleziono żadnych drzwi w pobliżu.");
  			return 1;
		}
		ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Najbliżej znajdujące się drzwi to \"%s\" (UID: %d).", DoorName(doorid), GetDoorUID(doorid));
		return 1;
	}
	if(!strcmp(type, "przeladuj", true) || !strcmp(type, "reload", true))
	{
	    new door_uid;
	    if(sscanf(varchar, "d", door_uid))
	    {
	        ShowTipForPlayer(playerid, "/adrzwi przeladuj [UID drzwi]");
	        return 1;
	    }
	    new doorid = GetDoorID(door_uid);
	    if(doorid == INVALID_DOOR_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID drzwi.");
			return 1;
	    }
	    if(GetPlayerDoorID(playerid) == doorid)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz znajdować się w tych drzwiach podczas przeładowywania.");
	        return 1;
	    }
		new DoorData[sDoorInfo];
		Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	    
		// Usuń stare obiekty z tego VW (jeśli są)
		new ObjectData[MAX_VIS_OBJECTS],
			object_count = Streamer_GetNearbyItems(DoorData[dExitX], DoorData[dExitY], DoorData[dExitZ], STREAMER_TYPE_OBJECT, ObjectData, MAX_VIS_OBJECTS, MAX_DRAW_DISTANCE, DoorData[dUID]);

		for (new object = 0; object < object_count; object++)
		{
		    DestroyDynamicObject(ObjectData[object]);
		}
		
  		new query[512];
		mysql_format(connHandle, query, sizeof(query), "SELECT "SQL_PREF"objects.*, "SQL_PREF"materials.material_texture FROM "SQL_PREF"objects LEFT JOIN "SQL_PREF"materials on "SQL_PREF"objects.object_uid = "SQL_PREF"materials.material_owner WHERE "SQL_PREF"objects.object_world = '%d' ORDER BY "SQL_PREF"objects.object_uid ASC", DoorData[dExitVW]);
  		mysql_tquery(connHandle, query, "query_OnLoadObjects", "");

		DoorData[dObjectsLoaded] = true;
		Streamer_SetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
		
        ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Wnętrze drzwi %s (UID: %d) zostało pomyślnie przeładowane.", DoorData[dName], DoorData[dUID]);
	    return 1;
	}
	return 1;
}
alias:adrzwi("ad");

cmd:drzwi(playerid, params[])
{
	new type[32], varchar[32], doorid = GetPlayerDoorID(playerid);
	if(sscanf(params, "s[32]S()[32]", type, varchar))
	{
	    ShowTipForPlayer(playerid, "/drzwi [info, zamknij, opcje]");
	 	return 1;
	}
	if(!strcmp(type, "info", true))
	{
	    if(doorid == INVALID_DOOR_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w drzwiach.");
	        return 1;
	    }
 		new DoorData[sDoorInfo];
    	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
    	
   		if(DoorData[dOwnerType] == OWNER_NONE && !(PlayerCache[playerid][pAdmin] & A_PERM_DOORS))
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie jesteś właścicielem tego budynku.");
		    return 1;
		}
		if(DoorData[dOwnerType] == OWNER_PLAYER && DoorData[dOwner] != PlayerCache[playerid][pUID])
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie jesteś właścicielem tego budynku.");
		    return 1;
		}
		if(DoorData[dOwnerType] == OWNER_GROUP)
		{
		    if(!HavePlayerGroupPerm(playerid, DoorData[dOwner], G_PERM_DOORS))
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie posiadasz uprawnień dla drzwi, w grupie dla której są one przypisane.");
		        return 1;
		    }
		}
		ShowPlayerDoorInfo(playerid, doorid);
	    return 1;
	}
	if(!strcmp(type, "zamknij", true) || !strcmp(type, "z", true))
	{
		new Float:PosX, Float:PosY, Float:PosZ,
			virtual_world = GetPlayerVirtualWorld(playerid), interior_id = GetPlayerInterior(playerid);

		GetPlayerPos(playerid, PosX, PosY, PosZ);

		new NearDoor[MAX_VIS_DOORS],
			count_doors = Streamer_GetNearbyItems(PosX, PosY, PosZ, STREAMER_TYPE_PICKUP, NearDoor, MAX_VIS_DOORS, 2.0, virtual_world);

		if(count_doors > 0)
		{
			for (new door = 0; door < count_doors; door++)
			{
			    doorid = NearDoor[door];
				break;
			}
		}
		else
		{
			new DoorData[sDoorInfo];
			count_doors = Streamer_GetUpperBound(STREAMER_TYPE_PICKUP);

			for (new door = 0; door <= count_doors; door++)
			{
				if(IsValidDynamicPickup(door))
				{
					Streamer_GetArrayData(STREAMER_TYPE_PICKUP, door, E_STREAMER_EXTRA_ID, DoorData);
					if(DoorData[dExitVW] == virtual_world && DoorData[dExitInt] == interior_id)
					{
						if(IsPlayerInRangeOfPoint(playerid, 2.0, DoorData[dExitX], DoorData[dExitY], DoorData[dExitZ]))
						{
							doorid = door;
							break;
						}
					}
				}
			}
		}
		
		if(doorid == INVALID_DOOR_ID)   return 1;
	
	    new DoorData[sDoorInfo];
	    Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	
		if(DoorData[dOwnerType] == OWNER_NONE)
		{
 			ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie posiadasz kluczy do tych drzwi.");
 			return 1;
		}
		if(DoorData[dOwnerType] == OWNER_PLAYER)
		{
  			if(DoorData[dOwner] != PlayerCache[playerid][pUID] && PlayerCache[playerid][pHouse] != DoorData[dUID])
  			{
				ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie posiadasz kluczy do tych drzwi.");
				return 1;
			}
		}
		if(DoorData[dOwnerType] == OWNER_GROUP)
		{
			if(!HavePlayerGroupPerm(playerid, DoorData[dOwner], G_PERM_DOORS))
  			{
				ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie posiadasz kluczy do tych drzwi.");
				return 1;
  			}
		}
		if(DoorData[dLocked])
		{
			GameTextForPlayer(playerid, "~w~Drzwi ~g~otwarte", 4000, 6);

			ApplyAnimation(playerid,"INT_HOUSE", "wash_up", 4.1, 0, 0, 0, 0, 0, 1);
			PlayerPlaySound(playerid, 1145, 0.0, 0.0, 0.0);

			DoorData[dLocked] = false;
		}
		else
		{
			GameTextForPlayer(playerid, "~w~Drzwi ~r~zamkniete", 4000, 6);

			ApplyAnimation(playerid,"INT_HOUSE", "wash_up", 4.1, 0, 0, 0, 0, 0, 1);
			PlayerPlaySound(playerid, 1145, 0.0, 0.0, 0.0);

			DoorData[dLocked] = true;
		}
		Streamer_SetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
		SaveDoor(doorid);
	    return 1;
	}
	if(!strcmp(type, "opcje", true))
	{
	    new string[128];
	    if(doorid == INVALID_DOOR_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w drzwiach.");
	        return 1;
	    }
	    new DoorData[sDoorInfo];
	    Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	    
   		if(DoorData[dOwnerType] == OWNER_NONE)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie jesteś właścicielem tego budynku.");
		    return 1;
		}
		if(DoorData[dOwnerType] == OWNER_PLAYER && DoorData[dOwner] != PlayerCache[playerid][pUID])
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie jesteś właścicielem tego budynku.");
		    return 1;
		}
		if(DoorData[dOwnerType] == OWNER_GROUP)
		{
		    if(!HavePlayerGroupPerm(playerid, DoorData[dOwner], G_PERM_LEADER))
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie jesteś właścicielem tego budynku.");
		        return 1;
		    }
		}
		PlayerCache[playerid][pMainTable] = doorid;
		
		format(string, sizeof(string), "%s (UID: %d) » Opcje", DoorData[dName], DoorData[dUID]);
		ShowPlayerDialog(playerid, D_DOOR_OPTIONS, DIALOG_STYLE_LIST, string, "1. Edytuj nazwę drzwi\n2. Ustal koszt wstępu\n3. Przypisz drzwi\n4. Muzyka spoza gry\n5. Pokaż magazyn\n6. Załaduj wnętrze\n7. Możliwość przejazdu\n8. Ustal pozycję wyjściową\n9. Przedmioty w schowku\n10. Ustal metraż budynku\n11. Zmień godzinę wewnątrz", "Wybierz", "Anuluj");
	    return 1;
	}
	return 1;
}

cmd:aprzedmiot(playerid, params[])
{
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_ITEMS))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz zarządzać przedmiotami.");
	    return 1;
	}
	new type[32], varchar[64];
	if(sscanf(params, "s[32]S()[64]", type, varchar))
	{
	    ShowTipForPlayer(playerid, "/aprzedmiot [stworz, typ, value1, value2, info]");
	    return 1;
	}
	if(!strcmp(type, "stworz", true) || !strcmp(type, "stwórz", true) || !strcmp(type, "create", true))
	{
	    new item_type, item_value1, item_value2, item_name[32];
	    if(sscanf(varchar, "k<item_type>dds[32]", item_type, item_value1, item_value2, item_name))
	    {
	        ShowTipForPlayer(playerid, "/aprzedmiot stworz [Typ przedmiotu] [Wartość 1] [Wartość 2] [Nazwa przedmiotu]");
	        return 1;
	    }
	    if(item_type == INVALID_ITEM_TYPE)
	    {
            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędny typ przedmiotu.");
	        return 1;
	    }
	    escape_pl(item_name);

     	CreatePlayerItem(playerid, item_name, item_type, item_value1, item_value2);
     	ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Przedmiot został pomyślnie stworzony. Szczegóły:\n\nNazwa: %s\nTyp: %s\nWartości: %d/%d\n\nPrzedmiot pojawił się w Twoim ekwipunku.", item_name, ItemTypeInfo[item_type][iTypeName], item_value1, item_value2);
	    return 1;
	}
	if(!strcmp(type, "typ", true))
	{
	    new item_uid, item_type;
	    if(sscanf(varchar, "dk<item_type>", item_uid, item_type))
	    {
	        ShowTipForPlayer(playerid, "/aprzedmiot typ [UID przedmiotu] [Typ]");
	        return 1;
	    }
	    new player_owner = GetItemOwner(item_uid);
	    if(player_owner == INVALID_PLAYER_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID przedmiotu.\nPamiętaj, że przedmiot musi być w posiadaniu gracza.");
	        return 1;
	    }
	    new itemid = GetPlayerItemID(player_owner, item_uid);
	    if(itemid == INVALID_ITEM_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID przedmiotu.\nPamiętaj, że przedmiot musi być w posiadaniu gracza.");
	        return 1;
	    }
	    if(item_type < 0 || item_type > ITEM_COUNT)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłowy typ przedmiotu.\nTyp powinien mieścić się w przedziale od 0 do %d.", ITEM_COUNT);
	        return 1;
	    }
		PlayerItemCache[player_owner][itemid][iType] = item_type;
	    orm_update(PlayerItemCache[player_owner][itemid][iOrm]);

		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Typ przedmiotu %s (UID: %d) został pomyślnie zmieniony.\nNowy typ przedmiotu: %s.", PlayerItemCache[player_owner][itemid][iName], PlayerItemCache[player_owner][itemid][iUID], ItemTypeInfo[item_type][iTypeName]);
		return 1;
	}
	if(!strcmp(type, "nazwa", true))
	{
 		new item_uid, item_name[32], real_item_name[32];
	    if(sscanf(varchar, "ds[32]", item_uid, item_name))
	    {
	        ShowTipForPlayer(playerid, "/aprzedmiot nazwa [UID przedmiotu] [Nazwa]");
	        return 1;
	    }
	    new player_owner = GetItemOwner(item_uid);
	    if(player_owner == INVALID_PLAYER_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID przedmiotu.\nPamiętaj, że przedmiot musi być w posiadaniu gracza.");
	        return 1;
	    }
	    new itemid = GetPlayerItemID(player_owner, item_uid);
	    if(itemid == INVALID_ITEM_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID przedmiotu.\nPamiętaj, że przedmiot musi być w posiadaniu gracza.");
	        return 1;
	    }
	    mysql_escape_string(item_name, real_item_name);
		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Nazwa przedmiotu %s (UID: %d) została pomyślnie zmieniona.\nNowa nazwa przedmiotu: %s.", PlayerItemCache[player_owner][itemid][iName], PlayerItemCache[player_owner][itemid][iUID], real_item_name);

		strmid(PlayerItemCache[player_owner][itemid][iName], real_item_name, 0, strlen(real_item_name), 32);
		orm_update(PlayerItemCache[player_owner][itemid][iOrm]);
		return 1;
	}
	if(!strcmp(type, "value1", true))
	{
 		new item_uid, item_value1;
	    if(sscanf(varchar, "dd", item_uid, item_value1))
	    {
	        ShowTipForPlayer(playerid, "/aprzedmiot value1 [UID przedmiotu] [Value 1]");
	        return 1;
	    }
	    new player_owner = GetItemOwner(item_uid);
	    if(player_owner == INVALID_PLAYER_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID przedmiotu.\nPamiętaj, że przedmiot musi być w posiadaniu gracza.");
	        return 1;
	    }
	    new itemid = GetPlayerItemID(player_owner, item_uid);
	    if(itemid == INVALID_ITEM_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID przedmiotu.\nPamiętaj, że przedmiot musi być w posiadaniu gracza.");
	        return 1;
	    }
		PlayerItemCache[player_owner][itemid][iValue][0] = item_value1;
		orm_update(PlayerItemCache[player_owner][itemid][iOrm]);

		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Wartość nr. 1 przedmiotu %s (UID: %d) została pomyślnie zmieniona.\nNowa wartość nr. 1 przedmiotu: %d.", PlayerItemCache[player_owner][itemid][iName], PlayerItemCache[playerid][itemid][iUID], PlayerItemCache[player_owner][itemid][iValue][0]);
		return 1;
	}
	if(!strcmp(type, "value2", true))
	{
 		new item_uid, item_value2;
	    if(sscanf(varchar, "dd", item_uid, item_value2))
	    {
	        ShowTipForPlayer(playerid, "/aprzedmiot value2 [UID przedmiotu] [Value 2]");
	        return 1;
	    }
	    new player_owner = GetItemOwner(item_uid);
	    if(player_owner == INVALID_PLAYER_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID przedmiotu.\nPamiętaj, że przedmiot musi być w posiadaniu gracza.");
	        return 1;
	    }
	    new itemid = GetPlayerItemID(player_owner, item_uid);
	    if(itemid == INVALID_ITEM_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID przedmiotu.\nPamiętaj, że przedmiot musi być w posiadaniu gracza.");
	        return 1;
	    }
		PlayerItemCache[player_owner][itemid][iValue][1] = item_value2;
		orm_update(PlayerItemCache[player_owner][itemid][iOrm]);

		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Wartość nr. 2 przedmiotu %s (UID: %d) została pomyślnie zmieniona.\nNowa wartość nr. 2 przedmiotu: %d.", PlayerItemCache[player_owner][itemid][iName], PlayerItemCache[player_owner][itemid][iUID], PlayerItemCache[player_owner][itemid][iValue][1]);
		return 1;
	}
	if(!strcmp(type, "info", true))
	{
		new item_uid;
	    if(sscanf(varchar, "d", item_uid))
	    {
	        ShowTipForPlayer(playerid, "/aprzedmiot info [UID przedmiotu]");
	        return 1;
	    }
	    new player_owner = GetItemOwner(item_uid);
	    if(player_owner == INVALID_PLAYER_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID przedmiotu.\nPamiętaj, że przedmiot musi być w posiadaniu gracza.");
	        return 1;
	    }
	    new itemid = GetPlayerItemID(player_owner, item_uid);
	    if(itemid == INVALID_ITEM_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID przedmiotu.\nPamiętaj, że przedmiot musi być w posiadaniu gracza.");
	        return 1;
	    }
		ShowPlayerItemInfo(playerid, itemid);
	    return 1;
	}
	return 1;
}
alias:aprzedmiot("ap");

cmd:p(playerid, params[])
{
	new type[24], varchar[24], string[128];
	if(sscanf(params, "s[24]S()[24]", type, varchar))
	{
		ListPlayerItems(playerid);
		TD_ShowHint(playerid, HINT_ITEMS, 15, "Przedmioty na serwerze to wazna rzecz. Wiekszosc ~y~interakcji ~w~opiera sie wlasnie za ich pomoca.~n~~n~Kazdy ma swoja wlasna ~p~liste przedmiotow~w~, ktorymi mozna manipulowac na rozne sposoby oraz uzywac ich.~n~~n~Zdobyc przedmiot mozesz na ~g~kilka sposobow~w~: otrzymac od gracza, znalezc na ziemi, otrzymac od aktora... i wiele wiecej! Przekonasz sie o tym podczas rozgrywki.");
	    return 1;
	}
	
	if(!strcmp(type, "podnies", true))
	{
	    ListPlayerNearItems(playerid);
	    return 1;
	}
	
	if(!strcmp(type, "pokaz", true))
	{
 		new giveplayer_id;
	    if(sscanf(varchar, "u", giveplayer_id))
	    {
	        ShowTipForPlayer(playerid, "/p pokaz [ID gracza]");
	        return 1;
	    }
		if(giveplayer_id == INVALID_PLAYER_ID)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	    	return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
		   	return 1;
		}
		ListPlayerItemsForPlayer(playerid, giveplayer_id);

 		format(string, sizeof(string), "~n~~n~~n~~n~~n~~n~~n~~n~~n~~y~Gotowka gracza ~r~%s~y~: ~g~$%d~y~.", PlayerName(playerid), PlayerCache[playerid][pCash]);
		GameTextForPlayer(giveplayer_id, string, 6000, 3);

		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Pokazałeś swoje przedmioty dla gracza %s.", PlayerName(giveplayer_id));
		printf("[item] %s (UID: %d, GID: %d) pokazał swoje przedmioty dla %s (UID: %d, GID: %d).", PlayerRealName(playerid), PlayerCache[playerid][pUID], PlayerCache[playerid][pGID], PlayerRealName(giveplayer_id), PlayerCache[giveplayer_id][pUID], PlayerCache[giveplayer_id][pGID]);
		return 1;
	}
	
	if(!strcmp(type, "lista", true))
	{
 		new giveplayer_id;
	    if(sscanf(varchar, "u", giveplayer_id))
	    {
            ListPlayerItems(playerid);
	        return 1;
	    }
   		if(!(PlayerCache[playerid][pAdmin] & A_PERM_BASIC))
		{
   		    ListPlayerItems(playerid);
   		    return 1;
		}
 		if(giveplayer_id == INVALID_PLAYER_ID)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	    	return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	 		return 1;
		}
		ListPlayerItemsForPlayer(giveplayer_id, playerid);
	    return 1;
	}
	
	foreach(new itemid : PlayerItem[playerid])
	{
		if(strfind(PlayerItemCache[playerid][itemid][iName], type, true) >= 0)
		{
			if(PlayerItemCache[playerid][itemid][iType] == ITEM_WEAPON || PlayerItemCache[playerid][itemid][iType] == ITEM_INHIBITOR || PlayerItemCache[playerid][itemid][iType] == ITEM_PAINT)
			{
				if(strlen(varchar) <= 0)
				{
					ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Jeżeli próbujesz wyjąć broń, korzystając ze sposobu szybkiego użytku,\nmusisz wpisać dodatkowe parametry, dzięki którym system sam ułoży treść /me.\n\nPrzykład:\n/p deagle zza paska.");
					return 1;
				}

				if(!OnPlayerUseItem(playerid, itemid))
				{
					return 1;
				}

				if(!PlayerItemCache[playerid][itemid][iUsed])
				{
					format(string, sizeof(string), "** %s chowa %s %s", PlayerName(playerid), PlayerItemCache[playerid][itemid][iName], varchar);
					ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
				}
				else
				{
					format(string, sizeof(string), "** %s wyjmuje %s %s", PlayerName(playerid), PlayerItemCache[playerid][itemid][iName], varchar);
					ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);

					TD_ShowSmallInfo(playerid, 5, "Uzyles przedmiotu ~y~%s (UID: %d)~w~.", PlayerItemCache[playerid][itemid][iName], PlayerItemCache[playerid][itemid][iUID]);
				}
			}
			else
			{
				OnPlayerUseItem(playerid, itemid);
			}
			break;
		}
	}
	return 1;
}

cmd:strefa(playerid, params[])
{
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_AREAS))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz zarządzać strefami.");
	    return 1;
	}
	new type[32], varchar[64];
	if(sscanf(params, "s[32]S()[64]", type, varchar))
	{
	    ShowTipForPlayer(playerid, "/strefa [stworz, usun, przypisz, pokaz, flagi]");
		return 1;
	}
	if(!strcmp(type, "stworz", true) || !strcmp(type, "create", true))
	{
		new Float:PosZ;
        PlayerCache[playerid][pCreatingArea] = true;
        
		GetPlayerPos(playerid, PlayerCache[playerid][pCreatingAreaPos][0], PlayerCache[playerid][pCreatingAreaPos][1], PosZ);
		ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Udaj się teraz po przekątnej strefy, a następnie wciśnij w wybranym miejscu klawisz PPM.\nAby anulować tworzenie strefy wciśnij klawisz ENTER.");
	    return 1;
	}
	if(!strcmp(type, "usun", true) || !strcmp(type, "delete", true))
	{
		new area_uid;
		if(sscanf(varchar, "d", area_uid))
		{
		    ShowTipForPlayer(playerid, "/strefa usun [UID strefy]");
		    return 1;
		}
		new areaid = GetAreaID(area_uid);
		if(areaid == INVALID_AREA_ID)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wporowadzono błędne UID strefy.");
		    return 1;
		}
		
		DeleteArea(areaid);
		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Strefa (UID: %d) została pomyślnie usunięta.", area_uid);
	    return 1;
	}
	if(!strcmp(type, "przypisz", true) || !strcmp(type, "assign", true))
	{
		new area_uid, owner_type[24], varchar2[24];
		if(sscanf(varchar, "ds[24]S()[24]", area_uid, owner_type, varchar2))
		{
		    ShowTipForPlayer(playerid, "/strefa przypisz [UID strefy] [Typ (gracz, grupa)]");
		    return 1;
		}
		new areaid = GetAreaID(area_uid);
		if(areaid == INVALID_AREA_ID)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wporowadzono błędne UID strefy.");
		    return 1;
		}
		new AreaData[sAreaData];
		Streamer_GetArrayData(STREAMER_TYPE_AREA, areaid, E_STREAMER_EXTRA_ID, AreaData);
		
		if(!strcmp(owner_type, "gracz", true) || !strcmp(owner_type, "player", true))
		{
  			new giveplayer_id;
			if(sscanf(varchar2, "u", giveplayer_id))
			{
			    ShowTipForPlayer(playerid, "/strefa przypisz %d gracz [ID gracza]", area_uid);
			    return 1;
			}
			if(giveplayer_id == INVALID_PLAYER_ID)
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
			    return 1;
			}
			if(!PlayerCache[giveplayer_id][pLogged])
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
			    return 1;
			}
			AreaData[aOwnerType] = OWNER_PLAYER;
			AreaData[aOwner] = PlayerCache[giveplayer_id][pUID];
			
			Streamer_SetArrayData(STREAMER_TYPE_AREA, areaid, E_STREAMER_EXTRA_ID, AreaData);
			SaveArea(areaid);
			
			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Strefa (UID: %d) została przypisana pomyślnie.\n\nTyp właściciela: gracz\nWłaściciel: %s (ID: %d, UID: %d).", AreaData[aUID], PlayerName(giveplayer_id), giveplayer_id, PlayerCache[giveplayer_id][pUID]);
		    return 1;
		}
		if(!strcmp(owner_type, "grupa", true) || !strcmp(owner_type, "group", true))
		{
  			new group_uid;
		    if(sscanf(varchar2, "d", group_uid))
		    {
		        ShowTipForPlayer(playerid, "/strefa przypisz %d grupa [UID grupy]", area_uid);
		        return 1;
		    }
		    new group_id = GetGroupID(group_uid);
 	    	if(group_id == INVALID_GROUP_ID)
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID grupy.");
		        return 1;
		    }
			AreaData[aOwnerType] = OWNER_GROUP;
			AreaData[aOwner] = GroupData[group_id][gUID];

			Streamer_SetArrayData(STREAMER_TYPE_AREA, areaid, E_STREAMER_EXTRA_ID, AreaData);
			SaveArea(areaid);
			
			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Strefa (UID: %d) została przypisana pomyślnie.\n\nTyp właściciela: grupa\nWłaściciel: %s (UID: %d)", AreaData[aUID], GroupData[group_id][gName], GroupData[group_id][gUID]);
			return 1;
		}
	    return 1;
	}
	if(!strcmp(type, "pokaz", true) || !strcmp(type, "show", true))
	{
	    new area_uid;
	    if(sscanf(varchar, "d", area_uid))
	    {
	        ShowTipForPlayer(playerid, "/strefa pokaz [UID strefy]");
	        return 1;
	    }
	    new areaid = GetAreaID(area_uid);
	    if(areaid == INVALID_AREA_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wporowadzono błędne UID strefy.");
	        return 1;
	    }
	    new Float:pointes[8];
	    GetDynamicPolygonPoints(areaid, pointes, 8);
	    
	    new gang_zone = GangZoneCreate(pointes[0], pointes[1], pointes[4], pointes[3]);
	    GangZoneShowForPlayer(playerid, gang_zone, COLOR_AREA);
	    
	    ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Strefa (UID: %d) została pomyślnie pokazana na mapie.", area_uid);
	    return 1;
	}
	if(!strcmp(type, "flagi", true) || !strcmp(type, "flagi", true))
	{
	    new area_uid;
	    if(sscanf(varchar, "d", area_uid))
	    {
	        ShowTipForPlayer(playerid, "/strefa flagi [UID strefy]");
	        return 1;
	    }
	    new areaid = GetAreaID(area_uid);
	    if(areaid == INVALID_AREA_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wporowadzono błędne UID strefy.");
	        return 1;
	    }
	    new AreaData[sAreaData], title[64], list_flags[1024];
	    Streamer_GetArrayData(STREAMER_TYPE_AREA, areaid, E_STREAMER_EXTRA_ID, AreaData);
	    
	    DynamicGui_Init(playerid);
	    
    	for(new i = 0; i < sizeof(AreaFlag); i++)
		{
		    AreaFlag[i][fName][0] = chrtolower(AreaFlag[i][fName][0]);
		    
		    if(AreaData[aFlags] & AreaFlag[i][fType])
		    {
		        format(list_flags, sizeof(list_flags), "%s\n[X]\t%s", list_flags, AreaFlag[i][fName]);
			}
			else
			{
			    format(list_flags, sizeof(list_flags), "%s\n[ ]\t%s", list_flags, AreaFlag[i][fName]);
			}
			DynamicGui_AddRow(playerid, D_NONE, AreaFlag[i][fType]);
		}
		
		PlayerCache[playerid][pMainTable] = areaid;
		
		format(title, sizeof(title), "Flagi dla strefy (UID: %d):", AreaData[aUID]);
		ShowPlayerDialog(playerid, D_AREA_FLAGS, DIALOG_STYLE_LIST, title, list_flags, "Wybierz", "Zamknij");
	}
	return 1;
}

cmd:tel(playerid, params[])
{
	if(!PlayerCache[playerid][pPhoneNumber])
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz żadnego telefonu w użyciu.\nSkorzystaj z komendy /p, by włączyć telefon.");
	    return 1;
	}
	
	if(is_null(params))
	{
	    new itemid = GetPlayerPhoneItemID(playerid, PlayerCache[playerid][pPhoneNumber]);
   		OnPlayerUseItem(playerid, itemid);
   		return 1;
	}
	
	if(!strcmp(params, "zakoncz", true) || !strcmp(params, "z", true))
	{
		foreach(new i : Player)
		{
		    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
		    {
		        if(PlayerCache[i][pCallingTo] == playerid)
		        {
          			PlayerCache[i][pCallingTo] = INVALID_PLAYER_ID;

					SetPlayerSpecialAction(i, SPECIAL_ACTION_STOPUSECELLPHONE);
					RemovePlayerAttachedObject(i, SLOT_PHONE);
					
	            	SendClientMessage(i, COLOR_YELLOW, "Rozmowa została pomyślnie zakończona.");
		        }
		    }
		}
		
		if(PlayerCache[playerid][pCallingTo] != INVALID_PLAYER_ID)
		{
		    SendClientMessage(playerid, COLOR_YELLOW, "Rozmowa została pomyślnie zakończona.");
		    PlayerCache[playerid][pCallingTo] = INVALID_PLAYER_ID;
		    
   			SetPlayerSpecialAction(playerid, SPECIAL_ACTION_STOPUSECELLPHONE);
			RemovePlayerAttachedObject(playerid, SLOT_PHONE);
		}
		else
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aktualnie z nikim nie rozmawiasz oraz nikt nie próbuje się z Tobą połączyć.");
		}
		return 1;
	}
	
	if(!strcmp(params, "odbierz", true) || !strcmp(params, "od", true))
	{
		if(PlayerCache[playerid][pCallingTo] != INVALID_PLAYER_ID)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aktualnie prowadzisz już jakąś rozmowę telefoniczną.\nZakończ obecną rozmowę, by móc zadzwonić (/tel zakoncz).");
		    return 1;
		}
		
		foreach(new i : Player)
		{
		    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
		    {
		        if(PlayerCache[i][pCallingTo] == playerid)
		        {
		            PlayerCache[playerid][pCallingTo] = i;
		            
	         		SetPlayerAttachedObject(playerid, SLOT_PHONE, 330, 6);
		            SetPlayerSpecialAction(playerid, SPECIAL_ACTION_USECELLPHONE);

		            SendClientMessage(playerid, COLOR_YELLOW, "Odebrałeś telefon. Aby zakończyć rozmowę użyj komendy /tel zakoncz.");
	                SendClientMessage(i, COLOR_YELLOW, "Odebrano telefon. Aby zakończyć rozmowę użyj komendy /tel zakoncz.");
	                return 1;
		        }
		    }
		}
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nikt w danej chwili nie próbuje się z Tobą połączyć.");
	    return 1;
	}
	
	if(!strval(params))	return 1;
	
	new phone_number = strval(params), string[128];
	if(phone_number == PlayerCache[playerid][pPhoneNumber])
	{
	    SendClientMessage(playerid, COLOR_DO, "* Słychać sygnał zajętości... *");
	    return 1;
	}
	if(PlayerCache[playerid][pCallingTo] != INVALID_PLAYER_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aktualnie prowadzisz już jakąś rozmowę telefoniczną.\nZakończ obecną rozmowę, by móc zadzwonić (/tel zakoncz).");
	    return 1;
	}
	
	// Hurtownia
	if(phone_number == NUMBER_WHOLESALE)
	{
	    new doorid = GetPlayerDoorID(playerid);
	    if(doorid == INVALID_DOOR_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby móc zamówić produkty, musisz znajdować się w budynku grupowym.");
	        return 1;
	    }
	    new DoorData[sDoorInfo];
	    Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	    
	    if(DoorData[dOwnerType] == OWNER_NONE || DoorData[dOwnerType] == OWNER_PLAYER)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby móc zamówić produkty, musisz znajdować się w budynku grupowym.");
	        return 1;
	    }
	    if(DoorData[dOwnerType] == OWNER_GROUP)
	    {
	        if(!HavePlayerGroupPerm(playerid, DoorData[dOwner], G_PERM_ORDER))
	        {
	            ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz zamawiać produktów.");
	            return 1;
	        }
	    }
	    PlayerCache[playerid][pMainTable] = doorid;
	    PlayerCache[playerid][pCallingTo] = NUMBER_WHOLESALE;
	    
		SetPlayerAttachedObject(playerid, SLOT_PHONE, 330, 6);
		SetPlayerSpecialAction(playerid, SPECIAL_ACTION_USECELLPHONE);
		
		new list_category[512],
		    category_uid, category_name[32];

		new rows, Cache:tmp_cache = mysql_query(connHandle, "SELECT * FROM `"SQL_PREF"order_category`");

		cache_get_row_count(rows);
		for(new row = 0; row != rows; row++)
		{
		    cache_get_value_index_int(row, 0, category_uid);
		    cache_get_value_index(row, 1, category_name, 32);
		    
		    format(list_category, sizeof(list_category), "%s\n%d\t%s", list_category, category_uid, category_name);
		}
		if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
		
		if(strlen(list_category))
		{
  			if(HavePlayerGroupPerm(playerid, DoorData[dOwner], G_PERM_CAPITAL))
  			{
				new group_id = GetGroupID(DoorData[dOwner]);
				if(PlayerCache[playerid][pDuty][DUTY_GROUP] == group_id)
				{
			    	TD_ShowSmallInfo(playerid, 0, "~r~Uwaga!~n~~w~Za ta usluge zaplacisz za pomoca kapitalu grupy ~y~%s (UID: %d)~w~. Jesli nie chcesz tego robic - ~r~dezaktywuj ~w~sluzbe grupy.", GroupData[group_id][gName], GroupData[group_id][gUID]);
				}
			}
			
		    ShowPlayerDialog(playerid, D_ORDER_CATEGORY, DIALOG_STYLE_LIST, "Wybierz kategorię:", list_category, "Wybierz", "Anuluj");
		}
		else
		{
		    TD_ShowSmallInfo(playerid, 3, "Nie znaleziono ~r~zadnych ~w~kategorii.");
		}
	    return 1;
	}
	
	// Taxi
	if(phone_number == NUMBER_TAXI || phone_number == NUMBER_GASTRONOMY || phone_number == NUMBER_NEWS || phone_number == NUMBER_ALARM)
	{
	    new group_type, group_flag;
	    switch(phone_number)
		{
		    case NUMBER_TAXI:   	group_type = G_TYPE_TAXI;
		    case NUMBER_GASTRONOMY: group_type = G_TYPE_BAR;
		    case NUMBER_NEWS:       group_type = G_TYPE_NEWS;
		    case NUMBER_ALARM:      group_flag = G_FLAG_911;
		}
		
		DynamicGui_Init(playerid);
	
		new list_groups[1024], count_groups;
		format(list_groups, sizeof(list_groups), "Nazwa grupy\tNa służbie");
		
		foreach(new group_id : Groups)
		{
 	 		if(GroupData[group_id][gUID])
  			{
  				if((group_type != 0 && GroupData[group_id][gType] == group_type) || (group_flag != 0 && GroupData[group_id][gFlags] & group_flag))
  				{
  					new workers;
					foreach(new i : Player)
					{
					  	if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
					  	{
						  	if(PlayerCache[i][pDuty][DUTY_GROUP] == group_id)
						  	{
								workers ++;
  							}
  						}
					}
					count_groups ++;
					
					format(list_groups, sizeof(list_groups), "%s\n%s\tx%d", list_groups, GroupData[group_id][gName], workers);
  					DynamicGui_AddRow(playerid, D_NONE, group_id);
				}
    		}
      	}
		if(count_groups > 0)
		{
  			SetPlayerAttachedObject(playerid, SLOT_PHONE, 330, 6);
			SetPlayerSpecialAction(playerid, SPECIAL_ACTION_USECELLPHONE);

			PlayerCache[playerid][pCallingTo] = phone_number;
			ShowPlayerDialog(playerid, D_GROUP_SELECT, DIALOG_STYLE_TABLIST_HEADERS, "Wybierz grupę, do której chcesz zadzwonić:", list_groups, "Dalej", "Anuluj");
		}
		else
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "W chwili obecnej nie ma żadnych firm.");
		}
	    return 1;
	}

	foreach(new i : Player)
	{
	    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	    {
	        if(PlayerCache[i][pPhoneNumber] == phone_number)
	        {
	            if(PlayerCache[i][pCallingTo] != INVALID_PLAYER_ID)
	            {
	                SendClientMessage(playerid, COLOR_DO, "* Słychać sygnał zajętości... *");
	                return 1;
	            }
	            PlayerCache[playerid][pCallingTo] = i;
	            
 				SetPlayerAttachedObject(playerid, SLOT_PHONE, 330, 6);
				SetPlayerSpecialAction(playerid, SPECIAL_ACTION_USECELLPHONE);
				
				format(string, sizeof(string), "* Słychać dźwięk dzwoniącego telefonu. (( %s ))", PlayerName(i));
				ProxDetector(10.0, i, string, COLOR_DO, COLOR_DO, COLOR_DO, COLOR_DO, COLOR_DO);
				
				SendClientMessage(playerid, COLOR_DO, "* Słychać sygnał próby połączenia się... *");
				SendClientFormatMessage(i, COLOR_YELLOW, "Połączenie przychodzące od %d, użyj (/tel)efon odbierz, by odebrać rozmowę.", PlayerCache[playerid][pPhoneNumber]);

				PlayAudioForPlayer(playerid, AUDIO_CALLING_TO);

				foreach(new player : Player)
			    {
					if(PlayerCache[player][pLogged] && PlayerCache[player][pSpawned])
					{
					    if(IsPlayerInRangeOfPoint(player, 15.0, PlayerCache[i][pPosX], PlayerCache[i][pPosY], PlayerCache[i][pPosZ]))
					    {
							Play3DAudioForPlayer(player, AUDIO_CALLING, PlayerCache[i][pPosX], PlayerCache[i][pPosY], PlayerCache[i][pPosZ], 10.0);
						}
					}
			    }
			    return 1;
			}
	    }
	}
	SendClientMessage(playerid, COLOR_DO, "* Nie można połączyć się z wybranym numerem...");
	return 1;
}
alias:tel("telefon", "call");

cmd:sms(playerid, params[])
{
	if(!PlayerCache[playerid][pPhoneNumber])
  	{
   		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz żadnego telefonu w użyciu.\nSkorzystaj z komendy /p, by włączyć telefon.");
   		return 1;
   	}
	new number, text[128], string[256];
	if(sscanf(params, "ds[128]", number, text))
	{
	    ShowTipForPlayer(playerid, "/sms [Nr. tel] [Treść]");
	    return 1;
	}
	
	foreach(new i : Player)
	{
	    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	    {
	        if(PlayerCache[i][pPhoneNumber] == number)
	        {
         		format(string, sizeof(string), "* %s wysyła SMS-a.", PlayerName(playerid));
	            ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
	        
         		if(PlayerCache[i][pSex]) 			format(string, sizeof(string), "* %s otrzymał SMS-a.", PlayerName(i));
	            else 								format(string, sizeof(string), "* %s otrzymała SMS-a.", PlayerName(i));

	            ProxDetector(10.0, i, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
	            
	            SendClientFormatMessage(i, COLOR_YELLOW, "[SMS] %d: %s", PlayerCache[playerid][pPhoneNumber], text);
	            SendClientFormatMessage(playerid, COLOR_YELLOW, "Wysłano » [SMS] %d: %s", number, text);
	            
				new audio_handle;
  				foreach(new player : Player)
			    {
					if(PlayerCache[player][pLogged] && PlayerCache[player][pSpawned])
					{
					    if(IsPlayerInRangeOfPoint(player, 15.0, PlayerCache[i][pPosX], PlayerCache[i][pPosY], PlayerCache[i][pPosZ]))
					    {
					        Play3DAudioForPlayer(player, AUDIO_SMS, PlayerCache[i][pPosX], PlayerCache[i][pPosY], PlayerCache[i][pPosZ], 15.0);
						}
					}
			    }
				return 1;
			}
	    }
	}
	SendClientMessage(playerid, COLOR_DO, "* Wiadomość SMS nie została dostarczona...");
	return 1;
}

cmd:dom(playerid, params[])
{
	new doorid = GetPlayerDoorID(playerid);
	if(doorid == INVALID_DOOR_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znajdujesz się w swoim domu.");
	    return 1;
	}
 	new DoorData[sDoorInfo];
 	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
 	
	if(DoorData[dOwnerType] != OWNER_PLAYER || DoorData[dOwner] != PlayerCache[playerid][pUID])
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znajdujesz się w swoim domu.");
	    return 1;
	}
	new type[32], varchar[64];
	GivePlayerAchievement(playerid, ACHIEVE_HOUSE);
	
	if(sscanf(params, "s[32]S()[64]", type, varchar))
	{
	    ShowTipForPlayer(playerid, "/dom [zapros, wypros]");
	    return 1;
	}
	if(!strcmp(type, "zapros", true))
	{
	    new giveplayer_id;
	    if(sscanf(varchar, "u", giveplayer_id))
	    {
	        ShowTipForPlayer(playerid, "/dom zapros [ID gracza]");
	        return 1;
	    }
    	if(giveplayer_id == playerid)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaprosić samego siebie.");
			return 1;
		}
		if(giveplayer_id == INVALID_PLAYER_ID)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	    	return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
		{
	 		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
	 		return 1;
		}
		if(PlayerCache[giveplayer_id][pHouse])
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz posiada już jakiś dom, bądź jest gdzieś zameldowany.");
		    return 1;
		}
		PlayerCache[giveplayer_id][pHouse] = DoorData[dUID];
		orm_update(PlayerCache[giveplayer_id][pOrm]);

		SendClientFormatMessage(giveplayer_id, COLOR_LIGHTBLUE, "%s zaprosił Cię do swojego domu.", PlayerName(playerid));
		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Zaprosiłeś gracza %s do swojego domu.", PlayerName(giveplayer_id));
	    return 1;
	}
	if(!strcmp(type, "wypros", true))
	{
	    new giveplayer_id;
	    if(sscanf(varchar, "u", giveplayer_id))
		{
		    ShowTipForPlayer(playerid, "/dom wypros [ID gracza]");
		    return 1;
		}
    	if(giveplayer_id == playerid)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaprosić samego siebie.");
			return 1;
		}
		if(giveplayer_id == INVALID_PLAYER_ID)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	    	return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(PlayerCache[giveplayer_id][pHouse] != DoorData[dUID])
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz nie jest zameldowany w Twoim domu.");
		    return 1;
		}
		PlayerCache[giveplayer_id][pHouse] = 0;
		orm_update(PlayerCache[giveplayer_id][pOrm]);

		SendClientFormatMessage(giveplayer_id, COLOR_LIGHTBLUE, "%s wyprosił Cię ze swojego domu.", PlayerName(playerid));
		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Wyprosiłeś gracza %s ze swojego domu.", PlayerName(giveplayer_id));
	    return 1;
	}
	return 1;
}

cmd:kup(playerid, params[])
{
	new group_id = INVALID_GROUP_ID, doorid = GetPlayerDoorID(playerid);
	if(doorid != INVALID_DOOR_ID)
	{
		new DoorData[sDoorInfo];
 		Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
 		
		if(DoorData[dOwnerType] != OWNER_GROUP)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w budynku sklepu 24/7.");
		    return 1;
		}
		group_id = GetGroupID(DoorData[dOwner]);
		if(GroupData[group_id][gType] != G_TYPE_24/7)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w budynku sklepu 24/7.");
		    return 1;
		}
	}
	else
	{
	    new areaid = GetPlayerAreaID(playerid);
	    if(areaid == INVALID_AREA_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w budynku sklepu 24/7.");
	        return 1;
	    }
	    
   		new AreaData[sAreaData];
 		Streamer_GetArrayData(STREAMER_TYPE_AREA, areaid, E_STREAMER_EXTRA_ID, AreaData);
 		
 		if(!(AreaData[aFlags] & A_FLAG_OFFER))
 		{
 		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w budynku sklepu 24/7.");
 		    return 1;
 		}
		if(AreaData[aOwnerType] != OWNER_GROUP)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w budynku sklepu 24/7.");
		    return 1;
		}
		group_id = GetGroupID(AreaData[aOwner]);
		if(GroupData[group_id][gType] != G_TYPE_24/7)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w budynku sklepu 24/7.");
		    return 1;
		}
	}

	PlayerCache[playerid][pMainTable] = group_id;
	ListGroupProductsForPlayer(group_id, playerid, PRODUCT_LIST_BUY);
	return 1;
}
alias:kup("buy");

cmd:ubranie(playerid, params[])
{
	new group_id = INVALID_GROUP_ID, doorid = GetPlayerDoorID(playerid);
	if(doorid != INVALID_DOOR_ID)
	{
		new DoorData[sDoorInfo];
 		Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);

		if(DoorData[dOwnerType] != OWNER_GROUP)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w budynku sklepu z odzieżą.");
		    return 1;
		}
		group_id = GetGroupID(DoorData[dOwner]);
		if(GroupData[group_id][gType] != G_TYPE_CLOTHES)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w budynku sklepu z odzieżą.");
		    return 1;
		}
	}
	else
	{
	    new areaid = GetPlayerAreaID(playerid);
	    if(areaid == INVALID_AREA_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w budynku sklepu z odzieżą.");
	        return 1;
	    }

   		new AreaData[sAreaData];
 		Streamer_GetArrayData(STREAMER_TYPE_AREA, areaid, E_STREAMER_EXTRA_ID, AreaData);
 		
 		if(!(AreaData[aFlags] & A_FLAG_OFFER))
 		{
 		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w budynku sklepu z odzieżą.");
 		    return 1;
 		}
		if(AreaData[aOwnerType] != OWNER_GROUP)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w budynku sklepu z odzieżą.");
		    return 1;
		}
		group_id = GetGroupID(AreaData[aOwner]);
		if(GroupData[group_id][gType] != G_TYPE_CLOTHES)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w budynku sklepu z odzieżą.");
		    return 1;
		}
	}
	if(PlayerCache[playerid][pSelectSkin] != INVALID_SKIN_ID || PlayerCache[playerid][pSelectAccess] != INVALID_ACCESS_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aktualnie jesteś już w fazie wyboru.");
	    return 1;
	}

	ShowPlayerDialog(playerid, D_CLOTH_TYPE_SELECT, DIALOG_STYLE_LIST, "Co chcesz kupić?", "1. Ubranie\n2. Akcesorie", "Wybierz", "Anuluj");
	return 1;
}

cmd:skuj(playerid, params[])
{
	if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby użyć tej komendy, musisz być na służbie grupy z odpowiednimi uprawnieniami.");
		return 1;
 	}
	new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
	if(!(GroupData[group_id][gFlags] & G_FLAG_HANDCUFFS))
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Grupa, na której służbie jesteś nie posiada do tego uprawnień.");
		return 1;
	}
	new giveplayer_id;
	if(sscanf(params, "u", giveplayer_id))
	{
	    ShowTipForPlayer(playerid, "/skuj [ID gracza]");
	    return 1;
	}
	if(giveplayer_id == playerid)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz skuć samego siebie.");
		return 1;
	}
	if(giveplayer_id == INVALID_PLAYER_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
    	return 1;
	}
	if(!PlayerCache[giveplayer_id][pLogged])
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
    	return 1;
	}
	if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
	{
 		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
 		return 1;
	}
	if(!HavePlayerItemType(playerid, ITEM_HANDCUFFS))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz odpowiedniego przedmiotu w swoim ekwipunku.");
	    return 1;
	}
	foreach(new i : Player)
	{
	    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	    {
	        if(PlayerCache[i][pCuffedTo] == playerid)
	        {
	            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz skuć więcej osób.");
	            return 1;
	        }
	    }
	}
	
	// Zadanie
	if(MissionData[playerid][mUID] != 0)
	{
 		if(MissionData[playerid][mType] == MISSION_CHASE)
 		{
			if(MissionData[playerid][mVictim] == PlayerCache[giveplayer_id][pUID])
   			{
				new mission_leader = GetMissionLeader(MissionData[playerid][mUID]);
				group_id = MissionData[playerid][mGroup];
				
				foreach(new i : MissionPlayer[mission_leader])
				{
					TD_ShowHint(i, HINT_NONE, 10, "Zadanie zostalo wykonane ~g~pomyslnie~w~.Na konto grupy ~y~%s (UID: %d) ~w~dodano ~g~%d", GroupData[group_id][gName], GroupData[group_id][gUID], MissionData[playerid][mAward]);
				}

				GroupData[group_id][gCash] += MissionData[playerid][mAward];
				orm_update(GroupData[group_id][gOrm]);

				DeleteMission(MissionData[playerid][mUID]);
				
				mission_leader = giveplayer_id;
				foreach(new i : MissionPlayer[mission_leader])
				{
				    TD_ShowHint(i, HINT_NONE, 10, "Lider grupy wykonujacej zadanie zostal ~r~skuty~w~. Zadanie ~r~nie zostalo ~w~wykonanie prawidlowo.");
				}
				DeleteMission(MissionData[mission_leader][mUID]);
    		}
    	}
	}
	PlayerCache[giveplayer_id][pCuffedTo] = playerid;
	
	SetPlayerSpecialAction(giveplayer_id, SPECIAL_ACTION_CUFFED);
  	SetPlayerAttachedObject(giveplayer_id, SLOT_HANDCUFFS, 19418, 6, -0.011000, 0.028000, -0.022000, -15.600012, -33.699977, -81.700035, 0.891999, 1.000000, 1.168000);

	ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Skułeś gracza %s, aby rozkuć, użyj komendy /rozkuj.", PlayerName(giveplayer_id));
	return 1;
}

cmd:rozkuj(playerid, params[])
{
	new giveplayer_id;
	if(sscanf(params, "u", giveplayer_id))
	{
		ShowTipForPlayer(playerid, "/rozkuj [ID gracza]");
	    return 1;
	}
	if(giveplayer_id == playerid)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz rozkuć siebie.");
		return 1;
	}
	if(giveplayer_id == INVALID_PLAYER_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
    	return 1;
	}
	if(!PlayerCache[giveplayer_id][pLogged])
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
    	return 1;
	}
	if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
	{
 		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
 		return 1;
	}
	if(PlayerCache[giveplayer_id][pCuffedTo] != playerid)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz nie jest przykuty do Ciebie.");
	    return 1;
	}
	PlayerCache[giveplayer_id][pCuffedTo] = INVALID_PLAYER_ID;

	SetPlayerSpecialAction(giveplayer_id, SPECIAL_ACTION_NONE);
	RemovePlayerAttachedObject(giveplayer_id, SLOT_HANDCUFFS);

	ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Gracz %s został rozkuty.", PlayerName(giveplayer_id));
	return 1;
}

cmd:oferuj(playerid, params[])
{
	new type[32], varchar[64], string[256];
	if(sscanf(params, "s[32]S()[64]", type, varchar))
	{
	    new list_offers[512];
	    format(list_offers, sizeof(list_offers), "{C0C0C0}Podstawowe:{FFFFFF}");
	    
	    strcat(list_offers, "\n • przedmiot", sizeof(list_offers));
	    strcat(list_offers, "\n • pojazd", sizeof(list_offers));
	    strcat(list_offers, "\n • vcard", sizeof(list_offers));
	    strcat(list_offers, "\n • drzwi", sizeof(list_offers));
	    strcat(list_offers, "\n • holowanie", sizeof(list_offers));
	    
	    if(IsPlayerInAnyGroup(playerid))
	    {
	        format(list_offers, sizeof(list_offers), "%s\n \n{C0C0C0}Grupa:{FFFFFF}", list_offers);
	        
	        strcat(list_offers, "\n • produkt", sizeof(list_offers));
	        
	        if(IsPlayerInGroupType(playerid, G_TYPE_GYM))
	        {
                strcat(list_offers, "\n • karnet", sizeof(list_offers));
                strcat(list_offers, "\n • styl", sizeof(list_offers));
	        }
	        
	        if(IsPlayerInGroupType(playerid, G_TYPE_CARDEALER))
	        {
	            strcat(list_offers, "\n • salon", sizeof(list_offers));
	            strcat(list_offers, "\n • kluczyki", sizeof(list_offers));
	        }
	        
	        if(IsPlayerInGroupType(playerid, G_TYPE_TAXI))
	        {
	            strcat(list_offers, "\n • przejazd", sizeof(list_offers));
	        }
	        
	        if(IsPlayerInGroupType(playerid, G_TYPE_POLICE))
	        {
      			strcat(list_offers, "\n • mandat", sizeof(list_offers));
	            strcat(list_offers, "\n • odblokowanie", sizeof(list_offers));
	        }
	        
       		if(IsPlayerInGroupType(playerid, G_TYPE_GOV))
	     	{
    			strcat(list_offers, "\n • dokument", sizeof(list_offers));
	            strcat(list_offers, "\n • biznes", sizeof(list_offers));
	            
    			strcat(list_offers, "\n • rejestracje", sizeof(list_offers));
    			strcat(list_offers, "\n • podatek", sizeof(list_offers));
    			
    			strcat(list_offers, "\n • slub", sizeof(list_offers));
	     	}
	     	
	     	if(IsPlayerInGroupType(playerid, G_TYPE_MEDICAL) || IsPlayerInGroupType(playerid, G_TYPE_FIREDEPT))
	     	{
	     	    strcat(list_offers, "\n • leczenie", sizeof(list_offers));
	     	}
	     	
	     	if(IsPlayerInGroupType(playerid, G_TYPE_NEWS))
	     	{
           		strcat(list_offers, "\n • reklame", sizeof(list_offers));
	     	}
	     	
	     	if(IsPlayerInGroupType(playerid, G_TYPE_MOTORS))
	     	{
	     	    strcat(list_offers, "\n • paintjob", sizeof(list_offers));
	     	}
	     	
	     	if(IsPlayerInGroupType(playerid, G_TYPE_DRIVING))
	     	{
	     	    strcat(list_offers, "\n • lekcja", sizeof(list_offers));
	     	}
	    }
	    
	    if(WorkInfo[playerid][wID] != JOB_NONE)
	    {
	        format(list_offers, sizeof(list_offers), "%s\n \n{C0C0C0}Praca:{FFFFFF}", list_offers);
	        
	        if(WorkInfo[playerid][wID] == JOB_MECHANIC)
	        {
       			strcat(list_offers, "\n • tankowanie", sizeof(list_offers));
	       		strcat(list_offers, "\n • naprawe", sizeof(list_offers));

	         	strcat(list_offers, "\n • lakierowanie", sizeof(list_offers));
	          	strcat(list_offers, "\n • montaz", sizeof(list_offers));
	        }
	        
	        if(WorkInfo[playerid][wID] == JOB_SELLER)
	        {
	            strcat(list_offers, "\n • produkt", sizeof(list_offers));
	        }
	        
	        if(WorkInfo[playerid][wID] == JOB_NEWSPAPER)
	        {
	            strcat(list_offers, "\n • gazete", sizeof(list_offers));
	        }
		}
	    
	    ShowPlayerDialog(playerid, D_OFFER_LIST, DIALOG_STYLE_LIST, "Dostępne typy ofert:", list_offers, "Wybierz", "Anuluj");
	    return 1;
	}
	
	if(!strcmp(type, "przedmiot", true) || !strcmp(type, "item", true))
	{
 		new giveplayer_id, price, item_uid;
	    if(sscanf(varchar, "udd", giveplayer_id, item_uid, price))
	    {
	        ShowTipForPlayer(playerid, "/oferuj przedmiot [ID gracza] [UID przedmiotu] [Cena]");
	        return 1;
	    }
   		if(giveplayer_id == playerid)
    	{
     		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować czegoś sobie.");
       		return 1;
    	}
		if(giveplayer_id == INVALID_PLAYER_ID)
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	    	return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
	    	return 1;
		}
		if(PlayerCache[giveplayer_id][pBW])
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz ma BW.");
		    return 1;
		}
		new itemid = GetPlayerItemID(playerid, item_uid);
		if(itemid == INVALID_ITEM_ID)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID przedmiotu.");
		    return 1;
		}
		if(PlayerItemCache[playerid][itemid][iUsed])
  		{
  		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować tego przedmiotu.");
		    return 1;
		}
		if(price < 0)
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłową kwotę.");
	    	return 1;
		}
		OnPlayerSendOffer(playerid, giveplayer_id, PlayerItemCache[playerid][itemid][iName], OFFER_ITEM, PlayerItemCache[playerid][itemid][iUID], 0, price);
	    return 1;
	}
	
	if(!strcmp(type, "pojazd", true) || !strcmp(type, "vehicle", true))
	{
 		new giveplayer_id, price;
	    if(sscanf(varchar, "ud", giveplayer_id, price))
	    {
	        ShowTipForPlayer(playerid, "/oferuj pojazd [ID gracza] [Cena]");
	        return 1;
	    }
	    if(!IsPlayerInAnyVehicle(playerid))
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz siedzieć w pojeździe który chcesz sprzedać.");
	        return 1;
	    }
		new vehid = GetPlayerVehicleID(playerid);
		if(CarInfo[vehid][cOwnerType] != OWNER_PLAYER || CarInfo[vehid][cOwner] != PlayerCache[playerid][pUID])
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten pojazd nie należy do Ciebie.");
		    return 1;
		}
   		if(giveplayer_id == playerid)
    	{
     		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować czegoś sobie.");
       		return 1;
    	}
		if(giveplayer_id == INVALID_PLAYER_ID)
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	    	return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
	    	return 1;
		}
		if(PlayerCache[giveplayer_id][pBW])
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz ma BW.");
		    return 1;
		}
		if(price < 0)
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłową kwotę.");
  			return 1;
		}
		OnPlayerSendOffer(playerid, giveplayer_id, GetVehicleName(CarInfo[vehid][cModel]), OFFER_VEHICLE, vehid, 0, price);
	    return 1;
	}
	
	if(!strcmp(type, "produkt", true) || !strcmp(type, "product", true))
	{
		if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID && WorkInfo[playerid][wID] != JOB_SELLER)
  	    {
  	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz być na służbie grupy lub posiadać pracę dorywczą sprzedawcy, by móc coś zaoferować.");
  	        return 1;
  	    }
		if(PlayerCache[playerid][pDuty][DUTY_GROUP] != INVALID_GROUP_ID && !HavePlayerGroupPerm(playerid, GroupData[PlayerCache[playerid][pDuty][DUTY_GROUP]][gUID], G_PERM_OFFER))
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz oferować produktów.");
			return 1;
		}
	    new giveplayer_id;
	    if(sscanf(varchar, "u", giveplayer_id))
	    {
			ShowTipForPlayer(playerid, "/oferuj produkt [ID gracza]");
	        return 1;
	    }
   		/*if(giveplayer_id == playerid)
    	{
     		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować czegoś sobie.");
       		return 1;
    	}*/
		if(giveplayer_id == INVALID_PLAYER_ID)
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	    	return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
	    	return 1;
		}
		if(PlayerCache[giveplayer_id][pBW])
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz ma BW.");
		    return 1;
		}
		
		new doorid = GetPlayerDoorID(playerid), product_owner;
		
		if(doorid != INVALID_DOOR_ID)
		{
			new DoorData[sDoorInfo];
			Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);

			if(DoorData[dOwnerType] != OWNER_GROUP)
			{
                ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować produktu z magazynu w tym miejscu.");
			    return 1;
			}

			if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
  			{
				ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować produktu z magazynu w tym miejscu.");
				return 1;
	    	}

			new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
			if(DoorData[dOwner] != GroupData[group_id][gUID])
			{
                ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować produktu z magazynu w tym miejscu.");
			    return 1;
			}

			product_owner = DoorData[dOwner];
		}
		else
		{
		    new areaid = GetPlayerAreaID(playerid);
		    if(areaid != INVALID_AREA_ID)
		    {
  				if(WorkInfo[playerid][wID] == JOB_SELLER)
				{
				    goto work_seller;
				}
				
		        new AreaData[sAreaData];
		        Streamer_GetArrayData(STREAMER_TYPE_AREA, areaid, E_STREAMER_EXTRA_ID, AreaData);
		        
		        if(AreaData[aOwnerType] != OWNER_GROUP)
		        {
		            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować produktu z magazynu w tym miejscu.");
					return 1;
		        }
		        
		   		if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
		    	{
       				ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować produktu z magazynu w tym miejscu.");
       				return 1;
			    }
		        
		        new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
 				if(AreaData[aOwner] != GroupData[group_id][gUID])
	  			{
					ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować produktu z magazynu w tym miejscu.");
					return 1;
				}
				

				product_owner = AreaData[aOwner];

		    }
		    else
			{
				if(IsPlayerInAnyVehicle(playerid))
				{
				    new vehid = GetPlayerVehicleID(playerid);
				    if(CarInfo[vehid][cOwnerType] != OWNER_GROUP)
				    {
				        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować produktu z magazynu w tym miejscu.");
						return 1;
				    }
				    
				    if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
				    {
				        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować produktu z magazynu w tym miejscu.");
				        return 1;
				    }
				    
				    new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
				    if(CarInfo[vehid][cOwner] != GroupData[group_id][gUID])
				    {
				        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować produktu z magazynu w tym miejscu.");
				        return 1;
				    }
					if(GroupData[group_id][gType] != G_TYPE_BAR)
					{
					    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować produktu z magazynu w tym miejscu.");
					    return 1;
					}
				
				    product_owner = CarInfo[vehid][cOwner];
				}
				else
				{
				    work_seller:
				    
				    new object_id = GetClosestObjectType(playerid, OBJECT_FOOD_BOX);
				    if(object_id == INVALID_OBJECT_ID)
				    {
				        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować produktu z magazynu w tym miejscu.");
				        return 1;
				    }
				    
        			if(WorkInfo[playerid][wID] != JOB_SELLER)
		            {
		                ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz pracy dorywczej jako sprzedawca.");
		                return 1;
		            }
		            new Float:PosX, Float:PosY, Float:PosZ,
		                virtual_world = GetPlayerVirtualWorld(playerid);

		            GetPlayerPos(playerid, PosX, PosY, PosZ);

           			new NearDoor[MAX_VIS_DOORS], DoorData[sDoorInfo], group_id,
						count_doors = Streamer_GetNearbyItems(PosX, PosY, PosZ, STREAMER_TYPE_PICKUP, NearDoor, MAX_VIS_DOORS, 250.0, virtual_world);

					if(count_doors > 0)
					{
						for (new door = 0; door < count_doors; door++)
						{
							Streamer_GetArrayData(STREAMER_TYPE_PICKUP, NearDoor[door], E_STREAMER_EXTRA_ID, DoorData);
							group_id = GetGroupID(DoorData[dOwner]);

							if(GroupData[group_id][gType] == G_TYPE_BAR)
							{
							    product_owner = DoorData[dOwner];
							    break;
							}
						}
					}
					if(product_owner <= 0)
					{
					    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znaleziono żadnych produktów w magazynie.");
					    return 1;
					}
				}
		    }
		}
		PlayerCache[playerid][pMainTable] = giveplayer_id;
		new group_id = GetGroupID(product_owner);
		
		ListGroupProductsForPlayer(group_id, playerid, PRODUCT_LIST_OFFER);
	    return 1;
	}
	
	if(!strcmp(type, "vcard", true))
	{
 		if(!PlayerCache[playerid][pPhoneNumber])
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby móc wysłać vCard musisz mieć włączony telefon.");
	        return 1;
	    }
	    new giveplayer_id;
	    if(sscanf(varchar, "u", giveplayer_id))
	    {
	        ShowTipForPlayer(playerid, "/oferuj vcard [ID gracza]");
	        return 1;
	    }
   		if(giveplayer_id == playerid)
    	{
     		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować czegoś sobie.");
       		return 1;
    	}
		if(giveplayer_id == INVALID_PLAYER_ID)
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	    	return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
	    	return 1;
		}
  		if(!PlayerCache[giveplayer_id][pPhoneNumber])
    	{
     		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz nie posiada telefonu w użyciu.");
       		return 1;
    	}
		if(PlayerCache[giveplayer_id][pBW])
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz ma BW.");
		    return 1;
		}
     	OnPlayerSendOffer(playerid, giveplayer_id, "vCard", OFFER_VCARD, PlayerCache[playerid][pPhoneNumber], 0, 0);
	    return 1;
	}
	
	if(!strcmp(type, "drzwi", true))
	{
	    new giveplayer_id, price, doorid = GetPlayerDoorID(playerid);
	    if(sscanf(varchar, "ud", giveplayer_id, price))
	    {
	        ShowTipForPlayer(playerid, "/oferuj drzwi [ID gracza] [Cena]");
	        return 1;
	    }
		if(doorid == INVALID_DOOR_ID)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w budynku, który zamierzasz sprzedać.");
		    return 1;
		}
		new DoorData[sDoorInfo];
		Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
		
		if(DoorData[dOwnerType] != OWNER_PLAYER || DoorData[dOwner] != PlayerCache[playerid][pUID])
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie jesteś właścicielem tego budynku.");
		    return 1;
		}
   		if(giveplayer_id == playerid)
    	{
     		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować czegoś sobie.");
       		return 1;
    	}
		if(giveplayer_id == INVALID_PLAYER_ID)
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	    	return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
	    	return 1;
		}
		if(PlayerCache[giveplayer_id][pBW])
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz ma BW.");
		    return 1;
		}
		if(price < 0)
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłową kwotę.");
  			return 1;
		}
		OnPlayerSendOffer(playerid, giveplayer_id, DoorData[dName], OFFER_DOOR, doorid, 0, price);
	    return 1;
	}
	
	if(!strcmp(type, "holowanie", true))
	{
 		new giveplayer_id, price;
	    if(sscanf(varchar, "ud", giveplayer_id, price))
	    {
	        ShowTipForPlayer(playerid, "/oferuj holowanie [ID gracza] [Cena]");
	        return 1;
	    }
   		if(giveplayer_id == playerid)
    	{
     		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować czegoś sobie.");
       		return 1;
    	}
		if(giveplayer_id == INVALID_PLAYER_ID)
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	    	return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(!PlayerToPlayer(10.0, playerid, giveplayer_id))
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
	    	return 1;
		}
		if(!IsPlayerInAnyVehicle(playerid))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz siedzieć w pojeździe, by móc zaoferować holowanie.");
		    return 1;
		}
		if(!IsPlayerInAnyVehicle(giveplayer_id))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz musi siedzieć w pojeździe, by móc zaoferować holowanie.");
		    return 1;
		}
		if(GetPlayerState(giveplayer_id) != PLAYER_STATE_PASSENGER)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz musi siedzieć w pojeździe jako pasażer.", "Okej", "");
		    return 1;
		}
		new vehid = GetPlayerVehicleID(playerid);
		if(IsTrailerAttachedToVehicle(vehid))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Holujesz już aktualnie jakiś pojazd.");
		    return 1;
		}
		if(price < 0)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędną kwotę.");
		    return 1;
		}
		
		if(GetVehicleModel(vehid) == 525 || HavePlayerItemType(playerid, ITEM_LINE))
		{
			OnPlayerSendOffer(playerid, giveplayer_id, "Holowanie", OFFER_TOWING, vehid, GetPlayerVehicleID(giveplayer_id), price);
		}
		else
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz posiadać linę holowniczą, bądź siedzieć w holowniku.");
		}
	    return 1;
	}
	
	if(!strcmp(type, "przejazd", true))
	{
		if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
  	    {
  	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz być na służbie grupy, by móc coś oferować.");
  	        return 1;
  	    }
		new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
		if(GroupData[group_id][gType] != G_TYPE_TAXI || !HavePlayerGroupPerm(playerid, GroupData[group_id][gUID], G_PERM_OFFER))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz niczego oferować.");
		    return 1;
		}
	    new giveplayer_id, price;
	    if(sscanf(varchar, "ud", giveplayer_id, price))
	    {
			ShowTipForPlayer(playerid, "/oferuj przejazd [ID gracza] [Koszt/100m]");
	        return 1;
	    }
	    if(PlayerCache[playerid][pTaxiPassenger] != INVALID_PLAYER_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować przejażdżki drugiej osobie.");
	        return 1;
	    }
	    if(!IsPlayerInAnyVehicle(playerid) || GetPlayerState(playerid) != PLAYER_STATE_DRIVER)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz siedzieć w pojeździe firmowym jako kierowca, aby móc zaoferować przejazd.");
	        return 1;
	    }
		new vehid = GetPlayerVehicleID(playerid);
		if(CarInfo[vehid][cOwnerType] != OWNER_GROUP || CarInfo[vehid][cOwner] != GroupData[group_id][gUID])
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz siedzieć w pojeździe firmowym jako kierowca, aby móc zaoferować przejazd.");
		    return 1;
		}
   		if(giveplayer_id == playerid)
    	{
     		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować czegoś sobie.");
       		return 1;
    	}
		if(giveplayer_id == INVALID_PLAYER_ID)
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	    	return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
	    	return 1;
		}
		if(GetPlayerState(giveplayer_id) != PLAYER_STATE_PASSENGER || GetPlayerVehicleID(giveplayer_id) != vehid)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz musi siedzieć w Twoim pojeździe jako pasażer.");
		    return 1;
		}
		if(price <= 0 || price > 15)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nieprawidłowa kwota.");
		    return 1;
		}
		format(string, sizeof(string), "Kurs ($%d/100m)", price);
		OnPlayerSendOffer(playerid, giveplayer_id, string, OFFER_PASSAGE, vehid, 0, price);
	    return 1;
	}
	
	if(!strcmp(type, "tankowanie", true) || !strcmp(type, "refuel", true))
	{
	    if(WorkInfo[playerid][wID] != JOB_MECHANIC)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz pracy mechanika, jako dorywczej.");
	        return 1;
	    }
   		new object_id = GetClosestObjectType(playerid, OBJECT_FUELING);
		if(object_id == INVALID_OBJECT_ID)
		{
	 		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znaleziono żadnego dystrybutora w pobliżu.");
	   		return 1;
		}
	    new giveplayer_id, bens_type, fuel_value;
	    if(sscanf(varchar, "udd", giveplayer_id, bens_type, fuel_value))
	    {
	        ShowTipForPlayer(playerid, "/oferuj tankowanie [ID gracza] [Rodzaj paliwa] [Ilość litrów]");
	        
	        SendClientMessage(playerid, COLOR_GREY, " ");
            SendClientMessage(playerid, COLOR_GREY, "Dostępne rodzaje paliwa:");
            
	        SendClientMessage(playerid, COLOR_GREY, "1 - Benzyna");
	        SendClientMessage(playerid, COLOR_GREY, "2 - Gaz");
	        SendClientMessage(playerid, COLOR_GREY, "3 - Diesel");
	        return 1;
	    }
   		if(giveplayer_id == playerid)
    	{
     		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować czegoś sobie.");
       		return 1;
    	}
   		if(giveplayer_id == INVALID_PLAYER_ID)
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	    	return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
	    	return 1;
		}
		if(PlayerCache[giveplayer_id][pBW])
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz ma BW.");
		    return 1;
		}
		if(!IsPlayerInAnyVehicle(giveplayer_id))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz musi siedzieć w pojeździe, który zamierzasz zatankować.");
		    return 1;
		}
		if(bens_type < 0 || bens_type > 3)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wybrano nieprawidłowy rodzaj paliwa.");
		    return 1;
		}
		new vehid = GetPlayerVehicleID(giveplayer_id);
		if((bens_type - 1) != CarInfo[vehid][cFuelType])
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wybrany rodzaj paliwa nie pasuje do tego pojazdu.");
		    return 1;
		}
		if(fuel_value < 0)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłową ilość litrów.");
		    return 1;
		}
		if(fuel_value + CarInfo[vehid][cFuel] > GetVehicleMaxFuel(CarInfo[vehid][cModel]))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "W baku nie zmieści się tyle paliwa.");
		    return 1;
		}
		new price;
		bens_type -= 1;

		if(bens_type == FUEL_TYPE_BENS) 			price = floatround(fuel_value * 3.5);
		else if(bens_type == FUEL_TYPE_GAS) 		price = floatround(fuel_value * 2.0);
		else if(bens_type == FUEL_TYPE_DIESEL) 		price = floatround(fuel_value * 3.0);

		format(string, sizeof(string), "%s (%dL)", FuelTypeName[bens_type], fuel_value);
		OnPlayerSendOffer(playerid, giveplayer_id, string, OFFER_REFUEL, CarInfo[vehid][cUID], fuel_value, price);
	    return 1;
	}
	
	if(!strcmp(type, "naprawe", true) || !strcmp(type, "repair", true))
	{
		if(WorkInfo[playerid][wID] != JOB_MECHANIC && !IsPlayerInGroupType(playerid, G_TYPE_WORKSHOP))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz pracy dorywczej mechanika, lub nie pracujesz w warsztacie.");
		    return 1;
		}
		new doorid = GetPlayerDoorID(playerid);
		if(doorid != INVALID_DOOR_ID)
		{
		    new DoorData[sDoorInfo];
		    Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
		    
		    if(DoorData[dOwnerType] == OWNER_NONE || DoorData[dOwnerType] == OWNER_PLAYER)
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Naprawiać pojazdy możesz tylko w budynku warsztatu lub strefie z flagą serwisu.");
		        return 1;
		    }
		    if(DoorData[dOwnerType] == OWNER_GROUP)
		    {
		        if(!IsPlayerInGroup(playerid, DoorData[dOwner]))
		        {
		            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Naprawiać pojazdy możesz tylko w budynku warsztatu lub strefie z flagą serwisu.");
		            return 1;
		        }
		    }
		}
		else
		{
			new areaid = GetPlayerAreaID(playerid);
			if(areaid == INVALID_AREA_ID)
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Naprawiać pojazdy możesz tylko w budynku warsztatu lub strefie z flagą serwisu.");
			    return 1;
			}
			new AreaData[sAreaData];
			Streamer_GetArrayData(STREAMER_TYPE_AREA, areaid, E_STREAMER_EXTRA_ID, AreaData);
			
			if(AreaData[aOwnerType] == OWNER_NONE || AreaData[aOwnerType] == OWNER_PLAYER)
			{
			    if(WorkInfo[playerid][wID] != JOB_MECHANIC)
			    {
			        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Naprawiać pojazdy możesz tylko w budynku warsztatu lub strefie z flagą serwisu.");
			        return 1;
			    }
			}
			if(AreaData[aOwnerType] == OWNER_GROUP)
			{
				if(!IsPlayerInGroup(playerid, AreaData[aOwner]))
				{
				    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Naprawiać pojazdy możesz tylko w budynku warsztatu lub strefie z flagą serwisu.");
				    return 1;
				}
			}
			if(!(AreaData[aFlags] & A_FLAG_SERVICE))
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Naprawiać pojazdy możesz tylko w budynku warsztatu lub strefie z flagą serwisu.");
			    return 1;
			}
		}
	    new giveplayer_id;
	    if(sscanf(varchar, "u", giveplayer_id))
	    {
	        ShowTipForPlayer(playerid, "/oferuj naprawe [ID gracza]");
	        return 1;
	    }
	    if(PlayerCache[playerid][pRepairVeh] != INVALID_VEHICLE_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Obecnie jesteś już w trakcie naprawiania innego pojazdu.");
	        return 1;
	    }
   		if(giveplayer_id == playerid)
    	{
     		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować czegoś sobie.");
       		return 1;
    	}
   		if(giveplayer_id == INVALID_PLAYER_ID)
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	    	return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
	    	return 1;
		}
		if(!IsPlayerInAnyVehicle(giveplayer_id))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz musi siedzieć w pojeździe, który zamierzasz naprawiać.");
		    return 1;
		}
		if(PlayerCache[giveplayer_id][pBW])
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz ma BW.");
		    return 1;
		}
		new vehid = GetPlayerVehicleID(giveplayer_id),
			price = 1000 - floatround(CarInfo[vehid][cHealth], floatround_ceil);

 		if(price < 0)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wysokość kwoty za naprawę pojazdu jest nieprawidłowa.");
		    return 1;
		}
		OnPlayerSendOffer(playerid, giveplayer_id, "Naprawa", OFFER_REPAIR, CarInfo[vehid][cUID], 0, price);
	    return 1;
	}
	
	if(!strcmp(type, "lakierowanie", true) || !strcmp(type, "painting", true))
	{
		if(WorkInfo[playerid][wID] != JOB_MECHANIC && !IsPlayerInGroupType(playerid, G_TYPE_WORKSHOP))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz pracy dorywczej mechanika, lub nie pracujesz w warsztacie.");
		    return 1;
		}
		new doorid = GetPlayerDoorID(playerid);
		if(doorid != INVALID_DOOR_ID)
		{
		    new DoorData[sDoorInfo];
		    Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);

		    if(DoorData[dOwnerType] == OWNER_NONE || DoorData[dOwnerType] == OWNER_PLAYER)
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Lakierować pojazdy możesz tylko w budynku warsztatu lub strefie z flagą serwisu.");
		        return 1;
		    }
		    if(DoorData[dOwnerType] == OWNER_GROUP)
		    {
		        if(!IsPlayerInGroup(playerid, DoorData[dOwner]))
		        {
		            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Lakierować pojazdy możesz tylko w budynku warsztatu lub strefie z flagą serwisu.");
		            return 1;
		        }
		    }
		}
		else
		{
			new areaid = GetPlayerAreaID(playerid);
			if(areaid == INVALID_AREA_ID)
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Lakierować pojazdy możesz tylko w budynku warsztatu lub strefie z flagą serwisu.");
			    return 1;
			}
			new AreaData[sAreaData];
			Streamer_GetArrayData(STREAMER_TYPE_AREA, areaid, E_STREAMER_EXTRA_ID, AreaData);

			if(AreaData[aOwnerType] == OWNER_NONE || AreaData[aOwnerType] == OWNER_PLAYER)
			{
			    if(WorkInfo[playerid][wID] != JOB_MECHANIC)
			    {
			        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Lakierować pojazdy możesz tylko w budynku warsztatu lub strefie z flagą serwisu.");
			        return 1;
			    }
			}
			if(AreaData[aOwnerType] == OWNER_GROUP)
			{
				if(!IsPlayerInGroup(playerid, AreaData[aOwner]))
				{
				    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Lakierować pojazdy możesz tylko w budynku warsztatu lub strefie z flagą serwisu.");
				    return 1;
				}
			}
			if(!(AreaData[aFlags] & A_FLAG_SERVICE))
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Lakierować pojazdy możesz tylko w budynku warsztatu lub strefie z flagą serwisu.");
			    return 1;
			}
		}
	    new giveplayer_id, color1, color2, price;
	    if(sscanf(varchar, "uddd", giveplayer_id, color1, color2, price))
	    {
	        ShowTipForPlayer(playerid, "/oferuj lakierowanie [ID gracza] [Kolor 1] [Kolor 2] [Robocizna]");
	        return 1;
	    }
	    if(PlayerCache[playerid][pSprayVeh] != INVALID_VEHICLE_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Obecnie jesteś już w trakcie lakierowania innego pojazdu.");
	        return 1;
	    }
   		if(giveplayer_id == playerid)
    	{
     		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować czegoś sobie.");
       		return 1;
		}
   		if(giveplayer_id == INVALID_PLAYER_ID)
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	    	return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
	    	return 1;
		}
		if(PlayerCache[giveplayer_id][pBW])
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz ma BW.");
		    return 1;
		}
		if(!IsPlayerInAnyVehicle(giveplayer_id))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz musi siedzieć w pojeździe, który zamierzasz przelakierować.");
		    return 1;
		}
 		if(color1 < 0 || color1 > 255 || color2 < 0 || color2 > 255)
		{
       		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "ID koloru nie może być mniejsze niż 0 a także większe niż 255.");
         	return 1;
       	}
		if(price < 0)
		{
		   	ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłową kwotę.");
		    return 1;
		}
		if(PlayerCache[playerid][pItemWeapon] == INVALID_ITEM_ID)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz mieć lakier w użyciu.");
		    return 1;
		}
		new itemid = PlayerCache[playerid][pItemWeapon];
		if(PlayerItemCache[playerid][itemid][iType] != ITEM_PAINT)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz mieć lakier w użyciu.");
		    return 1;
		}
		
		format(string, sizeof(string), "Kolory (%d/%d)", color1, color2);
		OnPlayerSendOffer(playerid, giveplayer_id, string, OFFER_PAINT, color1, color2, price);
	    return 1;
	}
	
	if(!strcmp(type, "paintjob", true))
	{
		if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
  	    {
  	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz być na służbie grupy, by móc coś oferować.");
  	        return 1;
  	    }
		new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
		if(GroupData[group_id][gType] != G_TYPE_MOTORS || !HavePlayerGroupPerm(playerid, GroupData[group_id][gUID], G_PERM_OFFER))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz niczego oferować.");
		    return 1;
		}
  		new giveplayer_id, paintjob_id, price;
	    if(sscanf(varchar, "udd", giveplayer_id, paintjob_id, price))
	    {
	        ShowTipForPlayer(playerid, "/oferuj paintjob [ID gracza] [PaintJob ID] [Robocizna]");
	        return 1;
	    }
	    if(PlayerCache[playerid][pSprayVeh] != INVALID_VEHICLE_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Obecnie jesteś już w trakcie lakierowania innego pojazdu.");
	        return 1;
	    }
   		if(giveplayer_id == playerid)
    	{
     		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować czegoś sobie.");
       		return 1;
		}
   		if(giveplayer_id == INVALID_PLAYER_ID)
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	    	return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
	    	return 1;
		}
		if(PlayerCache[giveplayer_id][pBW])
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz ma BW.");
		    return 1;
		}
		if(!IsPlayerInAnyVehicle(giveplayer_id))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz musi siedzieć w pojeździe, który zamierzasz przelakierować.");
		    return 1;
		}
 		if(paintjob_id < 0 || paintjob_id > 3)
		{
       		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "PaintJob ID nie może być mniejsze niż 0 oraz większe od 3.");
         	return 1;
       	}
		if(price < 0)
		{
		   	ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłową kwotę.");
		    return 1;
		}
		if(PlayerCache[playerid][pItemWeapon] == INVALID_ITEM_ID)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz mieć lakier w użyciu.");
		    return 1;
		}
		new itemid = PlayerCache[playerid][pItemWeapon];
		if(PlayerItemCache[playerid][itemid][iType] != ITEM_PAINT)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz mieć lakier w użyciu.");
		    return 1;
		}
		
		format(string, sizeof(string), "PaintJob ID: %d", paintjob_id);
		OnPlayerSendOffer(playerid, giveplayer_id, string, OFFER_PAINTJOB, paintjob_id, 0, price);
	    return 1;
	}
	
	if(!strcmp(type, "montaz", true))
	{
		if(WorkInfo[playerid][wID] != JOB_MECHANIC && !IsPlayerInGroupType(playerid, G_TYPE_WORKSHOP))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz pracy dorywczej mechanika, lub nie pracujesz w warsztacie.");
		    return 1;
		}
		new doorid = GetPlayerDoorID(playerid);
		if(doorid != INVALID_DOOR_ID)
		{
		    new DoorData[sDoorInfo];
		    Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);

		    if(DoorData[dOwnerType] == OWNER_NONE || DoorData[dOwnerType] == OWNER_PLAYER)
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Montować części w pojazdach możesz tylko w budynku warsztatu lub strefie z flagą serwisu.");
		        return 1;
		    }
		    if(DoorData[dOwnerType] == OWNER_GROUP)
		    {
		        if(!IsPlayerInGroup(playerid, DoorData[dOwner]))
		        {
		            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Montować części w pojazdach możesz tylko w budynku warsztatu lub strefie z flagą serwisu.");
		            return 1;
		        }
		    }
		}
		else
		{
			new areaid = GetPlayerAreaID(playerid);
			if(areaid == INVALID_AREA_ID)
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Montować części w pojazdach możesz tylko w budynku warsztatu lub strefie z flagą serwisu.");
			    return 1;
			}
			new AreaData[sAreaData];
			Streamer_GetArrayData(STREAMER_TYPE_AREA, areaid, E_STREAMER_EXTRA_ID, AreaData);

			if(AreaData[aOwnerType] == OWNER_NONE || AreaData[aOwnerType] == OWNER_PLAYER)
			{
			    if(WorkInfo[playerid][wID] != JOB_MECHANIC)
			    {
			        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Lakierować pojazdy możesz tylko w budynku warsztatu lub strefie z flagą naprawiania.");
			        return 1;
			    }
			}
			if(AreaData[aOwnerType] == OWNER_GROUP)
			{
				if(!IsPlayerInGroup(playerid, AreaData[aOwner]))
				{
				    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Montować części w pojazdach możesz tylko w budynku warsztatu lub strefie z flagą serwisu.");
				    return 1;
				}
			}
			if(!(AreaData[aFlags] & A_FLAG_SERVICE))
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Montować części w pojazdach możesz tylko w budynku warsztatu lub strefie z flagą serwisu.");
			    return 1;
			}
		}
	    new item_uid, giveplayer_id, price;
	    if(sscanf(varchar, "dud", item_uid, giveplayer_id, price))
	    {
	        ShowTipForPlayer(playerid, "/oferuj montaz [UID przedmiotu] [ID gracza] [Robocizna]");
	        return 1;
	    }
   		new itemid = GetPlayerItemID(playerid, item_uid);
   		if(itemid == INVALID_ITEM_ID)
   		{
   		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID przedmiotu.");
   		    return 1;
   		}
		if(PlayerItemCache[playerid][itemid][iType] != ITEM_TUNING && PlayerItemCache[playerid][itemid][iType] != ITEM_VEH_ACCESS)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zamontować tego przedmiotu.");
		    return 1;
		}
   		if(giveplayer_id == playerid)
    	{
     		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować czegoś sobie.");
       		return 1;
    	}
		if(giveplayer_id == INVALID_PLAYER_ID)
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	    	return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
	    	return 1;
		}
		if(PlayerCache[giveplayer_id][pBW])
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz ma BW.");
		    return 1;
		}
		if(!IsPlayerInAnyVehicle(giveplayer_id))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz musi siedzieć w pojeździe, w którym zamierzasz coś zamontować.");
		    return 1;
		}
		new vehid = GetPlayerVehicleID(giveplayer_id);
		if(CarInfo[vehid][cModel] == 604 || CarInfo[vehid][cModel] == 605)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie można nic zamontować w tym pojeździe.");
		    return 1;
		}
		if(PlayerItemCache[playerid][itemid][iType] == ITEM_TUNING)
		{
			new slot = GetVehicleComponentType(PlayerItemCache[playerid][itemid][iValue][0]);
			if(CarInfo[vehid][cComponent][slot] != 0)
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Jakiś komponent tego typu jest już zamontowany.\nMusi zostać on odmontowany.");
			    return 1;
			}
		}
		if(PlayerItemCache[playerid][itemid][iType] == ITEM_VEH_ACCESS)
		{
		    if(CarInfo[vehid][cAccess] & PlayerItemCache[playerid][itemid][iValue][0])
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "W tym pojeździe jest już zamontowane to akcesorie.");
		        return 1;
		    }
		}
		if(price < 0)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędną kwotę.");
  			return 1;
		}
		
		format(string, sizeof(string), "%s (%d)", PlayerItemCache[playerid][itemid][iName], PlayerItemCache[playerid][itemid][iUID]);
		OnPlayerSendOffer(playerid, giveplayer_id, string, OFFER_MONTAGE, CarInfo[vehid][cUID], PlayerItemCache[playerid][itemid][iUID], price);
	    return 1;
	}
	
	if(!strcmp(type, "mandat", true) || !strcmp(type, "mandate", true))
	{
		if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
  	    {
  	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz być na służbie grupy, by móc coś oferować.");
  	        return 1;
  	    }
		new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
		if(GroupData[group_id][gType] != G_TYPE_POLICE || !HavePlayerGroupPerm(playerid, GroupData[group_id][gUID], G_PERM_OFFER))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz niczego oferować.");
		    return 1;
		}
	    new giveplayer_id, points, price, reason[32];
	    if(sscanf(varchar, "udds[32]", giveplayer_id, points, price, reason))
	    {
	        ShowTipForPlayer(playerid, "/oferuj mandat [ID gracza] [PKT. Karne] [Cena] [Powód]");
	        return 1;
	    }
   		if(giveplayer_id == playerid)
    	{
     		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować czegoś sobie.");
       		return 1;
    	}
   		if(giveplayer_id == INVALID_PLAYER_ID)
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	    	return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
	    	return 1;
		}
		if(PlayerCache[giveplayer_id][pBW])
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz ma BW.");
		    return 1;
		}
		if(points < 0)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłową ilość punktów karnych.");
		    return 1;
		}
		if(price < 0)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłową kwotę za mandat.");
		    return 1;
		}
		OnPlayerSendOffer(playerid, giveplayer_id, reason, OFFER_MANDATE, points, 0, price);
	    return 1;
	}
	
	if(!strcmp(type, "odblokowanie", true) || !strcmp(type, "unblock", true))
	{
		if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
  	    {
  	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz być na służbie grupy, by móc coś oferować.");
  	        return 1;
  	    }
		new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
		if(GroupData[group_id][gType] != G_TYPE_POLICE || !HavePlayerGroupPerm(playerid, GroupData[group_id][gUID], G_PERM_OFFER))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz niczego oferować.");
		    return 1;
		}
	    new giveplayer_id, veh_uid;
	    if(sscanf(varchar, "ud", giveplayer_id, veh_uid))
	    {
	        ShowTipForPlayer(playerid, "/oferuj odblokowanie [ID gracza] [UID pojazdu]");
	        return 1;
	    }
   		if(giveplayer_id == playerid)
    	{
     		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować czegoś sobie.");
       		return 1;
    	}
   		if(giveplayer_id == INVALID_PLAYER_ID)
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	    	return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
	    	return 1;
		}
		new vehid = GetVehicleID(veh_uid);
		if(vehid == INVALID_VEHICLE_ID)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne UID pojazdu.");
		    return 1;
		}
		if(!CarInfo[vehid][cBlockWheel])
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten pojazd nie ma założonej blokady na koło.");
		    return 1;
		}
		format(string, sizeof(string), "Zdjecie blokady pojazdu (UID: %d)", CarInfo[vehid][cUID]);
		OnPlayerSendOffer(playerid, giveplayer_id, string, OFFER_UNBLOCK, vehid, 0, CarInfo[vehid][cBlockWheel]);
		return 1;
	}
	
	if(!strcmp(type, "dokument", true) || !strcmp(type, "document", true))
	{
		if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
  	    {
  	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz być na służbie grupy, by móc coś oferować.");
  	        return 1;
  	    }
  	 	new doorid = GetPlayerDoorID(playerid);
	  	if(doorid == INVALID_DOOR_ID)
	  	{
        	ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w budynku grupy, by móc oferować.");
	  	    return 1;
	  	}
		new DoorData[sDoorInfo];
	  	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	  	
	  	if(DoorData[dOwnerType] != OWNER_GROUP || DoorData[dOwner] != GroupData[PlayerCache[playerid][pDuty][DUTY_GROUP]][gUID])
	  	{
            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w budynku grupy, by móc oferować.");
	  	    return 1;
	  	}
	    new document_type[24], giveplayer_id;
	    if(sscanf(varchar, "us[24]", giveplayer_id, document_type))
	    {
	       	ShowTipForPlayer(playerid, "/oferuj dokument [ID gracza] [Typ dokumentu (dowod, prawko, metryczka, poczytalnosc)]");
	        return 1;
	    }
   		if(giveplayer_id == playerid)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować czegoś sobie.");
			return 1;
		}
		if(giveplayer_id == INVALID_PLAYER_ID)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
 			return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
  			return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
			return 1;
		}
		new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
		if(!strcmp(document_type, "dowod", true))
		{
			if(GroupData[group_id][gType] != G_TYPE_GOV || !HavePlayerGroupPerm(playerid, GroupData[group_id][gUID], G_PERM_OFFER))
			{
		        ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz wyrobić tego dokumentu.");
		        return 1;
		    }
		    if(PlayerCache[giveplayer_id][pDocuments] & DOC_PROOF)
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz posiada już dowód osobisty.");
		        return 1;
		    }
		    OnPlayerSendOffer(playerid, giveplayer_id, "Dowod osobisty", OFFER_DOCUMENT, DOC_PROOF, 0, 80);
		    return 1;
		}
		if(!strcmp(document_type, "prawko", true))
		{
			if(GroupData[group_id][gType] != G_TYPE_GOV || !HavePlayerGroupPerm(playerid, GroupData[group_id][gUID], G_PERM_OFFER))
			{
		        ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz wyrobić tego dokumentu.");
		        return 1;
		    }
  			if(PlayerCache[giveplayer_id][pDocuments] & DOC_DRIVER)
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz posiada już prawo jazdy.");
		        return 1;
		    }
		    if(PlayerCache[giveplayer_id][pMileage] < 15.0)
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz nie potrafi prowadzić pojazdu (ma przejechane mniej niż 15km).");
		        return 1;
		    }
		    OnPlayerSendOffer(playerid, giveplayer_id, "Prawo jazdy", OFFER_DOCUMENT, DOC_DRIVER, 0, 350);
		    return 1;
		}
		if(!strcmp(document_type, "metryczka", true))
		{
			if(GroupData[group_id][gType] != G_TYPE_MEDICAL || !HavePlayerGroupPerm(playerid, GroupData[group_id][gUID], G_PERM_OFFER))
			{
		        ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz wyrobić tego dokumentu.");
		        return 1;
		    }
   			if(PlayerCache[giveplayer_id][pDocuments] & DOC_SEND)
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz posiada już metryczkę zdrowia.");
		        return 1;
		    }
		    OnPlayerSendOffer(playerid, giveplayer_id, "Metryczka zdrowia", OFFER_DOCUMENT, DOC_SEND, 0, 250);
		    return 1;
		}
		if(!strcmp(document_type, "poczytalnosc", true))
		{
			if(GroupData[group_id][gType] != G_TYPE_MEDICAL || !HavePlayerGroupPerm(playerid, GroupData[group_id][gUID], G_PERM_OFFER))
			{
		        ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz wyrobić tego dokumentu.");
		        return 1;
		    }
   			if(PlayerCache[giveplayer_id][pDocuments] & DOC_SANITY)
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz posiada już zaświadczenie o poczytalności.");
		        return 1;
		    }
		    OnPlayerSendOffer(playerid, giveplayer_id, "Zaswiadczenie - poczytalnosc", OFFER_DOCUMENT, DOC_SANITY, 0, 250);
		    return 1;
		}
	    return 1;
	}
	
	if(!strcmp(type, "biznes", true) || !strcmp(type, "business", true))
	{
		if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
  	    {
  	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz być na służbie grupy, by móc coś oferować.");
  	        return 1;
  	    }
		new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
		if(GroupData[group_id][gType] != G_TYPE_GOV || !HavePlayerGroupPerm(playerid, GroupData[group_id][gUID], G_PERM_LEADER))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz niczego oferować.");
		    return 1;
		}
  	 	new doorid = GetPlayerDoorID(playerid);
	  	if(doorid == INVALID_DOOR_ID)
	  	{
	  	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w budynku grupy, by móc oferować.");
	  	    return 1;
		}
		new DoorData[sDoorInfo];
	  	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	  	
	  	if(DoorData[dOwnerType] != OWNER_GROUP || DoorData[dOwner] != GroupData[group_id][gUID])
	  	{
	  	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w budynku grupy, by móc oferować.");
	  	    return 1;
	  	}
	  	new giveplayer_id, business_type, price, business_name[32];
	  	if(sscanf(varchar, "udds[32]", giveplayer_id, business_type, price, business_name))
	  	{
	  	    ShowTipForPlayer(playerid, "/oferuj biznes [ID gracza] [Typ] [Cena] [Nazwa]");
	  	    SendClientMessage(playerid, COLOR_GREY, "Lista dostępnych typów grup, wraz z ich minimalnymi cenami:");

            for (new i = 0; i < sizeof(GroupTypeInfo); i++)
            {
                if(GroupTypeInfo[i][gTypePrice] > 0)
                {
                    SendClientFormatMessage(playerid, COLOR_GREY, "%d | %s | $%d", i + 1, GroupTypeInfo[i][gTypeName], GroupTypeInfo[i][gTypePrice]);
                }
            }
	  	    return 1;
	  	}
  		if(giveplayer_id == playerid)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować czegoś sobie.");
			return 1;
		}
		if(giveplayer_id == INVALID_PLAYER_ID)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
 			return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
  			return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
			return 1;
		}
	  	if(business_type - 1 > sizeof(GroupTypeInfo) || GroupTypeInfo[business_type - 1][gTypePrice] <= 0)
	  	{
	  	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano nieprawidłowy typ grupy.");
	  	    return 1;
	  	}
	  	if(price < GroupTypeInfo[business_type - 1][gTypePrice])
	  	{
	  	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podana cena jest mniejsza od minimalnej.");
	  	    return 1;
	  	}
	  	OnPlayerSendOffer(playerid, giveplayer_id, business_name, OFFER_BUSINESS, business_type - 1, 0, price);
	    return 1;
	}
	
	if(!strcmp(type, "rejestracje", true) || !strcmp(type, "register", true))
	{
		if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
  	    {
  	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz być na służbie grupy, by móc coś oferować.");
  	        return 1;
  	    }
		new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
		if(GroupData[group_id][gType] != G_TYPE_GOV || !HavePlayerGroupPerm(playerid, GroupData[group_id][gUID], G_PERM_OFFER))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz niczego oferować.");
		    return 1;
		}
  	 	new doorid = GetPlayerDoorID(playerid);
	  	if(doorid == INVALID_DOOR_ID)
	  	{
	  	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w budynku grupy, by móc oferować.");
	  	    return 1;
	  	}
		new DoorData[sDoorInfo];
	  	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	  	
	  	if(DoorData[dOwnerType] != OWNER_GROUP || DoorData[dOwner] != GroupData[group_id][gUID])
	  	{
	  	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w budynku grupy, by móc oferować.");
	  	    return 1;
	  	}
	    new giveplayer_id, veh_uid;
	    if(sscanf(varchar, "ud", giveplayer_id, veh_uid))
	    {
	        ShowTipForPlayer(playerid, "/oferuj rejestracje [ID gracza] [UID pojazdu]");
	        return 1;
	    }
   		if(giveplayer_id == playerid)
    	{
     		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować czegoś sobie.");
       		return 1;
    	}
   		if(giveplayer_id == INVALID_PLAYER_ID)
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	    	return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
	    	return 1;
		}
		new vehid = GetVehicleID(veh_uid);
		if(vehid == INVALID_VEHICLE_ID)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne UID pojazdu.");
		    return 1;
		}
		if(strlen(CarInfo[vehid][cRegister]))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten pojazd jest już zarejestrowany.");
		    return 1;
		}
		format(string, sizeof(string), "Rejestracja pojazdu (UID: %d)", CarInfo[vehid][cUID]);
		OnPlayerSendOffer(playerid, giveplayer_id, string, OFFER_REGISTER, vehid, 0, 150);
	    return 1;
	}
	
	if(!strcmp(type, "podatek", true) || !strcmp(type, "tax", true))
	{
		if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
  	    {
  	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz być na służbie grupy, by móc coś oferować.");
  	        return 1;
  	    }
		new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
		if(GroupData[group_id][gType] != G_TYPE_GOV || !HavePlayerGroupPerm(playerid, GroupData[group_id][gUID], G_PERM_OFFER))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz niczego oferować.");
		    return 1;
		}
  	 	new doorid = GetPlayerDoorID(playerid);
	  	if(doorid == INVALID_DOOR_ID)
	  	{
	  	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w budynku grupy, by móc oferować.");
	  	    return 1;
	  	}
		new DoorData[sDoorInfo];
	  	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	  	
	  	if(DoorData[dOwnerType] != OWNER_GROUP || DoorData[dOwner] != GroupData[group_id][gUID])
	  	{
	  	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w budynku grupy, by móc oferować.");
	  	    return 1;
	  	}
	  	new giveplayer_id, group_uid, price;
	  	if(sscanf(varchar, "udd", giveplayer_id, group_uid, price))
	  	{
	  	    ShowTipForPlayer(playerid, "/oferuj podatek [ID gracza] [UID grupy] [Kwota od pracownika]");
	  	    return 1;
	  	}
  		if(giveplayer_id == playerid)
    	{
     		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować czegoś sobie.");
       		return 1;
    	}
   		if(giveplayer_id == INVALID_PLAYER_ID)
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	    	return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
	    	return 1;
		}
		group_id = GetGroupID(group_uid);
		if(group_id == INVALID_GROUP_ID)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID grupy.");
		    return 1;
		}
		if(!IsPlayerInGroup(giveplayer_id, GroupData[group_id][gUID]))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz nie jest członkiem tej grupy.");
		    return 1;
		}
		if(price <= 0 || price > 300)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Kwota od pracownika nie może być mniejsza od $0 oraz większa niż $200.");
		    return 1;
		}
		new members_count;
		new rows, Cache:tmp_cache, query[256];
		
		mysql_format(connHandle, query, sizeof(query), "SELECT COUNT(char_uid) FROM `"SQL_PREF"char_groups` WHERE group_belongs = '%d'", GroupData[group_id][gUID]);
		tmp_cache = mysql_query(connHandle, query);
		
		cache_get_row_count(rows);
		if(rows > 0)
		{
		    cache_get_value_index_int(0, 0, members_count);
		}
		if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
		
		format(string, sizeof(string), "Podatek - %s (UID: %d)", GroupData[group_id][gName], GroupData[group_id][gUID]);
		OnPlayerSendOffer(playerid, giveplayer_id, string, OFFER_TAX, group_id, 0, price * members_count);
	    return 1;
	}
	
	if(!strcmp(type, "slub", true))
	{
		if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
  	    {
  	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz być na służbie grupy, by móc coś oferować.");
  	        return 1;
  	    }
		new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
		if(GroupData[group_id][gType] != G_TYPE_GOV || !HavePlayerGroupPerm(playerid, GroupData[group_id][gUID], G_PERM_OFFER))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz niczego oferować.");
		    return 1;
		}
 		new doorid = GetPlayerDoorID(playerid);
	  	if(doorid == INVALID_DOOR_ID)
	  	{
	  	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w budynku grupy, by móc oferować.");
	  	    return 1;
	  	}
		new DoorData[sDoorInfo];
	  	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	  	
	  	if(DoorData[dOwnerType] != OWNER_GROUP || DoorData[dOwner] != GroupData[group_id][gUID])
	  	{
	  	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w budynku grupy, by móc oferować.");
	  	    return 1;
	  	}
	  	new getplayer_id, giveplayer_id, price;
	  	if(sscanf(varchar, "uud", getplayer_id, giveplayer_id, price))
	  	{
	  	    ShowTipForPlayer(playerid, "/oferuj slub [ID gracza (M)] [ID gracza (K)] [Cena]");
	  	    return 1;
	  	}
  		if(giveplayer_id == playerid || getplayer_id == playerid)
    	{
     		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować czegoś sobie.");
       		return 1;
    	}
   		if(giveplayer_id == INVALID_PLAYER_ID || getplayer_id == INVALID_PLAYER_ID)
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	    	return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged] || !PlayerCache[getplayer_id][pLogged])
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id) || !PlayerToPlayer(5.0, playerid, getplayer_id))
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
	    	return 1;
		}
		if(IsPlayerInGroupType(giveplayer_id, G_TYPE_FAMILY) || IsPlayerInGroupType(getplayer_id, G_TYPE_FAMILY))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Któryś z graczy ma już rodzinę.");
		    return 1;
		}
		if(!PlayerCache[getplayer_id][pSex] || PlayerCache[giveplayer_id][pSex])
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wziąć ślub mogą tylko płci przeciwne (M - mężczyzna, K - kobieta).");
		    return 1;
		}
		if(price < 2000)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Cena ślubu nie może być mniejsza niż $2000.");
		    return 1;
		}
		/*
		format(string, sizeof(string), "Slub z %s", PlayerName(giveplayer_id));
		OnPlayerSendOffer(playerid, getplayer_id, string, OFFER_WEDDING, giveplayer_id, 0, price);
		
		format(string, sizeof(string), "Slub z %s", PlayerName(getplayer_id));
		OnPlayerSendOffer(playerid, giveplayer_id, string, OFFER_WEDDING, giveplayer_id, 0, price);
		*/
	    return 1;
	}
	
	if(!strcmp(type, "leczenie", true))
	{
		if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
  	    {
  	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz być na służbie grupy, by móc coś oferować.");
  	        return 1;
  	    }
		new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
		if(GroupData[group_id][gType] != G_TYPE_MEDICAL && GroupData[group_id][gType] != G_TYPE_FIREDEPT || !HavePlayerGroupPerm(playerid, GroupData[group_id][gUID], G_PERM_OFFER))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz niczego oferować.");
		    return 1;
		}
	    new giveplayer_id, price;
	    if(sscanf(varchar, "ud", giveplayer_id, price))
	    {
	        ShowTipForPlayer(playerid, "/oferuj leczenie [ID gracza] [Cena]");
	        return 1;
	    }
		if(giveplayer_id == playerid)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować czegoś sobie.");
			return 1;
		}
		if(giveplayer_id == INVALID_PLAYER_ID)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	  		return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	  		return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
			return 1;
		}
		if(PlayerCache[giveplayer_id][pHealth] >= 100)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz jest zdrowy.");
		    return 1;
		}
		if(price < 0)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłową kwotę za leczenie.");
		    return 1;
		}
		OnPlayerSendOffer(playerid, giveplayer_id, "Leczenie", OFFER_HEAL, 0, 0, price);
		return 1;
	}
	
	if(!strcmp(type, "karnet", true) || !strcmp(type, "pass", true))
	{
		if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
  	    {
  	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz być na służbie grupy, by móc coś oferować.");
  	        return 1;
  	    }
		new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
		if(GroupData[group_id][gType] != G_TYPE_GYM || !HavePlayerGroupPerm(playerid, GroupData[group_id][gUID], G_PERM_OFFER))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz niczego oferować.");
		    return 1;
		}
	  	new doorid = GetPlayerDoorID(playerid);
	  	if(doorid == INVALID_DOOR_ID)
	  	{
	  	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w budynku grupy, by móc oferować.");
	  	    return 1;
	  	}
  		new DoorData[sDoorInfo];
	  	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	  	
	  	if(DoorData[dOwnerType] != OWNER_GROUP || DoorData[dOwner] != GroupData[group_id][gUID])
	  	{
	  	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w budynku grupy, by móc oferować.");
	  	    return 1;
	  	}
	  	new giveplayer_id, price;
	  	if(sscanf(varchar, "ud", giveplayer_id, price))
	  	{
	  	    ShowTipForPlayer(playerid, "/oferuj karnet [ID gracza] [Cena]");
	  	    return 1;
	  	}
		if(giveplayer_id == playerid)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować czegoś sobie.");
			return 1;
		}
		if(giveplayer_id == INVALID_PLAYER_ID)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	  		return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	  		return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
			return 1;
		}
		if(price < 120)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Cena nie może być mniejsza niż $120.");
		    return 1;
		}
		format(string, sizeof(string), "(K) %s", GroupData[group_id][gName]);
 		OnPlayerSendOffer(playerid, giveplayer_id, string, OFFER_PASS, 15, GroupData[group_id][gUID], price);
	    return 1;
	}
	
	if(!strcmp(type, "styl", true))
	{
		if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
  	    {
  	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz być na służbie grupy, by móc coś oferować.");
  	        return 1;
  	    }
		new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
		if(GroupData[group_id][gType] != G_TYPE_GYM || !HavePlayerGroupPerm(playerid, GroupData[group_id][gUID], G_PERM_OFFER))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz niczego oferować.");
		    return 1;
		}
	  	new doorid = GetPlayerDoorID(playerid);
	  	if(doorid == INVALID_DOOR_ID)
	  	{
	  	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w budynku grupy, by móc oferować.");
	  	    return 1;
	  	}
		new DoorData[sDoorInfo];
	  	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	  	
	  	if(DoorData[dOwnerType] != OWNER_GROUP || DoorData[dOwner] != GroupData[group_id][gUID])
	  	{
	  	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w budynku grupy, by móc oferować.");
	  	    return 1;
	  	}
	  	new giveplayer_id, price, style;
	  	if(sscanf(varchar, "udd", giveplayer_id, price, style))
	  	{
	  	    ShowTipForPlayer(playerid, "/oferuj style [ID gracza] [Cena] [Styl walki (1-3)]");
	  	    
    	   	SendClientMessage(playerid, COLOR_GREY, " ");
	   	 	SendClientMessage(playerid, COLOR_GREY, "Dostępne style walki:");

			for(new i = 1; i < sizeof(FightStyleData); i++)	SendClientFormatMessage(playerid, COLOR_GREY, "%d - %s", i, FightStyleData[i][0]);
	  	    return 1;
	  	}
		if(giveplayer_id == playerid)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować czegoś sobie.");
			return 1;
		}
		if(giveplayer_id == INVALID_PLAYER_ID)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	  		return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	  		return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
			return 1;
		}
		if(PlayerCache[giveplayer_id][pStrength] < 9000)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz nie posiada wystarczającej ilości siły (9000j).");
		    return 1;
		}
		if(price < 500)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Cena nie może być mniejsza niż $500.");
		    return 1;
		}
		if(style <= 0 || style > 3)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędny styl walki.");
		    return 1;
		}
		OnPlayerSendOffer(playerid, giveplayer_id, FightStyleData[style][0], OFFER_STYLE, style, 0, price);
	    return 1;
	}
	
	if(!strcmp(type, "salon", true))
	{
		if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
  	    {
  	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz być na służbie grupy, by móc coś oferować.");
  	        return 1;
  	    }
		new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
		if(GroupData[group_id][gType] != G_TYPE_CARDEALER || !HavePlayerGroupPerm(playerid, GroupData[group_id][gUID], G_PERM_OFFER))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz niczego oferować.");
		    return 1;
		}
	  	new doorid = GetPlayerDoorID(playerid);
	  	if(doorid == INVALID_DOOR_ID)
	  	{
	  	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w budynku grupy, by móc oferować.");
	  	    return 1;
	  	}
		new DoorData[sDoorInfo];
	  	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	  	
	  	if(DoorData[dOwnerType] != OWNER_GROUP || DoorData[dOwner] != GroupData[group_id][gUID])
	  	{
	  	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w budynku grupy, by móc oferować.");
	  	    return 1;
		}
	  	new giveplayer_id, veh_model;
	  	if(sscanf(varchar, "uk<vehicle_model>", giveplayer_id, veh_model))
	  	{
	  	    ShowTipForPlayer(playerid, "/oferuj salon [ID gracza] [Model/Nazwa pojazdu]");
	  	    return 1;
	  	}
		if(giveplayer_id == playerid)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować czegoś sobie.");
			return 1;
		}
		if(giveplayer_id == INVALID_PLAYER_ID)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	  		return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	  		return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
			return 1;
		}
		new veh_price, Cache:tmp_cache, query[256];
		
		mysql_format(connHandle, query, sizeof(query), "SELECT `salon_price` FROM `"SQL_PREF"salon_vehicles` WHERE salon_model = '%d' LIMIT 1", veh_model);
		tmp_cache = mysql_query(connHandle, query);
		
		cache_get_value_index_int(0, 0, veh_price);
		if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
		
		if(veh_price > 0)
		{
			format(string, sizeof(string), "%s", GetVehicleName(veh_model));
 			OnPlayerSendOffer(playerid, giveplayer_id, string, OFFER_SALON, veh_model, 0, veh_price);
		}
		else
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znaleziono takiego pojazdu.");
		}
		return 1;
	}
	
	if(!strcmp(type, "kluczyki", true) || !strcmp(type, "keys", true))
	{
		if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
  	    {
  	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz być na służbie grupy, by móc coś oferować.");
  	        return 1;
  	    }
		new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
		if(GroupData[group_id][gType] != G_TYPE_CARDEALER || !HavePlayerGroupPerm(playerid, GroupData[group_id][gUID], G_PERM_OFFER))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz niczego oferować.");
		    return 1;
		}
 		new doorid = GetPlayerDoorID(playerid);
	  	if(doorid == INVALID_DOOR_ID)
	  	{
	  	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w budynku grupy, by móc oferować.");
	  	    return 1;
	  	}
		new DoorData[sDoorInfo];
	  	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	  	
	  	if(DoorData[dOwnerType] != OWNER_GROUP || DoorData[dOwner] != GroupData[group_id][gUID])
	  	{
	  	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w budynku grupy, by móc oferować.");
	  	    return 1;
	  	}
  		new giveplayer_id, veh_uid;
		if(sscanf(varchar, "ud", giveplayer_id, veh_uid))
		{
		    ShowTipForPlayer(playerid, "/salon kluczyki [ID gracza] [UID pojazdu]");
		    return 1;
		}
		if(giveplayer_id == playerid)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować czegoś sobie.");
			return 1;
		}
		if(giveplayer_id == INVALID_PLAYER_ID)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	  		return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	  		return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
			return 1;
		}
	    new vehid = GetVehicleID(veh_uid);
	    if(vehid == INVALID_VEHICLE_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Pojazd musi być zespawnowany.");
	        return 1;
	    }
	    if(CarInfo[vehid][cOwnerType] != OWNER_PLAYER)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz nie jest właścicielem tego pojazdu.");
	        return 1;
	    }
	    if(CarInfo[vehid][cOwner] != PlayerCache[giveplayer_id][pUID])
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz nie jest właścicielem tego pojazdu.");
	        return 1;
	    }
   		format(string, sizeof(string), "Kluczyki - %s (UID: %d)", GetVehicleName(CarInfo[vehid][cModel]), CarInfo[vehid][cUID]);
 		OnPlayerSendOffer(playerid, giveplayer_id, string, OFFER_KEYS, vehid, 0, 80);
	    return 1;
	}
	
	if(!strcmp(type, "reklame", true))
	{
		if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
  	    {
  	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz być na służbie grupy, by móc coś oferować.");
  	        return 1;
  	    }
		new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
		if(GroupData[group_id][gType] != G_TYPE_NEWS || !HavePlayerGroupPerm(playerid, GroupData[group_id][gUID], G_PERM_OFFER))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz niczego oferować.");
		    return 1;
		}
	    new giveplayer_id, time, price;
	    if(sscanf(varchar, "udd", giveplayer_id, time, price))
	    {
	        ShowTipForPlayer(playerid, "/oferuj reklame [ID gracza] [Czas (min)] [Cena]");
	        return 1;
	    }
		if(giveplayer_id == playerid)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować czegoś sobie.");
			return 1;
		}
		if(giveplayer_id == INVALID_PLAYER_ID)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	  		return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	  		return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
			return 1;
		}
		format(string, sizeof(string), "Nadanie reklamy (%d min)", time);
		OnPlayerSendOffer(playerid, giveplayer_id, string, OFFER_ADVERTISE, time, 0, price);
		return 1;
	}
	
	if(!strcmp(type, "lekcja", true) || !strcmp(type, "lesson", true))
	{
		if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
  	    {
  	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz być na służbie grupy, by móc coś oferować.");
  	        return 1;
  	    }
		new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
		if(GroupData[group_id][gType] != G_TYPE_DRIVING || !HavePlayerGroupPerm(playerid, GroupData[group_id][gUID], G_PERM_OFFER))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz niczego oferować.");
		    return 1;
		}
	  	new doorid = GetPlayerDoorID(playerid);
	  	if(doorid == INVALID_DOOR_ID)
	  	{
	  	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w budynku grupy, by móc oferować.");
	  	    return 1;
	  	}
		new DoorData[sDoorInfo];
	  	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	  	
	  	if(DoorData[dOwnerType] != OWNER_GROUP || DoorData[dOwner] != GroupData[group_id][gUID])
	  	{
	  	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w budynku grupy, by móc oferować.");
	  	    return 1;
	  	}
	    new giveplayer_id, lesson_time, price;
	    if(sscanf(varchar, "udd", giveplayer_id, lesson_time, price))
	    {
	        ShowTipForPlayer(playerid, "/oferuj lekcja [ID gracza] [Czas (min)] [Cena]");
	        return 1;
	    }
		if(giveplayer_id == playerid)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaoferować czegoś sobie.");
			return 1;
		}
		if(giveplayer_id == INVALID_PLAYER_ID)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	  		return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	  		return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
			return 1;
		}
		if(price < 200)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Cena nie może być mniejsza niż 200$!");
		    return 1;
		}
		if(lesson_time <= 0 || lesson_time > 10)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłowy czas lekcji.\nNie może być większy niż 10 min.");
		    return 1;
		}
		OnPlayerSendOffer(playerid, giveplayer_id, "Lekcja jazdy", OFFER_LESSON, lesson_time, group_id, price);
	    return 1;
	}
	return 1;
}
alias:oferuj("o");

cmd:bank(playerid, params[])
{
	new doorid = GetPlayerDoorID(playerid);
	if(doorid == INVALID_DOOR_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znajdujesz się w banku.");
	    return 1;
	}
	new DoorData[sDoorInfo];
	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	
	if(DoorData[dOwnerType] != OWNER_GROUP)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znajdujesz się w banku.");
	    return 1;
	}
	new group_id = GetGroupID(DoorData[dOwner]);
	if(GroupData[group_id][gType] != G_TYPE_BANK)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znajdujesz się w banku.");
	    return 1;
	}
	if(!PlayerCache[playerid][pBankNumber])
	{
		ShowPlayerDialog(playerid, D_BANK_CREATE_ACCOUNT, DIALOG_STYLE_MSGBOX, "Informacja", "Aby w pełni korzystać z funkcji banku musisz założyć konto bankowe,\ndo którego będzie przypisany odpowiedni numer bankowy.\n\nNumer bankowy będzie wykorzystywany do wszystkich akcji związanych z pieniędzmi w banku.\nCzy chcesz założyć konto bankowe?", "Tak", "Nie");
  	}
  	else
  	{
   		ShowPlayerDialog(playerid, D_BANK_SELECT_OPTIONS, DIALOG_STYLE_LIST, "Wybierz opcję", "1. Stan konta\n2. Wpłać gotówkę\n3. Wypłać gotówkę\n4. Dokonaj przelewu", "Wybierz", "Anuluj");
   	}
	return 1;
}

cmd:bankomat(playerid, params[])
{
	new object_id = GetClosestObjectType(playerid, OBJECT_ATM);
	if(object_id == INVALID_OBJECT_ID)
	{
 		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znajdujesz się przy bankomacie.");
   		return 1;
	}
	if(!PlayerCache[playerid][pBankNumber])
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby móc korzystać z bankomatu, musisz posiadać konto bankowe.");
	    TD_ShowHint(playerid, HINT_ATM, 15, "Ups! Nie posiadasz konta w ~g~banku~w~? Musisz je czym predzej zalozyc, by moc trzymac tam bezpiecznie swoje oszczednosci.~n~~n~Zalozenie konta w banku ~r~nic nie kosztuje~w~, a daje wiele korzysci - miedzy innymi mozliwosc ~y~placenia ~w~karta za uslugi.~n~~n~Konto zalozysz w siedzibie ~g~banku~w~, ktorych w miescie jest kilka. Na mapie widac banki, udaj sie do najblizszego (to znak ~g~$~w~).");
	    return 1;
	}
	ApplyAnimation(playerid, "PED", "ATM", 4.0, 0, 0, 0, 0, 0, true);
	ShowPlayerDialog(playerid, D_BANK_SELECT_OPTIONS, DIALOG_STYLE_LIST, "Bankomat", "1. Stan konta\n2. Wpłać gotówkę\n3. Wypłać gotówkę", "Wybierz", "Anuluj");
	return 1;
}

cmd:mc(playerid, params[])
{
	new modelid, bool: priority = false;
	if(sscanf(params, "dL(0)", modelid, priority))
	{
	    ShowTipForPlayer(playerid, "/mc [Model]");
	    return 1;
	}
	if(PlayerCache[playerid][pEditObject] != INVALID_OBJECT_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz tworzyć nowych obiektów podczas edycji.");
	    return 1;
	}
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_OBJECTS))
	{
		new doorid = GetPlayerDoorID(playerid);
		if(doorid != INVALID_DOOR_ID)
		{
			new DoorData[sDoorInfo];
	  		Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	  		
			if(DoorData[dOwnerType] == OWNER_NONE)
			{
				ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Ten budynek lub strefa nie należy do Ciebie.");
				return 1;
			}
			if(DoorData[dOwnerType] == OWNER_PLAYER)
			{
		 		if(DoorData[dOwner] != PlayerCache[playerid][pUID])
		   		{
					ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Ten budynek lub strefa nie należy do Ciebie.");
		   			return 1;
				}
			}
			if(DoorData[dOwnerType] == OWNER_GROUP)
			{
			    if(!HavePlayerGroupPerm(playerid, DoorData[dOwner], G_PERM_LEADER))
			    {
			        ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Ten budynek lub strefa nie należy do Ciebie.");
			        return 1;
			    }
			}
		}
		else
		{
		    new areaid = GetPlayerAreaID(playerid);
		    if(areaid == INVALID_AREA_ID)
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby móc stworzyć obiekt, musisz znajdować się w budynku lub strefie.");
		        return 1;
		    }
		    new AreaData[sAreaData];
		    Streamer_GetArrayData(STREAMER_TYPE_AREA, areaid, E_STREAMER_EXTRA_ID, AreaData);
		    
		    if(AreaData[aOwnerType] == OWNER_NONE)
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Ten budynek lub strefa nie należy do Ciebie.");
		        return 1;
		    }
		    if(AreaData[aOwnerType] == OWNER_PLAYER)
		    {
		        if(AreaData[aOwner] != PlayerCache[playerid][pUID])
		        {
		            ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Ten budynek lub strefa nie należy do Ciebie.");
		            return 1;
		        }
		    }
		    if(AreaData[aOwnerType] == OWNER_GROUP)
		    {
		        if(!HavePlayerGroupPerm(playerid, AreaData[aOwner], G_PERM_LEADER))
		        {
		            ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Ten budynek lub strefa nie należy do Ciebie.");
		            return 1;
		        }
		    }
		    
   			new Float:pointes[8];
			GetDynamicPolygonPoints(areaid, pointes, 8);

			new AreaField, Side[2], ObjectLimit;
  			Side[0] = floatround((pointes[0] > pointes[4]) ? (pointes[0] - pointes[4]) : (pointes[4] - pointes[0]));
		    Side[1] = floatround((pointes[1] > pointes[3]) ? (pointes[1] - pointes[3]) : (pointes[3] - pointes[1]));

		    AreaField = Side[0] * Side[1];
		    ObjectLimit = (IsPlayerPremium(playerid)) ? (AreaField / (Side[0] + Side[1])) * 2 : (AreaField / (Side[0] + Side[1]));
		    
		    new object_id, Float:objX, Float:objY, Float:objZ,
		        Float:PosX, Float:PosY, Float:PosZ, virtual_world = GetPlayerVirtualWorld(playerid);
		    
		    GetPlayerPos(playerid, PosX, PosY, PosZ);
		    
			new ObjectData[MAX_VIS_OBJECTS],
				count_objects = Streamer_GetNearbyItems(PosX, PosY, PosZ, STREAMER_TYPE_OBJECT, ObjectData, MAX_VIS_OBJECTS, 100.0, virtual_world);

			for(new object = 0; object < count_objects; object++)
			{
			    object_id = ObjectData[object];
			    if(!Streamer_IsToggleItemStatic(STREAMER_TYPE_OBJECT, object_id))
			    {
	   				GetDynamicObjectPos(object_id, objX, objY, objZ);
			    	if(!IsPointInDynamicArea(areaid, objX, objY, objZ) && GetObjectUID(object_id) > 0)
			    	{
	  	    			count_objects --;
			    	}
				}
			}

			if(count_objects >= ObjectLimit)
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz postawić więcej niż %d obiektów w tej strefie.", ObjectLimit);
			    return 1;
			}
		}
	}
	/*
	if(!IsValidObjectModel(modelid))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłowy model obiektu.");
	    return 1;
	}
	*/
	new Float:PosX, Float:PosY, Float:PosZ,
	    interior_id = GetPlayerInterior(playerid), world_id = GetPlayerVirtualWorld(playerid);

	GetPlayerPos(playerid, PosX, PosY, PosZ);
	GetXYInFrontOfPlayer(playerid, PosX, PosY, 2.0);
	
	new object_id = PlayerCache[playerid][pLastObject] = crp_AddObject(modelid, PosX, PosY, PosZ, 0.0, 0.0, 0.0, interior_id, world_id);

	Streamer_Update(playerid, STREAMER_TYPE_OBJECT);
	
	ResetDynamicObjectPos(object_id);
    OnPlayerSelectDynamicObject(playerid, object_id, modelid, PosX, PosY, PosZ);
	return 1;
}
alias:mc("oc");

cmd:msel(playerid, params[])
{
	if(PlayerCache[playerid][pEditObject] != INVALID_OBJECT_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aktualnie edytujesz już jakiś obiekt.");
	    return 1;
	}
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_OBJECTS))
	{
		new doorid = GetPlayerDoorID(playerid);
		if(doorid != INVALID_DOOR_ID)
		{
			new DoorData[sDoorInfo];
	  		Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	  		
			if(DoorData[dOwnerType] == OWNER_NONE)
			{
				ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Ten budynek lub strefa nie należy do Ciebie.");
				return 1;
			}
			if(DoorData[dOwnerType] == OWNER_PLAYER)
			{
		 		if(DoorData[dOwner] != PlayerCache[playerid][pUID])
		   		{
					ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Ten budynek lub strefa nie należy do Ciebie.");
		   			return 1;
				}
			}
			if(DoorData[dOwnerType] == OWNER_GROUP)
			{
			    if(!HavePlayerGroupPerm(playerid, DoorData[dOwner], G_PERM_LEADER))
			    {
			        ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Ten budynek lub strefa nie należy do Ciebie.");
			        return 1;
			    }
			}
		}
		else
		{
		    new areaid = GetPlayerAreaID(playerid);
		    if(areaid == INVALID_AREA_ID)
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby móc edytować obiekt, musisz znajdować się w budynku lub strefie.");
		        return 1;
		    }
		    new AreaData[sAreaData];
		    Streamer_GetArrayData(STREAMER_TYPE_AREA, areaid, E_STREAMER_EXTRA_ID, AreaData);
		    
		    if(AreaData[aOwnerType] == OWNER_NONE)
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Ten budynek lub strefa nie należy do Ciebie.");
		        return 1;
		    }
		    if(AreaData[aOwnerType] == OWNER_PLAYER)
		    {
		        if(AreaData[aOwner] != PlayerCache[playerid][pUID])
		        {
		            ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Ten budynek lub strefa nie należy do Ciebie.");
		            return 1;
		        }
		    }
		    if(AreaData[aOwnerType] == OWNER_GROUP)
		    {
		        if(!HavePlayerGroupPerm(playerid, AreaData[aOwner], G_PERM_LEADER))
		        {
		            ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Ten budynek lub strefa nie należy do Ciebie.");
		            return 1;
		        }
		    }
		    PlayerCache[playerid][pCurrentArea] = areaid;
		}
	}

	new object_model;
	if(sscanf(params, "d", object_model))
	{
		SelectObject(playerid);
		TD_ShowSmallInfo(playerid, 5, "Wybierz ~b~obiekt ~w~do edycji (klawisz ~r~~k~~PED_FIREWEAPON~~w~).");
		return 1;
	}

	new object_id = GetClosestObjectType(playerid, object_model);
	if(object_id == INVALID_OBJECT_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znaleziono żadnego obiektu o podanym modelu w pobliżu.");
	    return 1;
	}
	new Float:PosX, Float:PosY, Float:PosZ;
	GetDynamicObjectPos(object_id, PosX, PosY, PosZ);
	
	OnPlayerSelectDynamicObject(playerid, object_id, object_model, PosX, PosY, PosZ);
	return 1;
}
alias:msel("osel");

cmd:mdel(playerid, params[])
{
	if(PlayerCache[playerid][pEditObject] == INVALID_OBJECT_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie edytujesz aktualnie żadnego obiektu.");
	    return 1;
	}
	new object_id = PlayerCache[playerid][pEditObject];
	
	PlayerCache[playerid][pEditObject] = INVALID_OBJECT_ID;
	PlayerCache[playerid][pCurrentArea] = INVALID_AREA_ID;
	
	CancelEdit(playerid);
	DeleteObject(object_id);
	
	TD_HideLargeInfo(playerid);
	TD_ShowSmallInfo(playerid, 3, "~b~Obiekt ~w~zostal calkowicie ~r~usuniety~w~.");
	return 1;
}
alias:mdel("odel");

cmd:mgate(playerid, params[])
{
	if(PlayerCache[playerid][pEditObject] == INVALID_OBJECT_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie edytujesz aktualnie żadnego obiektu.");
	    return 1;
	}
	new object_id = PlayerCache[playerid][pEditObject], object_uid = GetObjectUID(object_id),
		Float:GateX, Float:GateY, Float:GateZ, Float:GateRX, Float:GateRY, Float:GateRZ;
		
	new player_object = Streamer_GetItemInternalID(playerid, STREAMER_TYPE_OBJECT, object_id);
	
	GetPlayerObjectPos(playerid, player_object, GateX, GateY, GateZ);
	GetPlayerObjectRot(playerid, player_object, GateRX, GateRY, GateRZ);
	
	mysql_query_format("UPDATE `"SQL_PREF"objects` SET object_gatex = '%f', object_gatey = '%f', object_gatez = '%f', object_gaterotx = '%f', object_gateroty = '%f', object_gaterotz = '%f', object_gate = '1' WHERE object_uid = '%d' LIMIT 1", GateX, GateY, GateZ, GateRX, GateRY, GateRZ, object_uid);
	
	new objData[sObjectData];
	
	objData[objUID] = object_uid;

	objData[objGateX] = GateX;
	objData[objGateY] = GateY;
	objData[objGateZ] = GateZ;
	
	objData[objGateRX] = GateRX;
	objData[objGateRY] = GateRY;
	objData[objGateRZ] = GateRZ;
	
	objData[objGateStatus] = false;
	objData[objGate] = true;
	
	Streamer_SetArrayData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_EXTRA_ID, objData);
	
	CancelEdit(playerid);
	ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Brama została utworzona.\nSkorzystaj z komendy /brama.");
	return 1;
}
alias:mgate("ogate");

cmd:mmat(playerid, params[])
{
	if(PlayerCache[playerid][pEditObject] == INVALID_OBJECT_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie edytujesz aktualnie żadnego obiektu.");
	    return 1;
	}
	new material_type, varchar[128];
	if(sscanf(params, "dS()[128]", material_type, varchar))
	{
	    ShowTipForPlayer(playerid, "/mmat [Typ 0 - tekstura, 1 - tekst] [Pozostałe]");
	    return 1;
	}

	// Material
	if(material_type == 0)
	{
	    new index, color, modelid, txdname[32], texturename[64], query[512];
	    if(sscanf(varchar, "dxds[32]s[64]", index, color, modelid, txdname, texturename))
	    {
	        ShowTipForPlayer(playerid, "/mmat 0 [Index (0-15)] [Kolor (ARGB)] [Model] [Txdname] [Texturename]");
	        return 1;
	    }
	    
    	new object_id = PlayerCache[playerid][pEditObject], object_uid = GetObjectUID(object_id);
    	
    	mysql_format(connHandle, query, sizeof(query), "UPDATE `"SQL_PREF"materials` SET material_texture = '0^%d:%x:%d:%e:%e' WHERE material_owner = %d AND material_index = %d", index, color, modelid, txdname, texturename, object_uid, index);
	    mysql_query(connHandle, query);
	    
	    if(cache_affected_rows() <= 0)
	    {
	        mysql_format(connHandle, query, sizeof(query), "INSERT INTO `"SQL_PREF"materials` (material_owner, material_texture, material_index) VALUES (%d, '0^%d:%x:%d:%s:%s', %d)", object_uid, index, color, modelid, txdname, texturename, index);
            mysql_query(connHandle, query);
		}
	    
	    SetDynamicObjectMaterial(object_id, index, modelid, txdname, texturename, color);
	    return 1;
	}

	// Tekst
	if(material_type == 1)
	{
	    new index, matsize, fontsize, bold, fontcolor, backcolor, alignment, fonttype[12], text[256], query[512];
	    if(sscanf(varchar, "ddddxxds[12]s[256]", index, matsize, fontsize, bold, fontcolor, backcolor, alignment, fonttype, text))
	    {
	        ShowTipForPlayer(playerid, "/mmat 1 [Index (0-15)] [Matsize (10-140)] [Fontsize (24-255)] [Bold] [Fontcol] [Backcol] [Align (0-2)] [Font] [Txt]");
	        return 1;
	    }
	    
		new object_id = PlayerCache[playerid][pEditObject], object_uid = GetObjectUID(object_id);
		mysql_format(connHandle, query, sizeof(query), "UPDATE `"SQL_PREF"materials` SET material_texture = '1^%d:%d:%d:%d:%x:%x:%d:%e:%e' WHERE material_owner = %d AND material_index = %d", index, matsize, fontsize, bold, fontcolor, backcolor, alignment, fonttype, text, object_uid, index);
		mysql_query(connHandle, query);
		
		if(cache_affected_rows() <= 0)
		{
		    mysql_format(connHandle, query, sizeof(query), "INSERT INTO `"SQL_PREF"materials` SET material_texture = '1^%d:%d:%d:%d:%x:%x:%d:%e:%e', material_owner = %d, material_index = %d", index, matsize, fontsize, bold, fontcolor, backcolor, alignment, fonttype, text, object_uid, index);
		    mysql_query(connHandle, query);
		}
	    format(text, sizeof(text), "%s", WordWrap(text, WRAP_MANUAL));
	    SetDynamicObjectMaterialText(object_id, index, text, matsize, fonttype, fontsize, bold, fontcolor, backcolor, alignment);
	    return 1;
	}
	return 1;
}
alias:mmat("omat");

cmd:mcopy(playerid, params[])
{
	if(PlayerCache[playerid][pEditObject] == INVALID_OBJECT_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie edytujesz aktualnie żadnego obiektu.");
	    return 1;
	}
	new object_id = PlayerCache[playerid][pEditObject], string[12],
		object_model = GetObjectModel(object_id);
		
	new Float:object_pos[3], Float:object_rot[3];
	
	GetDynamicObjectPos(object_id, object_pos[0], object_pos[1], object_pos[2]);
	GetDynamicObjectRot(object_id, object_rot[0], object_rot[1], object_rot[2]);

	PlayerCache[playerid][pEditObject] = INVALID_OBJECT_ID;

	format(string, sizeof(string), "%d 1", object_model);
	pc_cmd_mc(playerid, string);
	
	new copy_object_id = PlayerCache[playerid][pLastObject],
		object_uid = GetObjectUID(copy_object_id);
	
	if(copy_object_id == INVALID_OBJECT_ID)
	{
		// Coś nie pykło
	    return 1;
	}
	
	SetDynamicObjectPos(copy_object_id, object_pos[0], object_pos[1], object_pos[2]);
	SetDynamicObjectRot(copy_object_id, object_rot[0], object_rot[1], object_rot[2]);
	
	// Materials
	new color1[16], color2[16], modelid[16], txdname[16][32], texturename[16][64],
 		matsize[16], fontsize[16], bold[16], alignment[16], fonttype[16][12], text[16][128];
		
 	new main_query[2048];
 	format(main_query, sizeof(main_query), "INSERT INTO `"SQL_PREF"materials` (material_owner, material_texture, material_index) (SELECT %d, material_texture, material_index FROM `"SQL_PREF"materials` WHERE material_owner = '%d')", object_uid, GetObjectUID(object_id));
 	mysql_query(connHandle, main_query);
 	
	for(new i; i < 16; i++)
	{
		if(IsDynamicObjectMaterialUsed(object_id, i))
		{
			GetDynamicObjectMaterial(object_id, i, modelid[i], txdname[i], texturename[i], color1[i]);
			SetDynamicObjectMaterial(copy_object_id, i, modelid[i], txdname[i], texturename[i], color1[i]);
		}

		if(IsDynamicObjectMaterialTextUsed(object_id, i))
		{
			GetDynamicObjectMaterialText(object_id, i, text[i], matsize[i], fonttype[i], fontsize[i], bold[i], color1[i], color2[i], alignment[i]);
			SetDynamicObjectMaterialText(copy_object_id, i, text[i], matsize[i], fonttype[i], fontsize[i], bold[i], color1[i], color2[i], alignment[i]);
		}
	}
	
	PlayerCache[playerid][pLastObject] = INVALID_OBJECT_ID;
	PlayerCache[playerid][pEditObject] = INVALID_OBJECT_ID;

	OnPlayerSelectDynamicObject(playerid, copy_object_id, object_model, object_pos[0], object_pos[1], object_pos[2]);
	return 1;
}
alias:mcopy("ocopy");

cmd:mget(playerid, params[])
{
   	if(PlayerCache[playerid][pEditObject] == INVALID_OBJECT_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie edytujesz aktualnie żadnego obiektu.");
	    return 1;
	}
	new object_id = PlayerCache[playerid][pEditObject];
	
		// Materials
	new color1[16], color2[16], modelid[16], txdname[16][32], texturename[16][64],
 		matsize[16], fontsize[16], bold[16], alignment[16], fonttype[16][12], text[16][128];
 		
	for(new i; i < 16; i++)
	{
		if(IsDynamicObjectMaterialUsed(object_id, i))
		{
			GetDynamicObjectMaterial(object_id, i, modelid[i], txdname[i], texturename[i], color1[i]);
			SendClientFormatMessage(playerid, COLOR_INFO, "/mmat 0 %d %x %d %s %s", i, color1[i], modelid[i], txdname[i], texturename[i]);
		}

		if(IsDynamicObjectMaterialTextUsed(object_id, i))
		{
			GetDynamicObjectMaterialText(object_id, i, text[i], matsize[i], fonttype[i], fontsize[i], bold[i], color1[i], color2[i], alignment[i]);
            SendClientFormatMessage(playerid, COLOR_INFO, "/mmat 1 %d %d %d %d %x %x %d %s %s", i, matsize[i], fontsize[i], bold[i], color1[i], color2[i], alignment[i], fonttype[i], text[i]);
		}
	}
	return 1;
}
alias:mget("oget");

cmd:rx(playerid, params[])
{
	if(PlayerCache[playerid][pEditObject] == INVALID_OBJECT_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie edytujesz aktualnie żadnego obiektu.");
	    return 1;
	}
	new Float:rot_x;
	if(sscanf(params, "f", rot_x))
	{
	    ShowTipForPlayer(playerid, "/rx [Rotacja X]");
	    return 1;
	}
	new object_id = PlayerCache[playerid][pEditObject],
		Float:PosX, Float:PosY, Float:PosZ,
		Float:RotX, Float:RotY, Float:RotZ;
		
	new player_object = Streamer_GetItemInternalID(playerid, STREAMER_TYPE_OBJECT, object_id);

	GetDynamicObjectPos(object_id, PosX, PosY, PosZ);
	GetPlayerObjectRot(playerid, player_object, RotX, RotY, RotZ);
	
	RotX = rot_x;
	
	SetDynamicObjectRot(object_id, RotX, RotY, RotZ);
	MovePlayerObject(playerid, player_object, PosX, PosY, PosZ, 3.0, RotX, RotY, RotZ);
	
	OnPlayerEditDynamicObject(playerid, object_id, EDIT_RESPONSE_UPDATE, PosX, PosY, PosZ, RotX, RotY, RotZ);
	return 1;
}

cmd:ry(playerid, params[])
{
	if(PlayerCache[playerid][pEditObject] == INVALID_OBJECT_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie edytujesz aktualnie żadnego obiektu.");
	    return 1;
	}
	new Float:rot_y;
	if(sscanf(params, "f", rot_y))
	{
	    ShowTipForPlayer(playerid, "/ry [Rotacja Y]");
	    return 1;
	}
	new object_id = PlayerCache[playerid][pEditObject],
		Float:PosX, Float:PosY, Float:PosZ,
		Float:RotX, Float:RotY, Float:RotZ;

	new player_object = Streamer_GetItemInternalID(playerid, STREAMER_TYPE_OBJECT, object_id);

	GetPlayerObjectRot(playerid, player_object, RotX, RotY, RotZ);
	RotY = rot_y;

	SetDynamicObjectRot(object_id, RotX, RotY, RotZ);
	SetPlayerObjectRot(playerid, player_object, RotX, RotY, RotZ);
	
	GetDynamicObjectPos(object_id, PosX, PosY, PosZ);
	OnPlayerEditDynamicObject(playerid, object_id, EDIT_RESPONSE_UPDATE, PosX, PosY, PosZ, RotX, RotY, RotZ);
	return 1;
}

cmd:rz(playerid, params[])
{
	if(PlayerCache[playerid][pEditObject] == INVALID_OBJECT_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie edytujesz aktualnie żadnego obiektu.");
	    return 1;
	}
	new Float:rot_z;
	if(sscanf(params, "f", rot_z))
	{
	    ShowTipForPlayer(playerid, "/rz [Rotacja Z]");
	    return 1;
	}
	new object_id = PlayerCache[playerid][pEditObject],
	    Float:PosX, Float:PosY, Float:PosZ,
		Float:RotX, Float:RotY, Float:RotZ;

	new player_object = Streamer_GetItemInternalID(playerid, STREAMER_TYPE_OBJECT, object_id);

	GetPlayerObjectRot(playerid, player_object, RotX, RotY, RotZ);
	RotZ = rot_z;

	SetDynamicObjectRot(object_id, RotX, RotY, RotZ);
	SetPlayerObjectRot(playerid, player_object, RotX, RotY, RotZ);
	
	GetDynamicObjectPos(object_id, PosX, PosY, PosZ);
	OnPlayerEditDynamicObject(playerid, object_id, EDIT_RESPONSE_UPDATE, PosX, PosY, PosZ, RotX, RotY, RotZ);
	return 1;
}

cmd:brama(playerid, params[])
{
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_OBJECTS))
	{
		new doorid = GetPlayerDoorID(playerid);
		if(doorid != INVALID_DOOR_ID)
		{
			new DoorData[sDoorInfo];
	  		Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	  		
			if(DoorData[dOwnerType] == OWNER_NONE)
			{
				ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Ten budynek lub strefa nie należy do Ciebie.");
				return 1;
			}
			if(DoorData[dOwnerType] == OWNER_PLAYER)
			{
		 		if(DoorData[dOwner] != PlayerCache[playerid][pUID] && PlayerCache[playerid][pHouse] != DoorData[dUID])
		   		{
					ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Ten budynek lub strefa nie należy do Ciebie.");
		   			return 1;
				}
			}
			if(DoorData[dOwnerType] == OWNER_GROUP)
			{
			    if(!HavePlayerGroupPerm(playerid, DoorData[dOwner], G_PERM_GATE))
			    {
			        ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Ten budynek lub strefa nie należy do Ciebie.");
			        return 1;
			    }
			}
		}
		else
		{
		    new areaid = GetPlayerAreaID(playerid);
		    if(areaid == INVALID_AREA_ID)
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby móc skorzystać z bramy, musisz znajdować się w budynku lub strefie.");
		        return 1;
		    }
		    new AreaData[sAreaData];
		    Streamer_GetArrayData(STREAMER_TYPE_AREA, areaid, E_STREAMER_EXTRA_ID, AreaData);
		    
		    if(AreaData[aOwnerType] == OWNER_NONE)
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Ten budynek lub strefa nie należy do Ciebie.");
		        return 1;
		    }
		    print("/brama [6]");
		    if(AreaData[aOwnerType] == OWNER_PLAYER)
		    {
		        if(AreaData[aOwner] != PlayerCache[playerid][pUID])
		        {
		            ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Ten budynek lub strefa nie należy do Ciebie.");
		            return 1;
		        }
		    }
		    if(AreaData[aOwnerType] == OWNER_GROUP)
		    {
		        if(!HavePlayerGroupPerm(playerid, AreaData[aOwner], G_PERM_GATE))
		        {
		            ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Ten budynek lub strefa nie należy do Ciebie.");
		            return 1;
		        }
		    }
		}
	}
	new object_id, Float:object_pos[6],
	    Float:PosX, Float:PosY, Float:PosZ, virtual_world, Float:dist, count_gates, objData[sObjectData];
	
	if(IsPlayerInAnyVehicle(playerid))  	dist = 8.0;
	else                                	dist = 4.0;
	
	GetPlayerPos(playerid, PosX, PosY, PosZ);
	virtual_world = GetPlayerVirtualWorld(playerid);
	
	new ObjectData[MAX_VIS_OBJECTS],
		count_objects = Streamer_GetNearbyItems(PosX, PosY, PosZ, STREAMER_TYPE_OBJECT, ObjectData, MAX_VIS_OBJECTS, dist, virtual_world);

	for(new object = 0; object < count_objects; object++)
	{
		object_id = ObjectData[object];
		Streamer_GetArrayData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_EXTRA_ID, objData);
		
		if(objData[objGate] == true)
		{
		    GetDynamicObjectPos(object_id, object_pos[0], object_pos[1], object_pos[2]);
		    GetDynamicObjectRot(object_id, object_pos[3], object_pos[4], object_pos[5]);

			if(IsPlayerInRangeOfPoint(playerid, dist, object_pos[0], object_pos[1], object_pos[2]) || IsPlayerInRangeOfPoint(playerid, dist, objData[objGateX], objData[objGateY], objData[objGateZ]))
			{
       	 		if(!IsDynamicObjectMoving(object_id))
       	 		{
       	 		    if(objData[objGateStatus])
       	 		    {
       	 		        GameTextForPlayer(playerid, "~w~Brama ~r~zamknieta", 4000, 6);
						MoveDynamicObject(object_id, objData[objGateX], objData[objGateY], objData[objGateZ], 3.0, objData[objGateRX], objData[objGateRY], objData[objGateRZ]);

						objData[objGateStatus] = false;
       	 		    }
       	 		    else
       	 		    {
       	 		        GameTextForPlayer(playerid, "~w~Brama ~g~otwarta", 4000, 6);
       	 		        MoveDynamicObject(object_id, objData[objGateX], objData[objGateY], objData[objGateZ], 3.0, objData[objGateRX], objData[objGateRY], objData[objGateRZ]);

						objData[objGateStatus] = true;
	   	 		    }

					objData[objGateX] = object_pos[0];
					objData[objGateY] = object_pos[1];
					objData[objGateZ] = object_pos[2];

					objData[objGateRX] = object_pos[3];
					objData[objGateRY] = object_pos[4];
					objData[objGateRZ] = object_pos[5];
       	 		}
                Streamer_SetArrayData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_EXTRA_ID, objData);

       			count_gates ++;
       			continue;
   			}
		}
	}
	
	if(!count_gates)
	{
	    TD_ShowSmallInfo(playerid, 3, "Nie znaleziono ~r~zadnych ~w~bram w poblizu.");
	    return 1;
	}
	return 1;
}

cmd:ec(playerid, params[])
{
	new Float:distance, desc[256];
	if(sscanf(params, "fs[256]", distance, desc))
	{
	    ShowTipForPlayer(playerid, "/ec [Odległość] [Treść]");
	    return 1;
	}
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_3DTEXTS))
	{
		new doorid = GetPlayerDoorID(playerid);
		if(doorid == INVALID_DOOR_ID)
		{
	 		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby móc stworzyć obiekt, musisz znajdować się w budynku.");
	   		return 1;
		}
		new DoorData[sDoorInfo];
	  	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	  	
		if(DoorData[dOwnerType] == OWNER_NONE)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten budynek nie należy do Ciebie.");
			return 1;
		}
		if(DoorData[dOwnerType] == OWNER_PLAYER)
		{
	 		if(DoorData[dOwner] != PlayerCache[playerid][pUID])
	   		{
				ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten budynek nie należy do Ciebie.");
	   			return 1;
			}
		}
		if(DoorData[dOwnerType] == OWNER_GROUP)
		{
			if(!HavePlayerGroupPerm(playerid, DoorData[dOwner], G_PERM_LEADER))
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten budynek nie należy do Ciebie.");
			    return 1;
			}
		}
	}
	new Float:PosX, Float:PosY, Float:PosZ,
	    interior_id = GetPlayerInterior(playerid), world_id = GetPlayerVirtualWorld(playerid);

	GetPlayerPos(playerid, PosX, PosY, PosZ);
	GetXYInFrontOfPlayer(playerid, PosX, PosY, 2.0);
	
	format(desc, sizeof(desc), "%s", WordWrap(desc, WRAP_MANUAL));

	Add3DTextLabel(desc, COLOR_WHITE, PosX, PosY, PosZ, distance, world_id, interior_id);
	Streamer_Update(playerid, STREAMER_TYPE_3D_TEXT_LABEL);
	
	ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Etykieta 3D została pomyślnie stworzona, powinna pojawić się tuż przed Tobą.\nAby zarządzać stworzoną etykietą użyj komendy /esel w pobliżu jej.");
	return 1;
}
alias:ec("tc");

cmd:esel(playerid, params[])
{
	if(PlayerCache[playerid][pEdit3DText] != INVALID_3DTEXT_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aktualnie edytujesz już jakąś etykietę.");
	    return 1;
	}
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_3DTEXTS))
	{
		new doorid = GetPlayerDoorID(playerid);
		if(doorid == INVALID_DOOR_ID)
		{
	 		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Edytować etykiety możesz tylko będąc w budynku, którego właścicielem jesteś.");
	   		return 1;
		}
		new DoorData[sDoorInfo];
	  	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	  	
		if(DoorData[dOwnerType] == OWNER_NONE)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Edytować etykiety możesz tylko będąc w budynku, którego właścicielem jesteś.");
			return 1;
		}
		if(DoorData[dOwnerType] == OWNER_PLAYER)
		{
	 		if(DoorData[dOwner] != PlayerCache[playerid][pUID])
	   		{
				ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Edytować etykiety możesz tylko będąc w budynku, którego właścicielem jesteś.");
	   			return 1;
			}
		}
		if(DoorData[dOwnerType] == OWNER_GROUP)
		{
			if(!HavePlayerGroupPerm(playerid, DoorData[dOwner], G_PERM_LEADER))
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Edytować etykiety możesz tylko będąc w budynku, którego właścicielem jesteś.");
			    return 1;
			}
		}
	}
	new label_id = GetClosestLabel(playerid);
	if(label_id == INVALID_OBJECT_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znaleziono żadnej etykiety w pobliżu.");
	    return 1;
	}
	foreach(new i : Player)
	{
	    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	    {
	        if(PlayerCache[i][pEdit3DText] == label_id)
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ktoś aktualnie edytuje tę etykietę.");
			    return 1;
			}
	    }
	}
	new Float:PosX, Float:PosY, Float:PosZ;
	
	Streamer_GetFloatData(STREAMER_TYPE_3D_TEXT_LABEL, label_id, E_STREAMER_X, PosX);
	Streamer_GetFloatData(STREAMER_TYPE_3D_TEXT_LABEL, label_id, E_STREAMER_Y, PosY);
	Streamer_GetFloatData(STREAMER_TYPE_3D_TEXT_LABEL, label_id, E_STREAMER_Z, PosZ);

	SetPlayerCameraPos(playerid, PosX + 3, PosY + 4, PosZ + 4);
	SetPlayerCameraLookAt(playerid, PosX, PosY, PosZ);

	OnPlayerFreeze(playerid, true, 0);
	PlayerCache[playerid][pEdit3DText] = label_id;

	TD_ShowSmallInfo(playerid, 0, "Edytor etykiety ~g~aktywny~w~.~n~~n~~y~/esave ~w~- zapisz pozycje etykiety~n~~y~/edel ~w~- usun etykiete");
	return 1;
}
alias:esel("tsel");

cmd:esave(playerid, params[])
{
	if(PlayerCache[playerid][pEdit3DText] == INVALID_3DTEXT_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie edytujesz aktualnie żadnej etykiety.");
	    return 1;
	}
	new label_id = PlayerCache[playerid][pEdit3DText];

	OnPlayerFreeze(playerid, false, 0);
	ResetPlayerCamera(playerid);

	Save3DTextLabel(label_id);
	PlayerCache[playerid][pEdit3DText] = INVALID_3DTEXT_ID;

	TD_ShowSmallInfo(playerid, 3, "Pozycja etykiety zostala ~g~pomyslnie ~w~zapisana.");
	return 1;
}
alias:esave("tsave");

cmd:edel(playerid, params[])
{
	if(PlayerCache[playerid][pEdit3DText] == INVALID_3DTEXT_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie edytujesz aktualnie żadnej etykiety.");
	    return 1;
	}
	new label_id = PlayerCache[playerid][pEdit3DText];

	OnPlayerFreeze(playerid, false, 0);
	ResetPlayerCamera(playerid);

	crp_Delete3DTextLabel(label_id);
	PlayerCache[playerid][pEdit3DText] = INVALID_3DTEXT_ID;

	TD_ShowSmallInfo(playerid, 3, "Etykieta zostala ~r~calkowicie ~w~usunieta.");
	return 1;
}
alias:edel("tdel");

cmd:tankuj(playerid, params[])
{
	if(GetPlayerState(playerid) != PLAYER_STATE_ONFOOT)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby zatankować pojazd musisz znajdować się obok niego.");
	    return 1;
	}
	new object_id = GetClosestObjectType(playerid, OBJECT_FUELING);
	if(object_id == INVALID_OBJECT_ID)
	{
 		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znaleziono żadnego dystrybutora w pobliżu.");
   		return 1;
	}
	new bens_type, fuel_value, string[128];
	if(sscanf(params, "dd", bens_type, fuel_value))
	{
	    ShowTipForPlayer(playerid, "/tankuj [Rodzaj paliwa] [Ilość litrów]");
	    
	    SendClientMessage(playerid, COLOR_GREY, " ");
   	 	SendClientMessage(playerid, COLOR_GREY, "Dostępne rodzaje paliwa:");

		SendClientMessage(playerid, COLOR_GREY, "1 - Benzyna");
		SendClientMessage(playerid, COLOR_GREY, "2 - Gaz");
		SendClientMessage(playerid, COLOR_GREY, "3 - Diesel");
	    return 1;
	}
	new vehid = GetClosestVehicle(playerid);
	if(vehid == INVALID_VEHICLE_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znaleziono żadnego pojazdu w pobliżu.");
	    return 1;
	}
	if(bens_type < 0 || bens_type > 3)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wybrano nieprawidłowy rodzaj paliwa.");
	    return 1;
	}
	if((bens_type - 1) != CarInfo[vehid][cFuelType])
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wybrany rodzaj paliwa nie pasuje tego pojazdu.");
	    return 1;
	}
	if(fuel_value <= 0)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłową ilość litrów.");
	    return 1;
	}
	if(fuel_value + CarInfo[vehid][cFuel] > GetVehicleMaxFuel(CarInfo[vehid][cModel]))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "W baku nie zmieści się tyle paliwa.");
	    return 1;
	}
	new price;
	bens_type -= 1;

	if(bens_type == FUEL_TYPE_BENS) 			price = floatround(fuel_value * 4.5);
	else if(bens_type == FUEL_TYPE_GAS) 		price = floatround(fuel_value * 2.5);
	else if(bens_type == FUEL_TYPE_DIESEL) 		price = floatround(fuel_value * 4.0);

	if(PlayerCache[playerid][pCash] < price)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz takiej ilości gotówki.");
	    return 1;
	}
	crp_GivePlayerMoney(playerid, -price);
	orm_update(PlayerCache[playerid][pOrm]);

	CarInfo[vehid][cFuel] = floatadd(CarInfo[vehid][cFuel], fuel_value);
	orm_update(CarInfo[vehid][cOrm]);

	SendClientFormatMessage(playerid, COLOR_LIGHTBLUE, "Zapłaciłeś $%d za %d litrów paliwa.", price, fuel_value);
	ApplyAnimation(playerid, "INT_HOUSE", "wash_up",4.1, 0, 0, 0, 0, 0, 1);

	format(string, sizeof(string), "* %s wkłada wąż do baku.", PlayerName(playerid));
	ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);

	format(string, sizeof(string), "* Pojazd %s został pomyślnie zatankowany (( %s ))", GetVehicleName(CarInfo[vehid][cModel]), PlayerName(playerid));
    ProxDetector(10.0, playerid, string, COLOR_DO, COLOR_DO, COLOR_DO, COLOR_DO, COLOR_DO);
    
    TD_ShowSmallInfo(playerid, 10, "Jezeli tankujesz z pomoca ~y~mechanika ~w~koszt za paliwo wychodzi nawet do ~r~40%% ~w~taniej! Warto wiec sprobowac.");
	return 1;
}
alias:tankuj("zatankuj");

cmd:pokoj(playerid, params[])
{
	new type[32], varchar[32], doorid = GetPlayerDoorID(playerid);
	if(sscanf(params, "s[32]S()[32]", type, varchar))
	{
	    ShowTipForPlayer(playerid, "/pokoj [zamelduj, wymelduj, wejdz, wyjdz, koszt]");
	    return 1;
	}
	if(!strcmp(type, "zamelduj", true))
	{
		if(doorid == INVALID_DOOR_ID)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w hotelu.");
		    return 1;
		}
		new DoorData[sDoorInfo];
	  	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	  	
		if(DoorData[dOwnerType] != OWNER_GROUP)
		{
      		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w hotelu.");
		    return 1;
		}
		new group_id = GetGroupID(DoorData[dOwner]);
		if(GroupData[group_id][gType] != G_TYPE_HOTEL)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w hotelu.");
		    return 1;
		}
	    if(PlayerCache[playerid][pHouse] == DoorData[dOwner])
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Jesteś już zameldowany w tym hotelu.");
	        return 1;
	    }
	    PlayerCache[playerid][pHouse] = DoorData[dUID];
	    ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Wynająłeś pokój w hotelu \"%s\".\nOpłata ($%d) będzie pobierana przy każdej wypłacie.\n\nTwój numer pokoju to: %d", DoorData[dName], GroupData[group_id][gValue1], PlayerCache[playerid][pUID]);
	    return 1;
	}
	if(!strcmp(type, "wymelduj", true))
	{
		if(doorid == INVALID_DOOR_ID)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w hotelu.");
		    return 1;
		}
		new DoorData[sDoorInfo];
	  	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	  	
		if(DoorData[dOwnerType] != OWNER_GROUP)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w hotelu.");
		    return 1;
		}
		new group_id = GetGroupID(DoorData[dOwner]);
		if(GroupData[group_id][gType] != G_TYPE_HOTEL)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w hotelu.");
		    return 1;
		}
	    if(PlayerCache[playerid][pHouse] != DoorData[dUID])
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w hotelu, którym jesteś zameldowany.");
	        return 1;
	    }
	    PlayerCache[playerid][pHouse] = 0;
	    ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Skończyłeś wynajmowanie pokoju w tym hotelu.\nOpłata za wynajm nie będzie już więcej pobierana.");
	    return 1;
	}
	if(!strcmp(type, "wejdz", true))
	{
		if(doorid == INVALID_DOOR_ID)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w hotelu.");
		    return 1;
		}
		new DoorData[sDoorInfo];
	  	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	  	
		if(DoorData[dOwnerType] != OWNER_GROUP)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w hotelu.");
		    return 1;
		}
		new group_id = GetGroupID(DoorData[dOwner]);
		if(GroupData[group_id][gType] != G_TYPE_HOTEL)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w hotelu.");
		    return 1;
		}
	    new room;
	    if(sscanf(varchar, "d", room))
	    {
	        ShowTipForPlayer(playerid, "/pokoj wejdz [Numer pokoju]");
	        return 1;
	    }
	    foreach(new i : Player)
		{
		    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
		    {
		        if(PlayerCache[i][pHouse] == DoorData[dUID])
		        {
		            if(PlayerCache[i][pUID] == room)
		            {
						crp_SetPlayerPos(playerid, PosInfo[HOTEL_SPAWN_POS][sPosX], PosInfo[HOTEL_SPAWN_POS][sPosY], PosInfo[HOTEL_SPAWN_POS][sPosZ]);
						SetPlayerFacingAngle(playerid, PosInfo[HOTEL_SPAWN_POS][sPosA]);
						
						SetPlayerInterior(playerid, PosInfo[HOTEL_SPAWN_POS][sPosInterior]);
						SetPlayerVirtualWorld(playerid, PlayerCache[i][pUID]);
						
						ResetPlayerCamera(playerid);
						TD_ShowSmallInfo(playerid, 3, "Uzyj komendy ~y~/pokoj wyjdz~w~, aby opuscic pokoj.");
						return 1;
		            }
		        }
		    }
		}
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Drzwi od tego pokoju są zamknięte.");
		return 1;
	}
	if(!strcmp(type, "wyjdz", true))
	{
	    if(!IsPlayerInRangeOfPoint(playerid, 30.0, PosInfo[HOTEL_SPAWN_POS][sPosX], PosInfo[HOTEL_SPAWN_POS][sPosY], PosInfo[HOTEL_SPAWN_POS][sPosZ]))
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znajdujesz się w pokoju hotelowym.");
	        return 1;
	    }
	    foreach(new i : Player)
		{
		    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
		    {
		        if(PlayerCache[i][pHouse])
		        {
	      			if(PlayerCache[i][pUID] == GetPlayerVirtualWorld(playerid))
	      			{
	              		new hotel_doorid = GetDoorID(PlayerCache[i][pHouse]);
	              		
      					new DoorData[sDoorInfo];
	  					Streamer_GetArrayData(STREAMER_TYPE_PICKUP, hotel_doorid, E_STREAMER_EXTRA_ID, DoorData);

						crp_SetPlayerPos(playerid, DoorData[dExitX], DoorData[dExitY], DoorData[dExitZ]);

						SetPlayerInterior(playerid, DoorData[dExitInt]);
						SetPlayerVirtualWorld(playerid, DoorData[dExitVW]);

						OnPlayerFreeze(playerid, true, 3);
						return 1;
	      			}
				}
		    }
		}
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Drzwi od tego pokoju są zamknięte.");
	    return 1;
	}
	if(!strcmp(type, "koszt", true))
	{
	    new string[256];
		if(doorid == INVALID_DOOR_ID)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w hotelu.");
		    return 1;
		}
		new DoorData[sDoorInfo];
	  	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	  	
		if(DoorData[dOwnerType] != OWNER_GROUP)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w hotelu.");
		    return 1;
		}
		new group_id = GetGroupID(DoorData[dOwner]);
		if(GroupData[group_id][gType] != G_TYPE_HOTEL)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w hotelu.");
		    return 1;
		}
		if(HavePlayerGroupPerm(playerid, DoorData[dOwner], G_PERM_LEADER))
		{
  			format(string, sizeof(string), "Wprowadź kwotę, jaką chcesz pobierać za wynajem pokoju.\nObecny koszt wynajmu pokoju wynosi $%d.\n\nOpłata za pokój pobierana jest raz dziennie, razem z wydaniem wypłat.", GroupData[group_id][gValue1]);
		    ShowPlayerDialog(playerid, D_ROOM_PRICE, DIALOG_STYLE_INPUT, "Zmień koszt wynajmu", string, "Zmień", "Anuluj");
		}
		else
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Koszt wynajmu pokoju wynosi $%d.\nOpłata za pokój pobierana jest raz dziennie, razem z wydaniem wypłat.", GroupData[group_id][gValue1]);
		}
	    return 1;
	}
	return 1;
}
alias:pokoj("hotel", "motel");

// -- Czaty -- //
cmd:c(playerid, params[])
{
	if(PlayerCache[playerid][pBW])
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz się odzywać podczas stanu nieprzytomności.");
	    return 1;
	}
	if(is_null(params))
	{
	   	ShowTipForPlayer(playerid, "/c [Tekst]");
	    return 1;
	}
	new string[256];
	params[0] = chrtoupper(params[0]);

	if(strlen(params) < 78)
	{
		format(string, sizeof(string), "%s szepcze: %s", PlayerName(playerid), params);
		ProxDetector(2.5, playerid, string, COLOR_FADE1, COLOR_FADE2, COLOR_FADE3, COLOR_FADE4, COLOR_FADE5);
	}
	else
	{
	    new pos = strfind(params, " ", true, strlen(params) / 2);
		if(pos != -1)
		{
  			new text[64];

  			strmid(text, params, pos + 1, strlen(params));
			strdel(params, pos, strlen(params));

			format(string, sizeof(string), "%s szepcze: %s...", PlayerName(playerid), params);
			ProxDetector(2.5, playerid, string, COLOR_FADE1, COLOR_FADE2, COLOR_FADE3, COLOR_FADE4, COLOR_FADE5);

			format(string, sizeof(string), "...%s", text);
			ProxDetector(2.5, playerid, string, COLOR_FADE1, COLOR_FADE2, COLOR_FADE3, COLOR_FADE4, COLOR_FADE5);
		}
	}
	return 1;
}

cmd:k(playerid, params[])
{
	if(PlayerCache[playerid][pBW])
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz się odzywać podczas stanu nieprzytomności.");
	    return 1;
	}
	if(is_null(params))
	{
	    ShowTipForPlayer(playerid, "/k [Tekst]");
	    return 1;
	}
	new string[256];
	params[0] = chrtoupper(params[0]);

	if(strlen(params) < 78)
	{
		format(string, sizeof(string), "%s krzyczy: %s!!", PlayerName(playerid), params);
		ProxDetector(25.0, playerid, string, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_FADE1, COLOR_FADE2);
	}
	else
	{
	    new pos = strfind(params, " ", true, strlen(params) / 2);
		if(pos != -1)
		{
  			new text[64];

  			strmid(text, params, pos + 1, strlen(params));
			strdel(params, pos, strlen(params));

			format(string, sizeof(string), "%s krzyczy: %s...", PlayerName(playerid), params);
			ProxDetector(25.0, playerid, string, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_FADE1, COLOR_FADE2);

			format(string, sizeof(string), "...%s!!", text);
			ProxDetector(25.0, playerid, string, COLOR_WHITE, COLOR_WHITE, COLOR_WHITE, COLOR_FADE1, COLOR_FADE2);
		}
	}
	
	ApplyAnimation(playerid, "ON_LOOKERS", "shout_in", 4.1, 0, 0, 0, 0, 0);
	return 1;
}
alias:k("krzycz", "s");

cmd:l(playerid, params[])
{
	if(PlayerCache[playerid][pBW])
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz się odzywać podczas stanu nieprzytomności.");
	    return 1;
	}
	if(is_null(params))
	{
	    ShowTipForPlayer(playerid, "/l [Tekst]");
	    return 1;
	}
	new string[256];
	params[0] = chrtoupper(params[0]);

	if(strlen(params) < 78)
	{
		format(string, sizeof(string), "%s mówi: %s", PlayerName(playerid), params);
		ProxDetector(10.0, playerid, string, COLOR_FADE1, COLOR_FADE2, COLOR_FADE3, COLOR_FADE4, COLOR_FADE5);
	}
	else
	{
	    new pos = strfind(params, " ", true, strlen(params) / 2);
		if(pos != -1)
		{
  			new text[64];

  			strmid(text, params, pos + 1, strlen(params));
			strdel(params, pos, strlen(params));

			format(string, sizeof(string), "%s mówi: %s...", PlayerName(playerid), params);
			ProxDetector(10.0, playerid, string, COLOR_FADE1, COLOR_FADE2, COLOR_FADE3, COLOR_FADE4, COLOR_FADE5);

			format(string, sizeof(string), "...%s", text);
			ProxDetector(10.0, playerid, string, COLOR_FADE1, COLOR_FADE2, COLOR_FADE3, COLOR_FADE4, COLOR_FADE5);
		}
	}
	return 1;
}

cmd:b(playerid, params[])
{
	if(PlayerCache[playerid][pBW])
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz teraz korzystać z czatu.");
	    return 1;
	}
	if(PlayerCache[playerid][pBlock] & BLOCK_OOC)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Twoja postać ma nałożoną blokadę czatu OOC.");
	    return 1;
	}
	if(is_null(params))
	{
	    ShowTipForPlayer(playerid, "/b [Tekst]");
	    return 1;
	}
	new string[256], get_name[32];
	params[0] = chrtoupper(params[0]);
	
	format(string, sizeof(string), "(( %s ))", params);
	SetPlayerChatBubble(playerid, string, 0xAFAFAF88, 15.0, 10000);
	
	if(PlayerCache[playerid][pItemMask] == INVALID_ITEM_ID)	format(get_name, sizeof(get_name), "[%d] %s", playerid, PlayerName(playerid));
	else													format(get_name, sizeof(get_name), "%s", PlayerName(playerid));

	if(strlen(params) < 78)
	{
  		format(string, sizeof(string), "(( %s: %s ))", get_name, params);
		ProxDetector(10.0, playerid, string, COLOR_GREY, COLOR_GREY, COLOR_FADE3, COLOR_FADE4, COLOR_FADE5);
	}
	else
	{
	    new pos = strfind(params, " ", true, strlen(params) / 2);
		if(pos != -1)
		{
  			new text[64];

  			strmid(text, params, pos + 1, strlen(params));
			strdel(params, pos, strlen(params));

            format(string, sizeof(string), "(( %s: %s...", get_name, params);
			ProxDetector(10.0, playerid, string, COLOR_GREY, COLOR_GREY, COLOR_FADE3, COLOR_FADE4, COLOR_FADE5);

			format(string, sizeof(string), "...%s ))", text);
			ProxDetector(10.0, playerid, string, COLOR_GREY, COLOR_GREY, COLOR_FADE3, COLOR_FADE4, COLOR_FADE5);
		}
	}
	return 1;
}

cmd:me(playerid, params[])
{
	if(is_null(params))
	{
	    ShowTipForPlayer(playerid, "/me [Akcja]");
	    return 1;
	}
	new string[256];
	params[0] = chrtolower(params[0]);

	if(strlen(params) < 78)
	{
		format(string, sizeof(string), "** %s %s", PlayerName(playerid), params);
		ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
	}
	else
	{
	    new pos = strfind(params, " ", true, strlen(params) / 2);
		if(pos != -1)
		{
  			new text[64];

  			strmid(text, params, pos + 1, strlen(params));
			strdel(params, pos, strlen(params));

			format(string, sizeof(string), "** %s %s...", PlayerName(playerid), params);
			ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);

			format(string, sizeof(string), "...%s", text);
			ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
		}
	}
	return 1;
}
alias:me("ja");

cmd:do(playerid, params[])
{
	if(is_null(params))
	{
	    ShowTipForPlayer(playerid, "/do [Sytuacja]");
	    return 1;
	}
	new string[256];
	params[0] = chrtoupper(params[0]);

	if(strlen(params) < 78)
	{
		format(string, sizeof(string), "** %s (( %s ))", params, PlayerName(playerid));
		ProxDetector(10.0, playerid, string, COLOR_DO, COLOR_DO, COLOR_DO, COLOR_DO, COLOR_DO);
	}
	else
	{
	    new pos = strfind(params, " ", true, strlen(params) / 2);
		if(pos != -1)
		{
  			new text[64];

  			strmid(text, params, pos + 1, strlen(params));
			strdel(params, pos, strlen(params));

			format(string, sizeof(string), "** %s...", params);
			ProxDetector(10.0, playerid, string, COLOR_DO, COLOR_DO, COLOR_DO, COLOR_DO, COLOR_DO);

			format(string, sizeof(string), "...%s (( %s ))", text, PlayerName(playerid));
			ProxDetector(10.0, playerid, string, COLOR_DO, COLOR_DO, COLOR_DO, COLOR_DO, COLOR_DO);
		}
	}
	return 1;
}

cmd:sprobuj(playerid, params[])
{
	if(is_null(params))
	{
		ShowTipForPlayer(playerid, "/sprobuj [Akcja np. trafić do kosza]");
	    return 1;
	}
	new string[256],
		loss = random(2);
		
	switch(loss)
	{
		case 0:
		{
  			if(PlayerCache[playerid][pSex])	format(string, sizeof(string), "*** %s zawiódł próbując %s", PlayerName(playerid), params);
			else							format(string, sizeof(string), "*** %s zawiodła próbując %s", PlayerName(playerid), params);
		}
		case 1:
		{
  			if(PlayerCache[playerid][pSex])	format(string, sizeof(string), "*** %s odniósł sukces próbując %s", PlayerName(playerid), params);
			else							format(string, sizeof(string), "*** %s odniosła sukces próbując %s", PlayerName(playerid), params);
		}
	}
	
	ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
	return 1;
}

cmd:w(playerid, params[])
{
	new giveplayer_id, text[128], string[256];
	if(sscanf(params, "us[128]", giveplayer_id, text))
	{
	    ShowTipForPlayer(playerid, "/w [ID gracza] [Tekst]");
	    return 1;
	}
	if(giveplayer_id == playerid)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz wysyłać prywatnej wiadomości do siebie.");
		return 1;
	}
	if(giveplayer_id == INVALID_PLAYER_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
    	return 1;
	}
	if(!PlayerCache[giveplayer_id][pLogged])
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
 		return 1;
	}
	if((PlayerCache[playerid][pBlock] & BLOCK_OOC) && !(PlayerCache[giveplayer_id][pAdmin] & A_PERM_BASIC))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Twoja postać ma nałożoną blokadę czatu OOC.");
	    return 1;
	}
	if(PlayerCache[giveplayer_id][pTogW] && !(PlayerCache[playerid][pAdmin] & A_PERM_BASIC))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz ma wyłączone otrzymywanie prywatnych wiadomości.");
	    return 1;
	}
	if(PlayerCache[playerid][pBW] && !PlayerToPlayer(25.0, playerid, giveplayer_id) && !(PlayerCache[giveplayer_id][pAdmin] & A_PERM_BASIC))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podczas stanu nieprzytomności, wiadomości prywatne możesz wysyłać na określoną odległość.");
    	return 1;
	}
	if(PlayerCache[giveplayer_id][pIgnored][playerid])
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz ignoruje wiadomości przychodzące od Ciebie.");
	    return 1;
	}
	new get_player_name[32], get_giveplayer_name[32]; text[0] = chrtoupper(text[0]);
	printf("[priv][%d][%d][priv][%d][%d] %s » %s", PlayerCache[playerid][pGID], PlayerCache[playerid][pUID], PlayerRealName(playerid), PlayerCache[giveplayer_id][pGID], PlayerCache[giveplayer_id][pUID], text);

	if(PlayerCache[playerid][pItemMask] == INVALID_ITEM_ID)			format(get_player_name, sizeof(get_player_name), "%s [%d]", PlayerName(playerid), playerid);
	else															format(get_player_name, sizeof(get_player_name), "%s", PlayerName(playerid));
	
	if(PlayerCache[giveplayer_id][pItemMask] == INVALID_ITEM_ID)	format(get_giveplayer_name, sizeof(get_giveplayer_name), "%s [%d]", PlayerName(giveplayer_id), giveplayer_id);
	else															format(get_giveplayer_name, sizeof(get_giveplayer_name), "%s", PlayerName(giveplayer_id));

	if(strlen(text) < 78)
	{
	    format(string, sizeof(string), "(( %s: %s ))", get_player_name, text);
	    SendClientMessage(giveplayer_id, COLOR_GOT_PW, string);
	    
	    format(string, sizeof(string), "(( » %s: %s ))", get_giveplayer_name, text);
	    SendClientMessage(playerid, COLOR_SEND_PW, string);
	}
	else
	{
	    new pos = strfind(text, " ", true, strlen(text) / 2);
		if(pos != -1)
		{
  			new text2[64];

  			strmid(text2, text, pos + 1, strlen(text));
			strdel(text, pos, strlen(text));
			
   			format(string, sizeof(string), "(( %s: %s...", get_player_name, text);
		    SendClientMessage(giveplayer_id, COLOR_GOT_PW, string);

		    format(string, sizeof(string), "(( » %s: %s...", get_giveplayer_name, text);
		    SendClientMessage(playerid, COLOR_SEND_PW, string);
		    
   			format(string, sizeof(string), "...%s ))", text2);
   			
		    SendClientMessage(giveplayer_id, COLOR_GOT_PW, string);
		    SendClientMessage(playerid, COLOR_SEND_PW, string);
		}
	}
	//PlayAudioForPlayer(giveplayer_id, AUDIO_MESSAGE);
	
	PlayerCache[giveplayer_id][pLastW] = playerid;
	PlayerCache[playerid][pLastW] = giveplayer_id;
	
	if(PlayerCache[playerid][pTogW])
	{
	    TD_ShowSmallInfo(playerid, 3, "Pamietaj, ze masz ~r~wylaczona ~w~mozliwosc otrzymywania prywatnych ~y~wiadomosci~w~.");
		return 1;
	}

	if(PlayerCache[giveplayer_id][pAFK] > 0)
	{
	    TD_ShowSmallInfo(playerid, 3, "Gracz, do ktorego ~g~wyslano ~w~ta ~y~wiadomosc ~w~jest teraz AFK.");
		return 1;
	}
	return 1;
}
alias:w("pm", "wiadomosc");

cmd:re(playerid, params[])
{
	if(PlayerCache[playerid][pLastW] == INVALID_PLAYER_ID)
	{
	   	ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Z nikim nie pisałeś przez ostatni czas.");
	    return 1;
	}
	if(is_null(params))
	{
	    ShowTipForPlayer(playerid, "/re [Tekst]");
	    return 1;
	}
	new string[256];

	format(string, sizeof(string), "%d %s", PlayerCache[playerid][pLastW], params);
	pc_cmd_w(playerid, string);
	return 1;
}
alias:re("wr");

cmd:tog(playerid, params[])
{
	new type[12], varchar[24];
	if(sscanf(params, "s[12]S()[24]", type, varchar))
	{
	    ShowTipForPlayer(playerid, "/tog [w, g, opis, nick]");
	    return 1;
	}
	if(!strcmp(type, "w", true))
	{
	    if(PlayerCache[playerid][pTogW])
	    {
	        PlayerCache[playerid][pTogW] = false;
	        GameTextForPlayer(playerid, "~n~~n~~n~~n~~n~~n~~n~~y~Otrzymywanie wiadomosci ~g~wlaczone", 3000, 3);
	    }
	    else
	    {
			PlayerCache[playerid][pTogW] = true;
			GameTextForPlayer(playerid, "~n~~n~~n~~n~~n~~n~~n~~y~Otrzymywanie wiadomosci ~r~wylaczone", 3000, 3);
	    }
	    return 1;
	}
	if(!strcmp(type, "g", true))
	{
	    new group_slot;
	    if(sscanf(varchar, "d", group_slot))
	    {
	        ShowTipForPlayer(playerid, "/tog g [slot (1-%d)]", MAX_GROUP_SLOTS);
	        return 1;
	    }
	    group_slot -= 1;
		if(group_slot < 0 || group_slot >= MAX_GROUP_SLOTS)
	    {
	        GameTextForPlayer(playerid, "~r~Nieprawidlowy slot grupy.", 3000, 3);
	        return 1;
	    }
		if(!PlayerGroup[playerid][group_slot][gpUID])
		{
			GameTextForPlayer(playerid, "~r~Nieprawidlowy slot grupy.", 3000, 3);
  			return 1;
		}
	    if(PlayerGroup[playerid][group_slot][gpTogG])
	    {
	        PlayerGroup[playerid][group_slot][gpTogG] = false;
	        TD_ShowSmallInfo(playerid, 5, "Czat OOC grupy (slot: %d) zostal ~g~wlaczony~w~.", group_slot + 1);
	    }
	    else
	    {
     		PlayerGroup[playerid][group_slot][gpTogG] = true;
	        TD_ShowSmallInfo(playerid, 5, "Czat OOC grupy (slot: %d) zostal ~r~wylaczony~w~.", group_slot + 1);
	    }
	    return 1;
	}
	if(!strcmp(type, "opis", true) || !strcmp(type, "desc", true) || !strcmp(type, "nick", true))
	{
	    new Text3D:label_id;
		for (new i = 0; i < MAX_PLAYERS; i++)
		{
		    if(i == playerid || IsPlayerPremium(i))   continue;
		    
 	    	if(!strcmp(type, "nick", true))
		    {
				label_id = PlayerCache[i][pNameTag];
		    }
		    else
		    {
		        label_id = PlayerCache[i][pDescTag];
		    }
		    
		    if(Streamer_IsInArrayData(STREAMER_TYPE_3D_TEXT_LABEL, label_id, E_STREAMER_PLAYER_ID, playerid))
		    {
	        	Streamer_RemoveArrayData(STREAMER_TYPE_3D_TEXT_LABEL, label_id, E_STREAMER_PLAYER_ID, playerid);
			}
			else
			{
			    Streamer_AppendArrayData(STREAMER_TYPE_3D_TEXT_LABEL, label_id, E_STREAMER_PLAYER_ID, playerid);
			}
	    }
	    if(!strcmp(type, "nick", true))
	    {
	        if(PlayerCache[playerid][pTogNick])
	        {
	            PlayerCache[playerid][pTogNick] = false;
	            TD_ShowSmallInfo(playerid, 5, "Nicki innych postaci beda ponownie ~g~widoczne~w~.");
	        }
	        else
	        {
	            PlayerCache[playerid][pTogNick] = true;
	            TD_ShowSmallInfo(playerid, 5, "Nicki innych postaci zostaly ~r~ukryte ~w~(nie dotyczy premium).~n~Uzyj ponownie ~y~/tog nick~w~, by przywrocic widoczosc nickow.");
	        }
	    }
		else
		{
		    if(PlayerCache[playerid][pTogDesc])
		    {
		        PlayerCache[playerid][pTogDesc] = false;
		        TD_ShowSmallInfo(playerid, 5, "Opisy innych postaci beda ponownie ~g~widoczne~w~.");
		    }
		    else
		    {
		        PlayerCache[playerid][pTogDesc] = true;
		        TD_ShowSmallInfo(playerid, 5, "Opisy innych postaci zostaly ~r~ukryte ~w~(nie dotyczy premium).~n~Uzyj ponownie ~y~/tog opis~w~, by przywrocic widoczosc opisow.");
		    }
	    }
	    Streamer_Update(playerid, STREAMER_TYPE_3D_TEXT_LABEL);
	    return 1;
	}
	return 1;
}

cmd:ignoruj(playerid, params[])
{
	new giveplayer_id;
	if(sscanf(params, "u", giveplayer_id))
	{
	    ShowTipForPlayer(playerid, "/ignoruj [ID gracza]");
	    return 1;
	}
	if(giveplayer_id == playerid)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz ignorować swoich wiadomości.");
		return 1;
	}
	if(giveplayer_id == INVALID_PLAYER_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
  		return 1;
	}
	if(!PlayerCache[giveplayer_id][pLogged])
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
  		return 1;
	}
	if(PlayerCache[playerid][pIgnored][giveplayer_id])
	{
	    PlayerCache[playerid][pIgnored][giveplayer_id] = false;
		ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Wiadomości przychodzące od gracza %s nie będą już ignorowane.", PlayerName(giveplayer_id));
	}
	else
	{
	    PlayerCache[playerid][pIgnored][giveplayer_id] = true;
	    ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Wiadomości przychodzące od gracza %s będą od teraz ignorowane.", PlayerName(giveplayer_id));
	}
	return 1;
}

cmd:m(playerid, params[])
{
	if(PlayerCache[playerid][pBW])
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz skorzystać teraz z tej komendy.");
	    return 1;
	}
	if(is_null(params))
	{
	    ShowTipForPlayer(playerid, "/m [Tekst]");
	    return 1;
	}
	if(!HavePlayerItemType(playerid, ITEM_MEGAPHONE))
	{
	     ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz odpowiedniego przedmiotu w swoim ekwipunku.");
	     return 1;
	}
	new string[256];
	if(!strcmp(params, "#M1", true))
	{
	    if(!IsPlayerInGroupType(playerid, G_TYPE_POLICE))
	    {
	        return 1;
	    }
	    
		new audio_handle;
		foreach(new i : Player)
 		{
			if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
			{
				if(IsPlayerInRangeOfPoint(i, 80.0, PlayerCache[playerid][pPosX], PlayerCache[playerid][pPosY], PlayerCache[playerid][pPosZ]))
    			{
    				//audio_handle = Audio_Play(i, AUDIO_LSPD);
    				
    				//Audio_SetFX(i, audio_handle, 4);
				    //Audio_Set3DPosition(i, audio_handle, PlayerCache[playerid][pPosX], PlayerCache[playerid][pPosY], PlayerCache[playerid][pPosZ], 80.0);
				}
			}
 		}
		format(string, sizeof(string), "%s (megafon): Tutaj LSPD, zjedź na pobocze i zgaś silnik!!!", PlayerName(playerid));
		ProxDetector(40.0, playerid, string, COLOR_YELLOW, COLOR_YELLOW, COLOR_YELLOW, COLOR_YELLOW, COLOR_YELLOW);
	    return 1;
	}
 	params[0] = chrtoupper(params[0]);

	if(strlen(params) < 78)
	{
		format(string, sizeof(string), "%s (megafon): %s!!!", PlayerName(playerid), params);
		ProxDetector(40.0, playerid, string, COLOR_YELLOW, COLOR_YELLOW, COLOR_YELLOW, COLOR_YELLOW, COLOR_YELLOW);
	}
	else
	{
	    new pos = strfind(params, " ", true, strlen(params) / 2);
		if(pos != -1)
		{
  			new text[64];

  			strmid(text, params, pos + 1, strlen(params));
			strdel(params, pos, strlen(params));

			format(string, sizeof(string), "%s (megafon): %s...", PlayerName(playerid), params);
			ProxDetector(40.0, playerid, string, COLOR_YELLOW, COLOR_YELLOW, COLOR_YELLOW, COLOR_YELLOW, COLOR_YELLOW);

			format(string, sizeof(string), "...%s!!!", text);
			ProxDetector(40.0, playerid, string, COLOR_YELLOW, COLOR_YELLOW, COLOR_YELLOW, COLOR_YELLOW, COLOR_YELLOW);
		}
	}
	return 1;
}

cmd:i(playerid, params[])
{
	if(PlayerCache[playerid][pAdmin] < A_PERM_MAX)
	{
	   	ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz pisać na czacie globalnym.");
	    return 1;
	}
	if(is_null(params))
	{
		ShowTipForPlayer(playerid, "/i [Tekst]");
	  	return 1;
	}
	new string[256];
	params[0] = chrtoupper(params[0]);

	if(strlen(params) < 78)
	{
		format(string, sizeof(string), "(( %s: %s ))", PlayerName(playerid), params);
		SendClientMessageToAll(COLOR_WHITE, string);
	}
	else
	{
	    new pos = strfind(params, " ", true, strlen(params) / 2);
		if(pos != -1)
		{
  			new text[64];

  			strmid(text, params, pos + 1, strlen(params));
			strdel(params, pos, strlen(params));

			format(string, sizeof(string), "(( %s: %s... ))", PlayerName(playerid), params);
			SendClientMessageToAll(COLOR_WHITE, string);

			format(string, sizeof(string), "(( ...%s ))", text);
			SendClientMessageToAll(COLOR_WHITE, string);
		}
	}
	return 1;
}

cmd:d(playerid, params[])
{
	if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby skorzystać z tej komendy, musisz być na służbie grupy.");
	    return 1;
	}
	new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
	if(!(GroupData[group_id][gFlags] & G_FLAG_DEPARTMENT))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie posiadasz odpowiednich uprawnień do użycia tej komendy.");
	    return 1;
	}
	if(PlayerCache[playerid][pBW])
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz skorzystać teraz z tej komendy.");
	    return 1;
	}
	new text[128], string[256];
	if(sscanf(params, "s[128]", text))
	{
	    ShowTipForPlayer(playerid, "/d [Tekst]");
	    return 1;
	}
	text[0] = chrtoupper(text[0]);
	format(string, sizeof(string), "** [%s] %s: %s **", GroupData[group_id][gTag], PlayerName(playerid), text);

	new other_group_id;
	foreach(new i : Player)
	{
	    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	    {
	        if(PlayerCache[i][pDuty][DUTY_GROUP] != INVALID_GROUP_ID)
	        {
	            other_group_id = PlayerCache[i][pDuty][DUTY_GROUP];
	            if((GroupData[other_group_id][gFlags] & G_FLAG_DEPARTMENT))
	       		{
	        		SendClientMessage(i, COLOR_KREM, string);
				}
			}
	    }
	}
	format(string, sizeof(string), "%s mówi (radio): %s", PlayerName(playerid), text);
	ProxDetector(10.0, playerid, string, COLOR_FADE1, COLOR_FADE2, COLOR_FADE3, COLOR_FADE4, COLOR_FADE5);
	return 1;
}

cmd:cb(playerid, params[])
{
	if(GetPlayerState(playerid) != PLAYER_STATE_DRIVER)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby korzystać z CB radio musisz siedzieć w pojeździe.");
	    return 1;
	}
	new vehid = GetPlayerVehicleID(playerid);
	if(!(CarInfo[vehid][cAccess] & VEH_ACCESS_RADIO))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "W tym pojeździe nie ma zamontowanego CB radio.");
	    return 1;
	}
	if(!CarInfo[vehid][cRadioCanal])
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie ustawiłeś żadnego kanału!");
	    return 1;
	}
	if(is_null(params))
	{
	   	ShowTipForPlayer(playerid, "/cb [Tekst]");
	    return 1;
	}
	new string[256], radio_canal = CarInfo[vehid][cRadioCanal];

	params[0] = chrtoupper(params[0]);
	format(string, sizeof(string), "[K:%d] %s: %s", radio_canal, PlayerName(playerid), params);

	foreach(new i : Player)
	{
	    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	    {
		    if(IsPlayerInAnyVehicle(i))
		    {
				vehid = GetPlayerVehicleID(i);
				if(CarInfo[vehid][cAccess] & VEH_ACCESS_RADIO)
				{
				    if(CarInfo[vehid][cRadioCanal] == radio_canal)
				    {
				        SendClientMessage(i, COLOR_CB_RADIO, string);
				    }
				}
		    }
		}
	}
	return 1;
}

cmd:report(playerid, params[])
{
	new giveplayer_id, text[128], string[256];
	if(sscanf(params, "us[128]", giveplayer_id, text))
	{
	    ShowTipForPlayer(playerid, "/report [ID gracza] [Treść]");
	    return 1;
	}
	if(giveplayer_id == playerid)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz wysłać raportu na siebie.");
		return 1;
	}
	if(giveplayer_id == INVALID_PLAYER_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
  		return 1;
	}
	if(!PlayerCache[giveplayer_id][pLogged])
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
  		return 1;
	}
	if((PlayerCache[playerid][pLastReport]) && PlayerCache[playerid][pLastReport] + 20 >= gettime())
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Zamierzasz wysłać raport zaraz po poprzednim, odczekaj chwilę.");
	    return 1;
	}
	format(string, sizeof(string), "[Raport] %s [%d]: %s (%s [%d])", PlayerName(playerid), playerid, text, PlayerName(giveplayer_id), giveplayer_id);
	SendClientMessage(playerid, COLOR_RED, string);

	foreach(new i : Player)
	{
	    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	    {
	        if((PlayerCache[i][pAdmin] & A_PERM_BASIC) && PlayerCache[i][pDuty][DUTY_ADMIN])
	        {
	            SendClientMessage(i, COLOR_LIGHTRED, string);
	        }
	    }
	}
	PlayerCache[playerid][pLastReport] = gettime();
	ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Za co możesz zostać ukarany?\n\n1. Za kilkukrotne wysyłanie powtarzających się raportów.\n2. Za pytania odnoszące się do administracji na /raport.\n3. Wyzwiska oraz obrazę w stosunku do administracji.");
	return 1;
}
alias:report("raport");

// -- Komendy frakcyjne -- //
cmd:dotacja(playerid, params[])
{
	if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby skorzystać z tej komendy, musisz być na służbie grupy.");
	    return 1;
	}
	new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
	if(GroupData[group_id][gType] != G_TYPE_GOV || !HavePlayerGroupPerm(playerid, GroupData[group_id][gUID], G_PERM_LEADER))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Grupa, na której służbie jesteś nie posiada do tego uprawnień.");
	    return 1;
	}
	new type[32], varchar[32];
	if(sscanf(params, "s[32]S()[32]", type, varchar))
	{
		ShowTipForPlayer(playerid, "/dotacja [wyplata, kapital]");
	    return 1;
	}
	if(!strcmp(type, "wyplata", true))
	{
	  	new group_uid, price;
	  	if(sscanf(varchar, "dd", group_uid, price))
	  	{
	  	    ShowTipForPlayer(playerid, "/dotacja wyplata [UID grupy] [Kwota]");
	  	    return 1;
	  	}
	  	group_id = GetGroupID(group_uid);
	  	if(group_id == INVALID_GROUP_ID)
	  	{
	  	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID grupy.");
	  	    return 1;
	  	}
	  	if(price < 0)
	  	{
	  	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłową kwotę.");
	  	    return 1;
	  	}
	  	new max_dotation = GroupTypeInfo[GroupData[group_id][gType]][gTypeMaxDotation];
	  	if(price <= max_dotation)
	  	{
			GroupData[group_id][gMaxPay] = price;
			orm_update(GroupData[group_id][gOrm]);

			ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Pomyślnie ustalono wyokość dotacji na pracownika dla grupy.\n\nGrupa: %s (UID: %d)\nAktualna kwota dotacji: $%d", GroupData[group_id][gName], GroupData[group_id][gUID], GroupData[group_id][gMaxPay]);
	  	}
	  	else
	  	{
	 		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Dla tego typu grupy maksymalna dotacja może wynieść $%d.", max_dotation);
	  	}
	  	return 1;
	}
	if(!strcmp(type, "kapital", true))
	{
		new group_uid, price;
	  	if(sscanf(varchar, "dd", group_uid, price))
	  	{
	  	    ShowTipForPlayer(playerid, "/dotacja kapital [UID grupy] [Kwota]");
	  	    return 1;
	  	}
	  	new dotation_group = GetGroupID(group_uid);
	  	if(group_id == INVALID_GROUP_ID)
	  	{
	  	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono błędne UID grupy.");
	  	    return 1;
	  	}
	  	if(price < 0)
	  	{
	  	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłową kwotę.");
	  	    return 1;
	  	}
	  	if(GroupData[group_id][gCapital] < price)
	  	{
	  	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz takiej sumy pieniędzy w kapitale grupy.");
	  	    return 1;
	  	}
	  	
	  	GroupData[group_id][gCapital] -= price;
	  	orm_update(GroupData[group_id][gOrm]);
	  	
	  	GroupData[dotation_group][gCapital] += price;
	  	orm_update(GroupData[dotation_group][gOrm]);
	  	
	  	AddGroupTransactionLog(playerid, dotation_group, TRANSACTION_DOTATION, price, gettime(), GroupData[group_id][gUID]);
	  	ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Grupa %s (UID: %d) otrzymała dostację w postaci kapitału: $%d\nObecny stan kapitału grupy: $%d", GroupData[dotation_group][gName], GroupData[dotation_group][gUID], price, GroupData[dotation_group][gCapital]);
	    return 1;
	}
	return 1;
}

cmd:kartoteka(playerid, params[])
{
	if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby skorzystać z tej komendy, musisz być na służbie grupy.");
	    return 1;
	}
	new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
	if(GroupData[group_id][gType] != G_TYPE_POLICE && GroupData[group_id][gType] != G_TYPE_FBI)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Grupa, na której służbie jesteś nie posiada do tego uprawnień.");
	    return 1;
	}
	new giveplayer_id;
	if(sscanf(params, "u", giveplayer_id))
	{
	    ShowTipForPlayer(playerid, "/kartoteka [ID gracza]");
	    return 1;
	}
	if(giveplayer_id == INVALID_PLAYER_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
    	return 1;
	}
	if(!PlayerCache[giveplayer_id][pLogged])
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
    	return 1;
	}
	if(IsPlayerInAnyVehicle(playerid))
	{
		new vehid = GetPlayerVehicleID(playerid);
		if(CarInfo[vehid][cOwnerType] != OWNER_GROUP || CarInfo[vehid][cOwner] != GroupData[group_id][gUID])
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w pojeździe lub budynku należącym do grupy.");
		    return 1;
		}
	}
	else
	{
	    new doorid = GetPlayerDoorID(playerid);
	    if(doorid == INVALID_DOOR_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w pojeździe lub budynku należącym do grupy.");
	        return 1;
	    }
   		new DoorData[sDoorInfo];
	  	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	  	
	    if(DoorData[dOwnerType] != OWNER_GROUP || DoorData[dOwner] != GroupData[group_id][gUID])
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w pojeździe lub budynku należącym do grupy.");
	        return 1;
	    }
	}
	ShowPlayerDirectoryForPlayer(giveplayer_id, playerid);
	PlayerCache[playerid][pMainTable] = PlayerCache[giveplayer_id][pUID];
	return 1;
}

cmd:przeszukaj(playerid, params[])
{
	if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby skorzystać z tej komendy, musisz być na służbie grupy.");
	    return 1;
	}
	new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
	if(!(GroupData[group_id][gFlags] & G_FLAG_SEARCHING))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Grupa, na której służbie jesteś nie posiada do tego uprawnień.");
	    return 1;
	}
	new giveplayer_id, string[128];
	if(sscanf(params, "u", giveplayer_id))
	{
	    if(!IsPlayerInAnyVehicle(playerid))
	    {
	    	ShowTipForPlayer(playerid, "/przeszukaj [ID gracza]");
		}
		else
		{
		    new vehid = GetPlayerVehicleID(playerid);
		    ListVehicleItemsForPlayer(vehid, playerid);
		    
	    	format(string, sizeof(string), "* %s przeszukuje pojazd %s.", PlayerName(playerid), GetVehicleName(CarInfo[vehid][cModel]));
			ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
		}
	    return 1;
	}
	if(giveplayer_id == playerid)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz przeszukiwać siebie.");
		return 1;
	}
	if(giveplayer_id == INVALID_PLAYER_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
    	return 1;
	}
	if(!PlayerCache[giveplayer_id][pLogged])
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
    	return 1;
	}
	if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
	{
 		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
 		return 1;
	}
	if(PlayerCache[playerid][pSearches] != INVALID_PLAYER_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aktualnie przeszukujesz już jakiegoś gracza, odczekaj chwilę.");
	    return 1;
	}
	PlayerCache[playerid][pSearches] = giveplayer_id;
	PlayerCache[playerid][pSearchTime] = 15;

	format(string, sizeof(string), "* %s przeszukuje %s.", PlayerName(playerid), PlayerName(giveplayer_id));
	ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);

	ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Przeszukiwanie gracza w toku.\nOdczekaj kilka sekund, aż przeszukiwanie dobiegnie końca.");
	return 1;
}

cmd:blokuj(playerid, params[])
{
    if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby skorzystać z tej komendy, musisz być na służbie grupy.");
	    return 1;
	}
	new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
	if(GroupData[group_id][gType] != G_TYPE_POLICE)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Grupa, na której służbie jesteś nie posiada do tego uprawnień.");
	    return 1;
	}
  	new vehid = GetClosestVehicle(playerid), string[256];
  	if(vehid == INVALID_VEHICLE_ID)
  	{
  	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znaleziono żadnego pojazdu w pobliżu.");
  	    return 1;
  	}
  	PlayerCache[playerid][pMainTable] = vehid;

  	format(string, sizeof(string), "Wprowadź cenę zdjęcia blokady dla pojazdu %s (UID: %d).\nWłaściciel pojazdu będzie musiał zgłosić się na komisariat, by zdjąć blokadę za podaną kwotę pieniędzy.", GetVehicleName(CarInfo[vehid][cModel]), CarInfo[vehid][cUID]);
  	ShowPlayerDialog(playerid, D_BLOCK_WHEEL, DIALOG_STYLE_INPUT, "Blokada koła", string, "Blokuj", "Anuluj");
	return 1;
}

cmd:blokada(playerid, params[])
{
	if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby skorzystać z tej komendy, musisz być na służbie grupy.");
	    return 1;
	}
	new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
	if(!(GroupData[group_id][gFlags] & G_FLAG_BLOCADE))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Grupa, na której służbie jesteś nie posiada do tego uprawnień.");
	    return 1;
	}
  	new blockade_type, blockade_id;
  	if(sscanf(params, "dd", blockade_type, blockade_id))
  	{
  	    ShowTipForPlayer(playerid, "/blokada [Typ blokady(1-8)] [ID blokady(1-20)]");
  	    return 1;
  	}
  	if(blockade_type <= 0 || blockade_type > 8)
  	{
  	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nieprawidłowy typ blokady.");
  	    return 1;
  	}
  	if(blockade_id <= 0 || blockade_id > 20)
  	{
  	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nieprawidłowe ID blokady.");
  	    return 1;
  	}
  	if(blockade_type == 7 && GroupData[group_id][gType] != G_TYPE_POLICE)
  	{
  	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Grupa, na której służbie jesteś nie posiada uprawnień do rozkładania tego typu blokad.");
  	    return 1;
  	}
  	if(blockade_type == 8 && GroupData[group_id][gType] != G_TYPE_FIREDEPT)
  	{
  	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Grupa, na której służbie jesteś nie posiada uprawnień do rozkładania tego typu blokad.");
  	    return 1;
  	}
  	if(IsPlayerInAnyVehicle(playerid))
  	{
  	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz siedzieć w pojeździe podczas stawiania blokady.");
  	    return 1;
  	}
  	if(IsValidDynamicObject(GroupData[group_id][gExtraArray][blockade_id - 1]))
  	{
  	    DestroyDynamicObject(GroupData[group_id][gExtraArray][blockade_id - 1]);
  	    TD_ShowSmallInfo(playerid, 3, "Blokada zostala ~r~usunieta~w~.");
  	    return 1;
  	}
  	new object_id, Float:PosX, Float:PosY, Float:PosZ, Float:PosA,
  	    virtual_world, interior_id, Float:dist;
  	    
	virtual_world = GetPlayerVirtualWorld(playerid);
	interior_id = GetPlayerInterior(playerid);

  	GetPlayerPos(playerid, PosX, PosY, PosZ);
  	GetPlayerFacingAngle(playerid, PosA);
	
	switch(blockade_type - 1)
	{
	    case 0:
	    {
			dist = 5.0;
		}
		case 1:
		{
			PosA = PosA - 90.0;
			dist = 3.0;
		}
		case 2:
		{
		    PosZ = PosZ - 0.5;
		    dist = 3.0;
		}
		case 3:
		{
			dist = 3.0;
		}
		case 4:
		{
  			PosA = PosA - 180.0;
		    dist = 5.0;
		}
		case 5:
		{
  			PosA = PosA - 180.0;
		    dist = 5.0;
		}
		case 6:
		{
		    PosZ = PosZ - 0.5;
			dist = 5.0;
			
			ApplyAnimation(playerid, "GRENADE", "WEAPON_throwu", 4.0, 0, 0, 0, 0, 0, true);
		}
		case 7:
		{
			PosA = PosA - 180.0;
		    dist = 5.0;
		}
	}
	
	new modelid = BlockadeType[blockade_type - 1];
	GetXYInFrontOfPlayer(playerid, PosX, PosY, dist);
	
	object_id = CreateDynamicObject(modelid, PosX, PosY, PosZ - 0.5, 0.0, 0.0, PosA, virtual_world, interior_id, -1, MAX_DRAW_DISTANCE);
	if(blockade_type == 1)	SetDynamicObjectMaterialText(object_id, 0, GroupData[group_id][gTag], 50, "Arial", 40, 1, -1, 0xFFFFD942, 1);
	
    GroupData[group_id][gExtraArray][blockade_id - 1] = object_id;
    OnPlayerSelectDynamicObject(playerid, object_id, modelid, PosX, PosY, PosZ - 0.5);

	Streamer_Update(playerid, STREAMER_TYPE_OBJECT);
	TD_ShowSmallInfo(playerid, 3, "Blokada zostala ~y~postawiona~w~.");
	return 1;
}

cmd:zabierz(playerid, params[])
{
	new type[32], varchar[32];
	if(sscanf(params, "s[32]S()[32]", type, varchar))
	{
		ShowTipForPlayer(playerid, "/zabierz [prawko, przedmiot]");
	    return 1;
	}
	if(!strcmp(type, "przedmiot", true))
	{
		if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby skorzystać z tej komendy, musisz być na służbie grupy.");
		    return 1;
		}
		new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
		if(GroupData[group_id][gType] != G_TYPE_POLICE && GroupData[group_id][gType] != G_TYPE_ARMY)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Grupa, na której służbie jesteś nie posiada do tego uprawnień.");
		    return 1;
		}
	    new giveplayer_id, item_uid;
	    if(sscanf(varchar, "ud", giveplayer_id, item_uid))
		{
		    ShowTipForPlayer(playerid, "/zabierz przedmiot [ID gracza] [UID przedmiotu]");
	        return 1;
	    }
 		if(giveplayer_id == playerid)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zabrać przedmiotu sobie.");
			return 1;
		}
		if(giveplayer_id == INVALID_PLAYER_ID)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	    	return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
		{
	 		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
	 		return 1;
		}
		new itemid = GetPlayerItemID(giveplayer_id, item_uid);
		if(itemid == INVALID_ITEM_ID)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłowe UID przedmiotu.");
		    return 1;
		}
		if(PlayerItemCache[giveplayer_id][itemid][iUsed])
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zabrać tego przedmiotu, ponieważ jest on w użytku.", "Okej", "");
		    return 1;
		}
		PlayerItemCache[giveplayer_id][itemid][iPlace] = PLACE_PLAYER;
		PlayerItemCache[giveplayer_id][itemid][iOwner] = PlayerCache[playerid][pUID];
		
		orm_update(PlayerItemCache[giveplayer_id][itemid][iOrm]);
		
		UnloadPlayerItem(giveplayer_id, itemid);
		itemid = LoadPlayerItem(playerid, item_uid);

		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Zabrałeś przedmiot %s (UID: %d) graczowi %s.\nPrzedmiot pojawił się w Twoim ekwipunku.", PlayerItemCache[playerid][itemid][iName], PlayerItemCache[playerid][itemid][iUID], PlayerName(giveplayer_id));
		ShowPlayerInfoDialog(giveplayer_id, D_TYPE_INFO, "Gracz %s zabrał Ci przedmiot %s (UID: %d).", PlayerName(playerid), PlayerItemCache[playerid][itemid][iName], PlayerItemCache[playerid][itemid][iUID]);
	    return 1;
	}
	if(!strcmp(type, "prawko", true))
	{
		if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby skorzystać z tej komendy, musisz być na służbie grupy.");
		    return 1;
		}
		new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
		if(GroupData[group_id][gType] != G_TYPE_POLICE)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Grupa, na której służbie jesteś nie posiada do tego uprawnień.");
		    return 1;
		}
 		new giveplayer_id;
	    if(sscanf(varchar, "ud", giveplayer_id))
		{
		    ShowTipForPlayer(playerid, "/zabierz prawko [ID gracza]");
	        return 1;
	    }
  		if(giveplayer_id == playerid)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zabrać przedmiotu sobie.");
			return 1;
		}
		if(giveplayer_id == INVALID_PLAYER_ID)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	    	return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
		{
	 		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
	 		return 1;
		}
		if(!(PlayerCache[giveplayer_id][pDocuments] & DOC_DRIVER))
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz nie posiada prawa jazdy.");
		    return 1;
		}
		if(PlayerCache[giveplayer_id][pPDP] < 21)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz musi mieć przyznanych conajmniej 21 pkt karnych.");
		    return 1;
		}
		PlayerCache[giveplayer_id][pDocuments] -= DOC_DRIVER;
		PlayerCache[giveplayer_id][pPDP] = 0;

		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Zabrałeś prawo jazdy gracza %s.", PlayerName(giveplayer_id));
		ShowPlayerInfoDialog(giveplayer_id, D_TYPE_INFO, "Gracz %s zabrał Ci prawo jazdy.", PlayerName(playerid));
	    return 1;
	}
	return 1;
}

cmd:hak(playerid, params[])
{
	if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby skorzystać z tej komendy, musisz być na służbie grupy.");
	    return 1;
	}
	new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
	if(GroupData[group_id][gType] != G_TYPE_POLICE)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Grupa, na której służbie jesteś nie posiada do tego uprawnień.");
	    return 1;
	}
  	if(GetPlayerState(playerid) != PLAYER_STATE_DRIVER)
  	{
  	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz siedzieć w holowniku.");
  	    return 1;
  	}
	new vehid = GetPlayerVehicleID(playerid);
	if(CarInfo[vehid][cOwnerType] != OWNER_GROUP || CarInfo[vehid][cOwner] != GroupData[group_id][gUID])
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Pojazd musi być przypisany pod grupę.");
	 	return 1;
	}
	if(GetVehicleModel(vehid) != 525)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz siedzieć w holowniku.");
	    return 1;
	}
	new Float:vPosX, Float:vPosY, Float:vPosZ;

	foreach(new carid : Vehicles)
	{
	    if(carid != vehid)
	    {
		    if(CarInfo[carid][cUID])
		    {
			    GetVehiclePos(carid, vPosX, vPosY, vPosZ);
			    if(IsPlayerInRangeOfPoint(playerid, 10.0, vPosX, vPosY, vPosZ))
			    {
			        AttachTrailerToVehicle(carid, vehid);
                    ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Pojazd zostal pomyślnie podczepiony.\nAby go odczepić wciśnij klawisz \"N\".");
					return 1;
			    }
			}
		}
	}
	ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znaleziono żadnego pojazdu w pobliżu.");
	return 1;
}

cmd:gps(playerid, params[])
{
	if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby skorzystać z tej komendy, musisz być na służbie grupy.");
	    return 1;
	}
	new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
	if(GroupData[group_id][gType] != G_TYPE_POLICE)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Grupa, na której służbie jesteś nie posiada do tego uprawnień.");
	    return 1;
	}
  	if(GetPlayerState(playerid) != PLAYER_STATE_DRIVER)
  	{
  	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz siedzieć w pojeździe jako kierowca, by móc włączyć GPS.");
		return 1;
  	}
	new vehid = GetPlayerVehicleID(playerid);
	if(CarInfo[vehid][cOwnerType] != OWNER_GROUP || CarInfo[vehid][cOwner] != GroupData[group_id][gUID])
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz siedzieć w pojeździe należącym do grupy.");
	    return 1;
	}
	if(!CarInfo[vehid][cGPS])
	{
		CarInfo[vehid][cGPS] = true;
		TD_ShowSmallInfo(playerid, 3, "Nadajnik ~b~GPS ~w~zostal ~g~uruchomiony~w~.");
		
  		foreach(new i : Player)
	    {
     		if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
       		{
         		if(IsPlayerInAnyVehicle(i))
           		{
					vehid = GetPlayerVehicleID(i);
					if(CarInfo[vehid][cGPS])
					{
	    				SetPlayerMarkerForPlayer(playerid, i, COLOR_BLUE);
					    SetPlayerMarkerForPlayer(i, playerid, COLOR_BLUE);
					}
     			}
        	}
	    }
	}
	else
	{
	    CarInfo[vehid][cGPS] = false;
   		TD_ShowSmallInfo(playerid, 3, "Nadajnik ~b~GPS ~w~zostal ~r~wylaczony~w~.");
   		
	    foreach(new i : Player)
	    {
     		if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
       		{
	    		SetPlayerMarkerForPlayer(playerid, i, COLOR_NICK);
       		}
	    }
	}
	return 1;
}

cmd:areszt(playerid, params[])
{
	if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby skorzystać z tej komendy, musisz być na służbie grupy.");
	    return 1;
	}
	new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
	if(!(GroupData[group_id][gFlags] & G_FLAG_ARREST))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Grupa, na której służbie jesteś nie posiada do tego uprawnień.");
	    return 1;
	}
	new giveplayer_id, time;
	if(sscanf(params, "ud", giveplayer_id, time))
	{
	    ShowTipForPlayer(playerid, "/areszt [ID gracza] [Czas (godz.)]");
	    return 1;
	}
	if(giveplayer_id == playerid)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz aresztować siebie.");
		return 1;
	}
	if(giveplayer_id == INVALID_PLAYER_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
 		return 1;
	}
	if(!PlayerCache[giveplayer_id][pLogged])
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
 		return 1;
	}
	if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
		return 1;
	}
	if(PlayerCache[giveplayer_id][pArrest])
	{
	    if(time <= 0)
	    {
	        PlayerCache[giveplayer_id][pArrest] = 0;
	        
			ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Gracz %s został zwolniony z aresztu.", PlayerName(giveplayer_id));
			SendClientFormatMessage(giveplayer_id, COLOR_INFO, "%s zwolnił Cię z aresztu.", PlayerName(playerid));
			return 1;
	    }
	    
	    PlayerCache[giveplayer_id][pArrest] = gettime() + (time * 3600);
	    
	    ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Pomyślnie zmieniono czas trwania aresztu graczowi %s. Aktualnie %d godzin.", PlayerName(giveplayer_id), time);
	    SendClientFormatMessage(giveplayer_id, COLOR_INFO, "%s zmienił Ci czas trwania aresztu na %d godzin.", PlayerName(playerid), time);
	}
	else
	{
	    if(time <= 0)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz aresztować gracza na czas mniejszy niż 1 godzina.");
	        return 1;
	    }
	    
	    PlayerCache[giveplayer_id][pArrest] = gettime() + (time * 3600);
	    
		PlayerCache[giveplayer_id][pInteriorID] = GetPlayerInterior(giveplayer_id);
		PlayerCache[giveplayer_id][pVirtualWorld] = GetPlayerVirtualWorld(giveplayer_id);

		GetPlayerPos(giveplayer_id, PlayerCache[giveplayer_id][pPosX], PlayerCache[giveplayer_id][pPosY], PlayerCache[giveplayer_id][pPosZ]);
		orm_update(PlayerCache[giveplayer_id][pOrm]);
		
		ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "%s został pomyślnie aresztowany na czas %d godzin.", PlayerName(giveplayer_id), time);
		SendClientFormatMessage(giveplayer_id, COLOR_INFO, "%s aresztował Cię na czas %d godzin.", PlayerName(playerid), time);
	}
	return 1;
}
alias:areszt("aresztuj");

cmd:kogut(playerid, params[])
{
	if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby skorzystać z tej komendy, musisz być na służbie grupy.");
	    return 1;
	}
	new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
	if(GroupData[group_id][gType] != G_TYPE_POLICE && GroupData[group_id][gType] != G_TYPE_FBI)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Grupa, na której służbie jesteś nie posiada do tego uprawnień.");
	    return 1;
	}
	if(GetPlayerState(playerid) != PLAYER_STATE_DRIVER)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz siedzieć w pojeździe jako kierowca, by móc użyć tej komendy.");
	    return 1;
	}
	new vehid = GetPlayerVehicleID(playerid);
	if(CarInfo[vehid][cOwnerType] != OWNER_GROUP || CarInfo[vehid][cOwner] != GroupData[group_id][gUID])
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w pojeździe należącym do grupy.");
	    return 1;
	}
	new Float:PosX, Float:PosY, Float:PosZ;
	GetPlayerPos(playerid, PosX, PosY, PosZ);
	
	new ObjectData[MAX_VIS_OBJECTS], object_id,
		count_objects = Streamer_GetNearbyItems(PosX, PosY, PosZ, STREAMER_TYPE_OBJECT, ObjectData, MAX_VIS_OBJECTS, 10.0, -1);

	for (new object = 0; object < count_objects; object++)
	{
		object_id = ObjectData[object];
		if(Streamer_GetIntData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_ATTACHED_VEHICLE) == vehid)
		{
  			DestroyDynamicObject(object_id);
			TD_ShowSmallInfo(playerid, 3, "Syrena ~b~policyjna ~w~zostala ~r~schowana~w~.");
			return 1;
		}
	}
	
	GetVehicleModelInfo(CarInfo[vehid][cModel], VEHICLE_MODEL_INFO_FRONTSEAT, PosX, PosY, PosZ);
	
	object_id = CreateDynamicObject(-2055, 0.0, 0.0, 0.0, 0.0, 0.00, 0.0, -1, -1, -1, MAX_DRAW_DISTANCE);
	AttachDynamicObjectToVehicle(object_id, vehid, PosX, PosY, PosZ + 0.95, -2.0, 0.0, 4.0);
		
	Streamer_Update(playerid, STREAMER_TYPE_OBJECT);
	TD_ShowSmallInfo(playerid, 3, "Syrena ~b~policyjna ~w~zostala ~g~wyjeta~w~.");
	return 1;
}
alias:kogut("syrena");

cmd:reanimuj(playerid, params[])
{
	if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
	{
 		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby skorzystać z tej komendy, musisz być na służbie grupy.");
   		return 1;
	}
	new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
	if(GroupData[group_id][gType] != G_TYPE_MEDICAL && GroupData[group_id][gType] != G_TYPE_FIREDEPT)
	{
 		ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Grupa, na której służbie jesteś nie posiada do tego uprawnień.");
   		return 1;
	}
	new giveplayer_id;
	if(sscanf(params, "u", giveplayer_id))
	{
	    ShowTipForPlayer(playerid, "/reanimuj [ID gracza]");
	    return 1;
	}
	if(giveplayer_id == playerid)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz reanimować siebie.");
		return 1;
	}
	if(giveplayer_id == INVALID_PLAYER_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
		return 1;
	}
	if(!PlayerCache[giveplayer_id][pLogged])
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
 		return 1;
	}
	if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
		return 1;
	}
	if(!PlayerCache[giveplayer_id][pBW])
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz nie ma BW.");
	    return 1;
	}
	PlayerCache[giveplayer_id][pBW] = 0;
	PlayerCache[giveplayer_id][pDeathBody] = 0;

	ApplyAnimation(giveplayer_id, "Attractors", "Stepsit_out", 4.0, 0, 1, 1, 0, 1, true);
	OnPlayerFreeze(giveplayer_id, false, 0);

	ResetPlayerCamera(giveplayer_id);
	crp_SetPlayerHealth(giveplayer_id, 20);
	return 1;
}

cmd:reklama(playerid, params[])
{
	if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby skorzystać z tej komendy, musisz być na służbie grupy.");
	    return 1;
	}
	new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
	if(GroupData[group_id][gType] != G_TYPE_NEWS)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Grupa, na której służbie jesteś nie posiada do tego uprawnień.");
	    return 1;
	}
	new desc[128], string[256];
	if(sscanf(params, "s[128]", desc))
	{
 		ShowTipForPlayer(playerid, "/reklama [Treść]");
   		return 1;
	}
	if(!strcmp(desc, "stop", true))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Transmisja reklamy została przerwana.");
	    TextDrawSetString(Text:TextDrawNews, "~y~~h~LSN ~w~~>~ Brak sygnalu nadawania.");
		return 1;
	}
	foreach(new i : Player)
	{
	    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	    {
	        if(PlayerCache[i][pRadioLive] || PlayerCache[i][pRadioInterview] != INVALID_PLAYER_ID)
	        {
	            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Stacja radiowa jest aktualnie zajęta.");
	            return 1;
	        }
	    }
	}
	if(IsPlayerInAnyVehicle(playerid))
	{
		new vehid = GetPlayerVehicleID(playerid);
		if(CarInfo[vehid][cOwnerType] != OWNER_GROUP || CarInfo[vehid][cOwner] != GroupData[group_id][gUID])
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w pojeździe lub budynku należącym do grupy.");
	    	return 1;
		}
	}
	else
	{
 		new doorid = GetPlayerDoorID(playerid);
   		if(doorid == INVALID_DOOR_ID)
	    {
     		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w pojeździe lub budynku należącym do grupy.");
       		return 1;
	    }
   		new DoorData[sDoorInfo];
	  	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	  	
	    if(DoorData[dOwnerType] != OWNER_GROUP || DoorData[dOwner] != GroupData[group_id][gUID])
	    {
     		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w pojeździe lub budynku należącym do grupy.");
       		return 1;
	    }
	}
	escape_pl(desc);

	format(string, sizeof(string), "~y~~h~LSN ~w~~>~ ~g~~h~Reklama: ~w~%s", FormatTextDrawColors(desc));
	TextDrawSetString(Text:TextDrawNews, string);
	return 1;
}

cmd:live(playerid, params[])
{
	if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby skorzystać z tej komendy, musisz być na służbie grupy.");
	    return 1;
	}
	new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
	if(GroupData[group_id][gType] != G_TYPE_NEWS)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Grupa, na której służbie jesteś nie posiada do tego uprawnień.");
	    return 1;
	}
	new type[24], varchar[24];
	if(sscanf(params, "s[24]S()[24]", type, varchar))
	{
	    ShowTipForPlayer(playerid, "/live [start | stop]");
	    return 1;
	}
	if(!strcmp(type, "start", true))
	{
	    if(PlayerCache[playerid][pRadioLive])
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aktualnie prowadzisz już jakąś transmisję na żywo.");
	        return 1;
	    }
	    
	    foreach(new i : Player)
	    {
	        if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	        {
	            if(PlayerCache[i][pRadioLive] || PlayerCache[i][pRadioInterview] != INVALID_PLAYER_ID)
	            {
	                ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Stacja radiowa jest aktualnie zajęta.");
	                return 1;
	            }
	        }
	    }
	    
		PlayerCache[playerid][pRadioLive] = true;

		TextDrawSetString(Text:TextDrawNews, "~y~~h~LSN ~w~~>~ Aktualnie prowadzona jest transmisja na zywo.");
		ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Transmisja na żywo została rozpoczęta.\nUżywaj głównego czatu w celu nadawania w radiu.");
		return 1;
	}
	if(!strcmp(type, "stop", true))
	{
	    if(!PlayerCache[playerid][pRadioLive])
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie prowadzisz żadnej transmisji na żywo.");
	        return 1;
	    }
	    PlayerCache[playerid][pRadioLive] = false;

	    TextDrawSetString(Text:TextDrawNews, "~y~~h~LSN ~w~~>~ Brak sygnalu nadawania.");
	    ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Transmisja na żywo została zakończona pomyślnie.");
	    return 1;
	}
	return 1;
}

cmd:wywiad(playerid, params[])
{
	if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby skorzystać z tej komendy, musisz być na służbie grupy.");
	    return 1;
	}
	new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
	if(GroupData[group_id][gType] != G_TYPE_NEWS)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Grupa, na której służbie jesteś nie posiada do tego uprawnień.");
	    return 1;
	}
	new type[32], varchar[32];
	if(sscanf(params, "s[32]S()[32]", type, varchar))
	{
		ShowTipForPlayer(playerid, "/wywiad [start | stop]");
	    return 1;
	}
	if(!strcmp(type, "start", true))
	{
	    if(PlayerCache[playerid][pRadioInterview] != INVALID_PLAYER_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aktualnie prowadzisz już jakiś wywiad.");
	        return 1;
	    }
	    new giveplayer_id;
	    if(sscanf(varchar, "u", giveplayer_id))
	    {
	        ShowTipForPlayer(playerid, "/wywiad start [ID gracza]");
	        return 1;
	    }
		if(giveplayer_id == playerid)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz prowadzić wywiadu ze sobą.");
			return 1;
		}
		if(giveplayer_id == INVALID_PLAYER_ID)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	    	return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
		{
	 		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
	 		return 1;
		}
		
  		foreach(new i : Player)
	    {
	        if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	        {
	            if(PlayerCache[i][pRadioLive] || PlayerCache[i][pRadioInterview] != INVALID_PLAYER_ID)
	            {
	                ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Stacja radiowa jest aktualnie zajęta.");
	                return 1;
	            }
	        }
	    }
		
		PlayerCache[playerid][pRadioInterview] = giveplayer_id;
		PlayerCache[giveplayer_id][pRadioInterview] = playerid;

		ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Roczpocząłeś wywiad z %s.\nPosługuj się głównym czatem, aby nadawać na antenie.", PlayerName(giveplayer_id));
        ShowPlayerInfoDialog(giveplayer_id, D_TYPE_INFO, "%s rozpoczął z Tobą wywiad.\nPosługuj się głównym czatem, aby nadawać na antenie.", PlayerName(playerid));
		return 1;
	}
	if(!strcmp(type, "stop", true))
	{
	    if(PlayerCache[playerid][pRadioInterview] == INVALID_PLAYER_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aktualnie nie prowadzisz żadnego wywiadu.");
	        return 1;
	    }
	    new interviewer_id = PlayerCache[playerid][pRadioInterview];

	    PlayerCache[playerid][pRadioInterview] = INVALID_PLAYER_ID;
	    PlayerCache[interviewer_id][pRadioInterview] = INVALID_PLAYER_ID;

	    ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Wywiad został zakończony.");
        ShowPlayerInfoDialog(interviewer_id, D_TYPE_INFO, "Wywiad został zakończony.");

		TextDrawSetString(Text:TextDrawNews, "~y~~h~LSN ~w~~>~ Brak sygnalu nadawania.");
		return 1;
	}
	return 1;
}

// --- Komendy podstawowe --- //

/*
cmd:bilard(playerid, params[])
{
	if(GetPlayerState(playerid) != PLAYER_STATE_ONFOOT)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz stać obok stołu bilardowego.");
	    return 1;
	}
	new object_id = GetClosestObjectType(playerid, OBJECT_POOL_TABLE);
	if(object_id == INVALID_OBJECT_ID)
	{
 		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znaleziono żadnego stołu bilardowego w pobliżu.");
   		return 1;
	}
	new Float:ObjectPosX, Float:ObjectPosY, Float:ObjectPosZ,
		Float:ObjectRotX, Float:ObjectRotY, Float:ObjectRotZ;

	GetDynamicObjectPos(object_id, ObjectPosX, ObjectPosY, ObjectPosZ);
	GetDynamicObjectRot(object_id, ObjectRotX, ObjectRotY, ObjectRotZ);

    new Float:Distance, Float:XMultiplier, Float:YMultiplier;
    Distance = floatsqroot(floatpower(ObjectPosX + 0.5 - ObjectPosX, 2) - floatpower(ObjectPosY - ObjectPosY, 2));
    
    ObjectPosZ += 0.95;
    
    // Biała bila
    CreateDynamicObject(3003, ObjectPosX, ObjectPosY, ObjectPosZ, 0, 0, ObjectRotZ);
    
   	ObjectPosX += ((Distance * floatsin(90 + ObjectRotZ, degrees) / floatsin(90, degrees)));
	ObjectPosY += ((Distance * floatsin(ObjectRotZ, degrees) / floatsin(90, degrees)));

	for(new i = 0; i < 14; i++)
	{
	    if(i == 0)
	    {
	        object_id = CreateDynamicObject(2996 + i, ObjectPosX + 0.05, ObjectPosY + 0.05, ObjectPosZ, 0, 0, 0);
	    }

	    if(i > 0 && i < 2)
	    {
	        object_id = CreateDynamicObject(2996 + i, ObjectPosX + 0.05, ObjectPosY + 0.05, ObjectPosZ, 0, 0, 0);
            object_id = CreateDynamicObject(3100 + i, ObjectPosX + 0.05, ObjectPosY - 0.05, ObjectPosZ, 0, 0, 0);
		}

	    if(i > 2 && i < 5)
	    {
	        object_id = CreateDynamicObject(2996 + i, ObjectPosX + 0.05, ObjectPosY + 0.05, ObjectPosZ, 0, 0, 0);
	        object_id = CreateDynamicObject(3100 + i, ObjectPosX + 0.05, ObjectPosY - 0.05, ObjectPosZ, 0, 0, 0);
	    }
	    
	    if(i > 5 && i < 10)
	    {
     		object_id = CreateDynamicObject(2996 + i, ObjectPosX + 0.05, ObjectPosY + 0.05, ObjectPosZ, 0, 0, 0);

	    }

	    GetDynamicObjectPos(object_id, ObjectPosX, ObjectPosY, ObjectPosZ);
	}

	CreateDynamicObject(3100, ObjectPosX + 0.3, ObjectPosY, ObjectPosZ + 0.95, 0, 0, 0);

	CreateDynamicObject(3101, ObjectPosX + 0.35, ObjectPosY + 0.03, ObjectPosZ + 0.95, 0, 0, ObjectRotZ);
	CreateDynamicObject(3102, ObjectPosX + 0.35, ObjectPosY - 0.03, ObjectPosZ + 0.95, 0, 0, 0);

	CreateDynamicObject(3103, ObjectPosX + 0.40, ObjectPosY + 0.08, ObjectPosZ + 0.95, 0, 0, ObjectRotZ);
	CreateDynamicObject(3104, ObjectPosX + 0.40, ObjectPosY - 0.08, ObjectPosZ + 0.95, 0, 0, ObjectRotZ);
	CreateDynamicObject(3105, ObjectPosX + 0.40, ObjectPosY, ObjectPosZ + 0.95, 0, 0, ObjectRotZ);

	CreateDynamicObject(2995, ObjectPosX + 0.45, ObjectPosY + 0.13, ObjectPosZ + 0.95, 0, 0, ObjectRotZ);
	CreateDynamicObject(2996, ObjectPosX + 0.45, ObjectPosY - 0.13, ObjectPosZ + 0.95, 0, 0, ObjectRotZ);
	CreateDynamicObject(2997, ObjectPosX + 0.45, ObjectPosY + 0.03, ObjectPosZ + 0.95, 0, 0, ObjectRotZ);
	CreateDynamicObject(2998, ObjectPosX + 0.45, ObjectPosY - 0.03, ObjectPosZ + 0.95, 0, 0, ObjectRotZ);

	CreateDynamicObject(2999, ObjectPosX + 0.50, ObjectPosY + 0.18, ObjectPosZ + 0.95, 0, 0, ObjectRotZ);
	CreateDynamicObject(3000, ObjectPosX + 0.50, ObjectPosY - 0.18, ObjectPosZ + 0.95, 0, 0, ObjectRotZ);
	CreateDynamicObject(3001, ObjectPosX + 0.50, ObjectPosY + 0.08, ObjectPosZ + 0.95, 0, 0, ObjectRotZ);
	CreateDynamicObject(3002, ObjectPosX + 0.50, ObjectPosY - 0.08, ObjectPosZ + 0.95, 0, 0, ObjectRotZ);
	CreateDynamicObject(3106, ObjectPosX + 0.50, ObjectPosY, ObjectPosZ + 0.95, 0, 0, ObjectRotZ);
	
	return 1;
}
*/

cmd:wyscig(playerid, params[])
{
	if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby skorzystać z tej komendy, musisz być na służbie grupy.");
	    return 1;
	}
	new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
	if(!(GroupData[group_id][gFlags] & G_FLAG_RACE))
	{
	  	ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz odpowiednich uprawnień do użycia tej komendy.");
	    return 1;
	}
	new type[32], varchar[32];
	if(sscanf(params, "s[32]S()[32]", type, varchar))
	{
	    ShowTipForPlayer(playerid, "/wyscig [stworz, zapros, wypros, zapisz, wczytaj, zakoncz]");
	    return 1;
	}
	if(!strcmp(type, "stworz", true))
	{
 		if(GetPlayerState(playerid) != PLAYER_STATE_DRIVER)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz siedzieć w pojeździe jako kierowca, aby móc stworzyć wyścig.");
	        return 1;
	    }
	    if(PlayerCache[playerid][pRaceCreating])
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aktualnie tworzysz już jakiś wyścig.");
	        return 1;
	    }
	    if(RaceInfo[playerid][rStart])
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aktualnie uczestniczysz już w jakimś wyścigu.");
	        return 1;
	    }
	    RaceInfo[playerid][rOwner] 				= playerid;
	    RaceInfo[playerid][rPoint]              = 0;
	    
	    PlayerCache[playerid][pRaceCheckpoints] = 0;
   		for (new checkpoint = 0; checkpoint < MAX_RACE_CP; checkpoint++)
		{
		    RaceInfo[playerid][rCPX][checkpoint] = 0.0;
		    RaceInfo[playerid][rCPY][checkpoint] = 0.0;
		    RaceInfo[playerid][rCPZ][checkpoint] = 0.0;
		}
	    
	    PlayerCache[playerid][pRaceCreating] 	= true;
	    TD_ShowHint(playerid, HINT_NONE, 0, "Rozpoczales ~r~proces ~w~tworzenia wyscigu, ~g~legenda~w~:~n~~n~~y~~k~~VEHICLE_FIREWEAPON~ ~w~- stawia checkpoint~n~~y~~k~~VEHICLE_FIREWEAPON_ALT~ ~w~- ustala linie mety~n~~n~Checkpointy: ~y~%d/%d", RaceInfo[playerid][rPoint], MAX_RACE_CP);
		return 1;
	}
	if(!strcmp(type, "zapros", true))
	{
	    if(RaceInfo[playerid][rOwner] != playerid)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz być liderem wyścigu, by móc zapraszać rywali.");
	        return 1;
	    }
 		if(PlayerCache[playerid][pRaceCreating])
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz teraz zapraszać rywali.");
	        return 1;
	    }
	    new giveplayer_id;
		if(sscanf(varchar, "u", giveplayer_id))
		{
		    ShowTipForPlayer(playerid, "/wyscig zapros [ID gracza]");
		    return 1;
		}
  		if(giveplayer_id == playerid)
    	{
     		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz zaprosić do wyścigu siebie.");
       		return 1;
     	}
		if(giveplayer_id == INVALID_PLAYER_ID)
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
   			return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(!PlayerToPlayer(10.0, playerid, giveplayer_id))
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
	    	return 1;
		}
		if(RaceInfo[giveplayer_id][rOwner] != INVALID_PLAYER_ID)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz uczestniczy już w jakimś wyścigu.");
		    return 1;
		}
		RaceInfo[giveplayer_id][rOwner] = playerid;
		PlayerCache[giveplayer_id][pRaceCheckpoints] = PlayerCache[playerid][pRaceCheckpoints];
		
		for (new checkpoint = 0; checkpoint < MAX_RACE_CP; checkpoint++)
		{
		    RaceInfo[giveplayer_id][rCPX][checkpoint] = 0.0;
		    RaceInfo[giveplayer_id][rCPY][checkpoint] = 0.0;
		    RaceInfo[giveplayer_id][rCPZ][checkpoint] = 0.0;
		    
			if(checkpoint <= PlayerCache[giveplayer_id][pRaceCheckpoints])
			{
   				RaceInfo[giveplayer_id][rCPX][checkpoint] = RaceInfo[playerid][rCPX][checkpoint];
			    RaceInfo[giveplayer_id][rCPY][checkpoint] = RaceInfo[playerid][rCPY][checkpoint];
			    RaceInfo[giveplayer_id][rCPZ][checkpoint] = RaceInfo[playerid][rCPZ][checkpoint];
			}
		}
		
		ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Gracz %s został zaproszony do wyścigu.", PlayerName(giveplayer_id));
		SendClientFormatMessage(giveplayer_id, COLOR_INFO, "Gracz %s zaprosił Cię do wyścigu.", PlayerName(playerid));
	    return 1;
	}
	if(!strcmp(type, "wypros", true))
	{
	    if(RaceInfo[playerid][rOwner] != playerid)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz być liderem wyścigu, by móc zapraszać rywali.");
	        return 1;
	    }
	    if(RaceInfo[playerid][rStart])
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz teraz wypraszać rywali.");
	        return 1;
	    }
	    new giveplayer_id;
		if(sscanf(varchar, "u", giveplayer_id))
		{
		    ShowTipForPlayer(playerid, "/wyscig wypros [ID gracza]");
		    return 1;
		}
  		if(giveplayer_id == playerid)
    	{
     		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz wyprosić z wyścigu siebie.");
       		return 1;
     	}
		if(giveplayer_id == INVALID_PLAYER_ID)
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
   			return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(!PlayerToPlayer(10.0, playerid, giveplayer_id))
		{
  			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
	    	return 1;
		}
		if(RaceInfo[giveplayer_id][rOwner] != playerid)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz nie uczestniczy w Twoim wyścigu.");
		    return 1;
		}
		RaceInfo[giveplayer_id][rOwner] = INVALID_PLAYER_ID;
		PlayerCache[giveplayer_id][pRaceCheckpoints] = 0;
		
		for (new checkpoint = 0; checkpoint < MAX_RACE_CP; checkpoint++)
		{
		    RaceInfo[giveplayer_id][rCPX][checkpoint] = 0.0;
		    RaceInfo[giveplayer_id][rCPY][checkpoint] = 0.0;
		    RaceInfo[giveplayer_id][rCPZ][checkpoint] = 0.0;
		}
		
		ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Gracz %s został wyproszony z wyścigu.", PlayerName(giveplayer_id));
		SendClientFormatMessage(giveplayer_id, COLOR_INFO, "Gracz %s wyprosił Cię z wyścigu.", PlayerName(playerid));
	    return 1;
	}
	if(!strcmp(type, "start", true))
	{
 		if(RaceInfo[playerid][rOwner] != playerid)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie jesteś liderem żadnego wyścigu.");
	        return 1;
	    }
		if(PlayerCache[playerid][pRaceCreating])
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz teraz rozpocząć wyścigu.");
		    return 1;
		}
		if(RaceInfo[playerid][rStart])
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz teraz rozpocząć wyścigu.");
		    return 1;
		}
		
		new racer_count;
		foreach(new i : Player)
		{
		    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
		    {
		        if(RaceInfo[i][rOwner] != INVALID_PLAYER_ID && RaceInfo[i][rOwner] == playerid)
		        {
		            racer_count ++;
		        
		            GameTextForPlayer(i, "~w~Wyscig ~g~rozpoczety!", 5000, 3);
		        
		            RaceInfo[i][rPoint] = 0;
		            RaceInfo[i][rStart] = gettime();
		            
		            SetPlayerRaceCheckpoint(i, 0, RaceInfo[i][rCPX][0], RaceInfo[i][rCPY][0], RaceInfo[i][rCPZ][0], RaceInfo[i][rCPX][1], RaceInfo[i][rCPY][1], RaceInfo[i][rCPZ][1], 10.0);
					TD_ShowSmallInfo(i, 0, "Wyscig ~y~trwa ~w~wjezdzaj w ~r~czerwone punkty~w~.~n~Nie opuszczaj swojego pojazdu.~n~~n~Checkpoint: ~y~%d/%d~n~~w~Twoj czas: ~p~~h~00:00", RaceInfo[i][rPoint], PlayerCache[i][pRaceCheckpoints]);
				}
		    }
		}
	    return 1;
	}
	if(!strcmp(type, "zapisz", true))
	{
		if(RaceInfo[playerid][rOwner] != playerid)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie jesteś liderem żadnego wyścigu.");
	        return 1;
	    }
		if(PlayerCache[playerid][pRaceCreating])
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz teraz zapisać wyścigu.");
		    return 1;
		}
		if(RaceInfo[playerid][rStart])
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz teraz zapisać wyścigu.");
		    return 1;
		}
		if(RaceInfo[playerid][rPoint] < 10)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Zapisać możesz tylko wyścigi mające więcej niż 10 checkpointów.");
		    return 1;
		}
  		if(!IsPlayerPremium(playerid))
    	{
     		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ta opcja jest dostępna tylko dla graczy posiadających aktywne konto premium.");
     		return 1;
	    }
		new string[256];
		
		format(string, sizeof(string), "Wprowadź poniżej nazwę dla tego wyścigu.\nNazwa nie może przekraczać 64 znaków.\n\nPróbujesz zapisać wyścig z %d checkpointami.", RaceInfo[playerid][rPoint]);
		ShowPlayerDialog(playerid, D_RACE_SAVE, DIALOG_STYLE_INPUT, "Zapisz wyścig", string, "Zapisz", "Anuluj");
	    return 1;
	}
	if(!strcmp(type, "wczytaj", true))
	{
 		if(PlayerCache[playerid][pRaceCreating])
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aktualnie tworzysz już jakiś wyścig.");
	        return 1;
	    }
	    if(RaceInfo[playerid][rStart])
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aktualnie uczestniczysz już w jakimś wyścigu.");
	        return 1;
	    }
	    new race_list[512],
	        race_uid, race_title[64];
	        
	    new rows, Cache:tmp_cache, query[256];
	    
		mysql_format(connHandle, query, sizeof(query), "SELECT `race_uid`, `race_title` FROM `"SQL_PREF"races` WHERE race_owner = '%d'", GroupData[group_id][gUID]);
	    tmp_cache = mysql_query(connHandle, query);
	    
	    cache_get_row_count(rows);
	    for(new row = 0; row != rows; row++)
	    {
	        cache_get_value_index_int(row, 0, race_uid);
	        cache_get_value_index(row, 1, race_title);
	        
			format(race_list, sizeof(race_list), "%s\n%d\t\t%s", race_list, race_uid, race_title);
	    }
     	if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
	    
	    if(strlen(race_list) > 0)
	    {
	    	ShowPlayerDialog(playerid, D_RACE_SELECT, DIALOG_STYLE_LIST, "Lista wyścigów grupy", race_list, "Wybierz", "Anuluj");
		}
		else
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie ma żadnych wyścigów przypisanych pod grupę.");
		}
	    return 1;
	}
	if(!strcmp(type, "zakoncz", true))
	{
	    if(RaceInfo[playerid][rOwner] == INVALID_PLAYER_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie bierzesz udziału w żadnym wyścigu.");
	        return 1;
	    }
	    DisablePlayerRaceCheckpoint(playerid);
	    
		RaceInfo[playerid][rOwner]				= INVALID_PLAYER_ID;
		RaceInfo[playerid][rStart]				= 0;

		RaceInfo[playerid][rPoint]				= 0;
		RaceInfo[playerid][rTime]				= 0;

		RaceInfo[playerid][rPosition]			= 0;
		
		PlayerCache[playerid][pRaceCreating]	= false;
		PlayerCache[playerid][pRaceCheckpoints]	= 0;
		
		TD_ShowSmallInfo(playerid, 10, "Przestales ~r~brac udzial ~w~w wyscigu.");
	    return 1;
	}
	return 1;
}
alias:wyscig("race");

cmd:taguj(playerid, params[])
{
	if(PlayerCache[playerid][pTaggingObject] != INVALID_OBJECT_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aktualnie malujesz już jakiś tag.");
	    return 1;
	}
	if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
	{
 		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz być na służbie grupy gangu, żeby móc namalować tag.");
   		return 1;
	}
	new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP];
	if(!(GroupData[group_id][gFlags] & G_FLAG_TAG))
	{
 		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz odpowiednich uprawnień do tagowania.");
   		return 1;
	}
	if(PlayerCache[playerid][pItemWeapon] == INVALID_ITEM_ID)
	{
 		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz mieć spray w użyciu.");
   		return 1;
	}
	new itemid = PlayerCache[playerid][pItemWeapon];
	if(PlayerItemCache[playerid][itemid][iType] != ITEM_WEAPON || PlayerItemCache[playerid][itemid][iValue][0] != 41)
	{
 		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz mieć spray w użyciu.");
 		return 1;
	}
	new object_id = GetClosestObjectType(playerid, OBJECT_TAG);
	if(object_id == INVALID_OBJECT_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znajdujesz się przy znaczniku, na którym możesz namalować tag.");
	    return 1;
	}
	PlayerCache[playerid][pTaggingObject] 	= object_id;
	PlayerCache[playerid][pTaggingTime]     = 750;
	
	PlayerCache[playerid][pMainTable]       = group_id;
	ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Możesz zacząć rzutować TAG.\nUżyj spraya i zacznij psikać nim na znacznik.");
	return 1;
}

cmd:kosz(playerid, params[])
{
	if(PlayerCache[playerid][pBasketObject] != INVALID_OBJECT_ID)
	{
	    DestroyDynamicObject(PlayerCache[playerid][pBasketBall]);
	    
	    PlayerCache[playerid][pBasketObject] 	= INVALID_OBJECT_ID;
	    PlayerCache[playerid][pBasketBall]      = INVALID_OBJECT_ID;
	    
		TD_ShowSmallInfo(playerid, 3, "Gra w kosza zostala ~r~zakonczona~w~.");
	}
	else
	{
		new object_id = GetClosestObjectType(playerid, OBJECT_BASKET);
		if(object_id == INVALID_OBJECT_ID)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znaleziono używalnego obiektu kosza w pobliżu.");
		    return 1;
		}
		foreach(new i : Player)
		{
		    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
		    {
		        if(PlayerCache[i][pBasketObject] == object_id)
		        {
		            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ktoś aktualnie rzuca do tego kosza.");
		            return 1;
		        }
		    }
		}
	    PlayerCache[playerid][pBasketObject] = object_id;
		PlayerCache[playerid][pBasketBall] = CreateDynamicObject(2114, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1, -1, -1, MAX_DRAW_DISTANCE);
	    
	    TD_ShowSmallInfo(playerid, 0, "Rozpoczales gre w ~y~kosza~w~.~n~Uzyj klawisza ~g~PPM~w~, by ustalic pozycje rzutu.");
	}
	return 1;
}

cmd:admins(playerid, params[])
{
	new text[256];
	if(sscanf(params, "s[256]", text))
	{
		new list_admins[1024];
		foreach(new i : Player)
		{
		    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
		    {
		        if(PlayerCache[i][pDuty][DUTY_ADMIN])
		        {
          			format(list_admins, sizeof(list_admins), "%s\n%d\t---\t{%s}%s{FFFFFF}", list_admins, i, AdminColor[PlayerCache[i][pAdminType]], PlayerName(i));
		        }
		    }
		}
		if(strlen(list_admins))
		{
		    ShowPlayerDialog(playerid, D_PERMS, DIALOG_STYLE_LIST, "Administratorzy on-line:", list_admins, "Uprawnienia", "Zamknij");
		}
		else
		{
		    TD_ShowSmallInfo(playerid, 3, "Nie ma ~r~zadnych ~w~administratorow online.");
		}
		return 1;
	}
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_BASIC))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz skorzystać z tej komendy.");
	    return 1;
	}
	new string[256];
	text[0] = chrtoupper(text[0]);

	format(string, sizeof(string), "(( [AC] {%s}%s{EEE8AA}: %s ))", AdminColor[PlayerCache[playerid][pAdminType]], PlayerName(playerid), text);
	foreach(new i : Player)
	{
	    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	    {
	        if(PlayerCache[i][pAdmin] & A_PERM_BASIC)
	        {
	            SendClientMessage(i, COLOR_ADMIN, string);
	        }
	    }
	}
	return 1;
}
alias:admins("a");

cmd:pokaz(playerid, params[])
{
	new type[32], varchar[32];
	if(sscanf(params, "s[32]S()[32]", type, varchar))
	{
	    ShowTipForPlayer(playerid, "/pokaz [id, licencje, metryczke, poczytalnosc, odznake, cennik]");
	    return 1;
	}
	if(!strcmp(type, "id", true))
	{
		if(!(PlayerCache[playerid][pDocuments] & DOC_PROOF))
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz tego dokumentu.");
	        return 1;
	    }
	    new giveplayer_id, string[256];
	    if(sscanf(varchar, "u", giveplayer_id))
	    {
	        ShowTipForPlayer(playerid, "/pokaz id [ID gracza]");
	        return 1;
	    }
    	if(giveplayer_id == INVALID_PLAYER_ID)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	    	return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
		{
	 		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
	 		return 1;
		}
		format(string, sizeof(string), "Imię, nazwisko:\t%s\nRok urodzenia:\t%d", PlayerRealName(playerid), PlayerCache[playerid][pBirth]);
		ShowPlayerDialog(giveplayer_id, D_NONE, DIALOG_STYLE_MSGBOX, "** Identyfikator **", string, "OK", "");

		if(PlayerCache[playerid][pSex] == 0)	format(string, sizeof(string), "* %s pokazała identyfikator %s.", PlayerName(playerid), PlayerName(giveplayer_id));
		else                                    format(string, sizeof(string), "* %s pokazał identyfikator %s.", PlayerName(playerid), PlayerName(giveplayer_id));

		ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
	    return 1;
	}
	if(!strcmp(type, "licencje", true))
	{
		if(!(PlayerCache[playerid][pDocuments] & DOC_DRIVER))
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz tego dokumentu.");
	        return 1;
	    }
	    new giveplayer_id, string[256];
	    if(sscanf(varchar, "u", giveplayer_id))
	    {
	        ShowTipForPlayer(playerid, "/pokaz licencje [ID gracza]");
	        return 1;
	    }
    	if(giveplayer_id == INVALID_PLAYER_ID)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	    	return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
		{
	 		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
	 		return 1;
		}
		format(string, sizeof(string), "Imię, nazwisko:\t%s\nRok urodzenia:\t%d", PlayerRealName(playerid), PlayerCache[playerid][pBirth]);
		ShowPlayerDialog(giveplayer_id, D_NONE, DIALOG_STYLE_MSGBOX, "** Licencja prowadzenia pojazdów **", string, "OK", "");

		if(PlayerCache[playerid][pSex] == 0)	format(string, sizeof(string), "* %s pokazała licencje %s.", PlayerName(playerid), PlayerName(giveplayer_id));
		else                                    format(string, sizeof(string), "* %s pokazał licencje %s.", PlayerName(playerid), PlayerName(giveplayer_id));
		
		ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
	    return 1;
	}
	if(!strcmp(type, "metryczke", true))
	{
		if(!(PlayerCache[playerid][pDocuments] & DOC_SEND))
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz tego dokumentu.");
	        return 1;
	    }
	    new giveplayer_id, string[256];
	    if(sscanf(varchar, "u", giveplayer_id))
	    {
	        ShowTipForPlayer(playerid, "/pokaz metryczke [ID gracza]");
	        return 1;
	    }
    	if(giveplayer_id == INVALID_PLAYER_ID)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	    	return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
		{
	 		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
	 		return 1;
		}
		format(string, sizeof(string), "Imię, nazwisko:\t%s\nRok urodzenia:\t%d\n\nStan zdrowia:\tNienaganny", PlayerRealName(playerid), PlayerCache[playerid][pBirth]);
		ShowPlayerDialog(giveplayer_id, D_NONE, DIALOG_STYLE_MSGBOX, "** Metryczka zdrowia **", string, "OK", "");

		format(string, sizeof(string), "* %s pokazał metryczkę zdrowia %s.", PlayerName(playerid), PlayerName(giveplayer_id));
		ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
	    return 1;
	}
	if(!strcmp(type, "poczytalnosc", true))
	{
		if(!(PlayerCache[playerid][pDocuments] & DOC_SANITY))
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz tego dokumentu.");
	        return 1;
	    }
	    new giveplayer_id, string[256];
	    if(sscanf(varchar, "u", giveplayer_id))
	    {
	        ShowTipForPlayer(playerid, "/pokaz poczytalnosc [ID gracza]");
	        return 1;
	    }
    	if(giveplayer_id == INVALID_PLAYER_ID)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	    	return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
		{
	 		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
	 		return 1;
		}
		format(string, sizeof(string), "Imię, nazwisko:\t%s\nRok urodzenia:\t%d", PlayerRealName(playerid), PlayerCache[playerid][pBirth]);
		ShowPlayerDialog(giveplayer_id, D_NONE, DIALOG_STYLE_MSGBOX, "** Zaświadczenie o poczytalności **", string, "OK", "");

		format(string, sizeof(string), "* %s pokazał zaświadczenie o poczytalności %s.", PlayerName(playerid), PlayerName(giveplayer_id));
		ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
	    return 1;
	}
	if(!strcmp(type, "odznake", true))
	{
	    if(PlayerCache[playerid][pDuty][DUTY_GROUP] == INVALID_GROUP_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby skorzystać z tej komendy, musisz być na służbie grupy.");
	        return 1;
	    }
	    new giveplayer_id, title[64], string[256];
	    if(sscanf(varchar, "u", giveplayer_id))
	    {
	        ShowTipForPlayer(playerid, "/pokaz odznake [ID gracza]");
	        return 1;
	    }
    	if(giveplayer_id == INVALID_PLAYER_ID)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	    	return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
		{
	 		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
	 		return 1;
		}
		new group_id = PlayerCache[playerid][pDuty][DUTY_GROUP], group_slot = GetPlayerGroupSlot(playerid, GroupData[group_id][gUID]);
		format(title, sizeof(title), "** %s **", GroupData[group_id][gName]);

		format(string, sizeof(string), "Imię, nazwisko:\t%s\nRok urodzenia:\t%d\nTytuł:\t\t%s", PlayerRealName(playerid), PlayerCache[playerid][pBirth], PlayerGroup[playerid][group_slot][gpTitle]);
		ShowPlayerDialog(giveplayer_id, D_NONE, DIALOG_STYLE_MSGBOX, title, string, "OK", "");

		format(string, sizeof(string), "* %s pokazał odznakę %s.", PlayerName(playerid), PlayerName(giveplayer_id));
		ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
		return 1;
	}
	if(!strcmp(type, "cennik", true))
	{
	    new giveplayer_id;
	    if(sscanf(varchar, "u", giveplayer_id))
	    {
	        ShowTipForPlayer(playerid, "/pokaz cennik [ID gracza]");
	        return 1;
	    }
    	if(giveplayer_id == INVALID_PLAYER_ID)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
	    	return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
		{
	 		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
	 		return 1;
		}
		new doorid = GetPlayerDoorID(playerid);
		if(doorid == INVALID_DOOR_ID)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w budynku firmy, aby móc pokazać cennik.");
		    return 1;
		}
		new DoorData[sDoorInfo];
	  	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	  	
		if(DoorData[dOwnerType] == OWNER_GROUP)
		{
		    if(!HavePlayerGroupPerm(playerid, DoorData[dOwner], G_PERM_OFFER))
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz pokazać cennika.");
		        return 1;
		    }
		}
		new group_id = GetGroupID(DoorData[dOwner]), string[128];
		if(GroupData[group_id][gType] == G_TYPE_CARDEALER)
		{
			new cat_list[256],
			    category_uid, category_name[24];
			    
			new rows, Cache:tmp_cache = mysql_query(connHandle, "SELECT * FROM `"SQL_PREF"salon_category`");
			
			cache_get_row_count(rows);
			for(new row = 0; row != rows; row++)
			{
			    cache_get_value_index_int(row, 0, category_uid);
			    cache_get_value_index(row, 1, category_name, 24);
			    
			    format(cat_list, sizeof(cat_list), "%s\n%d. %s", cat_list, category_uid, category_name);
			}
			if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
			
			if(strlen(cat_list))
			{
			    ShowPlayerDialog(giveplayer_id, D_SALON_CATEGORY, DIALOG_STYLE_LIST, "Wybierz kategorię:", cat_list, "Wybierz", "Anuluj");
			    
   				format(string, sizeof(string), "* %s pokazał cennik %s.", PlayerName(playerid), PlayerName(giveplayer_id));
				ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
			}
			else
			{
			    TD_ShowSmallInfo(playerid, 3, "Nie znaleziono ~r~zadnych ~w~pojazdow w salonie.");
			}
		}
		else
		{
			ListGroupProductsForPlayer(group_id, giveplayer_id, PRODUCT_LIST_PRICE);
			
			format(string, sizeof(string), "* %s pokazał cennik %s.", PlayerName(playerid), PlayerName(giveplayer_id));
			ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
		}
  		return 1;
	}
	return 1;
}

cmd:pay(playerid, params[])
{
	new giveplayer_id, price, string[128];
	if(sscanf(params, "ud", giveplayer_id, price))
	{
	    ShowTipForPlayer(playerid, "/pay [ID gracza] [Kwota]");
	    return 1;
	}
	if(PlayerCache[playerid][pHours] < 5)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz mieć przegrane conajmniej 5h, by móc użyć tej komendy.");
	    return 1;
	}
	if(giveplayer_id == playerid)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz podać pieniedzy sobie.");
		return 1;
	}
	if(giveplayer_id == INVALID_PLAYER_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
  		return 1;
	}
	if(!PlayerCache[giveplayer_id][pLogged])
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
  		return 1;
	}
	if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
		return 1;
	}
	if(PlayerCache[giveplayer_id][pHours] < 5)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz podać pieniędzy temu graczu, dopóki nie przegra 5h.");
	    return 1;
	}
	if(price <= 0)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłową kwotę.");
	    return 1;
	}
	if(PlayerCache[playerid][pCash] < price)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz takiej ilości gotówki.");
	    return 1;
	}
	crp_GivePlayerMoney(playerid, -price);
	crp_GivePlayerMoney(giveplayer_id, price);

	orm_update(PlayerCache[playerid][pOrm]);
	orm_update(PlayerCache[giveplayer_id][pOrm]);

	ApplyAnimation(playerid, "DEALER", "shop_pay", 4.1, 0, 0, 0, 0, 0, true);

	format(string, sizeof(string), "* %s podaje trochę gotówki %s.", PlayerName(playerid), PlayerName(giveplayer_id));
	ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);

	SendClientFormatMessage(playerid, COLOR_LIGHTBLUE, "Podałeś $%d dla gracza %s.", price, PlayerName(giveplayer_id));
	SendClientFormatMessage(giveplayer_id, COLOR_LIGHTBLUE, "Otrzymałeś $%d od gracza %s.", price, PlayerName(playerid));
	
	printf("[cash] %s (UID: %d, GID: %d) podał $%d dla %s (UID: %d, GID: %d).", PlayerRealName(playerid), PlayerCache[playerid][pUID], PlayerCache[playerid][pGID], price, PlayerRealName(giveplayer_id), PlayerCache[giveplayer_id][pUID], PlayerCache[giveplayer_id][pGID]);
	return 1;
}
alias:pay("plac");

cmd:getvw(playerid, params[])
{
	ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "VirtualWorld w którym się obecnie znajdujesz to %d.", GetPlayerVirtualWorld(playerid));
	return 1;
}

cmd:time(playerid, params[])
{
	if(PlayerCache[playerid][pBW])
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz tego zrobić będąc nieprzytomnym.");
	    return 1;
	}
	if(!HavePlayerItemType(playerid, ITEM_WATCH))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz zegarka w swoim ekwipunku.");
	    return 1;
	}
	new hour, minute, second, string[128];
	gettime(hour, minute, second);

	format(string, sizeof(string), "~w~Godzina: ~p~%02d:%02d:%02d", hour, minute, second);
	GameTextForPlayer(playerid, string, 5000, 1);

	format(string, sizeof(string), "* %s spogląda na zegarek.", PlayerName(playerid));
	ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);

	ApplyAnimation(playerid, "COP_AMBIENT", "Coplook_watch", 4.1, 0, 0, 0, 0, 0, 1);
	return 1;
}
alias:time("czas", "zegarek");

cmd:kostka(playerid, params[])
{
	if(PlayerCache[playerid][pBW])
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz tego zrobić będąc nieprzytomnym.");
	    return 1;
	}
	if(!HavePlayerItemType(playerid, ITEM_CUBE))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz kostki do gry w swoim ekwipunku.");
	    return 1;
	}
	new rand = 1 + random(6), string[128];

	format(string, sizeof(string), "* %s wyrzucił %d oczek na 6.", PlayerName(playerid), rand);
	ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
	return 1;
}

cmd:wepchnij(playerid, params[])
{
	new giveplayer_id;
	if(sscanf(params, "u", giveplayer_id))
	{
	    ShowTipForPlayer(playerid, "/wepchnij [ID gracza]");
	    return 1;
	}
	if(GetPlayerState(playerid) != PLAYER_STATE_DRIVER)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz siedzieć w pojeździe jako kierowca.");
	    return 1;
	}
	if(giveplayer_id == playerid)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz wepchnąć siebie.");
		return 1;
	}
	if(giveplayer_id == INVALID_PLAYER_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
    	return 1;
	}
	if(!PlayerCache[giveplayer_id][pLogged])
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
    	return 1;
	}
	if(!PlayerToPlayer(5.0, playerid, giveplayer_id))
	{
 		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID znajduje się zbyt daleko od Ciebie.");
 		return 1;
	}
	if(!PlayerCache[giveplayer_id][pBW])
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz, którego chcesz wepchnąć musi być nieprzytomny.");
	    return 1;
	}
 	new vehid = GetPlayerVehicleID(playerid),
		seatid = GetFreeVehicleSeat(vehid);

	if(seatid != INVALID_VEHICLE_ID)
 	{
  		PlayerCache[giveplayer_id][pLastVeh] = vehid;

		PutPlayerInVehicle(giveplayer_id, vehid, seatid);
		OnPlayerFreeze(giveplayer_id, true, 0);
  	}
   	else
   	{
    	TD_ShowSmallInfo(playerid, 3, "Brak ~r~wolnego miejsca ~w~w pojezdzie.");
   	}
	return 1;
}

cmd:wyrzuc(playerid, params[])
{
	new giveplayer_id, string[128];
	if(sscanf(params, "u", giveplayer_id))
	{
	    ShowTipForPlayer(playerid, "/wyrzuc [ID gracza]");
	    return 1;
	}
	if(GetPlayerState(playerid) != PLAYER_STATE_DRIVER)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz siedzieć w pojeździe jako kierowca.");
		return 1;
	}
	if(giveplayer_id == playerid)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz wyrzucić siebie.");
		return 1;
	}
	if(giveplayer_id == INVALID_PLAYER_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
  		return 1;
	}
	if(!PlayerCache[giveplayer_id][pLogged])
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
  		return 1;
	}
	if(!IsPlayerInAnyVehicle(giveplayer_id))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz musi siedzieć w pojeździe.");
		return 1;
	}
	if(GetPlayerVehicleID(playerid) != GetPlayerVehicleID(giveplayer_id))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz musi siedzieć w tym samym pojeździe.");
	    return 1;
	}
	format(string, sizeof(string), "~n~~n~~n~~n~~n~~n~~w~Gracz ~p~%s ~w~wyrzuca Cie z pojazdu", PlayerName(playerid));
	GameTextForPlayer(giveplayer_id, string, 5000, 3);

	format(string, sizeof(string), "~n~~n~~n~~n~~n~~n~~w~Wyrzucasz gracza ~p~%s ~w~z pojazdu", PlayerName(giveplayer_id));
	GameTextForPlayer(playerid, string, 5000, 3);

	RemovePlayerFromVehicle(giveplayer_id);
	return 1;
}

cmd:zapukaj(playerid, params[])
{
	new string[128];
	
	new Float:PosX, Float:PosY, Float:PosZ,
		virtual_world = GetPlayerVirtualWorld(playerid);

	GetPlayerPos(playerid, PosX, PosY, PosZ);

	new NearDoor[MAX_VIS_DOORS],
		count_doors = Streamer_GetNearbyItems(PosX, PosY, PosZ, STREAMER_TYPE_PICKUP, NearDoor, MAX_VIS_DOORS, 2.0, virtual_world);

	if(count_doors > 0)
	{
		for (new door = 0; door < count_doors; door++)
		{
			foreach(new i : Player)
			{
			    if(i != playerid)
			    {
			    	if(GetPlayerDoorID(i) == NearDoor[door])
			    	{
						SendClientMessage(i, COLOR_DO, "** Słychać dźwięk pukania dobiegający od drzwi wejściowych. **");
			    	}
				}
			}
			ApplyAnimation(playerid, "HEIST9", "Use_SwipeCard", 4.1, 0, 0, 0, 0, 0, true);

			format(string, sizeof(string), "* %s puka do drzwi.", PlayerName(playerid));
			ProxDetector(10.0, playerid, string, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE, COLOR_PURPLE);
			break;
		}
	}
	return 1;
}

cmd:silownia(playerid, params[])
{
	if(PlayerCache[playerid][pGymObject] != INVALID_OBJECT_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Obecnie korzystasz już z jakiegoś obiektu sportowego.");
	    return 1;
	}
	if(!PlayerCache[playerid][pGymTime])
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Zanim zaczniesz trening, musisz użyć karnetu.");
	    return 1;
	}
	new type[12];
	if(sscanf(params, "s[12]", type))
	{
	    ShowTipForPlayer(playerid, "/silownia [laweczka, hantle]");
	    return 1;
	}
	if(!strcmp(type, "laweczka", true))
	{
	    new object_id = GetClosestObjectType(playerid, OBJECT_BENCH);
	    if(object_id == INVALID_OBJECT_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znaleziono ławeczki w pobliżu.");
	        return 1;
	    }
	    
	    foreach(new i : Player)
	    {
	        if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	        {
				if(PlayerCache[i][pGymObject] == object_id)
				{
				    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ktoś aktualnie korzysta z tego obiektu sportowego.");
				    return 1;
				}
	        }
	    }
	    new Float:ObjPosX, Float:ObjPosY, Float:ObjPosZ,
	        Float:ObjRotX, Float:ObjRotY, Float:ObjRotZ;
	        
		GetDynamicObjectPos(object_id, ObjPosX, ObjPosY, ObjPosZ);
		GetDynamicObjectRot(object_id, ObjRotX, ObjRotY, ObjRotZ);
		
		GetXYInFrontOfObject(object_id, ObjPosX, ObjPosY, 1.0);
	    
	    SetPlayerPos(playerid, ObjPosX, ObjPosY, ObjPosZ + 1.0);
	    SetPlayerFacingAngle(playerid, ObjRotZ);
	    
	    PlayerCache[playerid][pGymObject] = object_id;

	   	ApplyAnimation(playerid, "BENCHPRESS", "gym_bp_down", 4.0, 0, 0, 0, 1, 0, true);
	    SetPlayerAttachedObject(playerid, SLOT_TRAIN, 2913, 6, 0.0, 0.0, -0.2);

        ShowPlayerInfoDialog(playerid, D_TYPE_HELP, "Rozpocząłeś trening na ławeczce wyciskanej.\n\nWciśnij i przytrzymaj klawisz sprintu, aby wykonać pełne powtórzenie,\njeżeli zobaczysz, że wycisnąłeś sztangę maksymalnie, upuść klawisz.\n\nPowtarzaj opisaną czynność, by zdobyć większą ilość punktów siły.\nAby zakończyć trening wciśnij ENTER.");
		TD_ShowHint(playerid, HINT_NONE, 0, "Powtorzenia: ~b~~h~%d~n~~n~Mozesz sprobowac tez ~r~treningu ~w~po uzyciu ~y~odzywek~w~, ktore zakupisz w silowni.", PlayerCache[playerid][pGymRepeat]);
	    return 1;
	}
	
	if(!strcmp(type, "hantle", true))
	{
 		new object_id = GetClosestObjectType(playerid, OBJECT_BARBELL);
	    if(object_id == INVALID_OBJECT_ID)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znaleziono ławeczki w pobliżu.");
	        return 1;
	    }

	    foreach(new i : Player)
	    {
	        if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	        {
				if(PlayerCache[i][pGymObject] == object_id)
				{
				    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ktoś aktualnie korzysta z tego obiektu sportowego.");
				    return 1;
				}
	        }
	    }
	    new Float:ObjPosX, Float:ObjPosY, Float:ObjPosZ,
	        Float:ObjRotX, Float:ObjRotY, Float:ObjRotZ;

		GetDynamicObjectPos(object_id, ObjPosX, ObjPosY, ObjPosZ);
		GetDynamicObjectRot(object_id, ObjRotX, ObjRotY, ObjRotZ);

		GetXYInFrontOfObject(object_id, ObjPosX, ObjPosY, 1.0);

	    SetPlayerPos(playerid, ObjPosX, ObjPosY, ObjPosZ + 1.0);
	    SetPlayerFacingAngle(playerid, ObjRotZ);
	    
	    PlayerCache[playerid][pGymObject] = object_id;

	   	ApplyAnimation(playerid, "FREEWEIGHTS", "gym_free_down", 4.0, 0, 0, 0, 1, 0, true);
	    SetPlayerAttachedObject(playerid, SLOT_TRAIN, 2915, 6, 0.0, 0.0, -0.45, 0.0, 90.0, 0.0);
	    
	    ShowPlayerInfoDialog(playerid, D_TYPE_HELP, "Rozpocząłeś trening za pomocą hantli.\n\nWciśnij i przytrzymaj klawisz sprintu, aby wykonać pełne powtórzenie,\njeżeli zobaczysz, że wycisnąłeś hantle maksymalnie, upuść klawisz.\n\nPowtarzaj opisaną czynność, by zdobyć większą ilość punktów siły.\nAby zakończyć trening wciśnij ENTER.");
	    TD_ShowHint(playerid, HINT_NONE, 0, "Powtorzenia: ~b~~h~%d~n~~n~Mozesz sprobowac tez ~r~treningu ~w~po uzyciu ~y~odzywek~w~, ktore zakupisz w silowni.", PlayerCache[playerid][pGymRepeat]);
		return 1;
	}
	return 1;
}
alias:silownia("trenuj");

cmd:bus(playerid, params[])
{
	if(PlayerCache[playerid][pBW] || PlayerCache[playerid][pBusRide] || PlayerCache[playerid][pBusStart] != INVALID_OBJECT_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz teraz użyć tej komendy.");
	    return 1;
	}
	new object_id = GetClosestObjectType(playerid, OBJECT_BUSSTOP);
	if(object_id == INVALID_OBJECT_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znajdujesz się na przystanku autobusowym.");
	    return 1;
	}
	new player_group,
	    taxi_workers;
	    
	foreach(new i : Player)
	{
	    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	    {
	        if(PlayerCache[i][pDuty][DUTY_GROUP] != INVALID_GROUP_ID)
	        {
				player_group = PlayerCache[i][pDuty][DUTY_GROUP];
				if(GroupData[player_group][gType] == G_TYPE_TAXI)
				{
				    taxi_workers ++;
				}
	        }
	    }
	}
	
	if(taxi_workers >= 3)
	{
	    if(PlayerCache[playerid][pHours] > 5)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Na służbie taxi jest więcej niż 3 pracowników!\nSkorzystaj z taksówki (/tel %d), by dotrzeć w docelowe miejsce.", NUMBER_TAXI);
	        return 1;
	    }
	}
	
	new bus_object_uid;
	if(sscanf(params, "d", bus_object_uid))
	{
		new Float:ObjPosX, Float:ObjPosY, Float:ObjPosZ;
		GetDynamicObjectPos(object_id, ObjPosX, ObjPosY, ObjPosZ);

		SetPlayerCameraPos(playerid, ObjPosX, ObjPosY, ObjPosZ + 60.0);
	    SetPlayerCameraLookAt(playerid, ObjPosX, ObjPosY + 2, ObjPosZ, CAMERA_MOVE);

		PlayerCache[playerid][pBusPosition][0] = ObjPosX;
		PlayerCache[playerid][pBusPosition][1] = ObjPosY;
		PlayerCache[playerid][pBusPosition][2] = ObjPosZ;

		OnPlayerFreeze(playerid, true, 0);
		PlayerCache[playerid][pBusStart] = object_id;

		TD_ShowSmallInfo(playerid, 0, "Uzywaj klawiszy ~y~strzalek, ~w~by dowolnie zmieniac pozycje widoku z lotu ptaka.~n~~n~~y~~k~~PED_JUMPING~ ~w~- wybierz najblizszy przystanek~n~~y~~k~~VEHICLE_ENTER_EXIT~ ~w~- anuluj przejazdzke");
		return 1;
	}
	
    new bus_object_id = GetObjectID(bus_object_uid);
    if(bus_object_id == INVALID_OBJECT_ID || GetObjectModel(bus_object_id) != OBJECT_BUSSTOP || bus_object_id == object_id)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłowy numer przystanku.");
	    return 1;
	}
	new Float:PosX, Float:PosY, Float:PosZ,
	    Float:Distance, string[256];
	    
	PlayerCache[playerid][pBusTravel] = bus_object_id;
	GetDynamicObjectPos(object_id, PosX, PosY, PosZ);
	
	Streamer_GetDistanceToItem(PosX, PosY, PosZ, STREAMER_TYPE_OBJECT, bus_object_id, Distance);

	PlayerCache[playerid][pBusTime] = floatround(Distance, floatround_floor) / 15;
	PlayerCache[playerid][pBusPrice] = floatround(Distance, floatround_floor) / 20;

	if(PlayerCache[playerid][pHours] < 5)	PlayerCache[playerid][pBusPrice] = 0;

	format(string, sizeof(string), "Przejazd: %d <-> %d\n\nCzas trwania jazdy: %ds\nKoszt przejazdu: $%d\n\nCzy jesteś pewien, że chcesz się tutaj udać?", GetObjectUID(object_id), GetObjectUID(bus_object_id), PlayerCache[playerid][pBusTime], PlayerCache[playerid][pBusPrice]);
	ShowPlayerDialog(playerid, D_BUS_ACCEPT, DIALOG_STYLE_MSGBOX, "Bus", string, "Tak", "Nie");
	return 1;
}

cmd:anim(playerid, params[])
{
	DynamicGui_Init(playerid);

	new list_anims[2048];
	foreach(new anim_id : Anim)
	{
	    if(PlayerCache[playerid][pEditActor] != INVALID_ACTOR_ID && AnimCache[anim_id][aAction])    continue;
	    
	    format(list_anims, sizeof(list_anims), "%s\n%s", list_anims, AnimCache[anim_id][aCommand]);
	    DynamicGui_AddRow(playerid, D_PLAY_ANIM, anim_id);
	}
	
	if(strlen(list_anims))
	{
	    ShowPlayerDialog(playerid, (PlayerCache[playerid][pEditActor] == INVALID_ACTOR_ID) ? D_PLAY_ANIM : D_ACTOR_ANIM, DIALOG_STYLE_LIST, "Lista animacji:", list_anims, "Start", "Zamknij");
	}
	else
	{
	    TD_ShowSmallInfo(playerid, 3, "Nie znaleziono ~r~zadnych ~w~animacji.");
	}
	return 1;
}
alias:anim("animacje");

cmd:opis(playerid, params[])
{
	new desc[256];
	if(sscanf(params, "s[256]", desc))
	{
	    ShowTipForPlayer(playerid, "/opis [Treść opisu] | Aby usunąć opis, użyj komendy /opis usun.");
		return 1;
	}
	if(!strcmp(desc, "usun", true))
	{
 		UpdateDynamic3DTextLabelText(Text3D:PlayerCache[playerid][pDescTag], COLOR_DESC, " ");
		TD_ShowSmallInfo(playerid, 3, "Opis postaci zostal ~g~pomyslnie ~w~usuniety.");
	    return 1;
	}
	format(desc, sizeof(desc), "%s", WordWrap(desc, WRAP_AUTO));
	
	UpdateDynamic3DTextLabelText(Text3D:PlayerCache[playerid][pDescTag], COLOR_DESC, desc);
 	ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Ustalono nowy opis postaci:\n\n%s", desc);

    Streamer_SetIntData(STREAMER_TYPE_3D_TEXT_LABEL, Text3D:PlayerCache[playerid][pDescTag], E_STREAMER_ATTACHED_PLAYER, playerid);
    Streamer_SetFloatData(STREAMER_TYPE_3D_TEXT_LABEL, Text3D:PlayerCache[playerid][pDescTag], E_STREAMER_Z, -0.6);
	return 1;
}

cmd:id(playerid, params[])
{
	new nick[24], list_players[256];
    if(sscanf(params, "s[24]", nick))
	{
        foreach(new i : Player)
        {
            if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned] && PlayerCache[i][pSpectate] == INVALID_PLAYER_ID)
            {
                if(PlayerToPlayer(10.0, playerid, i))
                {
                    format(list_players, sizeof(list_players), "%s\n%d\t%s", list_players, i, PlayerName(i));
                }
            }
        }
        if(strlen(list_players))
        {
            ShowPlayerDialog(playerid, D_PLAYER_LIST, DIALOG_STYLE_LIST, "Gracze znajdujący się w pobliżu:", list_players, "PW", "Zamknij");
        }
        else
        {
            ShowTipForPlayer(playerid, "/id [Część nicku]");
        }
		return 1;
    }
	if(strlen(nick) < 3)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz wpisać przynajmniej 3 znaki.");
		return 1;
	}
	new name[24];
	foreach(new i : Player)
   	{
   	    GetPlayerName(i, name, sizeof(name));
        if(strfind(name, nick, true) >= 0 || strfind(PlayerCache[i][pGlobName], nick, true) >= 0)
		{
			format(list_players, sizeof(list_players), "%s\n%d\t%s", list_players, i, PlayerName(i));
		}
    }
	if(strlen(list_players))
	{
	    ShowPlayerDialog(playerid, D_PLAYER_LIST, DIALOG_STYLE_LIST, "Znaleziono graczy:", list_players, "PW", "Zamknij");
	}
	else
	{
	    TD_ShowSmallInfo(playerid, 3, "Nie znaleziono ~r~zadnych ~w~graczy.");
	}
    return 1;
}

cmd:yo(playerid, params[])
{
	new type;
	if(sscanf(params, "d", type))
	{
		ShowTipForPlayer(playerid, "/yo [typ (1-7)]");
	    return 1;
	}
	if(type < 1 || type > 7)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłowy typ powitania (1-7).");
	    return 1;
	}
	new giveplayer_id = GetPlayerCameraTargetPlayer(playerid);
	if(giveplayer_id == INVALID_PLAYER_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znaleziono żadnego gracza w pobliżu (musisz na niego patrzeć).");
	    return 1;
	}
	if(!PlayerCache[giveplayer_id][pLogged])
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
 		return 1;
	}
 	OnPlayerSendOffer(playerid, giveplayer_id, "Powitanie", OFFER_WELCOME, type, 0, 0);
	return 1;
}

cmd:kiss(playerid, params[])
{
	new type;
	if(sscanf(params, "d", type))
	{
		ShowTipForPlayer(playerid, "/kiss [1-3]");
	    return 1;
	}
	if(type < 1 || type > 3)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłowy typ pocałunku (1-3).");
	    return 1;
	}
	new giveplayer_id = GetClosestPlayer(playerid);
	if(giveplayer_id == INVALID_PLAYER_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znaleziono żadnego gracza w pobliżu.");
	    return 1;
	}
	if(!PlayerCache[giveplayer_id][pLogged])
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
 		return 1;
	}
	OnPlayerSendOffer(playerid, giveplayer_id, "Pocalunek", OFFER_WELCOME, type + 7, 0, 0);
	return 1;
}

cmd:paczka(playerid, params[])
{
	if(PlayerCache[playerid][pPackage] != INVALID_PACKAGE_ID)
	{
		DisablePlayerCheckpoint(playerid);
		
		PlayerCache[playerid][pCheckpoint] 	= CHECKPOINT_NONE;
		PlayerCache[playerid][pPackage]	 	= INVALID_PACKAGE_ID;
		
		TD_ShowSmallInfo(playerid, 3, "Dostarczanie paczki zostalo ~r~anulowane~w~.");
	    return 1;
	}

	new list_packages[1024], doorid, DoorData[sDoorInfo];
	DynamicGui_Init(playerid);
	    
	new rows, package_uid, package_dooruid, package_type;
	mysql_query(connHandle, "SELECT `package_uid`, `package_dooruid`, `package_type` FROM `"SQL_PREF"packages`");
	
	cache_get_row_count(rows);
	if(rows > 0)
	{
	    for(new row = 0; row != rows; row++)
	    {
	        cache_get_value_index_int(row, 0, package_uid);
	        
			cache_get_value_index_int(row, 1, package_dooruid);
			cache_get_value_index_int(row, 2, package_type);
			
			doorid = GetDoorID(package_dooruid);
			if(doorid == INVALID_DOOR_ID)   continue;
			
			Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);

			if(package_type == PACKAGE_DRUGS || package_type == PACKAGE_WEAPON)
			{
				if(!IsPlayerInGroup(playerid, DoorData[dOwner]))    continue;
			}
			else
			{
			    if(!IsPlayerInGroup(playerid, DoorData[dOwner]) && WorkInfo[playerid][wID] != JOB_COURIER)  continue;
			}
			
			format(list_packages, sizeof(list_packages), "%s\n%d\t\t%s", list_packages, package_uid, DoorData[dName]);
			DynamicGui_AddRow(playerid, package_type, package_uid);
		}
	}
	    
	if(strlen(list_packages))
	{
	    ShowPlayerDialog(playerid, D_PACKAGE_GET, DIALOG_STYLE_LIST, "Dostępne dla Ciebie paczki:", list_packages, "Dostarcz", "Anuluj");
	}
	else
	{
	    TD_ShowSmallInfo(playerid, 3, "Nie ma ~r~zadnych ~w~dostepnych dla Ciebie paczek.");
	}
	return 1;
}
alias:paczka("hurtownia");

cmd:przejazd(playerid, params[])
{
	if(GetPlayerState(playerid) != PLAYER_STATE_DRIVER)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w pojeździe.");
	    return 1;
	}
	new Float:PosX, Float:PosY, Float:PosZ,
		virtual_world = GetPlayerVirtualWorld(playerid), interior_id = GetPlayerInterior(playerid);

	GetPlayerPos(playerid, PosX, PosY, PosZ);

	new DoorData[sDoorInfo], NearDoor[MAX_VIS_DOORS], doorid,
		count_doors = Streamer_GetNearbyItems(PosX, PosY, PosZ, STREAMER_TYPE_PICKUP, NearDoor, MAX_VIS_DOORS, 5.0, virtual_world);

	if(count_doors > 0)
	{
		for (new door = 0; door < count_doors; door++)
		{
		    doorid = NearDoor[door];
		    
		    Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
		    if(DoorData[dGarage])
		    {
				OnPlayerEnterDoor(playerid, doorid);
				break;
			}
		}
	}
	else
	{
		count_doors = Streamer_GetUpperBound(STREAMER_TYPE_PICKUP);

		for (new door = 0; door <= count_doors; door++)
		{
  			if(IsValidDynamicPickup(door))
	    	{
		    	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, door, E_STREAMER_EXTRA_ID, DoorData);
			    if(DoorData[dExitVW] == virtual_world && DoorData[dExitInt] == interior_id)
			    {
			        if(DoorData[dGarage])
			        {
			        	if(IsPlayerInRangeOfPoint(playerid, 5.0, DoorData[dExitX], DoorData[dExitY], DoorData[dExitZ]))
				        {
							OnPlayerExitDoor(playerid, door);
							break;
       					}
					}
				}
			}
		}
	}
	return 1;
}

cmd:craft(playerid, params[])
{
	if(GetPlayerState(playerid) != PLAYER_STATE_ONFOOT)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znajdujesz się przy stole do craftingu (model %d).", OBJECT_CRAFT);
		return 1;
	}
	new object_id = GetClosestObjectType(playerid, OBJECT_CRAFT);
	if(object_id == INVALID_OBJECT_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znajdujesz się przy stole do craftingu (model %d).", OBJECT_CRAFT);
	    return 1;
	}
	
	new object_uid = GetObjectUID(object_id), list_craft[512],
	    item_uid, item_name[32], item_value1, craft_value = 0;
	    
	new rows, Cache:tmp_cache, query[256];
	
	mysql_format(connHandle, query, sizeof(query), "SELECT `item_uid`, `item_name`, `item_value1` FROM `"SQL_PREF"items` WHERE item_ownertype = '%d' AND item_owner = '%d'", PLACE_CRAFT, object_uid);
	tmp_cache = mysql_query(connHandle, query);
	
	cache_get_row_count(rows);
	for(new row = 0; row != rows; row++)
	{
	    cache_get_value_index_int(row, 0, item_uid);
	    
	    cache_get_value_index(row, 1, item_name, 32);
	    cache_get_value_index_int(row, 2, item_value1);
	    
	    format(list_craft, sizeof(list_craft), "%s\n%d\t\t%s", list_craft, item_uid, item_name);
		craft_value += item_value1;
	}
	if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
	
	if(strlen(list_craft))
	{
		strcat(list_craft, "\n----", sizeof(list_craft));

		switch(craft_value)
		{
		    case 53:	strcat(list_craft, "\nW\t24\tDesert Eagle", sizeof(list_craft));
		    case 455:  	strcat(list_craft, "\nW\t30\tAK47", sizeof(list_craft));
		    case 647:   strcat(list_craft, "\nW\t29\tMP5", sizeof(list_craft));
		    case 1035:  strcat(list_craft, "\nW\t25\tShotgun", sizeof(list_craft));
		    case 2061:  strcat(list_craft, "\nW\t32\tTec9", sizeof(list_craft));
		    case 4140:  strcat(list_craft, "\nW\t22\tGlock", sizeof(list_craft));
		    case 8391:  strcat(list_craft, "\nW\t31\tM4", sizeof(list_craft));
		    default:    strcat(list_craft, "\n{FB5006}#\t\tNieprawidłowo dopasowane części", sizeof(list_craft));
		}
	}
	else
	{
	    TD_ShowSmallInfo(playerid, 3, "Nie ma ~r~zadnych ~w~przedmiotow do craftingu.");
	}
	
	PlayerCache[playerid][pMainTable] = object_uid;
	ShowPlayerDialog(playerid, D_ITEM_CRAFT, DIALOG_STYLE_LIST, "Crafting", list_craft, "Wyjmij", "Zamknij");
	return 1;
}


// --- Komendy administracji --- //
cmd:aj(playerid, params[])
{
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_PUNISH))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz nadawać kar.");
	    return 1;
	}
	new giveplayer_id, time, reason[128];
	if(sscanf(params, "uds[128]", giveplayer_id, time, reason))
	{
	    ShowTipForPlayer(playerid, "/aj [ID gracza] [Czas (min - 0 uwalnia z AJ, jeśli jest)] [Powód]");
	    return 1;
	}
	if(giveplayer_id == INVALID_PLAYER_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
		return 1;
	}
	if(!PlayerCache[giveplayer_id][pLogged])
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
    	return 1;
	}
	if(PlayerCache[giveplayer_id][pBW])
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz ma BW.");
	    return 1;
	}
	reason[0] = chrtoupper(reason[0]);
	if(PlayerCache[giveplayer_id][pAJ])
	{
	    if(time <= 0)
	    {
	        PlayerCache[giveplayer_id][pAJ] = 0;
			SetPlayerSpawn(giveplayer_id);
			
			SendClientFormatMessage(giveplayer_id, COLOR_INFO, "%s uwolnił Cię z AJ. Powód: %s", PlayerName(playerid), reason);
			ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Pomyślnie uwolniono gracza %s z AJ.\nPowód: %s", PlayerName(giveplayer_id), reason);
	        return 1;
	    }
	    PlayerCache[giveplayer_id][pAJ] = time * 60;
	    
	    SendClientFormatMessage(giveplayer_id, COLOR_INFO, "%s zmienił Ci czas AJ. Aktualnie %d min. Powód: %s", PlayerName(playerid), time, reason);
	    ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Pomyślnie zmieniono czas trwania AJ graczowi %s. Aktualnie %d min.\nPowód: %s", PlayerName(giveplayer_id), time, reason);
	}
	else
	{
	    if(time <= 0)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz umieścić gracza w AJ na czas mniejszy niż 0.");
	        return 1;
	    }
		GivePlayerPunish(giveplayer_id, playerid, PUNISH_AJ, reason, time, 0);
	}
	return 1;
}

cmd:kick(playerid, params[])
{
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_PUNISH))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz nadawać kar.");
	    return 1;
	}
	new giveplayer_id, reason[128];
	if(sscanf(params, "us[128]", giveplayer_id, reason))
	{
	    ShowTipForPlayer(playerid, "/kick [ID gracza] [Powód]");
		return 1;
	}
	if(giveplayer_id == INVALID_PLAYER_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
		return 1;
	}
	if(!PlayerCache[giveplayer_id][pLogged])
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
    	return 1;
	}
	reason[0] = chrtoupper(reason[0]);
	GivePlayerPunish(giveplayer_id, playerid, PUNISH_KICK, reason, 0, 0);
	return 1;
}

cmd:warn(playerid, params[])
{
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_PUNISH))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz nadawać kar.");
	    return 1;
	}
	new giveplayer_id, reason[128];
	if(sscanf(params, "us[128]", giveplayer_id, reason))
	{
	    ShowTipForPlayer(playerid, "/warn [ID gracza] [Powód]");
		return 1;
	}
	if(giveplayer_id == INVALID_PLAYER_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
		return 1;
	}
	if(!PlayerCache[giveplayer_id][pLogged])
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
    	return 1;
	}
	reason[0] = chrtoupper(reason[0]);
	GivePlayerPunish(giveplayer_id, playerid, PUNISH_WARN, reason, 0, 0);
	return 1;
}

cmd:block(playerid, params[])
{
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_PUNISH))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz nadawać kar.");
	    return 1;
	}
	new type[12], varchar[256];
	if(sscanf(params, "s[12]S()[256]", type, varchar))
	{
	    ShowTipForPlayer(playerid, "/block [char | veh | run | ooc]");
	    return 1;
	}
	if(!strcmp(type, "char", true))
	{
	   	new giveplayer_id, reason[128];
		if(sscanf(varchar, "us[128]", giveplayer_id, reason))
		{
		    ShowTipForPlayer(playerid, "/block char [ID gracza] [Powód]");
			return 1;
		}
		if(giveplayer_id == INVALID_PLAYER_ID)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
			return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(PlayerCache[giveplayer_id][pBlock] & BLOCK_CHAR)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ta postać została już zablokowana!");
		    return 1;
		}
		reason[0] = chrtoupper(reason[0]);
        GivePlayerPunish(giveplayer_id, playerid, PUNISH_BLOCK, reason, 0, BLOCK_CHAR);
	    return 1;
	}
	if(!strcmp(type, "veh", true))
	{
		new giveplayer_id, time, reason[128];
		if(sscanf(varchar, "uds[128]", giveplayer_id, time, reason))
		{
		    ShowTipForPlayer(playerid, "/block veh [ID gracza] [Czas (dni)] [Powód]");
			return 1;
		}
		if(giveplayer_id == INVALID_PLAYER_ID)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
			return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(PlayerCache[giveplayer_id][pBlock] & BLOCK_VEH)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz ma już nałożoną blokadę prowadzenia pojazdów.");
		    return 1;
		}
		if(time <= 0 || time > 30)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Czas nie może być mniejszy niż 0 i 30.");
		    return 1;
		}
		reason[0] = chrtoupper(reason[0]);
        GivePlayerPunish(giveplayer_id, playerid, PUNISH_BLOCK, reason, time, BLOCK_VEH);
	    return 1;
	}
	if(!strcmp(type, "run", true))
	{
		new giveplayer_id, time, reason[128];
		if(sscanf(varchar, "uds[128]", giveplayer_id, time, reason))
		{
		    ShowTipForPlayer(playerid, "/block run [ID gracza] [Czas (dni)] [Powód]");
			return 1;
		}
		if(giveplayer_id == INVALID_PLAYER_ID)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
			return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(PlayerCache[giveplayer_id][pBlock] & BLOCK_RUN)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz ma już nałożoną blokadę biegania.");
		    return 1;
		}
		if(time <= 0 || time > 30)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Czas nie może być mniejszy niż 0 i 30.");
		    return 1;
		}
  		reason[0] = chrtoupper(reason[0]);
		GivePlayerPunish(giveplayer_id, playerid, PUNISH_BLOCK, reason, time, BLOCK_RUN);
	    return 1;
	}
	if(!strcmp(type, "ooc", true))
	{
		new giveplayer_id, time, reason[128];
		if(sscanf(varchar, "uds[128]", giveplayer_id, time, reason))
		{
		    ShowTipForPlayer(playerid, "/block ooc [ID gracza] [Czas (dni)] [Powód]");
			return 1;
		}
		if(giveplayer_id == INVALID_PLAYER_ID)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
			return 1;
		}
		if(!PlayerCache[giveplayer_id][pLogged])
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
	    	return 1;
		}
		if(PlayerCache[giveplayer_id][pBlock] & BLOCK_OOC)
		{
		    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz ma już nałożoną blokadę pisania na czacie OOC.");
		    return 1;
		}
		if(time <= 0 || time > 30)
		{
			ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Czas nie może być mniejszy niż 0 i 30.");
		    return 1;
		}
  		reason[0] = chrtoupper(reason[0]);
		GivePlayerPunish(giveplayer_id, playerid, PUNISH_BLOCK, reason, time, BLOCK_OOC);
	    return 1;
	}
	return 1;
}

cmd:ban(playerid, params[])
{
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_PUNISH))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz nadawać kar.");
	    return 1;
	}
	new giveplayer_id, time, reason[128];
	if(sscanf(params, "uds[128]", giveplayer_id, time, reason))
	{
	    ShowTipForPlayer(playerid, "/ban [ID gracza] [Czas (dni)] [Powód]");
		return 1;
	}
	if(giveplayer_id == INVALID_PLAYER_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
		return 1;
	}
	if(!PlayerCache[giveplayer_id][pLogged])
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
    	return 1;
	}
	if(time <= 0 || time > 365)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Czas nie może być mniejszy niż 0 i większy od 365.");
  		return 1;
	}
	reason[0] = chrtoupper(reason[0]);
	GivePlayerPunish(giveplayer_id, playerid, PUNISH_BAN, reason, time, 0);
	return 1;
}

cmd:bw(playerid, params[])
{
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_BASIC))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz używać tej komendy.");
	    return 1;
	}
	new giveplayer_id, time;
	if(sscanf(params, "ud", giveplayer_id, time))
	{
	    ShowTipForPlayer(playerid, "/bw [ID gracza] [Czas (min - 0 zdejmuje bw, jeśli ma)]");
	    
		new list_bw[256], killer_id, count_bw;
		format(list_bw, sizeof(list_bw), "ID\tPostać\tCzas BW\tKto zabił\n");
		
	    foreach(new i : Player)
	    {
	        if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	        {
	            if(PlayerCache[i][pBW] > 0)
	            {
	                killer_id = GetPlayerID(PlayerCache[i][pDeathKiller]);
	                if(killer_id == INVALID_PLAYER_ID)
	                {
	                	format(list_bw, sizeof(list_bw), "%s\n%d\t%s\t%dm\tBrak (%d)", list_bw, i, PlayerName(i), PlayerCache[i][pBW] / 60, PlayerCache[i][pDeathKiller]);
					}
					else
					{
					    format(list_bw, sizeof(list_bw), "%s\n%d\t%s\t%dm\t%s (%d)", list_bw, i, PlayerName(i), PlayerCache[i][pBW], PlayerName(killer_id), PlayerCache[i][pDeathKiller]);
					}
					count_bw ++;
				}
	        }
	    }
	    if(count_bw > 0)    ShowPlayerDialog(playerid, D_PLAYER_LIST, DIALOG_STYLE_TABLIST_HEADERS, "Lista graczy z BW:", list_bw, "Wybierz", "Zamknij");
	    return 1;
	}
	if(giveplayer_id == INVALID_PLAYER_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
    	return 1;
	}
	if(!PlayerCache[giveplayer_id][pLogged])
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
 		return 1;
	}
	if(PlayerCache[giveplayer_id][pBW])
	{
		if(time <= 0)
		{
			PlayerCache[giveplayer_id][pBW] = 0;
			PlayerCache[giveplayer_id][pDeathBody] = 0;

			ApplyAnimation(giveplayer_id, "Attractors", "Stepsit_out", 4.0, 0, 1, 1, 0, 1, true);
			OnPlayerFreeze(giveplayer_id, false, 0);

			ResetPlayerCamera(giveplayer_id);
			crp_SetPlayerHealth(giveplayer_id, 20);

			SendClientFormatMessage(giveplayer_id, COLOR_INFO, "%s zdjął Ci BW.", PlayerName(playerid));
			ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Pomyślnie zdjęto BW graczowi %s.", PlayerName(giveplayer_id));
			return 1;
		}

		PlayerCache[giveplayer_id][pBW] = time * 60;

		SendClientFormatMessage(giveplayer_id, COLOR_INFO, "%s zmienił Ci czas BW. Aktualnie %d min.", PlayerName(playerid), time);
		ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Pomyślnie zmieniono czas trwania BW graczowi %s. Aktualnie %d min.", PlayerName(giveplayer_id), time);
	}
	else
	{
	    if(time <= 0)
	    {
	        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz nałożyć BW na czas mniejszy niż 0.");
	        return 1;
	    }
	    PlayerCache[giveplayer_id][pBW] = time * 60;

		PlayerCache[giveplayer_id][pInteriorID] = GetPlayerInterior(giveplayer_id);
		PlayerCache[giveplayer_id][pVirtualWorld] = GetPlayerVirtualWorld(giveplayer_id);

		GetPlayerPos(giveplayer_id, PlayerCache[giveplayer_id][pPosX], PlayerCache[giveplayer_id][pPosY], PlayerCache[giveplayer_id][pPosZ]);

		SetPlayerCameraPos(giveplayer_id, PlayerCache[giveplayer_id][pPosX] + 3, PlayerCache[giveplayer_id][pPosY] + 4, PlayerCache[giveplayer_id][pPosZ] + 7);
		SetPlayerCameraLookAt(giveplayer_id, PlayerCache[giveplayer_id][pPosX], PlayerCache[giveplayer_id][pPosY], PlayerCache[giveplayer_id][pPosZ], CAMERA_CUT);

        OnPlayerFreeze(giveplayer_id, true, 0);
		orm_update(PlayerCache[giveplayer_id][pOrm]);

		SendClientFormatMessage(giveplayer_id, COLOR_INFO, "%s nałożył Ci BW na czas %d min.", PlayerName(playerid), time);
		ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Pomyślnie nałożono BW graczowi %s na czas %d min.", PlayerName(giveplayer_id), time);
	}
	return 1;
}

cmd:akceptujsmierc(playerid, params[])
{
	if(!PlayerCache[playerid][pBW])
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Używanie tej komendy dostępne jest tylko podczas stanu nieprzytomności.");
	    return 1;
	}
	if((!IsPlayerPremium(playerid) && PlayerCache[playerid][pHours] < 10) || PlayerCache[playerid][pHours] < 3)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz uśmiercić postaci, na której przegrałeś mniej niż 10 godzin (konto premium - 3).");
	    return 1;
	}
	new killer_uid = PlayerCache[playerid][pDeathKiller],
		weapon_uid = PlayerCache[playerid][pDeathWeapon];

	CreatePlayerCorpse(playerid, killer_uid, weapon_uid);
	
	PlayerCache[playerid][pBlock] += BLOCK_CHAR;
	orm_update(PlayerCache[playerid][pOrm]);
	
	ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Twoja postać została uśmiercona.\nOd tej pory postać, która została uśmiercona jest już nieaktywna.\n\nZostajesz wyrzucony z serwera.");
	defer OnKickPlayer(playerid);
	return 1;
}

cmd:tp(playerid, params[])
{
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_BASIC))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz skorzystać z tej komendy.");
	    return 1;
	}
	new Float:PosX, Float:PosY, Float:PosZ,
		interior_id, virtual_world;
		
	if(sscanf(params, "fffdd", PosX, PosY, PosZ, interior_id, virtual_world))
	{
	    ShowTipForPlayer(playerid, "/tp [PosX] [PosY] [PosZ] [Int] [Vw]");
	    return 1;
	}
	crp_SetPlayerPos(playerid, PosX, PosY, PosZ);

	SetPlayerInterior(playerid, interior_id);
	SetPlayerVirtualWorld(playerid, virtual_world);
	return 1;
}
alias:tp("teleport");

cmd:ptp(playerid, params[])
{
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_BASIC))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz skorzystać z tej komendy.");
	    return 1;
	}
	new getplayer_id, giveplayer_id;
	if(sscanf(params, "uu", getplayer_id, giveplayer_id))
	{
	    ShowTipForPlayer(playerid, "/ptp [ID gracza (1)] [ID gracza (2)]");
	    return 1;
	}
	if(giveplayer_id == INVALID_PLAYER_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
		return 1;
	}
	if(!PlayerCache[giveplayer_id][pLogged])
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
    	return 1;
	}
	new Float:PosX, Float:PosY, Float:PosZ,
	    interior_id, virtual_world;

	GetPlayerPos(giveplayer_id, PosX, PosY, PosZ);

	interior_id = GetPlayerInterior(giveplayer_id);
	virtual_world = GetPlayerVirtualWorld(giveplayer_id);

	crp_SetPlayerPos(getplayer_id, PosX, PosY, PosZ);

	SetPlayerInterior(getplayer_id, interior_id);
	SetPlayerVirtualWorld(getplayer_id, virtual_world);

	ShowPlayerInfoDialog(playerid, D_TYPE_INFO, "Gracz %s został przeteleportowany do gracza %s pomyślnie.", PlayerName(getplayer_id), PlayerName(giveplayer_id));
	return 1;
}

cmd:goto(playerid, params[])
{
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_BASIC))
	{
        ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz skorzystać z tej komendy.");
	    return 1;
	}
	new giveplayer_id;
	if(sscanf(params, "u", giveplayer_id))
	{
	    ShowTipForPlayer(playerid, "/goto [ID gracza]");
	    return 1;
	}
	if(giveplayer_id == INVALID_PLAYER_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
		return 1;
	}
	if(!PlayerCache[giveplayer_id][pLogged])
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
    	return 1;
	}
	new Float:PosX, Float:PosY, Float:PosZ,
	    interior_id, virtual_world;
	    
	GetPlayerPos(giveplayer_id, PosX, PosY, PosZ);

	interior_id = GetPlayerInterior(giveplayer_id);
	virtual_world = GetPlayerVirtualWorld(giveplayer_id);

	crp_SetPlayerPos(playerid, PosX + 3.0, PosY, PosZ);

	SetPlayerInterior(playerid, interior_id);
	SetPlayerVirtualWorld(playerid, virtual_world);
	return 1;
}
alias:goto("to");

cmd:gethere(playerid, params[])
{
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_BASIC))
	{
        ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz skorzystać z tej komendy.");
	    return 1;
	}
	new giveplayer_id;
	if(sscanf(params, "u", giveplayer_id))
	{
	    ShowTipForPlayer(playerid, "/gethere [ID gracza]");
	    return 1;
	}
	if(giveplayer_id == INVALID_PLAYER_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
		return 1;
	}
	if(!PlayerCache[giveplayer_id][pLogged])
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
    	return 1;
	}
	new Float:PosX, Float:PosY, Float:PosZ,
	    interior_id, virtual_world;
	    
	GetPlayerPos(playerid, PosX, PosY, PosZ);

	interior_id = GetPlayerInterior(playerid);
	virtual_world = GetPlayerVirtualWorld(playerid);

	crp_SetPlayerPos(giveplayer_id, PosX + 3.0, PosY, PosZ);

	SetPlayerInterior(giveplayer_id, interior_id);
	SetPlayerVirtualWorld(giveplayer_id, virtual_world);
	return 1;
}
alias:gethere("tm");

cmd:spec(playerid, params[])
{
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_BASIC))
	{
        ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz skorzystać z tej komendy.");
	    return 1;
	}
	new giveplayer_id;
	if(sscanf(params, "u", giveplayer_id))
	{
		if(PlayerCache[playerid][pSpectate] != INVALID_PLAYER_ID)
		{
			TogglePlayerSpectating(playerid, false);
		    return 1;
		}
		ShowTipForPlayer(playerid, "/spec [ID gracza]");
	    return 1;
	}
	if(giveplayer_id == playerid)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz podglądać siebie.");
	    return 1;
	}
	if(giveplayer_id == INVALID_PLAYER_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
		return 1;
	}
	if(!PlayerCache[giveplayer_id][pLogged])
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
    	return 1;
	}
	if(PlayerCache[giveplayer_id][pSpectate] != INVALID_PLAYER_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ten gracz podgląda innego gracza.");
	    return 1;
	}
	if(PlayerCache[playerid][pSpectate] == INVALID_PLAYER_ID)
	{
		GetPlayerPos(playerid, PlayerCache[playerid][pPosX], PlayerCache[playerid][pPosY], PlayerCache[playerid][pPosZ]);

		PlayerCache[playerid][pVirtualWorld] = GetPlayerVirtualWorld(playerid);
		PlayerCache[playerid][pInteriorID] = GetPlayerInterior(playerid);
	}

	// Jeśli ma broń
	if(PlayerCache[playerid][pItemWeapon] != INVALID_ITEM_ID)
	{
	    new itemid = PlayerCache[playerid][pItemWeapon];

		PlayerCache[playerid][pItemWeapon] = INVALID_ITEM_ID;
  		ResetPlayerWeaponsEx(playerid);

		RemovePlayerAttachedObject(playerid, SLOT_WEAPON);

  		PlayerCache[playerid][pCheckWeapon] = (gettime() + 5);
   		PlayerItemCache[playerid][itemid][iUsed] = false;

		orm_update(PlayerItemCache[playerid][itemid][iOrm]);
	}
	PlayerCache[playerid][pSpectate] = giveplayer_id;

	new player_state = GetPlayerState(giveplayer_id);
	TogglePlayerSpectating(playerid, true);

	switch(player_state)
	{
		case 0, 1, 7, 8:	PlayerSpectatePlayer(playerid, giveplayer_id);
		case 2, 3:			PlayerSpectateVehicle(playerid , GetPlayerVehicleID(giveplayer_id));
	}
	
	SetPlayerInterior(playerid, GetPlayerInterior(giveplayer_id));
	SetPlayerVirtualWorld(playerid, GetPlayerVirtualWorld(giveplayer_id));
	
	new sp = giveplayer_id, year, month, day, hour, minute, second;
	TimestampToDate(PlayerCache[giveplayer_id][pSession][SESSION_GAME], year, month, day, hour, minute, second, 1);
	
	TD_ShowLargeInfo(playerid, 0, "Postac: ~y~%s (%d)    ~w~Globalny: ~g~%s (%d)~w~~n~Zalogowany od: ~y~%02d:%02d~w~     Czas gry: ~b~%dh %dm~w~~n~~n~HP: ~r~%.0f%%~w~     Gotowka: ~g~$%d~w~     Bank: ~g~$%d~w~", PlayerName(sp), PlayerCache[sp][pUID], PlayerCache[sp][pGlobName], PlayerCache[sp][pGID], hour, minute, PlayerCache[sp][pHours], PlayerCache[sp][pMinutes], PlayerCache[sp][pHealth], PlayerCache[sp][pCash], PlayerCache[sp][pBankCash]);
	TD_ShowHint(playerid, HINT_NONE, 5, "Podglad gracza jest teraz ~y~aktywny~w~.~n~~n~Uzywaj klawiszy ~r~~k~~SNEAK_ABOUT~ ~w~oraz ~r~~k~~PED_SPRINT~~w~, aby swobodnie ~g~przeskakiwac ~w~miedzy graczami.~n~Klawisz ~y~~k~~PED_JUMPING~ ~w~odswieza podglad.");
	return 1;
}
alias:spec("recon", "rc");

cmd:setint(playerid, params[])
{
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_BASIC))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz skorzystać z tej komendy.");
	    return 1;
	}
	new giveplayer_id, interior_id;
	if(sscanf(params, "ud", giveplayer_id, interior_id))
	{
	    ShowTipForPlayer(playerid, "/setint [ID gracza] [Interior]");
	    return 1;
	}
	if(giveplayer_id == INVALID_PLAYER_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
		return 1;
	}
	if(!PlayerCache[giveplayer_id][pLogged])
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
    	return 1;
	}
	SetPlayerInterior(giveplayer_id, interior_id);
	ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "InteriorID gracza %s został zmieniony pomyślnie.\nNowy interior: %d", PlayerName(giveplayer_id), interior_id);
	return 1;
}

cmd:setvw(playerid, params[])
{
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_BASIC))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz skorzystać z tej komendy.");
	    return 1;
	}
	new giveplayer_id, virtual_world;
	if(sscanf(params, "ud", giveplayer_id, virtual_world))
	{
	    ShowTipForPlayer(playerid, "/setvw [ID gracza] [VirtualWorld]");
	    return 1;
	}
	if(giveplayer_id == INVALID_PLAYER_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
		return 1;
	}
	if(!PlayerCache[giveplayer_id][pLogged])
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
    	return 1;
	}
	SetPlayerVirtualWorld(giveplayer_id, virtual_world);
	ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "VirualWorld gracza %s został zmieniony pomyślnie.\nNowy VirtualWorld: %d", PlayerName(giveplayer_id), virtual_world);
	return 1;
}

cmd:sethp(playerid, params[])
{
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_BASIC))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz skorzystać z tej komendy.");
	    return 1;
	}
	new giveplayer_id, Float:health;
	if(sscanf(params, "uf", giveplayer_id, health))
	{
	    ShowTipForPlayer(playerid, "/sethp [ID gracza] [Ilość HP]");
	    return 1;
	}
	if(giveplayer_id == INVALID_PLAYER_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
		return 1;
	}
	if(!PlayerCache[giveplayer_id][pLogged])
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
    	return 1;
	}
	crp_SetPlayerHealth(giveplayer_id, health);
	ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "HP gracza %s zostało pomyślnie zmienione. Nowy stan HP: %.1f", PlayerName(giveplayer_id), health);
	return 1;
}
alias:sethp("hp");

cmd:settime(playerid, params[])
{
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_BASIC))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz skorzystać z tej komendy.");
	    return 1;
	}
	new hour;
	if(sscanf(params, "d", hour))
	{
	    ShowTipForPlayer(playerid, "/settime [godzina]");
	    return 1;
	}
	SetPlayerTime(playerid, hour, 0);
	return 1;
}

cmd:setskin(playerid, params[])
{
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_BASIC))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz skorzystać z tej komendy.");
	    return 1;
	}
	new giveplayer_id, skin_id;
	if(sscanf(params, "ud", giveplayer_id, skin_id))
	{
	    ShowTipForPlayer(playerid, "/setskin [ID gracza] [ID skina]");
	    return 1;
	}
	if(giveplayer_id == INVALID_PLAYER_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
		return 1;
	}
	if(!PlayerCache[giveplayer_id][pLogged])
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
    	return 1;
	}
	/*if(skin_id < 0 || skin_id > 300)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Wprowadzono nieprawidłowe ID skina.");
	    return 1;
	}*/
	crp_SetPlayerSkin(giveplayer_id, skin_id);
	ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Skin gracza %s został pomyślnie zmieniony. Nowy skin: %d", PlayerName(giveplayer_id), skin_id);
	return 1;
}

cmd:freeze(playerid, params[])
{
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_BASIC))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz skorzystać z tej komendy.");
	    return 1;
	}
	new giveplayer_id;
	if(sscanf(params, "u", giveplayer_id))
	{
	    ShowTipForPlayer(playerid, "/freeze [ID gracza]");
	    return 1;
	}
	if(giveplayer_id == INVALID_PLAYER_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
		return 1;
	}
	if(!PlayerCache[giveplayer_id][pLogged])
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
    	return 1;
	}
	OnPlayerFreeze(giveplayer_id, true, 0);
	ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Gracz %s został pomyślnie zamrożony.", PlayerName(giveplayer_id));
	return 1;
}

cmd:unfreeze(playerid, params[])
{
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_BASIC))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz skorzystać z tej komendy.");
	    return 1;
	}
	new giveplayer_id;
	if(sscanf(params, "u", giveplayer_id))
	{
	    ShowTipForPlayer(playerid, "/unfreeze [ID gracza]");
	    return 1;
	}
	if(giveplayer_id == INVALID_PLAYER_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
		return 1;
	}
	if(!PlayerCache[giveplayer_id][pLogged])
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
    	return 1;
	}
	OnPlayerFreeze(giveplayer_id, false, 0);
	ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Gracz %s został pomyślnie odmrożony.", PlayerName(giveplayer_id));
	return 1;
}

cmd:ado(playerid, params[])
{
	if(PlayerCache[playerid][pAdmin] < A_PERM_MAX)
	{
        ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz skorzystać z tej komendy.");
        return 1;
	}
	if(is_null(params))
	{
		ShowTipForPlayer(playerid, "/ado [Sytuacja]");
	    return 1;
	}
	new string[256];
	params[0] = chrtoupper(params[0]);

	format(string, sizeof(string), "** %s **", params);
	SendClientMessageToAll(COLOR_DO, string);
	return 1;
}

cmd:slap(playerid, params[])
{
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_BASIC))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz skorzystać z tej komendy.");
	    return 1;
	}
	new giveplayer_id;
	if(sscanf(params, "u", giveplayer_id))
	{
	    ShowTipForPlayer(playerid, "/slap [ID gracza]");
	    return 1;
	}
	if(giveplayer_id == INVALID_PLAYER_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
		return 1;
	}
	if(!PlayerCache[giveplayer_id][pLogged])
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
    	return 1;
	}
	new Float:PosX, Float:PosY, Float:PosZ;
	
	GetPlayerPos(giveplayer_id, PosX, PosY, PosZ);
	crp_SetPlayerPos(giveplayer_id, PosX, PosY, PosZ + 5.0);

	GameTextForPlayer(giveplayer_id, "~n~~n~~n~~r~SLAP!", 3000, 3);
	GameTextForPlayer(playerid, "~n~~n~~n~~r~SLAP!", 3000, 3);
	return 1;
}

cmd:setnick(playerid, params[])
{
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_BASIC))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz skorzystać z tej komendy.");
	    return 1;
	}
	new giveplayer_id, new_name[24];
	if(sscanf(params, "us[24]", giveplayer_id, new_name))
	{
	    ShowTipForPlayer(playerid, "/setnick [ID gracza] [Nowy nick tymczasowy]");
	    return 1;
	}
	if(giveplayer_id == INVALID_PLAYER_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
		return 1;
	}
	if(!PlayerCache[giveplayer_id][pLogged])
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
    	return 1;
	}
	if(!strcmp(new_name, "*", true))
	{
	    SetPlayerName(giveplayer_id, PlayerCache[giveplayer_id][pCharName]);
	    
	    UpdatePlayerStatus(playerid);
    	ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Pomyślnie przywrócono nick gracza (ID: %d) do pierwotnego.", giveplayer_id);
	    return 1;
	}
	SetPlayerName(giveplayer_id, new_name);

	UpdatePlayerStatus(playerid);
	ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Pomyślnie zmieniono tymczasowy nick gracza %s (ID: %d) na %s.\nAby zmienić nick z powrotem na pierwotny wpisz /setnick [ID gracza] *.", PlayerRealName(giveplayer_id), giveplayer_id, PlayerName(giveplayer_id));
	return 1;
}

cmd:res(playerid, params[])
{
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_BASIC))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz skorzystać z tej komendy.");
	    return 1;
	}
	new giveplayer_id;
	if(sscanf(params, "u", giveplayer_id))
	{
	    ShowTipForPlayer(playerid, "/res [ID gracza]");
	    return 1;
	}
	if(giveplayer_id == INVALID_PLAYER_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Podano błędne ID gracza.");
		return 1;
	}
	if(!PlayerCache[giveplayer_id][pLogged])
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Gracz o podanym ID nie jest zalogowany.");
    	return 1;
	}
	SetPlayerSpawn(giveplayer_id);
	ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Pomyślnie przywrócono gracza %s (ID: %d) na spawn.", PlayerName(giveplayer_id), giveplayer_id);
	return 1;
}

cmd:duty(playerid, params[])
{
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_BASIC))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz skorzystać z tej komendy.");
	    return 1;
	}
	if(!PlayerCache[playerid][pDuty][DUTY_ADMIN])
	{
 		PlayerCache[playerid][pDuty][DUTY_ADMIN] = true;
	    PlayerCache[playerid][pSession][SESSION_ADMIN] = gettime();
	    
	    SetPlayerName(playerid, PlayerCache[playerid][pGlobName]);
	    
	    UpdatePlayerStatus(playerid);
	    SendClientMessage(playerid, COLOR_INFO, "Wszedłeś na służbę administratora. Aby zejść, użyj ponownie tej komendy.");
	}
	else
	{
		new	duty_hours = floatround((gettime() - PlayerCache[playerid][pSession][SESSION_ADMIN]) / 3600, floatround_floor),
			duty_minutes = floatround((gettime() - PlayerCache[playerid][pSession][SESSION_ADMIN]) / 60, floatround_floor) % 60;
	
	    UpdatePlayerSession(playerid, SESSION_ADMIN, 0);
	
	    PlayerCache[playerid][pDuty][DUTY_ADMIN] = false;
	    PlayerCache[playerid][pSession][SESSION_ADMIN] = 0;
	    
		SetPlayerName(playerid, PlayerCache[playerid][pCharName]);

	    UpdatePlayerStatus(playerid);
	    SendClientFormatMessage(playerid, COLOR_INFO, "Zszedłeś ze służby administratora. Czas trwania sesji: %dh %dm", duty_hours, duty_minutes);
	}
	return 1;
}
alias:duty("sluzba");

cmd:ac(playerid, params[])
{
	new modelid, actor_name[32];
	if(sscanf(params, "ds[32]", modelid, actor_name))
 	{
  		ShowTipForPlayer(playerid, "/ac [Skin] [Nazwa]");
    	return 1;
    }
	new actorid,
		Float:PosX, Float:PosY, Float:PosZ,
		virtual_world = GetPlayerVirtualWorld(playerid), interior_id = GetPlayerInterior(playerid);
		
   	if(!(PlayerCache[playerid][pAdmin] & A_PERM_ACTORS))
	{
		GetPlayerPos(playerid, PosX, PosY, PosZ);

		new ActorData[MAX_VIS_ACTORS],
			count_actors = Streamer_GetNearbyItems(PosX, PosY, PosZ, STREAMER_TYPE_ACTOR, ActorData, MAX_VIS_ACTORS, 100.0, virtual_world);
	
		new doorid = GetPlayerDoorID(playerid);
		if(doorid != INVALID_DOOR_ID)
		{
			new DoorData[sDoorInfo];
	  		Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);

			if(DoorData[dOwnerType] == OWNER_NONE)
			{
				ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Ten budynek lub strefa nie należy do Ciebie.");
				return 1;
			}
			if(DoorData[dOwnerType] == OWNER_PLAYER)
			{
		 		if(DoorData[dOwner] != PlayerCache[playerid][pUID])
		   		{
					ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Ten budynek lub strefa nie należy do Ciebie.");
		   			return 1;
				}
			}
			if(DoorData[dOwnerType] == OWNER_GROUP)
			{
			    if(!HavePlayerGroupPerm(playerid, DoorData[dOwner], G_PERM_LEADER))
			    {
			        ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Ten budynek lub strefa nie należy do Ciebie.");
			        return 1;
			    }
			}
			if(count_actors >= (IsPlayerPremium(playerid) ? 4 : 2))
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz stworzyć tutaj więcej aktorów.\nOsoby z aktywnym kontem premium mogą stworzyć 4 aktorów w strefie/drzwiach (normalnie 3).");
			    return 1;
			}
		}
		else
		{
		    new areaid = GetPlayerAreaID(playerid);
		    if(areaid == INVALID_AREA_ID)
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby móc stworzyć aktora, musisz znajdować się w budynku lub strefie.");
		        return 1;
		    }
		    new AreaData[sAreaData];
		    Streamer_GetArrayData(STREAMER_TYPE_AREA, areaid, E_STREAMER_EXTRA_ID, AreaData);

		    if(AreaData[aOwnerType] == OWNER_NONE)
		    {
		        ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Ten budynek lub strefa nie należy do Ciebie.");
		        return 1;
		    }
		    if(AreaData[aOwnerType] == OWNER_PLAYER)
		    {
		        if(AreaData[aOwner] != PlayerCache[playerid][pUID])
		        {
		            ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Ten budynek lub strefa nie należy do Ciebie.");
		            return 1;
		        }
		    }
		    if(AreaData[aOwnerType] == OWNER_GROUP)
		    {
		        if(!HavePlayerGroupPerm(playerid, AreaData[aOwner], G_PERM_LEADER))
		        {
		            ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Ten budynek lub strefa nie należy do Ciebie.");
		            return 1;
		        }
		    }

            new Float:aX, Float:aY, Float:aZ;
			for(new actor = 0; actor < count_actors; actor++)
			{
			    actorid = ActorData[actor];
			    GetDynamicActorPos(actorid, aX, aY, aZ);

		    	if(!IsPointInDynamicArea(areaid, aX, aY, aZ))
		    	{
  	    			count_actors --;
		    	}
			}

			if(count_actors >= (IsPlayerPremium(playerid) ? 4 : 2))
			{
			    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie możesz stworzyć tutaj więcej aktorów.\nOsoby z aktywnym kontem premium mogą stworzyć 4 aktorów w strefie/drzwiach (normalnie 3).");
			    return 1;
			}
		}
	}
	
  	GetPlayerPos(playerid, PosX, PosY, PosZ);
	GetXYInFrontOfPlayer(playerid, PosX, PosY, 1.0);
	
	new actor_uid = crp_CreateActor(actor_name, modelid, PosX, PosY, PosZ, 0.0, virtual_world, interior_id);
	TD_ShowSmallInfo(playerid, 5, "Aktor zostal ~g~pomyslnie ~w~utworzony ~y~(UID: %d)~w~.~n~Skorzystaj z komendy ~p~/asel~w~, by dokonac jego modyfikacji.", actor_uid);
	return 1;
}

cmd:asel(playerid, params[])
{
	if(!(PlayerCache[playerid][pAdmin] & A_PERM_ACTORS))
	{
		new doorid = GetPlayerDoorID(playerid);
		if(doorid != INVALID_DOOR_ID)
		{
			new DoorData[sDoorInfo];
			Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);

			if(DoorData[dOwnerType] == OWNER_NONE)
			{
				ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Ten budynek lub strefa nie należy do Ciebie.");
				return 1;
			}
			if(DoorData[dOwnerType] == OWNER_PLAYER)
			{
				if(DoorData[dOwner] != PlayerCache[playerid][pUID])
				{
					ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Ten budynek lub strefa nie należy do Ciebie.");
					return 1;
				}
			}
			if(DoorData[dOwnerType] == OWNER_GROUP)
			{
	  			if(!HavePlayerGroupPerm(playerid, DoorData[dOwner], G_PERM_LEADER))
	  			{
	     			ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Ten budynek lub strefa nie należy do Ciebie.");
	        		return 1;
		    	}
			}

		}
		else
		{
	 		new areaid = GetPlayerAreaID(playerid);
	  		if(areaid == INVALID_AREA_ID)
	  		{
	    		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Aby móc edytować aktora, musisz znajdować się w budynku lub strefie.");
	      		return 1;
	    	}
		    new AreaData[sAreaData];
		    Streamer_GetArrayData(STREAMER_TYPE_AREA, areaid, E_STREAMER_EXTRA_ID, AreaData);

			if(AreaData[aOwnerType] == OWNER_NONE)
			{
				ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Ten budynek lub strefa nie należy do Ciebie.");
				return 1;
	   		}
		    if(AreaData[aOwnerType] == OWNER_PLAYER)
		    {
	     		if(AreaData[aOwner] != PlayerCache[playerid][pUID])
	       		{
	         		ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Ten budynek lub strefa nie należy do Ciebie.");
	           		return 1;
		        }
		    }
		    if(AreaData[aOwnerType] == OWNER_GROUP)
		    {
	     		if(!HavePlayerGroupPerm(playerid, AreaData[aOwner], G_PERM_LEADER))
	       		{
	         		ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Ten budynek lub strefa nie należy do Ciebie.");
	           		return 1;
		        }
		    }
		}
	}
	new actorid = GetPlayerCameraTargetDynActor(playerid);
	if(actorid == INVALID_ACTOR_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie znaleziono żadnego aktora w pobliżu (musisz na niego patrzeć).");
		return 1;
	}
	foreach(new i : Player)
	{
	    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	    {
	        if(PlayerCache[i][pEditActor] == actorid)
	        {
	            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ktoś aktualnie edytuje tego aktora.");
				return 1;
			}
	    }
	}
	new Float:PosX, Float:PosY, Float:PosZ;
	GetDynamicActorPos(actorid, PosX, PosY, PosZ);

	SetPlayerCameraPos(playerid, PosX + 3, PosY + 4, PosZ + 4);
	SetPlayerCameraLookAt(playerid, PosX, PosY, PosZ);

	OnPlayerFreeze(playerid, true, 0);
	PlayerCache[playerid][pEditActor] = actorid;
	
	TD_ShowHint(playerid, HINT_NONE, 0, "Edycja aktora~n~~n~Za pomoca ~g~strzalek ~w~edytuj pozycje aktora, przytrzymaj klawisz:~n~~y~SHIFT~w~ - gora/dol/rotacja~n~~y~LALT~w~ - wolniejsze poruszanie~n~~y~SPACE~w~ - szybsze poruszanie.~n~~n~Komendy:~n~~p~/asave~w~ - zapis aktora~n~~p~/adel~w~ - usun aktora~n~~p~/atext~w~ - tekst wymowy~n~~p~/atype~w~ - rodzaj~n~~n~Uzyj komendy ~r~/anim~w~, aby wybrac animacje lub wywolaj poprzez kropke ~y~(np. .krzeslo)~w~.");
	return 1;
}

cmd:adel(playerid, params[])
{
	if(PlayerCache[playerid][pEditActor] == INVALID_ACTOR_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie edytujesz aktualnie żadnego aktora.");
		return 1;
	}
	new actorid = PlayerCache[playerid][pEditActor];
	DeleteActor(actorid);

	OnPlayerFreeze(playerid, false, 0);
	ResetPlayerCamera(playerid);

	PlayerCache[playerid][pEditActor] = INVALID_ACTOR_ID;
	
	TD_ShowSmallInfo(playerid, 5, "Aktor zostal calkowicie ~r~usuniety~w~.");
	TD_HideHint(playerid);
	return 1;
}

cmd:asave(playerid, params[])
{
	if(PlayerCache[playerid][pEditActor] == INVALID_ACTOR_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie edytujesz aktualnie żadnego aktora.");
		return 1;
	}
	new actorid = PlayerCache[playerid][pEditActor];
	SaveActor(actorid);

	OnPlayerFreeze(playerid, false, 0);
	ResetPlayerCamera(playerid);

	PlayerCache[playerid][pEditActor] = INVALID_ACTOR_ID;
	
	TD_ShowSmallInfo(playerid, 5, "Dane o aktorze zostaly ~g~pomyslnie ~w~zapisane.");
	TD_HideHint(playerid);
	return 1;
}

cmd:atype(playerid, params[])
{
	if(PlayerCache[playerid][pEditActor] == INVALID_ACTOR_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie edytujesz aktualnie żadnego aktora.");
		return 1;
	}
	
	new list_actor_type[256];
	for (new i = 0; i < sizeof(ActorTypeInfo); i++)
	{
	    if(!(PlayerCache[playerid][pAdmin] & A_PERM_ACTORS))
	    {
			if(i >= 2)
			{
			    break;
			}
	    }
	    
 		format(list_actor_type, sizeof(list_actor_type), "%s\n%d\t%s", list_actor_type, i + 1, ActorTypeInfo[i][aTypeName]);
	}
	ShowPlayerDialog(playerid, D_ACTOR_TYPE, DIALOG_STYLE_LIST, "Wybierz typ aktora:", list_actor_type, "Wybierz", "Anuluj");
	return 1;
}


cmd:atext(playerid, params[])
{
	if(PlayerCache[playerid][pEditActor] == INVALID_ACTOR_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie edytujesz aktualnie żadnego aktora.");
		return 1;
	}
	new actor_text[256];
	if(sscanf(params, "s[256]", actor_text))
	{
	    ShowTipForPlayer(playerid, "/atext [Tekst, który aktor będzie wymawiał po interakcji (128 znaków)]");
	    SendClientMessage(playerid, COLOR_WHITE, "----------------------------------------------------------------------");
	    
	    ShowTipForPlayer(playerid, "Możesz używać tagów, które będą konwertowane odpowiednio:");
	    ShowTipForPlayer(playerid, "[player] - wyświetli nick gracza, który dokonał interakcji");
	    ShowTipForPlayer(playerid, "[door] - pokaże nazwę drzwi, w których znaduje się aktor");
	    ShowTipForPlayer(playerid, "[group] - nazwa grupy, do której należy aktor");
	    ShowTipForPlayer(playerid, "[actor] - nazwa aktora, z którym dokonywana jest interakcja");
	    return 1;
	}
	
	new actorid = PlayerCache[playerid][pEditActor],
	    ActorData[sActorData];

	Streamer_GetArrayData(STREAMER_TYPE_ACTOR, actorid, E_STREAMER_EXTRA_ID, ActorData);
	strmid(ActorData[aText], actor_text, 0, strlen(actor_text), 128);
	
	Streamer_SetArrayData(STREAMER_TYPE_ACTOR, actorid, E_STREAMER_EXTRA_ID, ActorData);
	ShowPlayerInfoDialog(playerid, D_TYPE_SUCCESS, "Pomyślnie ustalono tekst wymawiany przez aktora:\n\n%s", WordWrap(actor_text, WRAP_AUTO));
	return 1;
}

cmd:limits(playerid, params[])
{
	if(PlayerCache[playerid][pAdmin] < A_PERM_MAX)
	{
        ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz skorzystać z tej komendy.");
        return 1;
	}
	new string[256];
	
	format(string, sizeof(string), "Gracze:\t\t\t%d/%d\nPojazdy:\t\t%d/%d\nDrzwi:\t\t\t%d/UNLIMIT\nStrefy:\t\t\t%d/UNLIMIT\nProdukty:\t\t%d/%d\nGrupy:\t\t\t%d/%d", Iter_Count(Player), MAX_PLAYERS, Iter_Count(Vehicles), MAX_VEHICLES, Streamer_GetUpperBound(STREAMER_TYPE_PICKUP), Streamer_GetUpperBound(STREAMER_TYPE_AREA), Iter_Count(Product), MAX_PRODUCTS, Iter_Count(Groups), MAX_GROUPS);
	ShowPlayerDialog(playerid, D_NONE, DIALOG_STYLE_LIST, "Limity serwerowe", string, "OK", "");
	return 1;
}

cmd:agmx(playerid, params[])
{
	if(PlayerCache[playerid][pAdmin] < A_PERM_MAX)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_NO_PERM, "Nie możesz skorzystać z tej komendy.");
	    return 1;
	}
	foreach(new i : Player)
	{
	    OnPlayerDisconnect(i, 0);
		Kick(i);
	}
	SendRconCommand("exit");
	return 1;
}

cmd:attach(playerid, params[])
{
	new a_model, a_bone, a_name[32];
	if(sscanf(params, "dds[32]", a_model, a_bone, a_name))
	{
        ShowTipForPlayer(playerid, "/attach [Model] [Kość] [Nazwa przedmiotu]");
	    return 1;
	}
 	new Float:access_posx, Float:access_posy, Float:access_posz,
  		Float:access_rotx, Float:access_roty, Float:access_rotz,
    	Float:access_scalex, Float:access_scaley, Float:access_scalez;
	
 	new rows, Cache:tmp_cache, query[512];

	mysql_format(connHandle, query, sizeof(query), "SELECT `attach_uid`, `attach_x`, `attach_y`, `attach_z`, `attach_rx`, `attach_ry`, `attach_rz`, `attach_sx`, `attach_sy`, `attach_sz`, `attach_bone` FROM `"SQL_PREF"attached_objects` WHERE attach_model = '%d' LIMIT 1", a_model);
 	tmp_cache = mysql_query(connHandle, query);

    cache_get_row_count(rows);
	if(rows > 0)
	{
		cache_get_value_index_int(0, 0, AttachEdit[playerid][aUID]);

 		cache_get_value_index_float(0, 1, access_posx);
   		cache_get_value_index_float(0, 2, access_posy);
	    cache_get_value_index_float(0, 3, access_posz);

		cache_get_value_index_float(0, 4, access_rotx);
  		cache_get_value_index_float(0, 5, access_roty);
    	cache_get_value_index_float(0, 6, access_rotz);

		cache_get_value_index_float(0, 7, access_scalex);
  		cache_get_value_index_float(0, 8, access_scaley);
    	cache_get_value_index_float(0, 9, access_scalez);

		SetPlayerAttachedObject(playerid, SLOT_TRYING, a_model, a_bone, access_posx, access_posy, access_posz, access_rotx, access_roty, access_rotz, access_scalex, access_scaley, access_scalez);
		TD_ShowSmallInfo(playerid, 5, "Ten model jest juz w bazie. Edytujesz jego pozycje - nie zepsuj.");
	}
	else
	{
 		mysql_format(connHandle, query, sizeof(query), "INSERT INTO `"SQL_PREF"attached_objects` (attach_model, attach_bone, access_name) VALUES ('%d', '%d', '%e')", a_model, a_bone, a_name);
	    mysql_query(connHandle, query);

	    AttachEdit[playerid][aUID] = cache_insert_id();
	    SetPlayerAttachedObject(playerid, SLOT_TRYING, a_model, a_bone);
	    
	    TD_ShowSmallInfo(playerid, 5, "Utworzyles nowy model w bazie.");
	}
	if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
	EditAttachedObject(playerid, SLOT_TRYING);
	return 1;
}

cmd:corner(playerid, params[])
{
	new areaid = GetPlayerAreaID(playerid);
	if(areaid == INVALID_AREA_ID)
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w strefie z flagą handlu narkotykami.");
	    return 1;
	}
	new AreaData[sAreaData];
	Streamer_GetArrayData(STREAMER_TYPE_AREA, areaid, E_STREAMER_EXTRA_ID, AreaData);
	
	if(!(AreaData[aFlags] & A_FLAG_CORNER))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w strefie z flagą handlu narkotykami.");
	    return 1;
	}
	if(!HavePlayerItemType(playerid, ITEM_DRUG))
	{
	    ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Nie posiadasz w swoim ekwipunku narkotyków.");
	    return 1;
	}
	new object_id = INVALID_OBJECT_ID,
		Float:PosX, Float:PosY, Float:PosZ, virtual_world = GetPlayerVirtualWorld(playerid);

	GetPlayerPos(playerid, PosX, PosY, PosZ);

	new ObjectData[MAX_VIS_OBJECTS],
		count_objects = Streamer_GetNearbyItems(PosX, PosY, PosZ, STREAMER_TYPE_OBJECT, ObjectData, MAX_VIS_OBJECTS, 3.0, virtual_world);

	for (new object = 0; object < count_objects; object++)
	{
		if(GetObjectModel(ObjectData[object]) == OBJECT_CORNER_GREEN || GetObjectModel(ObjectData[object]) == OBJECT_CORNER_BLUE || GetObjectModel(ObjectData[object]) == OBJECT_CORNER_RED)
		{
			object_id = ObjectData[object];
			break;
		}
	}
	if(object_id == INVALID_OBJECT_ID)
	{
		ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Musisz znajdować się w pobliżu znacznika do handlowania (strzałka: zielona, niebieska lub czerwona).");
		return 1;
	}
	foreach(new i : Player)
	{
	    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	    {
	        if(PlayerCache[i][pCornerObject] == object_id)
	        {
	            ShowPlayerInfoDialog(playerid, D_TYPE_ERROR, "Ktoś aktualnie handluje już w tym miejscu.");
	            return 1;
	        }
	    }
	}
	PlayerCache[playerid][pCornerObject] = object_id;
	TD_ShowHint(playerid, HINT_NONE, 15, "Rozpoczales ~y~handel ~w~narkotykami. Oczekuj cierpliwie na klienta i ~r~nie oddalaj ~w~sie od tego miejsca.~n~~n~Klient zaoferuje Ci swoja cene, Ty mozesz z nim negocjowac lekko ja zawyzajac, lub po prostu ~g~zaakceptowac ~w~oferte i przytulic gotowke.~n~~n~Pamietaj, by posiadac w swoim ~p~ekwipunku ~w~narkotyki (nie w torbie), w innym wypadku handel zostanie przerwany.");
	return 1;
}
alias:corner("handel", "handluj");

cmd:screenshot(playerid, params[])
{
	new color;
	if(sscanf(params, "x", color))	color = 0x000000FF;
	
	if(!PlayerCache[playerid][pScreenShot])
	{
	    TD_ShowSmallInfo(playerid, 3, "Klawisz ~y~ESC ~w~lub ~p~/ss ~w~wylacza tryb zrzutu ekranu.~n~Mozesz takze wprowadzic wlasny kolor np. ~g~/screenshot 0x33AA33FF");
	
		PlayerTextDrawBoxColor(playerid, TextDrawScreenShot[playerid], color);
		PlayerTextDrawShow(playerid, TextDrawScreenShot[playerid]);
		
        SelectTextDraw(playerid, color);
	}
	else
	{
	    PlayerTextDrawHide(playerid, TextDrawScreenShot[playerid]);
	    CancelSelectTextDraw(playerid);
	}
	
	PlayerCache[playerid][pScreenShot] = !PlayerCache[playerid][pScreenShot];
	return 1;
}
alias:screenshot("ss");

/* STOCKI */
stock PlayerRealName(playerid)
{
	new pos, name[MAX_PLAYER_NAME];
	strmid(name, PlayerCache[playerid][pCharName], 0, strlen(PlayerCache[playerid][pCharName]), 24);

	pos = strfind(name, "_", true);
	while(pos != -1)
	{
		name[pos] = ' ';
		pos = strfind(name, "_", true);
	}
	return name;
}

stock PlayerName(playerid)
{
	new pos, name[MAX_PLAYER_NAME];
	GetPlayerName(playerid, name, sizeof(name));

    pos = strfind(name, "_", true);
	while(pos != -1)
	{
		name[pos] = ' ';
		pos = strfind(name, "_", true);
	}
	return name;
}

stock PlayerOriginalName(playerid)
{
	new name[MAX_PLAYER_NAME];
	GetPlayerName(playerid, name, sizeof(name));
	return name;
}

stock crp_SetPlayerHealth(playerid, Float:health)
{
	PlayerCache[playerid][pHealth] = health;
	SetPlayerHealth(playerid, PlayerCache[playerid][pHealth]);
	return 1;
}

stock crp_SetPlayerSkin(playerid, skinid)
{
	SetPlayerSkin(playerid, skinid);

	PlayerCache[playerid][pSkin] 		= skinid;
	PlayerCache[playerid][pLastSkin] 	= 0;
	return 1;
}

stock SetPlayerSkinEx(playerid, skinid)
{
	SetPlayerSkin(playerid, skinid);
	PlayerCache[playerid][pLastSkin] = skinid;
	return 1;
}

stock ResetPlayerCamera(playerid)
{
	new object_id = PlayerCache[playerid][pFirstPersonObject];
	if(object_id == INVALID_OBJECT_ID)
	{
	    SetCameraBehindPlayer(playerid);
	}
	else
	{
	    AttachObjectToPlayer(object_id, playerid, 0.0, 0.10, 0.65, 0.0, 0.0, 0.0);
	    AttachCameraToObject(playerid, object_id);
	}
	return 1;
}

stock crp_GivePlayerMoney(playerid, money)
{
	// Uniknijmy ujemnych wartości
	PlayerCache[playerid][pCash] = PlayerCache[playerid][pCash] + money;
	SetPlayerMoney(playerid, PlayerCache[playerid][pCash]);
	return 1;
}

stock crp_SetPlayerPos(playerid, Float:PosX, Float:PosY, Float:PosZ)
{
	PlayerCache[playerid][pCheckPos] = false;
    SetPlayerPos(playerid, PosX, PosY, PosZ);

	PlayerCache[playerid][pPosX] = PosX;
 	PlayerCache[playerid][pPosY] = PosY;
    PlayerCache[playerid][pPosZ] = PosZ;
	return 1;
}

stock IsGlobalLogged(player_gid)
{
	foreach(new i : Player)
	{
	    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	    {
	        if(PlayerCache[i][pGID] == player_gid)
	        {
	            return true;
	        }
	    }
	}
	return false;
}

stock PlayerToPlayer(Float:radi, playerid, targetid)
{
	if(GetPlayerState(targetid) == PLAYER_STATE_SPECTATING)
	{
	    return 0;
	}

	new Float:posx, Float:posy, Float:posz,
		Float:oldposx, Float:oldposy, Float:oldposz,
		Float:tempposx, Float:tempposy, Float:tempposz;

	GetPlayerPos(playerid, oldposx, oldposy, oldposz);

	GetPlayerPos(targetid, posx, posy, posz);
	tempposx = (oldposx -posx);
	tempposy = (oldposy -posy);
	tempposz = (oldposz -posz);

 	if (((tempposx < radi) && (tempposx > -radi)) && ((tempposy < radi) && (tempposy > -radi)) && ((tempposz < radi) && (tempposz > -radi)))
	{
		return 1;
	}
	return 0;
}

stock GetClosestPlayer(playerid)
{
	new Float:dist, Float:prevdist = 5.000,
		prevplayer = INVALID_PLAYER_ID;

	foreach(new i : Player)
	{
	    if(i != playerid)
	    {
			dist = GetDistanceToPlayer(playerid, i);
			if ((dist < prevdist))
			{
				prevdist = dist;
				prevplayer = i;
			}
		}
	}
	return prevplayer;
}

stock GetDistanceToPlayer(playerid, giveplayer_id)
{
	new Float:x1, Float:y1, Float:z1,
		Float:x2, Float:y2, Float:z2, Float:dis;

	GetPlayerPos(playerid, x1, y1, z1);
	GetPlayerPos(giveplayer_id, x2, y2, z2);

	dis = floatsqroot(floatpower(floatabs(floatsub(x2,x1)),2)+floatpower(floatabs(floatsub(y2,y1)),2)+floatpower(floatabs(floatsub(z2,z1)),2));
	return floatround(dis);
}

stock GetPlayerID(player_uid)
{
	new playerid = INVALID_PLAYER_ID;
	foreach(new i : Player)
	{
	    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	    {
			if(PlayerCache[i][pUID] == player_uid)
			{
				playerid = i;
				break;
			}
		}
	}
	return playerid;
}

stock GetCustomerID(playerid)
{
	new customerid = INVALID_PLAYER_ID;
	foreach(new i : Player)
	{
	    if(OfferData[i][oOffererID] == playerid)
	    {
	        customerid = i;
	        break;
	    }
	}
	return customerid;
}

stock GetXYInFrontOfPlayer(playerid, &Float:x, &Float:y, Float:distance) //by Y_Less
{
 	new Float:a;
 	GetPlayerPos(playerid, x, y, a);
 	GetPlayerFacingAngle(playerid, a);

 	x += (distance * floatsin(-a, degrees));
 	y += (distance * floatcos(-a, degrees));
}

stock CharCode(player_uid)
{
    new string[32], charcode[5];
	format(string, sizeof(string), "%d", player_uid);

    SHA256_PassHash(string, "code", charcode, sizeof(charcode));
    strmid(charcode, charcode, 0, 5, 5);
    
	return charcode;
}

stock SendClientFormatMessage(playerid, color, formatDesc[], va_args<>)
{
	new string[256];
	va_format(string, sizeof(string), formatDesc, va_start<3>);
	
	SendClientMessage(playerid, color, string);
	return 1;
}

stock ShowPlayerInfoDialog(playerid, dialog_type, desc[], va_args<>)
{
	new string_desc[512], title[24];
	va_format(string_desc, sizeof(string_desc), desc, va_start<3>);
	
	switch(dialog_type)
	{
	    case D_TYPE_INFO:
	    {
			title = "Informacja";
	    }
	    case D_TYPE_ERROR:
	    {
	        title = "Wystąpił błąd!";
	    }
	    case D_TYPE_SUCCESS:
	    {
	        title = "Powodzenie";
	    }
	    case D_TYPE_HELP:
	    {
	        title = "Pomoc";
	    }
	    case D_TYPE_NO_PERM:
	    {
	        title = "Brak uprawnień";
	    }
	}
	ShowPlayerDialog(playerid, D_NONE, DIALOG_STYLE_MSGBOX, title, string_desc, "OK", "");
	return 1;
}

stock ShowTipForPlayer(playerid, tipDesc[], va_args<>)
{
	new string[256];
	va_format(string, sizeof(string), tipDesc, va_start<2>);
	
	format(string, sizeof(string), "Tip: %s", string);
	SendClientMessage(playerid, COLOR_GREY, string);
	return 1;
}

stock mysql_query_format(format_query[], va_args<>)
{
	new query[512];
	va_format(query, sizeof(query), format_query, va_start<1>);
	
	mysql_query(connHandle, query);
	return 1;
}

stock PreloadAnimLib(playerid, animlib[])
{
	ApplyAnimation(playerid, animlib, "null", 0.0, 0, 0, 0, 0, 0);
	return 1;
}

stock PreloadPlayerAnimLib(playerid)
{
	PreloadAnimLib(playerid, "GHANDS");
	PreloadAnimLib(playerid, "GANGS");
	PreloadAnimLib(playerid, "PED");
	PreloadAnimLib(playerid, "MISC");
	PreloadAnimLib(playerid, "CRACK");
	PreloadAnimLib(playerid, "INT_HOUSE");
	PreloadAnimLib(playerid, "MUSCULAR");
	PreloadAnimLib(playerid, "ON_LOOKERS");
	PreloadAnimLib(playerid, "Attractors");
	PreloadAnimLib(playerid, "POOL");
	PreloadAnimLib(playerid, "INT_OFFICE");
	PreloadAnimLib(playerid, "BSKTBALL");
	PreloadAnimLib(playerid, "RAPPING");
	PreloadAnimLib(playerid, "BAR");
	PreloadAnimLib(playerid, "BEACH");
	PreloadAnimLib(playerid, "benchpress");
	PreloadAnimLib(playerid, "BASEBALL");
	PreloadAnimLib(playerid, "BLOWJOBZ");
	PreloadAnimLib(playerid, "BOMBER");
	PreloadAnimLib(playerid, "BOX");
	PreloadAnimLib(playerid, "BUDDY");
	PreloadAnimLib(playerid, "BUS");
	PreloadAnimLib(playerid, "CAMERA");
	PreloadAnimLib(playerid, "CAR");
	PreloadAnimLib(playerid, "CARRY");
	PreloadAnimLib(playerid, "CAR_CHAT");
	PreloadAnimLib(playerid, "CASINO");
	PreloadAnimLib(playerid, "CHAINSAW");
	PreloadAnimLib(playerid, "CHOPPA");
	PreloadAnimLib(playerid, "CLOTHES");
	PreloadAnimLib(playerid, "COACH");
	PreloadAnimLib(playerid, "COLT45");
	PreloadAnimLib(playerid, "COP_AMBIENT");
	PreloadAnimLib(playerid, "COP_DVBYZ");
	PreloadAnimLib(playerid, "CRIB");
	PreloadAnimLib(playerid, "DANCING");
	PreloadAnimLib(playerid, "DEALER");
	PreloadAnimLib(playerid, "DILDO");
	PreloadAnimLib(playerid, "DODGE");
	PreloadAnimLib(playerid, "DOZER");
	PreloadAnimLib(playerid, "DRIVEBYS");
	PreloadAnimLib(playerid, "FAT");
	PreloadAnimLib(playerid, "FIGHT_B");
	PreloadAnimLib(playerid, "FIGHT_C");
	PreloadAnimLib(playerid, "FIGHT_D");
	PreloadAnimLib(playerid, "FIGHT_E");
	PreloadAnimLib(playerid, "FINALE");
	PreloadAnimLib(playerid, "FINALE2");
	PreloadAnimLib(playerid, "FLAME");
	PreloadAnimLib(playerid, "Flowers");
	PreloadAnimLib(playerid, "FOOD");
	PreloadAnimLib(playerid, "Freeweights");
	PreloadAnimLib(playerid, "GHETTO_DB");
	PreloadAnimLib(playerid, "goggles");
	PreloadAnimLib(playerid, "GRAFFITI");
	PreloadAnimLib(playerid, "GRAVEYARD");
	PreloadAnimLib(playerid, "GRENADE");
	PreloadAnimLib(playerid, "GYMNASIUM");
	PreloadAnimLib(playerid, "HAIRCUTS");
	PreloadAnimLib(playerid, "HEIST9");
	PreloadAnimLib(playerid, "INT_OFFICE");
	PreloadAnimLib(playerid, "INT_SHOP");
	PreloadAnimLib(playerid, "JST_BUISNESS");
	PreloadAnimLib(playerid, "KART");
	PreloadAnimLib(playerid, "KISSING");
	PreloadAnimLib(playerid, "KNIFE");
	PreloadAnimLib(playerid, "LAPDAN1");
	PreloadAnimLib(playerid, "LAPDAN2");
	PreloadAnimLib(playerid, "LAPDAN3");
	PreloadAnimLib(playerid, "LOWRIDER");
	PreloadAnimLib(playerid, "MD_CHASE");
	PreloadAnimLib(playerid, "MD_END");
	PreloadAnimLib(playerid, "MEDIC");
	PreloadAnimLib(playerid, "MTB");
	PreloadAnimLib(playerid, "NEVADA");
	PreloadAnimLib(playerid, "OTB");
	PreloadAnimLib(playerid, "PARACHUTE");
	PreloadAnimLib(playerid, "PARK");
	PreloadAnimLib(playerid, "PAULNMAC");
	PreloadAnimLib(playerid, "PLAYER_DVBYS");
	PreloadAnimLib(playerid, "PLAYIDLES");
	PreloadAnimLib(playerid, "POLICE");
	PreloadAnimLib(playerid, "POOR");
	PreloadAnimLib(playerid, "PYTHON");
	PreloadAnimLib(playerid, "RIFLE");
	PreloadAnimLib(playerid, "RIOT");
	PreloadAnimLib(playerid, "ROB_BANK");
	PreloadAnimLib(playerid, "ROCKET");
	PreloadAnimLib(playerid, "RUSTLER");
	PreloadAnimLib(playerid, "RYDER");
	PreloadAnimLib(playerid, "SCRATCHING");
	PreloadAnimLib(playerid, "SHAMAL");
	PreloadAnimLib(playerid, "SHOP");
	PreloadAnimLib(playerid, "SHOTGUN");
	PreloadAnimLib(playerid, "SILENCED");
	PreloadAnimLib(playerid, "SKATE");
	PreloadAnimLib(playerid, "SMOKING");
	PreloadAnimLib(playerid, "SNIPER");
	PreloadAnimLib(playerid, "SPRAYCAN");
	PreloadAnimLib(playerid, "STRIP");
	PreloadAnimLib(playerid, "SUNBATHE");
	PreloadAnimLib(playerid, "SWAT");
	PreloadAnimLib(playerid, "SWEET");
	PreloadAnimLib(playerid, "SWIM");
	PreloadAnimLib(playerid, "SWORD");
	PreloadAnimLib(playerid, "TANK");
	PreloadAnimLib(playerid, "TATTOOS");
	PreloadAnimLib(playerid, "TEC");
	PreloadAnimLib(playerid, "TRAIN");
	PreloadAnimLib(playerid, "TRUCK");
	PreloadAnimLib(playerid, "UZI");
	PreloadAnimLib(playerid, "VAN");
	PreloadAnimLib(playerid, "VENDING");
	PreloadAnimLib(playerid, "VORTEX");
	PreloadAnimLib(playerid, "WAYFARER");
	PreloadAnimLib(playerid, "WEAPONS");
	PreloadAnimLib(playerid, "WUZI");
	return 1;
}

stock ClearPlayerChat(playerid)
{
	for(new i = 1; i < 40; i++)
	{
		SendClientMessage(playerid, COLOR_WHITE, " ");
	}
	return 1;
}

stock OnPlayerFreeze(playerid, bool: freeze, time)
{
	if(freeze)
	{
		TogglePlayerControllable(playerid, false);
		
		if(time)	PlayerCache[playerid][pFreeze] = time;
		else        PlayerCache[playerid][pFreeze] = -1;
	}
	else
	{
	    TogglePlayerControllable(playerid, true);
	    PlayerCache[playerid][pFreeze] = 0;
	}
	return 1;
}

stock SetPlayerMoney(playerid, money)
{
	ResetPlayerMoney(playerid);
	GivePlayerMoney(playerid, money);
	return 1;
}

stock TD_ShowSmallInfo(playerid, showTime = 5, infoString[], va_args<>)
{
	new string[512];
	va_format(string, sizeof(string), infoString, va_start<3>);

	PlayerTextDrawSetString(playerid, PlayerText:TD_SmallInfo[playerid], string);
	PlayerTextDrawShow(playerid, PlayerText:TD_SmallInfo[playerid]);

	PlayerCache[playerid][pSmallTextTime] = (showTime > 0) ? (gettime() + showTime) : 0;
	return 1;
}

stock TD_ShowLargeInfo(playerid, showTime = 5, infoString[], va_args<>)
{
	new string[512];
	
	va_format(string, sizeof(string), infoString, va_start<3>);
	PlayerTextDrawSetString(playerid, PlayerText:TextDrawLargeInfo[playerid][1], string);
	
	PlayerTextDrawShow(playerid, PlayerText:TextDrawLargeInfo[playerid][0]);
	PlayerTextDrawShow(playerid, PlayerText:TextDrawLargeInfo[playerid][1]);
	
	PlayerCache[playerid][pLargeTextTime] = (showTime > 0) ? (gettime() + showTime) : 0;
	return 1;
}

stock TD_HideSmallInfo(playerid)
{
	PlayerTextDrawHide(playerid, PlayerText:TD_SmallInfo[playerid]);
	PlayerCache[playerid][pSmallTextTime] = 0;
	return 1;
}

stock TD_HideLargeInfo(playerid)
{
    PlayerTextDrawHide(playerid, PlayerText:TextDrawLargeInfo[playerid][0]);
    PlayerTextDrawHide(playerid, PlayerText:TextDrawLargeInfo[playerid][1]);
    
	PlayerCache[playerid][pLargeTextTime] = 0;
	return 1;
}

stock TD_ShowDoor(playerid, showTime = 5, doorString[], va_args<>)
{
	new string[512];
	va_format(string, sizeof(string), doorString, va_start<3>);

	PlayerTextDrawSetString(playerid, PlayerText:TD_SmallInfo[playerid], string);
	
	PlayerTextDrawShow(playerid, PlayerText:TD_SmallInfo[playerid]);
	PlayerCache[playerid][pSmallTextTime] = (showTime > 0) ? (gettime() + showTime) : 0;
	return 1;
}

stock TD_HideDoor(playerid)
{
	PlayerTextDrawHide(playerid, PlayerText:TD_SmallInfo[playerid]);
	PlayerCache[playerid][pSmallTextTime] = 0;
	return 1;
}

stock TD_ShowHint(playerid, hintType, showTime = 0, infoString[], va_args<>)
{
	if(PlayerCache[playerid][pHint] & hintType) return 1;

	new string[1024];
	va_format(string, sizeof(string), infoString, va_start<4>);

	PlayerTextDrawSetString(playerid, PlayerText:TD_Hint[playerid], string);
	PlayerTextDrawShow(playerid, PlayerText:TD_Hint[playerid]);

	PlayerCache[playerid][pHintTextTime] = (showTime > 0) ? (gettime() + showTime) : 0;
	PlayerCache[playerid][pHint] += hintType;
	
	switch(hintType)
	{
	    case HINT_KEY_NO:
	    {
	        // Pokaż najbliższy przystanek
	        new object_id = GetClosestObjectType(playerid, OBJECT_BUSSTOP, 100.0), Float:objPos[3];
	        GetDynamicObjectPos(object_id, objPos[0], objPos[1], objPos[2]);
	        
	        SetPlayerCheckpoint(playerid, objPos[0], objPos[1], objPos[2], 5.0);
			PlayerCache[playerid][pCheckpoint] = CHECKPOINT_BUSSTOP;
	    }
	    case HINT_DOCUMENT:
	    {
	    
	    }
	    case HINT_BANK:
	    {
	        // Samouczek przydziela trochę kasy
	        if(PlayerCache[playerid][pBankCash] <= 0)
			{
				PlayerCache[playerid][pBankCash] += 400;
				orm_update(PlayerCache[playerid][pOrm]);
			}
	    }
	    case HINT_WORK:
	    {
	        switch(WorkInfo[playerid][wID])
	        {
	            case JOB_COURIER:		CreatePlayerItem(playerid, "Czapka kuriera", ITEM_CLOTH_ACCESS, 0, 236);
	            case JOB_NEWSPAPER: 	CreatePlayerItem(playerid, "Plecak na gazety", ITEM_CLOTH_ACCESS, 0, 237);
	            case JOB_MECHANIC:  	CreatePlayerItem(playerid, "Klucz mechanika", ITEM_CLOTH_ACCESS, 0, 239);
	            case JOB_SELLER:    	CreatePlayerItem(playerid, "Czapka sprzedawcy", ITEM_CLOTH_ACCESS, 0, 300);
	            case JOB_LUMBERJACK:	CreatePlayerItem(playerid, "Sluchawki drwala", ITEM_CLOTH_ACCESS, 0, 330);
			}
   		}
	}
	return 1;
}

stock TD_HideHint(playerid)
{
	PlayerTextDrawHide(playerid, PlayerText:TD_Hint[playerid]);
	PlayerCache[playerid][pHintTextTime] = 0;
	return 1;
}

stock TD_CreateForPlayer(playerid)
{
	// TextDraw informacyjny (small)
    TD_SmallInfo[playerid] = CreatePlayerTextDraw(playerid, 150.000000, 360.000000, "_");
	PlayerTextDrawBackgroundColor(playerid, TD_SmallInfo[playerid], 255);
	PlayerTextDrawFont(playerid, TD_SmallInfo[playerid], 1);
	PlayerTextDrawLetterSize(playerid, TD_SmallInfo[playerid], 0.290000, 1.699999);
	PlayerTextDrawColor(playerid, TD_SmallInfo[playerid], -1);
	PlayerTextDrawSetOutline(playerid, TD_SmallInfo[playerid], 0);
	PlayerTextDrawSetProportional(playerid, TD_SmallInfo[playerid], 1);
	PlayerTextDrawSetShadow(playerid, TD_SmallInfo[playerid], 1);
	PlayerTextDrawUseBox(playerid, TD_SmallInfo[playerid], 1);
	PlayerTextDrawBoxColor(playerid, TD_SmallInfo[playerid], 0);
	PlayerTextDrawTextSize(playerid, TD_SmallInfo[playerid], 500.000000, 0.000000);
	//  *** *** //
	
	// TextDraw samouczka
	TD_Hint[playerid] = CreatePlayerTextDraw(playerid, 450.000000, 120.000000, "_");
	PlayerTextDrawBackgroundColor(playerid, TD_Hint[playerid], 255);
	PlayerTextDrawFont(playerid, TD_Hint[playerid], 1);
	PlayerTextDrawLetterSize(playerid, TD_Hint[playerid], 0.280000, 1.500000);
	PlayerTextDrawColor(playerid, TD_Hint[playerid], -1);
	PlayerTextDrawSetOutline(playerid, TD_Hint[playerid], 1);
	PlayerTextDrawSetProportional(playerid, TD_Hint[playerid], 1);
	PlayerTextDrawUseBox(playerid, TD_Hint[playerid], 1);
	PlayerTextDrawBoxColor(playerid, TD_Hint[playerid], 68);
	PlayerTextDrawTextSize(playerid, TD_Hint[playerid], 607.000000, 170.000000);
	//  *** *** //
	
	new Float:posX, Float:posY;
	for(new group_slot = 0; group_slot < MAX_GROUP_SLOTS; group_slot++)
	{
	    posX = 190.000000;
		posY = 125.000000;

		if(group_slot == 1) posX += 130.000000;
		if(group_slot == 2) posY += 120.000000;
		if(group_slot == 3)
		{
			posX += 130.000000;
			posY += 120.000000;
		}

		TD_MainGroupTag[playerid][group_slot] = CreatePlayerTextDraw(playerid, posX, posY, "_");
		TD_MainGroupName[playerid][group_slot] = CreatePlayerTextDraw(playerid, posX + 2.0, posY + 16.0, "_");

		PlayerTextDrawBackgroundColor(playerid, TD_MainGroupTag[playerid][group_slot], 255);
		PlayerTextDrawFont(playerid, TD_MainGroupTag[playerid][group_slot], 1);
		PlayerTextDrawLetterSize(playerid, TD_MainGroupTag[playerid][group_slot], 0.410000, 1.500000);
		PlayerTextDrawColor(playerid, TD_MainGroupTag[playerid][group_slot], -1);
		PlayerTextDrawSetOutline(playerid, TD_MainGroupTag[playerid][group_slot], 1);
		PlayerTextDrawSetProportional(playerid, TD_MainGroupTag[playerid][group_slot], 1);
		PlayerTextDrawUseBox(playerid, TD_MainGroupTag[playerid][group_slot], 1);
		PlayerTextDrawBoxColor(playerid, TD_MainGroupTag[playerid][group_slot], 68);

		if(group_slot == 1 || group_slot == 3)
		{
			PlayerTextDrawTextSize(playerid, TD_MainGroupTag[playerid][group_slot], 440.000000, 150.000000);
		}
		else
		{
		    PlayerTextDrawTextSize(playerid, TD_MainGroupTag[playerid][group_slot], 310.000000, 150.000000);
		}

		PlayerTextDrawBackgroundColor(playerid, TD_MainGroupName[playerid][group_slot], 255);
		PlayerTextDrawFont(playerid, TD_MainGroupName[playerid][group_slot], 1);
		PlayerTextDrawLetterSize(playerid, TD_MainGroupName[playerid][group_slot], 0.200000, 1.000000);
		PlayerTextDrawColor(playerid, TD_MainGroupName[playerid][group_slot], -1);
		PlayerTextDrawSetOutline(playerid, TD_MainGroupName[playerid][group_slot], 0);
		PlayerTextDrawSetProportional(playerid, TD_MainGroupName[playerid][group_slot], 1);
		PlayerTextDrawSetShadow(playerid, TD_MainGroupName[playerid][group_slot], 1);
	}
	
	// TextDrawOferty
	TextDrawOfferDesc[playerid] = CreatePlayerTextDraw(playerid, 211.000000, 290.000000, "_");
	PlayerTextDrawLetterSize(playerid, TextDrawOfferDesc[playerid], 0.219999, 0.899999);
	PlayerTextDrawColor(playerid, TextDrawOfferDesc[playerid], -1);
	PlayerTextDrawSetOutline(playerid, TextDrawOfferDesc[playerid], 1);
	PlayerTextDrawSetProportional(playerid, TextDrawOfferDesc[playerid], 1);
	// ***  *** //
	
	// Osiągnięcia
	TextDrawAchieve[playerid] = CreatePlayerTextDraw(playerid, 498.000000, 101.000000, "_");
	PlayerTextDrawBackgroundColor(playerid, TextDrawAchieve[playerid], 255);
	PlayerTextDrawLetterSize(playerid, TextDrawAchieve[playerid], 0.210000, 1.000000);
	PlayerTextDrawColor(playerid, TextDrawAchieve[playerid], -1);
	PlayerTextDrawSetOutline(playerid, TextDrawAchieve[playerid], 1);
	PlayerTextDrawUseBox(playerid, TextDrawAchieve[playerid], 1);
	PlayerTextDrawBoxColor(playerid, TextDrawAchieve[playerid], 68);
	PlayerTextDrawTextSize(playerid, TextDrawAchieve[playerid], 606.000000, 170.000000);
	// ***  *** //
	
	// ***	TextDraw informacyjny (large)   *** //
	TextDrawLargeInfo[playerid][0] = CreatePlayerTextDraw(playerid, 0.000000, 337.000000, "_");
	PlayerTextDrawLetterSize(playerid, TextDrawLargeInfo[playerid][0], 0.300000, 12.300001);
	PlayerTextDrawUseBox(playerid, TextDrawLargeInfo[playerid][0], 1);
	PlayerTextDrawBoxColor(playerid, TextDrawLargeInfo[playerid][0], -1715157214);
	PlayerTextDrawTextSize(playerid, TextDrawLargeInfo[playerid][0], 640.000000, 600.000000);
	
	TextDrawLargeInfo[playerid][1] = CreatePlayerTextDraw(playerid, 150.000000, 350.000000, "_");
	PlayerTextDrawBackgroundColor(playerid, TextDrawLargeInfo[playerid][1], 255);
	PlayerTextDrawFont(playerid, TextDrawLargeInfo[playerid][1], 1);
	PlayerTextDrawLetterSize(playerid, TextDrawLargeInfo[playerid][1], 0.339999, 1.200000);
	PlayerTextDrawColor(playerid, TextDrawLargeInfo[playerid][1], -1);
	PlayerTextDrawSetOutline(playerid, TextDrawLargeInfo[playerid][1], 1);
	PlayerTextDrawSetProportional(playerid, TextDrawLargeInfo[playerid][1], 1);
	// ***  *** //
	
	// ***  TextDraw CB Radio   *** //
	TextDrawRadioCB[playerid] = CreatePlayerTextDraw(playerid, 499.000000, 98.799987, "_");
	PlayerTextDrawBackgroundColor(playerid, TextDrawRadioCB[playerid], 255);
	PlayerTextDrawFont(playerid, TextDrawRadioCB[playerid], 3);
	PlayerTextDrawLetterSize(playerid, TextDrawRadioCB[playerid], 0.300000, 1.000000);
	PlayerTextDrawColor(playerid, TextDrawRadioCB[playerid], -2925313);
	PlayerTextDrawSetOutline(playerid, TextDrawRadioCB[playerid], 1);
	PlayerTextDrawSetProportional(playerid, TextDrawRadioCB[playerid], 1);
	// ***  *** //
	
	// ***  TextDraw służby grupy   *** //
	TextDrawDuty[playerid] = CreatePlayerTextDraw(playerid, 7.000000, 424.800000, "_");
	PlayerTextDrawBackgroundColor(playerid, TextDrawDuty[playerid], COLOR_WHITE);
	PlayerTextDrawLetterSize(playerid, TextDrawDuty[playerid], 0.300000, 1.000000);
	PlayerTextDrawColor(playerid, TextDrawDuty[playerid], -1);
	PlayerTextDrawSetOutline(playerid, TextDrawDuty[playerid], 1);
	// ***  *** //
	
	// ***  TextDraw GII    *** //
	GII_VisualItem[playerid] = CreatePlayerTextDraw(playerid, 310.000000, 160.000000, "_");
	PlayerTextDrawColor(playerid, GII_VisualItem[playerid], COLOR_GREY);
	PlayerTextDrawAlignment(playerid, GII_VisualItem[playerid], 2);
	PlayerTextDrawFont(playerid, GII_VisualItem[playerid], 1);
	PlayerTextDrawLetterSize(playerid, GII_VisualItem[playerid], 0.319999, 1.300000);
	PlayerTextDrawColor(playerid, GII_VisualItem[playerid], -1);
	PlayerTextDrawSetOutline(playerid, GII_VisualItem[playerid], 1);
	PlayerTextDrawSetProportional(playerid, GII_VisualItem[playerid], 1);
	// *** *** //
	
	
	// *** ScreenShot   *** //
	TextDrawScreenShot[playerid] = CreatePlayerTextDraw(playerid, -20.000000,2.000000, "|");
	PlayerTextDrawUseBox(playerid, TextDrawScreenShot[playerid],1);
	PlayerTextDrawBoxColor(playerid, TextDrawScreenShot[playerid],0x000000ff);
	PlayerTextDrawTextSize(playerid, TextDrawScreenShot[playerid],660.000000,22.000000);
	PlayerTextDrawAlignment(playerid, TextDrawScreenShot[playerid],0);
	PlayerTextDrawBackgroundColor(playerid, TextDrawScreenShot[playerid],0x000000ff);
	PlayerTextDrawFont(playerid, TextDrawScreenShot[playerid],3);
	PlayerTextDrawLetterSize(playerid, TextDrawScreenShot[playerid],1.000000,52.200000);
	PlayerTextDrawColor(playerid, TextDrawScreenShot[playerid],0x000000ff);
	PlayerTextDrawSetOutline(playerid, TextDrawScreenShot[playerid],1);
	PlayerTextDrawSetProportional(playerid, TextDrawScreenShot[playerid],1);
	PlayerTextDrawSetShadow(playerid, TextDrawScreenShot[playerid],1);
	PlayerTextDrawSetSelectable(playerid, TextDrawScreenShot[playerid], 1);
	//  *** *** //
	return 1;
}


stock HidePlayerGroups(playerid)
{
	TextDrawHideForPlayer(playerid, Text:TextDrawGroupsTitle);
	for (new group_slot = 0; group_slot < MAX_GROUP_SLOTS; group_slot++)
	{
	    PlayerTextDrawSetString(playerid, PlayerText:TextDrawGroups[playerid][group_slot], "_");
		PlayerTextDrawHide(playerid, PlayerText:TextDrawGroups[playerid][group_slot]);
		
		for(new option_id = 0; option_id < 5; option_id++)
		{
			TextDrawHideForPlayer(playerid, Text:TextDrawGroupOption[group_slot][option_id]);
		}
	}
	CancelSelectTextDraw(playerid);
	return 1;
}

stock GetGroupID(group_uid)
{
	new group_id = INVALID_GROUP_ID;
	foreach(new i : Groups)
	{
	    if(GroupData[i][gUID] == group_uid)
	    {
			group_id = i;
			break;
	    }
	}
	return group_id;
}

stock GetPlayerGroupID(playerid, group_uid)
{
	new group_id = INVALID_GROUP_ID;
	for (new slot = 0; slot < MAX_GROUP_SLOTS; slot++)
	{
	    if(PlayerGroup[playerid][slot][gpUID] == group_uid)
	    {
	        group_id = PlayerGroup[playerid][slot][gpID];
	        break;
	    }
	}
	return group_id;
}

stock IsPlayerInGroup(playerid, group_uid)
{
	for (new slot = 0; slot < MAX_GROUP_SLOTS; slot++)
	{
	    if(PlayerGroup[playerid][slot][gpUID] == group_uid)
	    {
	        return true;
	    }
	}
	return false;
}

stock GetPlayerGroupSlot(playerid, group_uid)
{
	new group_slot = INVALID_SLOT_ID;
	for (new slot = 0; slot < MAX_GROUP_SLOTS; slot++)
	{
	    if(PlayerGroup[playerid][slot][gpUID])
	    {
		    if(PlayerGroup[playerid][slot][gpUID] == group_uid)
		    {
	     		group_slot = slot;
	     		break;
		    }
		}
	}
	return group_slot;
}

stock GetPlayerFreeGroupSlot(playerid)
{
	new group_slot = INVALID_SLOT_ID;
	for (new slot = 0; slot < MAX_GROUP_SLOTS; slot++)
	{
	    if(!PlayerGroup[playerid][slot][gpUID])
	    {
     		group_slot = slot;
     		break;
	    }
	}
	return group_slot;
}

stock IsPlayerInGroupType(playerid, type)
{
	new group_id;
	for (new slot = 0; slot < MAX_GROUP_SLOTS; slot++)
	{
	    if(PlayerGroup[playerid][slot][gpUID])
	    {
	        group_id = PlayerGroup[playerid][slot][gpID];
	        if(GroupData[group_id][gType] == type)
	        {
	        	return true;
			}
	    }
	}
	return false;
}

stock IsPlayerInAnyGroup(playerid)
{
	for (new slot = 0; slot < MAX_GROUP_SLOTS; slot++)
	{
	    if(PlayerGroup[playerid][slot][gpUID])
	    {
    		return true;
	    }
	}
	return false;
}

stock HavePlayerGroupPerm(playerid, group_uid, permission)
{
	new group_id = GetGroupID(group_uid), group_slot;
	if(GroupData[group_id][gOwner])
	{
	    if(IsPlayerInGroup(playerid, GroupData[group_id][gOwner]))
	    {
	        group_slot = GetPlayerGroupSlot(playerid, GroupData[group_id][gOwner]);
	        if(PlayerGroup[playerid][group_slot][gpPerm] & permission)
	        {
	            return true;
	        }
	    }
	}

 	if(IsPlayerInGroup(playerid, group_uid))
 	{
  		group_slot = GetPlayerGroupSlot(playerid, group_uid);
    	if(PlayerGroup[playerid][group_slot][gpPerm] & permission)
     	{
      		return true;
        }
	}
	return false;
}

stock GetVehicleID(veh_uid)
{
	new vehid = INVALID_VEHICLE_ID;
	foreach(new car : Vehicles)
	{
		if(CarInfo[car][cUID] == veh_uid)
		{
			vehid = car;
			break;
		}
	}
	return vehid;
}

stock GetClosestVehicle(playerid)
{
	new Float:dist, Float:prevdist = 5.000,
		prevcar = INVALID_VEHICLE_ID, virtual_world = GetPlayerVirtualWorld(playerid);
		
	foreach(new carid : Vehicles)
	{
	    if(GetVehicleVirtualWorld(carid) == virtual_world)
	    {
			dist = GetDistanceToVehicle(playerid, carid);
			if ((dist < prevdist))
			{
				prevdist = dist;
				prevcar = carid;
			}
		}
	}
	return prevcar;
}

stock GetDistanceToVehicle(playerid, carid)
{
	new Float:x1, Float:y1, Float:z1,
		Float:x2, Float:y2, Float:z2, Float:dis;

	GetPlayerPos(playerid, x1, y1, z1);
	GetVehiclePos(carid, x2, y2, z2);

	dis = floatsqroot(floatpower(floatabs(floatsub(x2,x1)),2)+floatpower(floatabs(floatsub(y2,y1)),2)+floatpower(floatabs(floatsub(z2,z1)),2));
	return floatround(dis);
}


stock IsAnyPlayerInVehicle(vehicleid)
{
	foreach(new i : Player)
	{
	    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	    {
			if(GetPlayerVehicleID(i) == vehicleid)
			{
				return true;
			}
		}
	}
	return false;
}

stock GetFreeVehicleSeat(vehicleid)
{
    new bool: vehicleSeatStatus[4];
    foreach(new i : Player)
    {
        if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
        {
	        if(GetPlayerVehicleID(i) == vehicleid)
	        {
	            vehicleSeatStatus[GetPlayerVehicleSeat(i)] = false;
	        }
		}
    }

    for(new i = 0; i < 4; i++)
    {
        if(vehicleSeatStatus[i] == true)
        {
            return i;
        }
    }

    return INVALID_VEHICLE_ID;
}

stock GetPlayerSpawnedVehicles(playerid)
{
	new vehicles;
	foreach(new i : Vehicles)
	{
	    if(CarInfo[i][cOwnerType] == OWNER_PLAYER && CarInfo[i][cOwner] == PlayerCache[playerid][pUID])
	    {
	        vehicles ++;
	    }
	}
	return vehicles;
}

stock IsPlayerFacingVehicle(playerid, vehicleid)
{
	new Float:plPosX, Float:plPosZ, Float:plPosY, Float:vePosX, Float:vePosY, Float:vePosZ, Float:MainAngle;

	GetVehiclePos(vehicleid, vePosX, vePosY, vePosZ);
	GetPlayerPos(playerid, plPosX, plPosY, plPosZ);

	if( vePosY > plPosY ) MainAngle = (-acos((vePosX - plPosX) / floatsqroot((vePosX - plPosX) * (vePosX - plPosX) + (vePosY - plPosY) * (vePosY - plPosY))) - 90.0);
	else if( vePosY < plPosY && vePosX < plPosX ) MainAngle = (acos((vePosX - plPosX) / floatsqroot((vePosX - plPosX) * (vePosX - plPosX) + (vePosY - plPosY) * (vePosY - plPosY))) - 450.0);
	else if( vePosY < plPosY ) MainAngle = (acos((vePosX - plPosX) / floatsqroot((vePosX - plPosX) * (vePosX - plPosX) + (vePosY - plPosY) * (vePosY - plPosY))) - 90.0);

	if(vePosX > plPosX) MainAngle = (floatabs(floatabs(MainAngle) + 180.0));
	else MainAngle = (floatabs(MainAngle) - 180.0);

	new Float:plAngle;
	GetPlayerFacingAngle(playerid, plAngle);

	if(MainAngle - plAngle < -130 || MainAngle - plAngle > 130)
	{
		return 0;
	}
	return 1;
}

stock ChangeVehicleEngineStatus(vehicleid, toggle)
{
	new engine, lights, alarm, doors, bonnet, boot, objective;

	GetVehicleParamsEx(vehicleid, engine, lights, alarm, doors, bonnet, boot, objective);
	SetVehicleParamsEx(vehicleid, toggle, lights, false, doors, bonnet, boot, objective);
	return toggle;
}

stock GetVehicleEngineStatus(vehicleid)
{
	new bool: engine, lights, alarm, doors, bonnet, boot, objective;
	GetVehicleParamsEx(vehicleid, engine, lights, alarm, doors, bonnet, boot, objective);
	return engine;
}

stock SetVehicleLock(vehicleid, toggle)
{
	new engine, lights, alarm, doors, bonnet, boot, objective;

	GetVehicleParamsEx(vehicleid, engine, lights, alarm, doors, bonnet, boot, objective);
    SetVehicleParamsEx(vehicleid, engine, lights, false, toggle, bonnet, boot, objective);
	return toggle;
}

stock ChangeVehicleLightsStatus(vehicleid, toggle)
{
	new engine, lights, alarm, doors, bonnet, boot, objective;

	GetVehicleParamsEx(vehicleid, engine, lights, alarm, doors, bonnet, boot, objective);
    SetVehicleParamsEx(vehicleid, engine, toggle, alarm, doors, bonnet, boot, objective);
	return toggle;
}

stock GetVehicleLightsStatus(vehicleid)
{
	new engine, lights, alarm, doors, bonnet, boot, objective;
	GetVehicleParamsEx(vehicleid, engine, lights, alarm, doors, bonnet, boot, objective);
	return lights;
}

stock ChangeVehicleBonnetStatus(vehicleid, toggle)
{
	new engine, lights, alarm, doors, bonnet, boot, objective;

	GetVehicleParamsEx(vehicleid, engine, lights, alarm, doors, bonnet, boot, objective);
    SetVehicleParamsEx(vehicleid, engine, lights, alarm, doors, toggle, boot, objective);
	return toggle;
}

stock GetVehicleBonnetStatus(vehicleid)
{
	new engine, lights, alarm, doors, bonnet, boot, objective;
	GetVehicleParamsEx(vehicleid, engine, lights, alarm, doors, bonnet, boot, objective);
	return bonnet;
}

stock ChangeVehicleBootStatus(vehicleid, toggle)
{
	new engine, lights, alarm, doors, bonnet, boot, objective;

	GetVehicleParamsEx(vehicleid, engine, lights, alarm, doors, bonnet, boot, objective);
    SetVehicleParamsEx(vehicleid, engine, lights, alarm, doors, bonnet, toggle, objective);
	return toggle;
}

stock GetVehicleBootStatus(vehicleid)
{
	new engine, lights, alarm, doors, bonnet, boot, objective;
	GetVehicleParamsEx(vehicleid, engine, lights, alarm, doors, bonnet, boot, objective);
	return boot;
}

stock ChangeVehicleAlarmStatus(vehicleid, toggle)
{
	new engine, lights, alarm, doors, bonnet, boot, objective;

	GetVehicleParamsEx(vehicleid, engine, lights, alarm, doors, bonnet, boot, objective);
    SetVehicleParamsEx(vehicleid, engine, lights, toggle, doors, bonnet, boot, objective);
	return toggle;
}

stock GetVehicleAlarmStatus(vehicleid)
{
	new engine, lights, alarm, doors, bonnet, boot, objective;
	GetVehicleParamsEx(vehicleid, engine, lights, alarm, doors, bonnet, boot, objective);
	return alarm;
}

stock crp_GetVehicleDamageStatus(vehicleid, &panels, &doors, &lights, &tires)
{
	sscanf(CarInfo[vehicleid][cVisual], "dddd", panels, doors, lights, tires);
	return 1;
}

stock crp_UpdateVehicleDamageStatus(vehicleid, panels, doors, lights, tires)
{
	format(CarInfo[vehicleid][cVisual], 32, "%d %d %d %d", panels, doors, lights, tires);
	UpdateVehicleDamageStatus(vehicleid, panels, doors, lights, tires);
	return 1;
}

stock crp_AddVehicleComponent(vehicleid, componentid)
{
	new slot = GetVehicleComponentType(componentid);
	if(slot != -1)
	{
	    AddVehicleComponent(vehicleid, componentid);
	    CarInfo[vehicleid][cComponent][slot] = componentid - 999;
	}
	return 1;
}

stock crp_RemoveVehicleComponent(vehicleid, componentid)
{
	new slot = GetVehicleComponentType(componentid);
	if(slot != 1)
	{
	    RemoveVehicleComponent(vehicleid, componentid);
	    CarInfo[vehicleid][cComponent][slot] = 0;
	}
	return 1;
}

stock GetVehicleRotation(vehicleid, &Float: heading,  &Float: attitude,  &Float: bank)
{
    new
		Float: quat_w,
		Float: quat_x,
		Float: quat_y,
		Float: quat_z;

    GetVehicleRotationQuat(vehicleid, quat_w, quat_x, quat_y, quat_z);
    ConvertNonNormaQuatToEuler(quat_w, quat_x, quat_z, quat_y,  heading,  attitude,  bank);

	bank = -1 * bank;
    return 1;
}

stock SetPlayerVehicleRadioCanal(playerid, vehicleid, radio_canal)
{
	new string[64];
	CarInfo[vehicleid][cRadioCanal] = radio_canal;
	
	format(string, sizeof(string), "CB radio: (%d) hz", radio_canal);
	PlayerTextDrawSetString(playerid, TextDrawRadioCB[playerid], string);
	
	PlayerTextDrawShow(playerid, TextDrawRadioCB[playerid]);
	return 1;
}

stock IsVehiclePlaceFree(vehid)
{
	new Float:VehPosX, Float:VehPosY, Float:VehPosZ, virtual_world = GetVehicleVirtualWorld(vehid), bool: IsFree = true;
 	GetVehiclePos(vehid, VehPosX, VehPosY, VehPosZ);

  	new rows, Cache:tmp_cache, query[512];
  	
	mysql_format(connHandle, query, sizeof(query), "SELECT vehicle_uid FROM `"SQL_PREF"vehicles` WHERE vehicle_posx < %f + 4 AND vehicle_posx > %f - 4 AND vehicle_posy < %f + 4 AND vehicle_posy > %f - 4 AND vehicle_posz < %f + 4 AND vehicle_posz > %f - 4 AND vehicle_world = %d LIMIT 1", VehPosX, VehPosX, VehPosY, VehPosY, VehPosZ, VehPosZ, virtual_world);
	tmp_cache = mysql_query(connHandle, query);
  	
  	cache_get_row_count(rows);
    if(rows > 0)
    {
    	IsFree = false;
    }
    if(cache_is_valid(tmp_cache)) cache_delete(tmp_cache);
	return IsFree;

}

stock IsVehicleInRangeOfPoint(vehid, Float:dist, Float:posX, Float:posY, Float:posZ)
{
	new Float:vPosX, Float:vPosY, Float:vPosZ;
	GetVehiclePos(vehid, vPosX, vPosY, vPosZ);
	
	if((vPosX < posX + dist) && (vPosX > posX - dist) && (vPosY < posY + dist) && (vPosY > posY - dist) && (vPosZ < posZ + dist) && (vPosZ > posZ - dist))
	{
	    return true;
	}
	return false;
}

stock GetVehicleDriver(vehicleid)
{
	foreach(new i : Player)
	{
	    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	    {
			if(GetPlayerState(i) == PLAYER_STATE_DRIVER)
			{
			    if(GetPlayerVehicleID(i) == vehicleid)
			    {
			        return i;
			    }
			}
		}
	}
	return INVALID_PLAYER_ID;
}

stock GetPlayerSpeed(playerid, get3d)
{
	new Float:PosX, Float:PosY, Float:PosZ;
	if(IsPlayerInAnyVehicle(playerid))
	{
	    new vehid = GetPlayerVehicleID(playerid);
		GetVehicleVelocity(vehid, PosX, PosY, PosZ);
	}
	else
	{
		GetPlayerVelocity(playerid, PosX, PosY, PosZ);
	}
	return floatround(floatsqroot((get3d)?(PosX * PosX + PosY * PosY + PosZ * PosZ):(PosX * PosX + PosY * PosY)) * 100.0 * 1.6);
}

stock SetPlayerSpeed(playerid, Float:speed)
{
    new Float:x1, Float:y1, Float:z1, Float:x2,
		Float:y2, Float:z2, Float:a;

	if(IsPlayerInAnyVehicle(playerid))
	{
	    new vehid = GetPlayerVehicleID(playerid);
	    
	    GetVehicleVelocity(vehid, x1, y1, z1);
	    GetVehiclePos(vehid, x2, y2, z2);
	    
	    GetVehicleZAngle(vehid, a);
	    a = 360 - a;
	    
     	x1 = (floatsin(a, degrees) * (speed / 100) + floatcos(a, degrees) * 0 + x2) - x2;
    	y1 = (floatcos(a, degrees) * (speed / 100) + floatsin(a, degrees) * 0 + y2) - y2;
    	
    	SetVehicleVelocity(vehid, x1, y1, z1);
	}
	else
	{
	    GetPlayerVelocity(playerid, x1, y1, z1);
	    GetPlayerPos(playerid, x2, y2, z2);
	    
	    GetPlayerFacingAngle(playerid, a);
	    a = 360 - a;
	    
    	x1 = (floatsin(a, degrees) * (speed / 100) + floatcos(a, degrees) * 0 + x2) - x2;
    	y1 = (floatcos(a, degrees) * (speed / 100) + floatsin(a, degrees) * 0 + y2) - y2;
    	
    	SetPlayerVelocity(playerid, x1, y1, z1);
	}
	return 1;
}

stock IsVehicleBike(vehid)
{
	new model = GetVehicleModel(vehid);
	if(model == 509 || model == 510 || model == 481)
	{
	    return true;
	}
	return false;
}

stock IsVehicleVan(vehid)
{
	new model = GetVehicleModel(vehid);
	if(model == 413 || model == 414 || model == 440 || model == 456 || model == 459 || model == 482 || model == 498 || model == 499 || model == 609)
	{
	    return true;
	}
	return false;
}

stock GetDoorID(door_uid)
{
	new doorid = INVALID_DOOR_ID, DoorData[sDoorInfo],
		count_doors = Streamer_GetUpperBound(STREAMER_TYPE_PICKUP);

	for (new door = 0; door <= count_doors; door++)
	{
 		if(IsValidDynamicPickup(door))
   		{
   			Streamer_GetArrayData(STREAMER_TYPE_PICKUP, door, E_STREAMER_EXTRA_ID, DoorData);
   			if(DoorData[dUID] == door_uid)
   			{
   			    doorid = door;
			   	break;
       		}
	    }
	}
	return doorid;
}

stock GetDoorUID(doorid)
{
	new DoorData[sDoorInfo];
	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	
	return DoorData[dUID];
}

stock DoorName(doorid)
{
	new DoorData[sDoorInfo], door_name[32];
	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	
	strmid(door_name, DoorData[dName], 0, strlen(DoorData[dName]), 32);
	return door_name;
}

stock GetDoorAreaID(doorid)
{
	new AreaID = INVALID_AREA_ID,
		count_areas = Streamer_GetUpperBound(STREAMER_TYPE_AREA), DoorData[sDoorInfo];
		
	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, doorid, E_STREAMER_EXTRA_ID, DoorData);
	
	for (new area = 0; area < count_areas; area++)
	{
	    if(IsValidDynamicArea(area))
	    {
		    if(Streamer_GetIntData(STREAMER_TYPE_AREA, area, E_STREAMER_WORLD_ID) == DoorData[dUID])
		    {
		        AreaID = area;
				break;
		    }
		}
	}
	return AreaID;
}

stock GetClosestDoor(playerid)
{
	new DoorID = INVALID_DOOR_ID, Float:PosX, Float:PosY, Float:PosZ,
		virtual_world = GetPlayerVirtualWorld(playerid);

	GetPlayerPos(playerid, PosX, PosY, PosZ);

	new DoorData[MAX_VIS_DOORS],
		count_doors = Streamer_GetNearbyItems(PosX, PosY, PosZ, STREAMER_TYPE_PICKUP, DoorData, MAX_VIS_DOORS, 5.0, virtual_world);

	for (new door = 0; door < count_doors; door++)
	{
		DoorID = DoorData[door];
		break;
	}
	return DoorID;
}

stock GetPlayerDoorID(playerid)
{
	new doorid = INVALID_DOOR_ID, DoorData[sDoorInfo],
		count_doors = Streamer_GetUpperBound(STREAMER_TYPE_PICKUP);
		
	new virtual_world = GetPlayerVirtualWorld(playerid), interior_id = GetPlayerInterior(playerid);

	if(virtual_world == 0)  return doorid;
	for (new door = 0; door <= count_doors; door++)
	{
 		if(IsValidDynamicPickup(door))
	    {
	    	Streamer_GetArrayData(STREAMER_TYPE_PICKUP, door, E_STREAMER_EXTRA_ID, DoorData);
		    if(DoorData[dExitVW] == virtual_world && DoorData[dExitInt] == interior_id)
		    {
				doorid = door;
				break;
    		}
		}
	}
	return doorid;
}

stock GetNearRandomDoorID(Float:PosX, Float:PosY, Float:PosZ, door_ownertype)
{
	new DoorData[sDoorInfo], NearDoor[MAX_VIS_DOORS],
		count_doors = Streamer_GetNearbyItems(PosX, PosY, PosZ, STREAMER_TYPE_PICKUP, NearDoor, MAX_VIS_DOORS, 500.0, 0);

    new Doors[100], doors;
	for (new door = 0; door < count_doors; door++)
	{
 		if(IsValidDynamicPickup(NearDoor[door]))
   		{
   			Streamer_GetArrayData(STREAMER_TYPE_PICKUP, NearDoor[door], E_STREAMER_EXTRA_ID, DoorData);
   			if(DoorData[dOwnerType] == door_ownertype)
   			{
		    	Doors[doors] = NearDoor[door];
		    	doors ++;

		    	if(doors >= 100)    break;
			}
	    }
	}
	return Doors[random(doors)];
}

stock WordWrap(givenString[256], wrap_type, spaces = 5)
{
	new editingString[256], spaceCounter = 0;
	memcpy(editingString, givenString, 0, 256 * 4);

	switch(wrap_type)
	{
	    // Automatyczne
	    case WRAP_AUTO:
	    {
    		for (new i = 0; editingString[i] != 0; i++)
			{
			    if(editingString[i] == ',' || editingString[i] == '.')
			    {
					if(editingString[i+1] != ' ')
					{
						strins(editingString, " ", i + 1);
					}
				}

			    if(editingString[i] == ' ' && editingString[i+1] != ' ')
				{
					spaceCounter++;
				}

			    if(spaceCounter >= spaces)
				{
					editingString[i] = '\n';
					spaceCounter = 0;
			 	}
			}
	    }
	    // Manualne
	    case WRAP_MANUAL:
	    {
    		for (new i = 0; editingString[i] != 0; i++)
			{
				if(editingString[i] == '(' && editingString[i + 7] == ')')
				{
				    editingString[i] = '{';
					editingString[i + 7] = '}';
				}

			    if(editingString[i] == ',' || editingString[i] == '.')
			    {
					if(editingString[i+1] != ' ')
					{
						strins(editingString, " ", i + 1);
					}
				}

			    if(editingString[i] == '|')
				{
					editingString[i] = '\n';
			 	}
			}
	    }
	}
	return editingString;
}

stock NewsPaperWrap(givenString[4096])
{
	new editingString[4096], spaceCounter = 0;
	memcpy(editingString, givenString, 0, 4096 * 4);
	
	for (new i = 0; editingString[i] != 0; i++)
	{
 		if(editingString[i] == ',' || editingString[i] == '.')
 		{
			if(editingString[i+1] != ' ')
			{
				strins(editingString, " ", i + 1);
			}
		}

		if(editingString[i] == ' ' && editingString[i+1] != ' ')
		{
			spaceCounter++;
		}

		if(spaceCounter >= 20)
		{
			editingString[i] = '\n';
			spaceCounter = 0;
		}
	}
	return editingString;
 }

stock FormatTextDrawColors(givenString[])
{
    new pos, editingString[128];
    memcpy(editingString, givenString, 0, 128 * 4);

    pos = strfind(editingString, "[w]", true);
    while(pos != -1)
    {
        strdel(editingString, pos, pos + 3);
        strins(editingString, "~w~", pos);

        pos = strfind(editingString, "[w]", true, pos + 3);
    }

    pos = strfind(editingString, "[b]", true);
    while(pos != -1)
    {
        strdel(editingString, pos, pos + 3);
        strins(editingString, "~b~", pos);

        pos = strfind(editingString, "[b]", true, pos + 3);
    }

    pos = strfind(editingString, "[g]", true);
    while(pos != -1)
    {
        strdel(editingString, pos, pos + 3);
        strins(editingString, "~g~", pos);

        pos = strfind(editingString, "[g]", true, pos + 3);
    }

    pos = strfind(editingString, "[r]", true);
    while(pos != -1)
    {
        strdel(editingString, pos, pos + 3);
        strins(editingString, "~r~", pos);

        pos = strfind(editingString, "[r]", true, pos + 3);
    }

    pos = strfind(editingString, "[p]", true);
    while(pos != -1)
    {
        strdel(editingString, pos, pos + 3);
        strins(editingString, "~p~", pos);

        pos = strfind(editingString, "[p]", true, pos + 3);
    }

    pos = strfind(editingString, "[y]", true);
    while(pos != -1)
    {
        strdel(editingString, pos, pos + 3);
        strins(editingString, "~y~", pos);

        pos = strfind(editingString, "[y]", true, pos + 3);
    }

    pos = strfind(editingString, "[h]", true);
    while(pos != -1)
    {
        strdel(editingString, pos, pos + 3);
        strins(editingString, "~h~", pos);

        pos = strfind(editingString, "[h]", true, pos + 3);
    }
    return editingString;
}

stock ColorFade(color, minvalue, maxvalue)
{
    if (0 <= minvalue <= maxvalue)
    {
        new
            Float: ratio = float (minvalue) / float (maxvalue);
        new
            r = max (0, min (255, floatround (float ((color >> 24) & 0xFF) * ratio))),
            g = max (0, min (255, floatround (float ((color >> 16) & 0xFF) * ratio))),
            b = max (0, min (255, floatround (float ((color >> 8) & 0xFF) * ratio)));
        return (r << 24) | (g << 16) | (b << 8) | (minvalue & 0xFF);
    }
    return 0;
}

stock escape_pl(name[])
{/*
    for(new i = 0; name[i] != 0; i++)
    {
	    if(name[i] == 'ś') name[i] = 's';
	    else if(name[i] == 'ę') name[i] = 'e';
	    else if(name[i] == 'ó') name[i] = 'o';
	    else if(name[i] == 'ą') name[i] = 'a';
	    else if(name[i] == 'ł') name[i] = 'l';
	    else if(name[i] == 'ż') name[i] = 'z';
	    else if(name[i] == 'ź') name[i] = 'z';
	    else if(name[i] == 'ć') name[i] = 'c';
	    else if(name[i] == 'ń') name[i] = 'n';
	    else if(name[i] == 'Ś') name[i] = 'S';
	    else if(name[i] == 'Ę') name[i] = 'E';
	    else if(name[i] == 'Ó') name[i] = 'O';
	    else if(name[i] == 'Ą') name[i] = 'A';
	    else if(name[i] == 'Ł') name[i] = 'L';
	    else if(name[i] == 'Ż') name[i] = 'Z';
	    else if(name[i] == 'Ź') name[i] = 'Z';
	    else if(name[i] == 'Ć') name[i] = 'C';
	    else if(name[i] == 'Ń') name[i] = 'N';
    }
	*/
}

stock GetPlayerItemID(playerid, item_uid)
{
	new itemid = INVALID_ITEM_ID;
	foreach(new i : PlayerItem[playerid])
	{
	    if(PlayerItemCache[playerid][i][iUID] == item_uid)
	    {
	        itemid = i;
	        break;
	    }
	}
	return itemid;
}

stock GetItemOwner(item_uid)
{
	new item_owner = INVALID_PLAYER_ID, itemid = INVALID_ITEM_ID;
	foreach(new i : Player)
	{
	    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	    {
			itemid = GetPlayerItemID(i, item_uid);
			if(itemid != INVALID_ITEM_ID)
			{
				item_owner = i;
		    	break;
			}
		}
	}
	return item_owner;
}

stock GetPlayerPhoneItemID(playerid, phone_number)
{
	new itemid = INVALID_ITEM_ID;
	foreach(new i : PlayerItem[playerid])
	{
	    if(PlayerItemCache[playerid][i][iType] == ITEM_PHONE)
	    {
	        if(PlayerItemCache[playerid][i][iUsed])
	        {
		        if(PlayerItemCache[playerid][i][iValue][0] == phone_number)
		        {
			        itemid = i;
			        break;
				}
			}
	    }
	}
	return itemid;
}

stock GetPlayerItemWeight(playerid, itemid)
{
	new item_weight = 0,
	    item_value1 = PlayerItemCache[playerid][itemid][iValue][0], item_type = PlayerItemCache[playerid][itemid][iType], item_value2 = PlayerItemCache[playerid][itemid][iValue][1];

	switch(item_type)
	{
	    case ITEM_WEAPON, ITEM_PAINT, ITEM_INHIBITOR:
	    {
	        item_weight = WeaponInfoData[item_value1][wWeight];
	    }
	    case ITEM_CIGGY:
	    {
	        item_weight = ItemTypeInfo[item_type][iTypeWeight] + item_value2;
	    }
	    case ITEM_DRUG:
	    {
	        item_weight = ItemTypeInfo[item_type][iTypeWeight] * item_value2;
	    }
	    case ITEM_BAG, ITEM_NOTEBOOK, ITEM_CHECKBOOK, ITEM_WOOD:
		{
		    item_weight = ItemTypeInfo[item_type][iTypeWeight] + item_value1;
		}
	    case ITEM_CANISTER:
	    {
	        item_weight = ItemTypeInfo[item_type][iTypeWeight] + item_value1 * 800;
	    }
	    default:
	    {
	        item_weight = ItemTypeInfo[item_type][iTypeWeight];
	    }
	}
	return item_weight;
}

stock HavePlayerItemType(playerid, item_type, value1 = 0, value2 = 0)
{
	new bool: got_item;
	foreach(new itemid : PlayerItem[playerid])
	{
	    if(PlayerItemCache[playerid][itemid][iType] == item_type)
	    {
			if(value1 != 0 && PlayerItemCache[playerid][itemid][iValue][0] != value1) continue;
			if(value2 != 0 && PlayerItemCache[playerid][itemid][iValue][1] != value2) continue;

	        got_item = true;
	        break;
		}
	}
	return got_item;
}

stock GetPlayerCapacity(playerid)
{
	new capacity = PlayerCache[playerid][pStrength] * 2;
	foreach(new itemid : PlayerItem[playerid])
	{
		capacity -= GetPlayerItemWeight(playerid, itemid);

		if(capacity <= 0)
		{
  			capacity = 0;
  			break;
		}
	}
	return capacity;
}

stock GetExternalItemCachePlace(playerid)
{
	new item_place;
	for(new place = 0; place != 10; place++)
	{
	    if(external_items_cache[playerid][place] != MYSQL_INVALID_CACHE)
	    {
			item_place = place;
	    }
	}
	return item_place;
}

stock ClearExternalItemCache(playerid)
{
	for(new place = 0; place != 10; place++)
	{
	    if(external_items_cache[playerid][place] != MYSQL_INVALID_CACHE)
	    {
			cache_delete(external_items_cache[playerid][place]);
			external_items_cache[playerid][place] = MYSQL_INVALID_CACHE;
	    }
	}
	return 1;
}

stock GetPlayerWeaponAmmo(playerid, weaponid)
{
	new ammo, weapons[13][2];
	for (new i = 0; i < 13; i++)
	{
		GetPlayerWeaponData(playerid, i, weapons[i][0], weapons[i][1]);
		if(weapons[i][0] == weaponid)
		{
			ammo = weapons[i][1];
		}
	}
	return ammo;
}

stock GetPlayerWeaponID(playerid)
{
	new weapon_id = GetPlayerWeapon(playerid);
	/*
	if(IsPlayerInAnyVehicle(playerid))
	{
	    new weapons[13][2];
		for (new i = 0; i < 13; i++)
		{
			GetPlayerWeaponData(playerid, i, weapons[i][0], weapons[i][1]);
			if(weapons[i][0] && weapons[i][1])
			{
	   		    weapon_id = weapons[i][0];
			}
		}
	}
	else
	{
	    weapon_id = GetPlayerWeapon(playerid);
	}
	*/
	return weapon_id;
}

stock GetPlayerWeaponSlot(playerid, weaponid)
{
	new slotid, weapons[13][2];
	for (new i = 0; i < 13; i++)
	{
		GetPlayerWeaponData(playerid, i, weapons[i][0], weapons[i][1]);
		if(weapons[i][0] == weaponid)
		{
   			slotid = i;
		}
	}
	return slotid;
}

stock HavePlayerAnyWeapon(playerid)
{
	new weapons[13][2];
	for (new i = 0; i < 13; i++)
	{
		GetPlayerWeaponData(playerid, i, weapons[i][0], weapons[i][1]);
		if(weapons[i][0])
		{
		    return true;
		}
	}
	return false;
}

stock GetWeaponType(weaponid)
{
	switch(weaponid)
 	{
  		case 22, 23, 24, 26, 28, 32:
    		return WEAPON_TYPE_LIGHT;

		case 3, 4, 16, 17, 18, 39, 10, 11, 12, 13, 14, 40, 41:
  			return WEAPON_TYPE_MELEE;

		case 2, 6, 7, 8, 9, 25, 27, 29, 30, 31, 33, 34, 35, 36, 37, 38:
  			return WEAPON_TYPE_HEAVY;
	}
	return WEAPON_TYPE_NONE;
}

stock ResetPlayerWeaponsEx(playerid)
{
	for (new i = 0; i < 13; i++)	SetPlayerAmmo(playerid, i, 0);
	ResetPlayerWeapons(playerid);
	return 1;
}

stock IsPlayerAiming(playerid)
{
	new anim = GetPlayerAnimationIndex(playerid);
	if (((anim >= 1160) && (anim <= 1163)) || (anim == 1167) || (anim == 1365) || (anim == 1643) || (anim == 1453) || (anim == 220))
	{
		return true;
	}
 	return false;
}

stock GetAreaID(area_uid)
{
	new areaid = INVALID_AREA_ID, areas = Streamer_GetUpperBound(STREAMER_TYPE_AREA);
	for (new i = 0; i <= areas; i++)
	{
	    if(IsValidDynamicArea(i))
	    {
		    if(Streamer_IsInArrayData(STREAMER_TYPE_AREA, i, E_STREAMER_EXTRA_ID, area_uid))
		    {
		        areaid = i;
		        break;
		    }
		}
	}
	return areaid;
}

stock GetAreaUID(areaid)
{
	new AreaData[sAreaData];
	Streamer_GetArrayData(STREAMER_TYPE_AREA, areaid, E_STREAMER_EXTRA_ID, AreaData);
	
	return AreaData[aUID];
}

stock GetPlayerAreaID(playerid)
{
	new AreaID = INVALID_AREA_ID,
		areas = Streamer_GetUpperBound(STREAMER_TYPE_AREA);
		
	for(new areaid = 0; areaid < areas; areaid++)
	{
	    if(IsValidDynamicArea(areaid))
	    {
	        if(IsPlayerInDynamicArea(playerid, areaid))
	        {
		        if(Streamer_IsInArrayData(STREAMER_TYPE_AREA, areaid, E_STREAMER_WORLD_ID, 0))
		        {
					AreaID = areaid;
					break;
		        }
			}
	    }
	}
	return AreaID;
}

stock GetRandomAreaID(flags)
{
	new areaid = INVALID_AREA_ID, AreaData[sAreaData],
		count_areas = Streamer_GetUpperBound(STREAMER_TYPE_AREA);

	new Areas[100], areas;
	for (new area = 0; area <= count_areas; area++)
	{
 		if(IsValidDynamicArea(area))
   		{
   			Streamer_GetArrayData(STREAMER_TYPE_AREA, area, E_STREAMER_EXTRA_ID, AreaData);
   			if(AreaData[aFlags] & flags)
   			{
		    	Areas[areas] = area;
		    	areas ++;

		    	if(areas >= 100)    break;
			}
	    }
	}
	if(areas > 0)	areaid = Areas[random(areas) - 1];

	return areaid;
}

stock GetActorID(actor_uid)
{
	new actorid = INVALID_ACTOR_ID, actors = Streamer_GetUpperBound(STREAMER_TYPE_ACTOR);
	for (new i = 0; i <= actors; i++)
	{
	    if(IsValidDynamicActor(i))
	    {
		    if(Streamer_IsInArrayData(STREAMER_TYPE_ACTOR, i, E_STREAMER_EXTRA_ID, actor_uid))
		    {
		        actorid = i;
		        break;
		    }
		}
	}
	return actorid;
}

stock GetActorUID(actorid)
{
	new ActorData[sActorData];
	Streamer_GetArrayData(STREAMER_TYPE_ACTOR, actorid, E_STREAMER_EXTRA_ID, ActorData);
	
	return ActorData[aUID];
}

stock GetProductID(product_uid)
{
	new product_id = INVALID_PRODUCT_ID;
	foreach(new i : Product)
	{
	    if(ProductData[i][pUID] == product_uid)
	    {
	        product_id = i;
	        break;
	    }
	}
	return product_id;
}

stock GetPlayerDistanceToPoint(playerid, Float:x, Float:y)
{
	new Float:PosX, Float:PosY, Float:PosZ, Float:dis;
	
	GetPlayerPos(playerid, PosX, PosY, PosZ);
	dis = floatsqroot(floatpower(floatabs(floatsub(PosX, x)), 2) + floatpower(floatabs(floatsub(PosY, y)), 2));
	
	return floatround(dis);
}

stock GetBodyPartType(bodypart)
{
	new body_part_type;
 	for(new bp_id = 0; bp_id < sizeof(BodyPartInfo); bp_id++)
	{
	    if(BodyPartInfo[bp_id][bpIndex] == bodypart)
	    {
	        body_part_type = BodyPartInfo[bp_id][bpType];
			break;
		}
	}
	return body_part_type;
}

stock ResetDynamicObjectPos(object_id)
{
	new Float:ObjPosX, Float:ObjPosY, Float:ObjPosZ,
	    Float:ObjRotX, Float:ObjRotY, Float:ObjRotZ;
	    
	Streamer_GetFloatData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_X, ObjPosX);
	Streamer_GetFloatData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_Y, ObjPosY);
	Streamer_GetFloatData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_Z, ObjPosZ);
	
	Streamer_GetFloatData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_R_X, ObjRotX);
	Streamer_GetFloatData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_R_Y, ObjRotY);
	Streamer_GetFloatData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_R_Z, ObjRotZ);
	
	SetDynamicObjectPos(object_id, ObjPosX, ObjPosY, ObjPosZ);
	SetDynamicObjectRot(object_id, ObjRotX, ObjRotY, ObjRotZ);
	return 1;
}

stock GetClosestObjectType(playerid, object_model, Float:prevdist = 5.0)
{
	new object_id, ObjectID = INVALID_OBJECT_ID,
		Float:PosX, Float:PosY, Float:PosZ, virtual_world = GetPlayerVirtualWorld(playerid);
	
	GetPlayerPos(playerid, PosX, PosY, PosZ);
	
	new ObjectData[MAX_VIS_OBJECTS],
		count_objects = Streamer_GetNearbyItems(PosX, PosY, PosZ, STREAMER_TYPE_OBJECT, ObjectData, MAX_VIS_OBJECTS, prevdist, virtual_world);

	for (new object = 0; object < count_objects; object++)
	{
		object_id = ObjectData[object];
		if(GetObjectModel(object_id) == object_model)
		{
		    ObjectID = object_id;
		    break;
		}
	}
	return ObjectID;
}

stock GetObjectID(object_uid)
{
	new object_counts = Streamer_GetUpperBound(STREAMER_TYPE_OBJECT);
	for (new object_id = 0; object_id <= object_counts; object_id++)
	{
	    if(IsValidDynamicObject(object_id))
	    {
		    if(Streamer_IsInArrayData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_EXTRA_ID, object_uid))
		    {
		        return object_id;
		    }
		}
	}
	return INVALID_OBJECT_ID;
}

stock GetObjectUID(object_id)
{
	new objData[sObjectData];
	Streamer_GetArrayData(STREAMER_TYPE_OBJECT, object_id, E_STREAMER_EXTRA_ID, objData);
	
	return objData[objUID];
}

stock GetXYInFrontOfObject(object_id, &Float:x, &Float:y, Float:distance)
{
 	new Float:z,
 	    Float:rotx, Float:roty, Float:rotz;

 	GetDynamicObjectPos(object_id, x, y, z);
	GetDynamicObjectRot(object_id, rotx, roty, rotz);

 	x -= (distance * floatsin(-rotz, degrees));
 	y -= (distance * floatcos(-rotz, degrees));
}

stock GetXYBehindOfObject(object_id, &Float:x, &Float:y, Float:distance)
{
 	new Float:z,
 	    Float:rotx, Float:roty, Float:rotz;

 	GetDynamicObjectPos(object_id, x, y, z);
	GetDynamicObjectRot(object_id, rotx, roty, rotz);

 	x += (distance * floatsin(-rotz, degrees));
 	y += (distance * floatcos(-rotz, degrees));
}

stock IsPlayerFacingObject(playerid, objectid)
{
	new Float:plPosX, Float:plPosZ, Float:plPosY,
		Float:obPosX, Float:obPosY, Float:obPosZ, Float:MainAngle;

	GetDynamicObjectPos(objectid, obPosX, obPosY, obPosZ);
	GetPlayerPos(playerid, plPosX, plPosY, plPosZ);

	if( obPosY > plPosY ) MainAngle = (-acos((obPosX - plPosX) / floatsqroot((obPosX - plPosX) * (obPosX - plPosX) + (obPosY - plPosY) * (obPosY - plPosY))) - 90.0);
	else if( obPosY < plPosY && obPosX < plPosX ) MainAngle = (acos((obPosX - plPosX) / floatsqroot((obPosX - plPosX) * (obPosX - plPosX) + (obPosY - plPosY) * (obPosY - plPosY))) - 450.0);
	else if( obPosY < plPosY ) MainAngle = (acos((obPosX - plPosX) / floatsqroot((obPosX - plPosX) * (obPosX - plPosX) + (obPosY - plPosY) * (obPosY - plPosY))) - 90.0);

	if(obPosX > plPosX) MainAngle = (floatabs(floatabs(MainAngle) + 180.0));
	else MainAngle = (floatabs(MainAngle) - 180.0);

	new Float:plAngle;
	GetPlayerFacingAngle(playerid, plAngle);

	if(MainAngle - plAngle < -130 || MainAngle - plAngle > 130)
	{
		return 0;
	}
	return 1;
}

stock GetClosestLabel(playerid)
{
	new label_id, LabelID = INVALID_3DTEXT_ID,
		Float:PosX, Float:PosY, Float:PosZ, virtual_world = GetPlayerVirtualWorld(playerid);

	GetPlayerPos(playerid, PosX, PosY, PosZ);

	new LabelData[MAX_VIS_LABELS],
		count_labels = Streamer_GetNearbyItems(PosX, PosY, PosZ, STREAMER_TYPE_3D_TEXT_LABEL, LabelData, MAX_VIS_LABELS, 5.0, virtual_world);

	for (new label = 0; label < count_labels; label++)
	{
	    label_id = LabelData[label];
     	if(Streamer_GetIntData(STREAMER_TYPE_3D_TEXT_LABEL, label_id, E_STREAMER_ATTACHED_PLAYER) == INVALID_PLAYER_ID && Streamer_GetIntData(STREAMER_TYPE_3D_TEXT_LABEL, label_id, E_STREAMER_ATTACHED_VEHICLE) == INVALID_VEHICLE_ID)
     	{
			LabelID = label_id;
			break;
		}
	}
	return LabelID;
}

stock GetClosestBusStop(playerid)
{
	new object_id, ObjectID = INVALID_OBJECT_ID,
	    virtual_world = GetPlayerVirtualWorld(playerid);
	    
	new ObjectData[MAX_VIS_OBJECTS],
		count_objects = Streamer_GetNearbyItems(PlayerCache[playerid][pBusPosition][0], PlayerCache[playerid][pBusPosition][1], PlayerCache[playerid][pBusPosition][2], STREAMER_TYPE_OBJECT, ObjectData, MAX_VIS_OBJECTS, 300.0, virtual_world);

	for (new object = 0; object < count_objects; object++)
	{
 		object_id = ObjectData[object];
   		if(GetObjectModel(object_id) == OBJECT_BUSSTOP)
   		{
  			if(object_id != PlayerCache[playerid][pBusStart])
  			{
   				ObjectID = object_id;
   				break;
			}
	    }
	}
	return ObjectID;
}

stock IsValidObjectModel(model)
{
	static
		valid_model[] = //credits to Slice
		{
			0b11111111111011111110110111111110, 0b00000000001111111111111111111111,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b11111111111111111111111110000000,
			0b11100001001111111111111111111111, 0b11110111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b00000001111000000111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111100011111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111011111, 0b11111111111111111111111101111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111100000000000001111111111,
			0b11111111111111111111111111111111, 0b11111111111010111101111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111001111111111111,
			0b11111111111111111111111111111111, 0b10000000000011111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111011111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111101011101111111111, 0b11111111111111111111111111110111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111110011,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111100111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111011110111101111,
			0b10000000000000000000000000000000, 0b00000010000010000000010011111111,
			0b00000000001000000100000000000000, 0b11111111101101100101111000000000,
			0b01110000111111111111111111111011, 0b00000000001111111111111111000000,
			0b10011111110000000000001111001100, 0b11111111101111001100000000011110,
			0b00001110110111111100111111111111, 0b11111111111111111111111111001110,
			0b11111000000011111111111111111111, 0b11111111111111111110111101101011,
			0b01000000000000000111111101110111, 0b11010111111111111111000001111100,
			0b11110011111111111111111001111111, 0b01011111111111111111111111111111,
			0b01111110100001111011111010101011, 0b10001001010101100100001000010000,
			0b10100000000000000001010000101010, 0b00001000001111101010111100100000,
			0b11111111111111111111111010100001, 0b00000000011111111111110101111111,
			0b00001111111111111111110000111100, 0b11011110111111001111011011111011,
			0b11111111111001111111110011001110, 0b11111111111111111111111111111111,
			0b01111111111111111111111110111111, 0b01111000111111111111110111111111,
			0b00011100000000010000000000000111, 0b00001111111100001000000000000000,
			0b10101111001001110111110011111000, 0b01010101010101010110100000101011,
			0b01110111110101011111110100101001, 0b01111111111100101110111011111011,
			0b11111111111111111100101111001000, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b00000000011111111111111111111111, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b11111111000000000000000000000000, 0b00010100101000001111111111111111,
			0b11111111101111011111111111000000, 0b00111111111111111111111100000001,
			0b11110000000000000000000000000000, 0b00000101010101010111111111111111,
			0b11110010110111000011111010000000, 0b11111110111110000111110111010000,
			0b00000000000000011111111111111111, 0b00000000000000000000000000000000,
			0b11111111111111111111111111000000, 0b11111111111111111111111111111111,
			0b11011111111111111111111111111111, 0b00000000000000000000000000000111,
			0b00000000000000000000000000000000, 0b11010111111000000000000000000000,
			0b10110011001000101111111111111111, 0b00011000010111010101011111010111,
			0b11011111111111111111010101111111, 0b11111111111111100000000000000011,
			0b11111111111111111111111111111111, 0b11111111111111111100000101111111,
			0b00000000000000000000000111111111, 0b00011000000001111000000000000000,
			0b11111111111111100111100000000100, 0b11110100011011111111110000000000,
			0b11111110001001111111110000000111, 0b11111111110110000100101010101000,
			0b11111111111111111100000000000000, 0b11111111111111111111111111111111,
			0b11101011111011110011111111111111, 0b11111111111111111111111111111111,
			0b00010001000001111100001111111111, 0b00100000000000000000000000000000,
			0b00000000000000000000000000000000, 0b11111101000000000000000000000000,
			0b11110001110101000001111111111111, 0b00000000000001101111010000010010,
			0b11111111111111111111111110000000, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11100001111100000111100000000000, 0b11100110011111111101011111111011,
			0b00000000000000000000000100111001, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000100110000101100111111001100,
			0b11111111111110000000000000000000, 0b00000000000001111111111111111111,
			0b11000001111111011100000110000000, 0b00000111111101111111111111111111,
			0b00000000001000011110000111010010, 0b00111000100111110011110000000000,
			0b00111111111110101000001001111110, 0b00000000000000100001111100000000,
			0b11111111111111111111111100000000, 0b01111111111111111111111111111111,
			0b01011100001111111110101111110111, 0b11100010111111100000000000111111,
			0b11011000011000110011100011111001, 0b01100110000011110001100000010000,
			0b00000111100000000000000000000100, 0b00010111111101100011100001101010,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b11111111101111111000000000000000, 0b01111000000111100000000111111111,
			0b00000000011111110111111110111111, 0b11111111111111111111111111111111,
			0b00000000101001101111111111111111, 0b11111111111111111111111111111110,
			0b10100001000000111111111111111111, 0b11111111111111111111111111111011,
			0b00000000000000000000000000000011, 0b00000000000000100000000000000000,
			0b01110001111111010000000000010000, 0b11111101111101100011011111111111,
			0b10000000011111111111110101010111, 0b11011111100000010011001010110111,
			0b11010011101011111111111111111111, 0b10101010000010010000001111111000,
			0b11111000101111100000111110010110, 0b11111111100000000000000000000001,
			0b11111111111111111111111111111111, 0b01111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111101111111111,
			0b11111111111111111111111111111111, 0b00000000000001111111111111111111,
			0b00111000000000010001000000000010, 0b00000000000011100000000000000000,
			0b00000000000000000000100000000000, 0b00000000000000000000000000000000,
			0b11110101000000000000000000000000, 0b00011111111000000101001000000111,
			0b11110000011110100011011101000000, 0b01111110111111111111111111111111,
			0b10101000000111110100101111011100, 0b11111111111111111111110000111010,
			0b00000000000000000000011111111111, 0b11111111111111111111111111111110,
			0b00001000111111111111111111111111, 0b00000000000000000000000000000000,
			0b00001111111110000000001111111101, 0b00111110000001111111101110100000,
			0b00001111111101111100011111000100, 0b11101010111101010011000111110000,
			0b11101010000000000000000111010001, 0b10001110110101100101000001110101,
			0b11000011111010101011111111111111, 0b11010110101111110000000000111111,
			0b00011111111111111111111111010100, 0b11111111111111111111111111111111,
			0b00111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b10000000001111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b00000000000000111111111111111111,
			0b00000000000000000000000001000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00011111000000000000000000000000,
			0b00011111111111100111111111111111, 0b00000011111111111111111111111110,
			0b00000000000000000000000000000000, 0b00101100000110000000000000010000,
			0b11100000111110000000001000000000, 0b11111000000000011111111100000000,
			0b11010000111111101011111111111111, 0b11001101010100011100011101000011,
			0b11111111111101010011110011100111, 0b01000000000111111001101111111111,
			0b00000000111010111111110010000111, 0b11111111111000000000001111111111,
			0b11111111111111111111111111111111, 0b11111111111011110111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b00000000000001100000001111111111, 0b00000000000000000000000000000000,
			0b11100000000000000000000000000000, 0b00000000000000000000000000000001,
			0b11111111111111111111110000010000, 0b00000111111111111111111111111111,
			0b11111111111111111110100000000000, 0b11111111111111111111111110111111,
			0b00000011100001111111111111111111, 0b00000000001100000000000000000000,
			0b01100110001011010000000000000000, 0b11111111111111111111111111111111,
			0b00000111111111111111111111111111, 0b00000000000000000000000011111110,
			0b11111111110100000000000000000000, 0b00000000000000000111111111101011,
			0b01100000000000000000000110011100, 0b11111111111111111111111111101010,
			0b11111100000000000111111111111111, 0b00000000000000000000000001111111,
			0b11101111000000000000000000000000, 0b11111110111111111111111111111111,
			0b11111111111111111111011111111111, 0b11000000001000000000000011011001,
			0b11011111111111111111111111111111, 0b11100000011000000000011111111110,
			0b00000000001111100011111111111111, 0b00011110111111000000000000000000,
			0b11001111111100001001011111110100, 0b00110001110001111000011101011110,
			0b00000000000000000000000001110110, 0b11111111111111111100000000000000,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b00111111111111111111111111111111,
			0b00000000000000000000000000000000, 0b11000000000000000000000000000000,
			0b00000000000000011111111111111111, 0b11101111111111110100001000000000,
			0b00001010000000001111111111111111, 0b00001100000110011000000000000000,
			0b01010011111111111111111111000000, 0b11000001111111111100000000000100,
			0b11111111111111111111111111111111, 0b11001111110000000000111111111111,
			0b11111111111111111111111111111111, 0b00001111111111111111111111011111,
			0b00000011100000000000111000100000, 0b11111111111111111110000000100000,
			0b11111111111001111111111111111111, 0b11111111111111111111111111111111,
			0b00000000000000000000000011111111, 0b10000000000000000000000000000000,
			0b11111111111111111111111111111111, 0b11111111111111111111111111001111,
			0b00000000000000000111111000001111, 0b00000000000000000000000000000000,
			0b11110111100000000000000000000000, 0b00111111111100001011111111111111,
			0b10110111101010010000000000000000, 0b11010000111111110001011011101010,
			0b10000011100000101101001011010000, 0b11111111111110000100000010111101,
			0b11110011011111110100001100011111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b00000000000110011111111111111111,
			0b00001111100000000000000000000000, 0b10000000000000001011111010000000,
			0b11100100000001111000000000000000, 0b00000000000000000000000000000011,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111011,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b00001110001111111101111001011011,
			0b00011110011000011100011000111100, 0b11000000001011111111111110010001,
			0b01111111111111111101101111111111, 0b00111111111111111010100001110010,
			0b01111111111000000100000001011000, 0b00000000001110000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000111000000000000000,
			0b01000001000100000011101000000001, 0b11001111100110110000000000111010,
			0b00000000000000000000000000000000, 0b11111000000000000100000000000000,
			0b01000000001000000001111110111111, 0b11111111111011100111000000000000,
			0b11111111111111111111111111111111, 0b00001111111111111111111111111111,
			0b11111111110000000000000000000000, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111100001111,
			0b11111111111111111111111111111111, 0b01111111101111011111111111111111,
			0b00100001000000000000000000000010, 0b10110111011001100111011000001000,
			0b00000000001000000000000010000111, 0b10000100000000011000001111100000,
			0b00000000000000000000000000000100, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b11111111111111111000000000000000,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11010111111111111111111111111101, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111100000011111111111111111111,
			0b11111111111111111111111111110011, 0b11111111111111111111100011111111,
			0b11111111111111111000000111111111, 0b11111111111111000011111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111110111111111, 0b00000000111101111111111111101111,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b11111111111111100000000000000000,
			0b00000001111111111111111111111111, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111000000011111110111111111, 0b11111111111111111111111111111111,
			0b11111111111111101111111111111111, 0b00000111111111111111111111111111,
			0b00001111111111111111111111111111, 0b01110100111101000100000111110000,
			0b10101000000000000000000000000001, 0b00000000111101000000000000000011,
			0b00000000111111000000000000000000, 0b00001001000111000000000000000000,
			0b00100010100000100000000000000000, 0b11111111111110001100000000100100,
			0b11111111111111111111111111111111, 0b01110000011101100011111001111010,
			0b11111000000000000000000000011110, 0b11000001111101100000111111111111,
			0b00000000011111111111111111101110, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b11111111111111111111111100000000,
			0b11111110001111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b01010111111111111111111111111111,
			0b01010101010101010101010101010101, 0b01010101000101010101010101010101,
			0b01010101010101010101010101010101, 0b10101010101010000101010101010101,
			0b01111010111111111111111111111010, 0b00000000111010101101100000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b10000000000000111100000000000000,
			0b11110000000000000000000000000101, 0b11111111111111111111111011111111,
			0b11111111111111111111111111111111, 0b11111101101101101100111111100001,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b00000000000000000000000000011111,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000101011000000000000, 0b01111011000000100000000000100000,
			0b11000011111111010000111111011000, 0b11111011100011110110111001111001,
			0b11001101111111110110000111100111, 0b00000101011110110000000001111110,
			0b11111111111111110000000000000000, 0b11111111110111111111111111111111,
			0b11111111111111111111111111111111, 0b00100011011111111111111111111111,
			0b00000000000000000000000000000001, 0b00000000000000000000000000000000,
			0b11111111000000000000000000000000, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b00000111111111111111111111111111, 0b00000000000000000000000000000000,
			0b11111111111111111111111111111111, 0b00000000001111111111111111111111,
			0b00000000010000000000000000000001, 0b00000011100000000000000000000000,
			0b00000000000000000000001111101010, 0b11111111111111110000000000000000,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b10111111111111111111111111111111, 0b11111111111111111100111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b01111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111110011111111111, 0b11101111111111111111000111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11111111111111111111111111111111, 0b11111111111111111111111111111111,
			0b11110000000001111111111111111111, 0b00001111111111111111111111111111,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00000000000000000000000000000000,
			0b00000000000000000000000000000000, 0b00100000000000000000000000000000
	};
	
	if (model > 19901)
	{
		return 0;
	}
	model -= 320;
	if (model < 0)
	{
		return 0;
	}
	return (valid_model[model >> 5] & (1 << (model & 0x1F)));
}

stock PlayAudioForPlayer(playerid, audio_id)
{
	new format_url[128];
	format(format_url, sizeof(format_url), "%s/%s", audio_url, AudioData[audio_id]);
	
	PlayAudioStreamForPlayer(playerid, format_url);
	TD_ShowHint(playerid, HINT_AUDIO, 10, "~b~Dzwieki na serwerze~n~~n~~w~U nas dzwieki odgrywaja ~y~bardzo wazna ~w~role podczas rozgrywki i bedziesz napotykal na nie bardzo czesto, pamietaj wiec, by ~g~wlaczyc ~w~dzwieki w menu gry.~n~~n~Jesli na czacie pojawila sie ~y~informacja ~w~o odtwarzanym dzwieku - uzyj komendy ~p~/audiomsg~w~, by uniknac spamu w przyszlosci.");
	return 1;
}

stock Play3DAudioForPlayer(playerid, audio_id, Float:posX, Float:posY, Float:posZ, Float:dist)
{
	new format_url[128];
	format(format_url, sizeof(format_url), "%s/%s", audio_url, AudioData[audio_id]);

	PlayAudioStreamForPlayer(playerid, format_url, posX, posY, posZ, dist, true);
	TD_ShowHint(playerid, HINT_AUDIO, 10, "~b~Dzwieki na serwerze~n~~n~~w~U nas dzwieki odgrywaja ~y~bardzo wazna ~w~role podczas rozgrywki i bedziesz napotykal na nie bardzo czesto, pamietaj wiec, by ~g~wlaczyc ~w~dzwieki w menu gry.~n~~n~Jesli na czacie pojawila sie ~y~informacja ~w~o odtwarzanym dzwieku - uzyj komendy ~p~/audiomsg~w~, by uniknac spamu w przyszlosci.");
	return 1;
}

stock PlayStreamedAudioForPlayer(playerid, streamString[])
{
	StopAudioStreamForPlayer(playerid);
	PlayAudioStreamForPlayer(playerid, streamString);
	return 1;
}

stock PlayStreamedAudio3DForPlayer(playerid, streamString[], Float:PosX, Float:PosY, Float:PosZ)
{
	StopAudioStreamForPlayer(playerid);
	PlayAudioStreamForPlayer(playerid, streamString, PosX, PosY, PosZ, 10.0, true);
	return 1;
}

stock StopStreamedAudioForPlayer(playerid)
{
	StopAudioStreamForPlayer(playerid);
	return 1;
}

stock GetAccessID(access_uid)
{
	new access_id = INVALID_ACCESS_ID;
	foreach(new i : Access)
	{
	    if(AccessData[i][aUID] == access_uid)
	    {
	        access_id = i;
	        break;
	    }
	}
	return access_id;
}

stock GetPlayerFreeSlotAccess(playerid)
{
	new slot_index = INVALID_SLOT_ID;
	if(!IsPlayerAttachedObjectSlotUsed(playerid, SLOT_ACCESS_1))
	{
	    slot_index = SLOT_ACCESS_1;
	}
	else if(!IsPlayerAttachedObjectSlotUsed(playerid, SLOT_ACCESS_2))
	{
	    slot_index = SLOT_ACCESS_2;
	}
	else if(IsPlayerPremium(playerid) && !IsPlayerAttachedObjectSlotUsed(playerid, SLOT_ACCESS_3))
	{
	    slot_index = SLOT_ACCESS_3;
	}
	return slot_index;
}

stock GetAnimID(anim_uid)
{
	new anim_id = INVALID_ANIM_ID;
	foreach(new i : Anim)
	{
	    if(AnimCache[i][aUID] == anim_uid)
		{
		    anim_id = i;
	        break;
	    }
	}
	return anim_id;
}

stock GetAnimUID(anim_id)
{
	new anim_uid = 0;
	foreach(new i : Anim)
	{
	    if(i == anim_id)
	    {
	        anim_uid = AnimCache[i][aUID];
	        break;
	    }
	}
	return anim_uid;
}

stock GetAnimByCommand(command[])
{
	new anim_id = INVALID_ANIM_ID;
	foreach(new anim : Anim)
	{
		if(!strcmp(command, AnimCache[anim][aCommand], true))
   		{
   		    anim_id = anim;
			break;
		}
	}
	return anim_id;
}

stock GetPlayerStatus(playerid)
{
	new player_status = 0;
	if(PlayerCache[playerid][pBW] > 0)
	{
		player_status += STATUS_TYPE_DAZED;
		
		if(PlayerCache[playerid][pDeathWeapon] == 0)
		{
		    player_status += STATUS_TYPE_DEFEATED;
		}
		else
		{
		    player_status += STATUS_TYPE_SHOT;
		}
	}

	if(GetPlayerDrunkLevel(playerid) >= 10000)   						player_status += STATUS_TYPE_DRUNK;
	if(PlayerCache[playerid][pStrength] >= 6500) 						player_status += STATUS_TYPE_MUSCLE;
	if(PlayerCache[playerid][pRoll])               						player_status += STATUS_TYPE_ROLL;
	if(PlayerCache[playerid][pItemMask] != INVALID_ITEM_ID)				player_status += STATUS_TYPE_MASKED;
	if(PlayerCache[playerid][pItemPlayer] != INVALID_ITEM_ID)           player_status += STATUS_TYPE_EARPIECE;
	if(PlayerCache[playerid][pAFK] > 0)                                 player_status += STATUS_TYPE_AFK;
	if(PlayerCache[playerid][pBelts])                                  	player_status += STATUS_TYPE_BELTS;
	if(PlayerCache[playerid][pDrugLevel] >= 10)                         player_status += STATUS_TYPE_STONED;
	if(PlayerCache[playerid][pItemGloves] != INVALID_ITEM_ID)           player_status += STATUS_TYPE_GLOVES;
	if(PlayerCache[playerid][pHealth] <= 10.0)                          player_status += STATUS_TYPE_INJURED;
	
	return player_status;
}

stock GetAchieveIndex(achieve_type)
{
	new achieve_index;
 	for(new achieve_id = 0; achieve_id < sizeof(AchieveInfo); achieve_id++)
	{
	    if(AchieveInfo[achieve_id][aType] & achieve_type)
	    {
	        achieve_index = achieve_id;
	        break;
	    }
	}
	return achieve_index;
}

stock GetSexName(sex_type)
{
	new sex_name[24];
	switch(sex_type)
	{
	    case 0: sex_name = "kobieta";
	    case 1: sex_name = "mężczyzna";
	}
	return sex_name;
}

stock GetMissionLeader(mission_uid)
{
	new leader = INVALID_PLAYER_ID;
	foreach(new i : Player)
	{
	    if(PlayerCache[i][pLogged] && PlayerCache[i][pSpawned])
	    {
	        if(MissionData[i][mUID] == mission_uid)
	        {
	            if(MissionData[i][mLeader] == true)
	            {
	                leader = i;
					break;
	            }
	        }
	    }
	}
	return leader;
}

SSCANF:item_type(string[])
{
	new item_type = INVALID_ITEM_TYPE;
	if ('0' <= string[0] <= '9')
	{
		new
			ret = strval(string);
		if (0 <= ret <= ITEM_COUNT)
		{
			return ret;
		}
	}
	for(new i = 0; i < sizeof(ItemTypeInfo); i++)
	{
		if(!strcmp(string, ItemTypeInfo[i][iTypeName], true))
		{
			item_type = i;
			break;
		}
	}
	return item_type;
}

SSCANF:group_type(string[])
{
	new group_type = INVALID_GROUP_TYPE;
	if ('0' <= string[0] <= '9')
	{
		new
			ret = strval(string);
		if (0 <= ret <= G_TYPE_COUNT)
		{
			return ret;
		}
	}
	for(new i = 0; i < sizeof(GroupTypeInfo); i++)
	{
		if(!strcmp(string, GroupTypeInfo[i][gTypeName], true))
		{
			group_type = i;
			break;
		}
	}
	return group_type;
}

SSCANF:vehicle_model(string[])
{
	new vehicle_model = INVALID_GROUP_TYPE;
	if ('0' <= string[0] <= '9')
	{
		new
			ret = strval(string);
		if (400 <= ret <= 611)
		{
			return ret;
		}
	}
	for(new i = 0; i < sizeof(VehicleModelData); i++)
	{
		if(!strcmp(string, VehicleModelData[i][vName], true))
		{
			vehicle_model = i + 400;
			break;
		}
	}
	return vehicle_model;
}